// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: livelink.proto
// Protobuf C++ Version: 6.31.1

#ifndef livelink_2eproto_2epb_2eh
#define livelink_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 6031001
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_livelink_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_livelink_2eproto {
  static const ::uint32_t offsets[];
};
extern "C" {
extern const ::google::protobuf::internal::DescriptorTable descriptor_table_livelink_2eproto;
}  // extern "C"
namespace livelinkapi {
class CameraState;
struct CameraStateDefaultTypeInternal;
extern CameraStateDefaultTypeInternal _CameraState_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull CameraState_class_data_;
class Empty;
struct EmptyDefaultTypeInternal;
extern EmptyDefaultTypeInternal _Empty_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Empty_class_data_;
class FileRequest;
struct FileRequestDefaultTypeInternal;
extern FileRequestDefaultTypeInternal _FileRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull FileRequest_class_data_;
class FileResponse;
struct FileResponseDefaultTypeInternal;
extern FileResponseDefaultTypeInternal _FileResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull FileResponse_class_data_;
class MatrixD;
struct MatrixDDefaultTypeInternal;
extern MatrixDDefaultTypeInternal _MatrixD_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull MatrixD_class_data_;
class Mesh;
struct MeshDefaultTypeInternal;
extern MeshDefaultTypeInternal _Mesh_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Mesh_class_data_;
class MeshData;
struct MeshDataDefaultTypeInternal;
extern MeshDataDefaultTypeInternal _MeshData_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull MeshData_class_data_;
class MeshList;
struct MeshListDefaultTypeInternal;
extern MeshListDefaultTypeInternal _MeshList_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull MeshList_class_data_;
class MeshRequest;
struct MeshRequestDefaultTypeInternal;
extern MeshRequestDefaultTypeInternal _MeshRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull MeshRequest_class_data_;
class StreamStatus;
struct StreamStatusDefaultTypeInternal;
extern StreamStatusDefaultTypeInternal _StreamStatus_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull StreamStatus_class_data_;
class Vec3;
struct Vec3DefaultTypeInternal;
extern Vec3DefaultTypeInternal _Vec3_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Vec3_class_data_;
class Vec4D;
struct Vec4DDefaultTypeInternal;
extern Vec4DDefaultTypeInternal _Vec4D_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Vec4D_class_data_;
}  // namespace livelinkapi
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace livelinkapi {

// ===================================================================


// -------------------------------------------------------------------

class Vec4D final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:livelinkapi.Vec4D) */ {
 public:
  inline Vec4D() : Vec4D(nullptr) {}
  ~Vec4D() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Vec4D* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Vec4D));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Vec4D(::google::protobuf::internal::ConstantInitialized);

  inline Vec4D(const Vec4D& from) : Vec4D(nullptr, from) {}
  inline Vec4D(Vec4D&& from) noexcept
      : Vec4D(nullptr, ::std::move(from)) {}
  inline Vec4D& operator=(const Vec4D& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vec4D& operator=(Vec4D&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Vec4D& default_instance() {
    return *reinterpret_cast<const Vec4D*>(
        &_Vec4D_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(Vec4D& a, Vec4D& b) { a.Swap(&b); }
  inline void Swap(Vec4D* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vec4D* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Vec4D* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Vec4D>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Vec4D& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Vec4D& from) { Vec4D::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Vec4D* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "livelinkapi.Vec4D"; }

 protected:
  explicit Vec4D(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  Vec4D(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Vec4D& from);
  Vec4D(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, Vec4D&& from) noexcept
      : Vec4D(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
    kWFieldNumber = 4,
  };
  // double x = 1;
  void clear_x() ;
  double x() const;
  void set_x(double value);

  private:
  double _internal_x() const;
  void _internal_set_x(double value);

  public:
  // double y = 2;
  void clear_y() ;
  double y() const;
  void set_y(double value);

  private:
  double _internal_y() const;
  void _internal_set_y(double value);

  public:
  // double z = 3;
  void clear_z() ;
  double z() const;
  void set_z(double value);

  private:
  double _internal_z() const;
  void _internal_set_z(double value);

  public:
  // double w = 4;
  void clear_w() ;
  double w() const;
  void set_w(double value);

  private:
  double _internal_w() const;
  void _internal_set_w(double value);

  public:
  // @@protoc_insertion_point(class_scope:livelinkapi.Vec4D)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const Vec4D& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    double x_;
    double y_;
    double z_;
    double w_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livelink_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Vec4D_class_data_;
// -------------------------------------------------------------------

class Vec3 final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:livelinkapi.Vec3) */ {
 public:
  inline Vec3() : Vec3(nullptr) {}
  ~Vec3() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Vec3* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Vec3));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Vec3(::google::protobuf::internal::ConstantInitialized);

  inline Vec3(const Vec3& from) : Vec3(nullptr, from) {}
  inline Vec3(Vec3&& from) noexcept
      : Vec3(nullptr, ::std::move(from)) {}
  inline Vec3& operator=(const Vec3& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vec3& operator=(Vec3&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Vec3& default_instance() {
    return *reinterpret_cast<const Vec3*>(
        &_Vec3_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(Vec3& a, Vec3& b) { a.Swap(&b); }
  inline void Swap(Vec3* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vec3* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Vec3* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Vec3>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Vec3& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Vec3& from) { Vec3::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Vec3* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "livelinkapi.Vec3"; }

 protected:
  explicit Vec3(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  Vec3(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Vec3& from);
  Vec3(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, Vec3&& from) noexcept
      : Vec3(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // float x = 1;
  void clear_x() ;
  float x() const;
  void set_x(float value);

  private:
  float _internal_x() const;
  void _internal_set_x(float value);

  public:
  // float y = 2;
  void clear_y() ;
  float y() const;
  void set_y(float value);

  private:
  float _internal_y() const;
  void _internal_set_y(float value);

  public:
  // float z = 3;
  void clear_z() ;
  float z() const;
  void set_z(float value);

  private:
  float _internal_z() const;
  void _internal_set_z(float value);

  public:
  // @@protoc_insertion_point(class_scope:livelinkapi.Vec3)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const Vec3& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    float x_;
    float y_;
    float z_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livelink_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Vec3_class_data_;
// -------------------------------------------------------------------

class StreamStatus final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:livelinkapi.StreamStatus) */ {
 public:
  inline StreamStatus() : StreamStatus(nullptr) {}
  ~StreamStatus() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(StreamStatus* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(StreamStatus));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR StreamStatus(::google::protobuf::internal::ConstantInitialized);

  inline StreamStatus(const StreamStatus& from) : StreamStatus(nullptr, from) {}
  inline StreamStatus(StreamStatus&& from) noexcept
      : StreamStatus(nullptr, ::std::move(from)) {}
  inline StreamStatus& operator=(const StreamStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamStatus& operator=(StreamStatus&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamStatus& default_instance() {
    return *reinterpret_cast<const StreamStatus*>(
        &_StreamStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(StreamStatus& a, StreamStatus& b) { a.Swap(&b); }
  inline void Swap(StreamStatus* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamStatus* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamStatus* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<StreamStatus>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const StreamStatus& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const StreamStatus& from) { StreamStatus::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(StreamStatus* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "livelinkapi.StreamStatus"; }

 protected:
  explicit StreamStatus(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  StreamStatus(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const StreamStatus& from);
  StreamStatus(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, StreamStatus&& from) noexcept
      : StreamStatus(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMessageFieldNumber = 1,
  };
  // string message = 1;
  void clear_message() ;
  const ::std::string& message() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_message();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_message();
  void set_allocated_message(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_message() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_message(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_message();

  public:
  // @@protoc_insertion_point(class_scope:livelinkapi.StreamStatus)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 40,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const StreamStatus& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr message_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livelink_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull StreamStatus_class_data_;
// -------------------------------------------------------------------

class MeshRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:livelinkapi.MeshRequest) */ {
 public:
  inline MeshRequest() : MeshRequest(nullptr) {}
  ~MeshRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(MeshRequest* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(MeshRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MeshRequest(::google::protobuf::internal::ConstantInitialized);

  inline MeshRequest(const MeshRequest& from) : MeshRequest(nullptr, from) {}
  inline MeshRequest(MeshRequest&& from) noexcept
      : MeshRequest(nullptr, ::std::move(from)) {}
  inline MeshRequest& operator=(const MeshRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MeshRequest& operator=(MeshRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MeshRequest& default_instance() {
    return *reinterpret_cast<const MeshRequest*>(
        &_MeshRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(MeshRequest& a, MeshRequest& b) { a.Swap(&b); }
  inline void Swap(MeshRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MeshRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MeshRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<MeshRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MeshRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const MeshRequest& from) { MeshRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(MeshRequest* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "livelinkapi.MeshRequest"; }

 protected:
  explicit MeshRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  MeshRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const MeshRequest& from);
  MeshRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, MeshRequest&& from) noexcept
      : MeshRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kObjecthandleFieldNumber = 1,
  };
  // int32 objecthandle = 1;
  void clear_objecthandle() ;
  ::int32_t objecthandle() const;
  void set_objecthandle(::int32_t value);

  private:
  ::int32_t _internal_objecthandle() const;
  void _internal_set_objecthandle(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:livelinkapi.MeshRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const MeshRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t objecthandle_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livelink_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull MeshRequest_class_data_;
// -------------------------------------------------------------------

class Mesh final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:livelinkapi.Mesh) */ {
 public:
  inline Mesh() : Mesh(nullptr) {}
  ~Mesh() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Mesh* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Mesh));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Mesh(::google::protobuf::internal::ConstantInitialized);

  inline Mesh(const Mesh& from) : Mesh(nullptr, from) {}
  inline Mesh(Mesh&& from) noexcept
      : Mesh(nullptr, ::std::move(from)) {}
  inline Mesh& operator=(const Mesh& from) {
    CopyFrom(from);
    return *this;
  }
  inline Mesh& operator=(Mesh&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Mesh& default_instance() {
    return *reinterpret_cast<const Mesh*>(
        &_Mesh_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(Mesh& a, Mesh& b) { a.Swap(&b); }
  inline void Swap(Mesh* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Mesh* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Mesh* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Mesh>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Mesh& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Mesh& from) { Mesh::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Mesh* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "livelinkapi.Mesh"; }

 protected:
  explicit Mesh(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  Mesh(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Mesh& from);
  Mesh(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, Mesh&& from) noexcept
      : Mesh(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNameFieldNumber = 1,
    kObjectHandleFieldNumber = 3,
    kIdFieldNumber = 2,
  };
  // string name = 1;
  void clear_name() ;
  const ::std::string& name() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_name();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_name();
  void set_allocated_name(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_name(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_name();

  public:
  // int64 objectHandle = 3;
  void clear_objecthandle() ;
  ::int64_t objecthandle() const;
  void set_objecthandle(::int64_t value);

  private:
  ::int64_t _internal_objecthandle() const;
  void _internal_set_objecthandle(::int64_t value);

  public:
  // int32 id = 2;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:livelinkapi.Mesh)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   0, 29,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const Mesh& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::int64_t objecthandle_;
    ::int32_t id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livelink_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Mesh_class_data_;
// -------------------------------------------------------------------

class FileResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:livelinkapi.FileResponse) */ {
 public:
  inline FileResponse() : FileResponse(nullptr) {}
  ~FileResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(FileResponse* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(FileResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR FileResponse(::google::protobuf::internal::ConstantInitialized);

  inline FileResponse(const FileResponse& from) : FileResponse(nullptr, from) {}
  inline FileResponse(FileResponse&& from) noexcept
      : FileResponse(nullptr, ::std::move(from)) {}
  inline FileResponse& operator=(const FileResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline FileResponse& operator=(FileResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FileResponse& default_instance() {
    return *reinterpret_cast<const FileResponse*>(
        &_FileResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(FileResponse& a, FileResponse& b) { a.Swap(&b); }
  inline void Swap(FileResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FileResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FileResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<FileResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FileResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const FileResponse& from) { FileResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(FileResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "livelinkapi.FileResponse"; }

 protected:
  explicit FileResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  FileResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const FileResponse& from);
  FileResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, FileResponse&& from) noexcept
      : FileResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kFiledataFieldNumber = 1,
  };
  // bytes filedata = 1;
  void clear_filedata() ;
  const ::std::string& filedata() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_filedata(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_filedata();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_filedata();
  void set_allocated_filedata(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_filedata() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_filedata(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_filedata();

  public:
  // @@protoc_insertion_point(class_scope:livelinkapi.FileResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const FileResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr filedata_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livelink_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull FileResponse_class_data_;
// -------------------------------------------------------------------

class FileRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:livelinkapi.FileRequest) */ {
 public:
  inline FileRequest() : FileRequest(nullptr) {}
  ~FileRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(FileRequest* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(FileRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR FileRequest(::google::protobuf::internal::ConstantInitialized);

  inline FileRequest(const FileRequest& from) : FileRequest(nullptr, from) {}
  inline FileRequest(FileRequest&& from) noexcept
      : FileRequest(nullptr, ::std::move(from)) {}
  inline FileRequest& operator=(const FileRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline FileRequest& operator=(FileRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FileRequest& default_instance() {
    return *reinterpret_cast<const FileRequest*>(
        &_FileRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(FileRequest& a, FileRequest& b) { a.Swap(&b); }
  inline void Swap(FileRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FileRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FileRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<FileRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FileRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const FileRequest& from) { FileRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(FileRequest* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "livelinkapi.FileRequest"; }

 protected:
  explicit FileRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  FileRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const FileRequest& from);
  FileRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, FileRequest&& from) noexcept
      : FileRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kFilepathFieldNumber = 1,
  };
  // string filepath = 1;
  void clear_filepath() ;
  const ::std::string& filepath() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_filepath(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_filepath();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_filepath();
  void set_allocated_filepath(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_filepath() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_filepath(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_filepath();

  public:
  // @@protoc_insertion_point(class_scope:livelinkapi.FileRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 40,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const FileRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr filepath_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livelink_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull FileRequest_class_data_;
// -------------------------------------------------------------------

class Empty final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:livelinkapi.Empty) */ {
 public:
  inline Empty() : Empty(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Empty* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Empty));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Empty(::google::protobuf::internal::ConstantInitialized);

  inline Empty(const Empty& from) : Empty(nullptr, from) {}
  inline Empty(Empty&& from) noexcept
      : Empty(nullptr, ::std::move(from)) {}
  inline Empty& operator=(const Empty& from) {
    CopyFrom(from);
    return *this;
  }
  inline Empty& operator=(Empty&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Empty& default_instance() {
    return *reinterpret_cast<const Empty*>(
        &_Empty_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(Empty& a, Empty& b) { a.Swap(&b); }
  inline void Swap(Empty* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Empty* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Empty* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<Empty>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Empty& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Empty& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "livelinkapi.Empty"; }

 protected:
  explicit Empty(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  Empty(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Empty& from);
  Empty(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, Empty&& from) noexcept
      : Empty(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:livelinkapi.Empty)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 0,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const Empty& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_livelink_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Empty_class_data_;
// -------------------------------------------------------------------

class MeshList final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:livelinkapi.MeshList) */ {
 public:
  inline MeshList() : MeshList(nullptr) {}
  ~MeshList() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(MeshList* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(MeshList));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MeshList(::google::protobuf::internal::ConstantInitialized);

  inline MeshList(const MeshList& from) : MeshList(nullptr, from) {}
  inline MeshList(MeshList&& from) noexcept
      : MeshList(nullptr, ::std::move(from)) {}
  inline MeshList& operator=(const MeshList& from) {
    CopyFrom(from);
    return *this;
  }
  inline MeshList& operator=(MeshList&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MeshList& default_instance() {
    return *reinterpret_cast<const MeshList*>(
        &_MeshList_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(MeshList& a, MeshList& b) { a.Swap(&b); }
  inline void Swap(MeshList* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MeshList* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MeshList* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<MeshList>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MeshList& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const MeshList& from) { MeshList::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(MeshList* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "livelinkapi.MeshList"; }

 protected:
  explicit MeshList(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  MeshList(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const MeshList& from);
  MeshList(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, MeshList&& from) noexcept
      : MeshList(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMeshesFieldNumber = 1,
  };
  // repeated .livelinkapi.Mesh meshes = 1;
  int meshes_size() const;
  private:
  int _internal_meshes_size() const;

  public:
  void clear_meshes() ;
  ::livelinkapi::Mesh* PROTOBUF_NONNULL mutable_meshes(int index);
  ::google::protobuf::RepeatedPtrField<::livelinkapi::Mesh>* PROTOBUF_NONNULL mutable_meshes();

  private:
  const ::google::protobuf::RepeatedPtrField<::livelinkapi::Mesh>& _internal_meshes() const;
  ::google::protobuf::RepeatedPtrField<::livelinkapi::Mesh>* PROTOBUF_NONNULL _internal_mutable_meshes();
  public:
  const ::livelinkapi::Mesh& meshes(int index) const;
  ::livelinkapi::Mesh* PROTOBUF_NONNULL add_meshes();
  const ::google::protobuf::RepeatedPtrField<::livelinkapi::Mesh>& meshes() const;
  // @@protoc_insertion_point(class_scope:livelinkapi.MeshList)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const MeshList& from_msg);
    ::google::protobuf::RepeatedPtrField< ::livelinkapi::Mesh > meshes_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livelink_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull MeshList_class_data_;
// -------------------------------------------------------------------

class MatrixD final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:livelinkapi.MatrixD) */ {
 public:
  inline MatrixD() : MatrixD(nullptr) {}
  ~MatrixD() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(MatrixD* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(MatrixD));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MatrixD(::google::protobuf::internal::ConstantInitialized);

  inline MatrixD(const MatrixD& from) : MatrixD(nullptr, from) {}
  inline MatrixD(MatrixD&& from) noexcept
      : MatrixD(nullptr, ::std::move(from)) {}
  inline MatrixD& operator=(const MatrixD& from) {
    CopyFrom(from);
    return *this;
  }
  inline MatrixD& operator=(MatrixD&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MatrixD& default_instance() {
    return *reinterpret_cast<const MatrixD*>(
        &_MatrixD_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(MatrixD& a, MatrixD& b) { a.Swap(&b); }
  inline void Swap(MatrixD* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MatrixD* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MatrixD* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<MatrixD>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MatrixD& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const MatrixD& from) { MatrixD::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(MatrixD* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "livelinkapi.MatrixD"; }

 protected:
  explicit MatrixD(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  MatrixD(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const MatrixD& from);
  MatrixD(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, MatrixD&& from) noexcept
      : MatrixD(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kRow0FieldNumber = 1,
    kRow1FieldNumber = 2,
    kRow2FieldNumber = 3,
  };
  // .livelinkapi.Vec4D row0 = 1;
  bool has_row0() const;
  void clear_row0() ;
  const ::livelinkapi::Vec4D& row0() const;
  [[nodiscard]] ::livelinkapi::Vec4D* PROTOBUF_NULLABLE release_row0();
  ::livelinkapi::Vec4D* PROTOBUF_NONNULL mutable_row0();
  void set_allocated_row0(::livelinkapi::Vec4D* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_row0(::livelinkapi::Vec4D* PROTOBUF_NULLABLE value);
  ::livelinkapi::Vec4D* PROTOBUF_NULLABLE unsafe_arena_release_row0();

  private:
  const ::livelinkapi::Vec4D& _internal_row0() const;
  ::livelinkapi::Vec4D* PROTOBUF_NONNULL _internal_mutable_row0();

  public:
  // .livelinkapi.Vec4D row1 = 2;
  bool has_row1() const;
  void clear_row1() ;
  const ::livelinkapi::Vec4D& row1() const;
  [[nodiscard]] ::livelinkapi::Vec4D* PROTOBUF_NULLABLE release_row1();
  ::livelinkapi::Vec4D* PROTOBUF_NONNULL mutable_row1();
  void set_allocated_row1(::livelinkapi::Vec4D* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_row1(::livelinkapi::Vec4D* PROTOBUF_NULLABLE value);
  ::livelinkapi::Vec4D* PROTOBUF_NULLABLE unsafe_arena_release_row1();

  private:
  const ::livelinkapi::Vec4D& _internal_row1() const;
  ::livelinkapi::Vec4D* PROTOBUF_NONNULL _internal_mutable_row1();

  public:
  // .livelinkapi.Vec4D row2 = 3;
  bool has_row2() const;
  void clear_row2() ;
  const ::livelinkapi::Vec4D& row2() const;
  [[nodiscard]] ::livelinkapi::Vec4D* PROTOBUF_NULLABLE release_row2();
  ::livelinkapi::Vec4D* PROTOBUF_NONNULL mutable_row2();
  void set_allocated_row2(::livelinkapi::Vec4D* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_row2(::livelinkapi::Vec4D* PROTOBUF_NULLABLE value);
  ::livelinkapi::Vec4D* PROTOBUF_NULLABLE unsafe_arena_release_row2();

  private:
  const ::livelinkapi::Vec4D& _internal_row2() const;
  ::livelinkapi::Vec4D* PROTOBUF_NONNULL _internal_mutable_row2();

  public:
  // @@protoc_insertion_point(class_scope:livelinkapi.MatrixD)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   3, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const MatrixD& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::livelinkapi::Vec4D* PROTOBUF_NULLABLE row0_;
    ::livelinkapi::Vec4D* PROTOBUF_NULLABLE row1_;
    ::livelinkapi::Vec4D* PROTOBUF_NULLABLE row2_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livelink_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull MatrixD_class_data_;
// -------------------------------------------------------------------

class CameraState final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:livelinkapi.CameraState) */ {
 public:
  inline CameraState() : CameraState(nullptr) {}
  ~CameraState() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CameraState* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CameraState));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CameraState(::google::protobuf::internal::ConstantInitialized);

  inline CameraState(const CameraState& from) : CameraState(nullptr, from) {}
  inline CameraState(CameraState&& from) noexcept
      : CameraState(nullptr, ::std::move(from)) {}
  inline CameraState& operator=(const CameraState& from) {
    CopyFrom(from);
    return *this;
  }
  inline CameraState& operator=(CameraState&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CameraState& default_instance() {
    return *reinterpret_cast<const CameraState*>(
        &_CameraState_default_instance_);
  }
  enum PosSetCase {
    kPosition = 1,
    POS_SET_NOT_SET = 0,
  };
  enum TargetSetCase {
    kTarget = 2,
    TARGET_SET_NOT_SET = 0,
  };
  enum UpSetCase {
    kUp = 3,
    UP_SET_NOT_SET = 0,
  };
  enum FovSetCase {
    kFov = 4,
    FOV_SET_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(CameraState& a, CameraState& b) { a.Swap(&b); }
  inline void Swap(CameraState* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CameraState* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CameraState* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CameraState>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CameraState& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CameraState& from) { CameraState::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CameraState* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "livelinkapi.CameraState"; }

 protected:
  explicit CameraState(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  CameraState(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const CameraState& from);
  CameraState(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, CameraState&& from) noexcept
      : CameraState(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPositionFieldNumber = 1,
    kTargetFieldNumber = 2,
    kUpFieldNumber = 3,
    kFovFieldNumber = 4,
  };
  // .livelinkapi.Vec3 position = 1;
  bool has_position() const;
  private:
  bool _internal_has_position() const;

  public:
  void clear_position() ;
  const ::livelinkapi::Vec3& position() const;
  [[nodiscard]] ::livelinkapi::Vec3* PROTOBUF_NULLABLE release_position();
  ::livelinkapi::Vec3* PROTOBUF_NONNULL mutable_position();
  void set_allocated_position(::livelinkapi::Vec3* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_position(::livelinkapi::Vec3* PROTOBUF_NULLABLE value);
  ::livelinkapi::Vec3* PROTOBUF_NULLABLE unsafe_arena_release_position();

  private:
  const ::livelinkapi::Vec3& _internal_position() const;
  ::livelinkapi::Vec3* PROTOBUF_NONNULL _internal_mutable_position();

  public:
  // .livelinkapi.Vec3 target = 2;
  bool has_target() const;
  private:
  bool _internal_has_target() const;

  public:
  void clear_target() ;
  const ::livelinkapi::Vec3& target() const;
  [[nodiscard]] ::livelinkapi::Vec3* PROTOBUF_NULLABLE release_target();
  ::livelinkapi::Vec3* PROTOBUF_NONNULL mutable_target();
  void set_allocated_target(::livelinkapi::Vec3* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_target(::livelinkapi::Vec3* PROTOBUF_NULLABLE value);
  ::livelinkapi::Vec3* PROTOBUF_NULLABLE unsafe_arena_release_target();

  private:
  const ::livelinkapi::Vec3& _internal_target() const;
  ::livelinkapi::Vec3* PROTOBUF_NONNULL _internal_mutable_target();

  public:
  // .livelinkapi.Vec3 up = 3;
  bool has_up() const;
  private:
  bool _internal_has_up() const;

  public:
  void clear_up() ;
  const ::livelinkapi::Vec3& up() const;
  [[nodiscard]] ::livelinkapi::Vec3* PROTOBUF_NULLABLE release_up();
  ::livelinkapi::Vec3* PROTOBUF_NONNULL mutable_up();
  void set_allocated_up(::livelinkapi::Vec3* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_up(::livelinkapi::Vec3* PROTOBUF_NULLABLE value);
  ::livelinkapi::Vec3* PROTOBUF_NULLABLE unsafe_arena_release_up();

  private:
  const ::livelinkapi::Vec3& _internal_up() const;
  ::livelinkapi::Vec3* PROTOBUF_NONNULL _internal_mutable_up();

  public:
  // float fov = 4;
  bool has_fov() const;
  void clear_fov() ;
  float fov() const;
  void set_fov(float value);

  private:
  float _internal_fov() const;
  void _internal_set_fov(float value);

  public:
  void clear_pos_set();
  PosSetCase pos_set_case() const;
  void clear_target_set();
  TargetSetCase target_set_case() const;
  void clear_up_set();
  UpSetCase up_set_case() const;
  void clear_fov_set();
  FovSetCase fov_set_case() const;
  // @@protoc_insertion_point(class_scope:livelinkapi.CameraState)
 private:
  class _Internal;
  void set_has_position();
  void set_has_target();
  void set_has_up();
  void set_has_fov();
  inline bool has_pos_set() const;
  inline void clear_has_pos_set();
  inline bool has_target_set() const;
  inline void clear_has_target_set();
  inline bool has_up_set() const;
  inline void clear_has_up_set();
  inline bool has_fov_set() const;
  inline void clear_has_fov_set();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 4,
                                   3, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const CameraState& from_msg);
    union PosSetUnion {
      constexpr PosSetUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::livelinkapi::Vec3* PROTOBUF_NULLABLE position_;
    } pos_set_;
    union TargetSetUnion {
      constexpr TargetSetUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::livelinkapi::Vec3* PROTOBUF_NULLABLE target_;
    } target_set_;
    union UpSetUnion {
      constexpr UpSetUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::livelinkapi::Vec3* PROTOBUF_NULLABLE up_;
    } up_set_;
    union FovSetUnion {
      constexpr FovSetUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      float fov_;
    } fov_set_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[4];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livelink_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull CameraState_class_data_;
// -------------------------------------------------------------------

class MeshData final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:livelinkapi.MeshData) */ {
 public:
  inline MeshData() : MeshData(nullptr) {}
  ~MeshData() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(MeshData* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(MeshData));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MeshData(::google::protobuf::internal::ConstantInitialized);

  inline MeshData(const MeshData& from) : MeshData(nullptr, from) {}
  inline MeshData(MeshData&& from) noexcept
      : MeshData(nullptr, ::std::move(from)) {}
  inline MeshData& operator=(const MeshData& from) {
    CopyFrom(from);
    return *this;
  }
  inline MeshData& operator=(MeshData&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MeshData& default_instance() {
    return *reinterpret_cast<const MeshData*>(
        &_MeshData_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(MeshData& a, MeshData& b) { a.Swap(&b); }
  inline void Swap(MeshData* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MeshData* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MeshData* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<MeshData>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MeshData& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const MeshData& from) { MeshData::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(MeshData* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "livelinkapi.MeshData"; }

 protected:
  explicit MeshData(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  MeshData(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const MeshData& from);
  MeshData(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, MeshData&& from) noexcept
      : MeshData(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPositionsFieldNumber = 2,
    kNormalsFieldNumber = 3,
    kVertsPerPolyFieldNumber = 4,
    kPolyVertIndicesFieldNumber = 5,
    kPolyNormalIndicesFieldNumber = 6,
    kNameFieldNumber = 1,
    kWorldMatrixFieldNumber = 8,
    kWindingOrderFieldNumber = 7,
  };
  // repeated .livelinkapi.Vec3 positions = 2;
  int positions_size() const;
  private:
  int _internal_positions_size() const;

  public:
  void clear_positions() ;
  ::livelinkapi::Vec3* PROTOBUF_NONNULL mutable_positions(int index);
  ::google::protobuf::RepeatedPtrField<::livelinkapi::Vec3>* PROTOBUF_NONNULL mutable_positions();

  private:
  const ::google::protobuf::RepeatedPtrField<::livelinkapi::Vec3>& _internal_positions() const;
  ::google::protobuf::RepeatedPtrField<::livelinkapi::Vec3>* PROTOBUF_NONNULL _internal_mutable_positions();
  public:
  const ::livelinkapi::Vec3& positions(int index) const;
  ::livelinkapi::Vec3* PROTOBUF_NONNULL add_positions();
  const ::google::protobuf::RepeatedPtrField<::livelinkapi::Vec3>& positions() const;
  // repeated .livelinkapi.Vec3 normals = 3;
  int normals_size() const;
  private:
  int _internal_normals_size() const;

  public:
  void clear_normals() ;
  ::livelinkapi::Vec3* PROTOBUF_NONNULL mutable_normals(int index);
  ::google::protobuf::RepeatedPtrField<::livelinkapi::Vec3>* PROTOBUF_NONNULL mutable_normals();

  private:
  const ::google::protobuf::RepeatedPtrField<::livelinkapi::Vec3>& _internal_normals() const;
  ::google::protobuf::RepeatedPtrField<::livelinkapi::Vec3>* PROTOBUF_NONNULL _internal_mutable_normals();
  public:
  const ::livelinkapi::Vec3& normals(int index) const;
  ::livelinkapi::Vec3* PROTOBUF_NONNULL add_normals();
  const ::google::protobuf::RepeatedPtrField<::livelinkapi::Vec3>& normals() const;
  // repeated uint32 vertsPerPoly = 4;
  int vertsperpoly_size() const;
  private:
  int _internal_vertsperpoly_size() const;

  public:
  void clear_vertsperpoly() ;
  ::uint32_t vertsperpoly(int index) const;
  void set_vertsperpoly(int index, ::uint32_t value);
  void add_vertsperpoly(::uint32_t value);
  const ::google::protobuf::RepeatedField<::uint32_t>& vertsperpoly() const;
  ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL mutable_vertsperpoly();

  private:
  const ::google::protobuf::RepeatedField<::uint32_t>& _internal_vertsperpoly() const;
  ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL _internal_mutable_vertsperpoly();

  public:
  // repeated uint32 polyVertIndices = 5;
  int polyvertindices_size() const;
  private:
  int _internal_polyvertindices_size() const;

  public:
  void clear_polyvertindices() ;
  ::uint32_t polyvertindices(int index) const;
  void set_polyvertindices(int index, ::uint32_t value);
  void add_polyvertindices(::uint32_t value);
  const ::google::protobuf::RepeatedField<::uint32_t>& polyvertindices() const;
  ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL mutable_polyvertindices();

  private:
  const ::google::protobuf::RepeatedField<::uint32_t>& _internal_polyvertindices() const;
  ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL _internal_mutable_polyvertindices();

  public:
  // repeated uint32 polyNormalIndices = 6;
  int polynormalindices_size() const;
  private:
  int _internal_polynormalindices_size() const;

  public:
  void clear_polynormalindices() ;
  ::uint32_t polynormalindices(int index) const;
  void set_polynormalindices(int index, ::uint32_t value);
  void add_polynormalindices(::uint32_t value);
  const ::google::protobuf::RepeatedField<::uint32_t>& polynormalindices() const;
  ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL mutable_polynormalindices();

  private:
  const ::google::protobuf::RepeatedField<::uint32_t>& _internal_polynormalindices() const;
  ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL _internal_mutable_polynormalindices();

  public:
  // string name = 1;
  void clear_name() ;
  const ::std::string& name() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_name();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_name();
  void set_allocated_name(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_name(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_name();

  public:
  // .livelinkapi.MatrixD worldMatrix = 8;
  bool has_worldmatrix() const;
  void clear_worldmatrix() ;
  const ::livelinkapi::MatrixD& worldmatrix() const;
  [[nodiscard]] ::livelinkapi::MatrixD* PROTOBUF_NULLABLE release_worldmatrix();
  ::livelinkapi::MatrixD* PROTOBUF_NONNULL mutable_worldmatrix();
  void set_allocated_worldmatrix(::livelinkapi::MatrixD* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_worldmatrix(::livelinkapi::MatrixD* PROTOBUF_NULLABLE value);
  ::livelinkapi::MatrixD* PROTOBUF_NULLABLE unsafe_arena_release_worldmatrix();

  private:
  const ::livelinkapi::MatrixD& _internal_worldmatrix() const;
  ::livelinkapi::MatrixD* PROTOBUF_NONNULL _internal_mutable_worldmatrix();

  public:
  // int32 windingOrder = 7;
  void clear_windingorder() ;
  ::int32_t windingorder() const;
  void set_windingorder(::int32_t value);

  private:
  ::int32_t _internal_windingorder() const;
  void _internal_set_windingorder(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:livelinkapi.MeshData)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 8,
                                   3, 41,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const MeshData& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::livelinkapi::Vec3 > positions_;
    ::google::protobuf::RepeatedPtrField< ::livelinkapi::Vec3 > normals_;
    ::google::protobuf::RepeatedField<::uint32_t> vertsperpoly_;
    ::google::protobuf::internal::CachedSize _vertsperpoly_cached_byte_size_;
    ::google::protobuf::RepeatedField<::uint32_t> polyvertindices_;
    ::google::protobuf::internal::CachedSize _polyvertindices_cached_byte_size_;
    ::google::protobuf::RepeatedField<::uint32_t> polynormalindices_;
    ::google::protobuf::internal::CachedSize _polynormalindices_cached_byte_size_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::livelinkapi::MatrixD* PROTOBUF_NULLABLE worldmatrix_;
    ::int32_t windingorder_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livelink_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull MeshData_class_data_;

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Vec3

// float x = 1;
inline void Vec3::clear_x() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.x_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline float Vec3::x() const {
  // @@protoc_insertion_point(field_get:livelinkapi.Vec3.x)
  return _internal_x();
}
inline void Vec3::set_x(float value) {
  _internal_set_x(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:livelinkapi.Vec3.x)
}
inline float Vec3::_internal_x() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.x_;
}
inline void Vec3::_internal_set_x(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.x_ = value;
}

// float y = 2;
inline void Vec3::clear_y() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.y_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float Vec3::y() const {
  // @@protoc_insertion_point(field_get:livelinkapi.Vec3.y)
  return _internal_y();
}
inline void Vec3::set_y(float value) {
  _internal_set_y(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:livelinkapi.Vec3.y)
}
inline float Vec3::_internal_y() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.y_;
}
inline void Vec3::_internal_set_y(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.y_ = value;
}

// float z = 3;
inline void Vec3::clear_z() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.z_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline float Vec3::z() const {
  // @@protoc_insertion_point(field_get:livelinkapi.Vec3.z)
  return _internal_z();
}
inline void Vec3::set_z(float value) {
  _internal_set_z(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:livelinkapi.Vec3.z)
}
inline float Vec3::_internal_z() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.z_;
}
inline void Vec3::_internal_set_z(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.z_ = value;
}

// -------------------------------------------------------------------

// Vec4D

// double x = 1;
inline void Vec4D::clear_x() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.x_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline double Vec4D::x() const {
  // @@protoc_insertion_point(field_get:livelinkapi.Vec4D.x)
  return _internal_x();
}
inline void Vec4D::set_x(double value) {
  _internal_set_x(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:livelinkapi.Vec4D.x)
}
inline double Vec4D::_internal_x() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.x_;
}
inline void Vec4D::_internal_set_x(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.x_ = value;
}

// double y = 2;
inline void Vec4D::clear_y() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.y_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double Vec4D::y() const {
  // @@protoc_insertion_point(field_get:livelinkapi.Vec4D.y)
  return _internal_y();
}
inline void Vec4D::set_y(double value) {
  _internal_set_y(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:livelinkapi.Vec4D.y)
}
inline double Vec4D::_internal_y() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.y_;
}
inline void Vec4D::_internal_set_y(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.y_ = value;
}

// double z = 3;
inline void Vec4D::clear_z() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.z_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double Vec4D::z() const {
  // @@protoc_insertion_point(field_get:livelinkapi.Vec4D.z)
  return _internal_z();
}
inline void Vec4D::set_z(double value) {
  _internal_set_z(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:livelinkapi.Vec4D.z)
}
inline double Vec4D::_internal_z() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.z_;
}
inline void Vec4D::_internal_set_z(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.z_ = value;
}

// double w = 4;
inline void Vec4D::clear_w() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.w_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline double Vec4D::w() const {
  // @@protoc_insertion_point(field_get:livelinkapi.Vec4D.w)
  return _internal_w();
}
inline void Vec4D::set_w(double value) {
  _internal_set_w(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:livelinkapi.Vec4D.w)
}
inline double Vec4D::_internal_w() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.w_;
}
inline void Vec4D::_internal_set_w(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.w_ = value;
}

// -------------------------------------------------------------------

// MatrixD

// .livelinkapi.Vec4D row0 = 1;
inline bool MatrixD::has_row0() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.row0_ != nullptr);
  return value;
}
inline void MatrixD::clear_row0() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.row0_ != nullptr) _impl_.row0_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::livelinkapi::Vec4D& MatrixD::_internal_row0() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::livelinkapi::Vec4D* p = _impl_.row0_;
  return p != nullptr ? *p : reinterpret_cast<const ::livelinkapi::Vec4D&>(::livelinkapi::_Vec4D_default_instance_);
}
inline const ::livelinkapi::Vec4D& MatrixD::row0() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livelinkapi.MatrixD.row0)
  return _internal_row0();
}
inline void MatrixD::unsafe_arena_set_allocated_row0(
    ::livelinkapi::Vec4D* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.row0_);
  }
  _impl_.row0_ = reinterpret_cast<::livelinkapi::Vec4D*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livelinkapi.MatrixD.row0)
}
inline ::livelinkapi::Vec4D* PROTOBUF_NULLABLE MatrixD::release_row0() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::livelinkapi::Vec4D* released = _impl_.row0_;
  _impl_.row0_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::livelinkapi::Vec4D* PROTOBUF_NULLABLE MatrixD::unsafe_arena_release_row0() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livelinkapi.MatrixD.row0)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::livelinkapi::Vec4D* temp = _impl_.row0_;
  _impl_.row0_ = nullptr;
  return temp;
}
inline ::livelinkapi::Vec4D* PROTOBUF_NONNULL MatrixD::_internal_mutable_row0() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.row0_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::livelinkapi::Vec4D>(GetArena());
    _impl_.row0_ = reinterpret_cast<::livelinkapi::Vec4D*>(p);
  }
  return _impl_.row0_;
}
inline ::livelinkapi::Vec4D* PROTOBUF_NONNULL MatrixD::mutable_row0()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::livelinkapi::Vec4D* _msg = _internal_mutable_row0();
  // @@protoc_insertion_point(field_mutable:livelinkapi.MatrixD.row0)
  return _msg;
}
inline void MatrixD::set_allocated_row0(::livelinkapi::Vec4D* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.row0_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.row0_ = reinterpret_cast<::livelinkapi::Vec4D*>(value);
  // @@protoc_insertion_point(field_set_allocated:livelinkapi.MatrixD.row0)
}

// .livelinkapi.Vec4D row1 = 2;
inline bool MatrixD::has_row1() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.row1_ != nullptr);
  return value;
}
inline void MatrixD::clear_row1() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.row1_ != nullptr) _impl_.row1_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::livelinkapi::Vec4D& MatrixD::_internal_row1() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::livelinkapi::Vec4D* p = _impl_.row1_;
  return p != nullptr ? *p : reinterpret_cast<const ::livelinkapi::Vec4D&>(::livelinkapi::_Vec4D_default_instance_);
}
inline const ::livelinkapi::Vec4D& MatrixD::row1() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livelinkapi.MatrixD.row1)
  return _internal_row1();
}
inline void MatrixD::unsafe_arena_set_allocated_row1(
    ::livelinkapi::Vec4D* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.row1_);
  }
  _impl_.row1_ = reinterpret_cast<::livelinkapi::Vec4D*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livelinkapi.MatrixD.row1)
}
inline ::livelinkapi::Vec4D* PROTOBUF_NULLABLE MatrixD::release_row1() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::livelinkapi::Vec4D* released = _impl_.row1_;
  _impl_.row1_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::livelinkapi::Vec4D* PROTOBUF_NULLABLE MatrixD::unsafe_arena_release_row1() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livelinkapi.MatrixD.row1)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::livelinkapi::Vec4D* temp = _impl_.row1_;
  _impl_.row1_ = nullptr;
  return temp;
}
inline ::livelinkapi::Vec4D* PROTOBUF_NONNULL MatrixD::_internal_mutable_row1() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.row1_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::livelinkapi::Vec4D>(GetArena());
    _impl_.row1_ = reinterpret_cast<::livelinkapi::Vec4D*>(p);
  }
  return _impl_.row1_;
}
inline ::livelinkapi::Vec4D* PROTOBUF_NONNULL MatrixD::mutable_row1()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::livelinkapi::Vec4D* _msg = _internal_mutable_row1();
  // @@protoc_insertion_point(field_mutable:livelinkapi.MatrixD.row1)
  return _msg;
}
inline void MatrixD::set_allocated_row1(::livelinkapi::Vec4D* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.row1_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.row1_ = reinterpret_cast<::livelinkapi::Vec4D*>(value);
  // @@protoc_insertion_point(field_set_allocated:livelinkapi.MatrixD.row1)
}

// .livelinkapi.Vec4D row2 = 3;
inline bool MatrixD::has_row2() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.row2_ != nullptr);
  return value;
}
inline void MatrixD::clear_row2() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.row2_ != nullptr) _impl_.row2_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::livelinkapi::Vec4D& MatrixD::_internal_row2() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::livelinkapi::Vec4D* p = _impl_.row2_;
  return p != nullptr ? *p : reinterpret_cast<const ::livelinkapi::Vec4D&>(::livelinkapi::_Vec4D_default_instance_);
}
inline const ::livelinkapi::Vec4D& MatrixD::row2() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livelinkapi.MatrixD.row2)
  return _internal_row2();
}
inline void MatrixD::unsafe_arena_set_allocated_row2(
    ::livelinkapi::Vec4D* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.row2_);
  }
  _impl_.row2_ = reinterpret_cast<::livelinkapi::Vec4D*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livelinkapi.MatrixD.row2)
}
inline ::livelinkapi::Vec4D* PROTOBUF_NULLABLE MatrixD::release_row2() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::livelinkapi::Vec4D* released = _impl_.row2_;
  _impl_.row2_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::livelinkapi::Vec4D* PROTOBUF_NULLABLE MatrixD::unsafe_arena_release_row2() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livelinkapi.MatrixD.row2)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::livelinkapi::Vec4D* temp = _impl_.row2_;
  _impl_.row2_ = nullptr;
  return temp;
}
inline ::livelinkapi::Vec4D* PROTOBUF_NONNULL MatrixD::_internal_mutable_row2() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.row2_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::livelinkapi::Vec4D>(GetArena());
    _impl_.row2_ = reinterpret_cast<::livelinkapi::Vec4D*>(p);
  }
  return _impl_.row2_;
}
inline ::livelinkapi::Vec4D* PROTOBUF_NONNULL MatrixD::mutable_row2()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::livelinkapi::Vec4D* _msg = _internal_mutable_row2();
  // @@protoc_insertion_point(field_mutable:livelinkapi.MatrixD.row2)
  return _msg;
}
inline void MatrixD::set_allocated_row2(::livelinkapi::Vec4D* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.row2_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.row2_ = reinterpret_cast<::livelinkapi::Vec4D*>(value);
  // @@protoc_insertion_point(field_set_allocated:livelinkapi.MatrixD.row2)
}

// -------------------------------------------------------------------

// Mesh

// string name = 1;
inline void Mesh::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& Mesh::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livelinkapi.Mesh.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void Mesh::set_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livelinkapi.Mesh.name)
}
inline ::std::string* PROTOBUF_NONNULL Mesh::mutable_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:livelinkapi.Mesh.name)
  return _s;
}
inline const ::std::string& Mesh::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void Mesh::_internal_set_name(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL Mesh::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE Mesh::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livelinkapi.Mesh.name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.name_.Set("", GetArena());
  }
  return released;
}
inline void Mesh::set_allocated_name(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livelinkapi.Mesh.name)
}

// int32 id = 2;
inline void Mesh::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t Mesh::id() const {
  // @@protoc_insertion_point(field_get:livelinkapi.Mesh.id)
  return _internal_id();
}
inline void Mesh::set_id(::int32_t value) {
  _internal_set_id(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:livelinkapi.Mesh.id)
}
inline ::int32_t Mesh::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_;
}
inline void Mesh::_internal_set_id(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = value;
}

// int64 objectHandle = 3;
inline void Mesh::clear_objecthandle() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.objecthandle_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int64_t Mesh::objecthandle() const {
  // @@protoc_insertion_point(field_get:livelinkapi.Mesh.objectHandle)
  return _internal_objecthandle();
}
inline void Mesh::set_objecthandle(::int64_t value) {
  _internal_set_objecthandle(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:livelinkapi.Mesh.objectHandle)
}
inline ::int64_t Mesh::_internal_objecthandle() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.objecthandle_;
}
inline void Mesh::_internal_set_objecthandle(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.objecthandle_ = value;
}

// -------------------------------------------------------------------

// MeshList

// repeated .livelinkapi.Mesh meshes = 1;
inline int MeshList::_internal_meshes_size() const {
  return _internal_meshes().size();
}
inline int MeshList::meshes_size() const {
  return _internal_meshes_size();
}
inline void MeshList::clear_meshes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.meshes_.Clear();
}
inline ::livelinkapi::Mesh* PROTOBUF_NONNULL MeshList::mutable_meshes(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:livelinkapi.MeshList.meshes)
  return _internal_mutable_meshes()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::livelinkapi::Mesh>* PROTOBUF_NONNULL MeshList::mutable_meshes()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:livelinkapi.MeshList.meshes)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_meshes();
}
inline const ::livelinkapi::Mesh& MeshList::meshes(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livelinkapi.MeshList.meshes)
  return _internal_meshes().Get(index);
}
inline ::livelinkapi::Mesh* PROTOBUF_NONNULL MeshList::add_meshes()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::livelinkapi::Mesh* _add = _internal_mutable_meshes()->Add();
  // @@protoc_insertion_point(field_add:livelinkapi.MeshList.meshes)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::livelinkapi::Mesh>& MeshList::meshes() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:livelinkapi.MeshList.meshes)
  return _internal_meshes();
}
inline const ::google::protobuf::RepeatedPtrField<::livelinkapi::Mesh>&
MeshList::_internal_meshes() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.meshes_;
}
inline ::google::protobuf::RepeatedPtrField<::livelinkapi::Mesh>* PROTOBUF_NONNULL
MeshList::_internal_mutable_meshes() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.meshes_;
}

// -------------------------------------------------------------------

// CameraState

// .livelinkapi.Vec3 position = 1;
inline bool CameraState::has_position() const {
  return pos_set_case() == kPosition;
}
inline bool CameraState::_internal_has_position() const {
  return pos_set_case() == kPosition;
}
inline void CameraState::set_has_position() {
  _impl_._oneof_case_[0] = kPosition;
}
inline void CameraState::clear_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (pos_set_case() == kPosition) {
    if (GetArena() == nullptr) {
      delete _impl_.pos_set_.position_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.pos_set_.position_);
    }
    clear_has_pos_set();
  }
}
inline ::livelinkapi::Vec3* PROTOBUF_NULLABLE CameraState::release_position() {
  // @@protoc_insertion_point(field_release:livelinkapi.CameraState.position)
  if (pos_set_case() == kPosition) {
    clear_has_pos_set();
    auto* temp = _impl_.pos_set_.position_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.pos_set_.position_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livelinkapi::Vec3& CameraState::_internal_position() const {
  return pos_set_case() == kPosition ? *_impl_.pos_set_.position_ : reinterpret_cast<::livelinkapi::Vec3&>(::livelinkapi::_Vec3_default_instance_);
}
inline const ::livelinkapi::Vec3& CameraState::position() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livelinkapi.CameraState.position)
  return _internal_position();
}
inline ::livelinkapi::Vec3* PROTOBUF_NULLABLE CameraState::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livelinkapi.CameraState.position)
  if (pos_set_case() == kPosition) {
    clear_has_pos_set();
    auto* temp = _impl_.pos_set_.position_;
    _impl_.pos_set_.position_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CameraState::unsafe_arena_set_allocated_position(
    ::livelinkapi::Vec3* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_pos_set();
  if (value) {
    set_has_position();
    _impl_.pos_set_.position_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livelinkapi.CameraState.position)
}
inline ::livelinkapi::Vec3* PROTOBUF_NONNULL CameraState::_internal_mutable_position() {
  if (pos_set_case() != kPosition) {
    clear_pos_set();
    set_has_position();
    _impl_.pos_set_.position_ = 
        ::google::protobuf::Message::DefaultConstruct<::livelinkapi::Vec3>(GetArena());
  }
  return _impl_.pos_set_.position_;
}
inline ::livelinkapi::Vec3* PROTOBUF_NONNULL CameraState::mutable_position()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::livelinkapi::Vec3* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:livelinkapi.CameraState.position)
  return _msg;
}

// .livelinkapi.Vec3 target = 2;
inline bool CameraState::has_target() const {
  return target_set_case() == kTarget;
}
inline bool CameraState::_internal_has_target() const {
  return target_set_case() == kTarget;
}
inline void CameraState::set_has_target() {
  _impl_._oneof_case_[1] = kTarget;
}
inline void CameraState::clear_target() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (target_set_case() == kTarget) {
    if (GetArena() == nullptr) {
      delete _impl_.target_set_.target_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.target_set_.target_);
    }
    clear_has_target_set();
  }
}
inline ::livelinkapi::Vec3* PROTOBUF_NULLABLE CameraState::release_target() {
  // @@protoc_insertion_point(field_release:livelinkapi.CameraState.target)
  if (target_set_case() == kTarget) {
    clear_has_target_set();
    auto* temp = _impl_.target_set_.target_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.target_set_.target_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livelinkapi::Vec3& CameraState::_internal_target() const {
  return target_set_case() == kTarget ? *_impl_.target_set_.target_ : reinterpret_cast<::livelinkapi::Vec3&>(::livelinkapi::_Vec3_default_instance_);
}
inline const ::livelinkapi::Vec3& CameraState::target() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livelinkapi.CameraState.target)
  return _internal_target();
}
inline ::livelinkapi::Vec3* PROTOBUF_NULLABLE CameraState::unsafe_arena_release_target() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livelinkapi.CameraState.target)
  if (target_set_case() == kTarget) {
    clear_has_target_set();
    auto* temp = _impl_.target_set_.target_;
    _impl_.target_set_.target_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CameraState::unsafe_arena_set_allocated_target(
    ::livelinkapi::Vec3* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_target_set();
  if (value) {
    set_has_target();
    _impl_.target_set_.target_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livelinkapi.CameraState.target)
}
inline ::livelinkapi::Vec3* PROTOBUF_NONNULL CameraState::_internal_mutable_target() {
  if (target_set_case() != kTarget) {
    clear_target_set();
    set_has_target();
    _impl_.target_set_.target_ = 
        ::google::protobuf::Message::DefaultConstruct<::livelinkapi::Vec3>(GetArena());
  }
  return _impl_.target_set_.target_;
}
inline ::livelinkapi::Vec3* PROTOBUF_NONNULL CameraState::mutable_target()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::livelinkapi::Vec3* _msg = _internal_mutable_target();
  // @@protoc_insertion_point(field_mutable:livelinkapi.CameraState.target)
  return _msg;
}

// .livelinkapi.Vec3 up = 3;
inline bool CameraState::has_up() const {
  return up_set_case() == kUp;
}
inline bool CameraState::_internal_has_up() const {
  return up_set_case() == kUp;
}
inline void CameraState::set_has_up() {
  _impl_._oneof_case_[2] = kUp;
}
inline void CameraState::clear_up() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (up_set_case() == kUp) {
    if (GetArena() == nullptr) {
      delete _impl_.up_set_.up_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.up_set_.up_);
    }
    clear_has_up_set();
  }
}
inline ::livelinkapi::Vec3* PROTOBUF_NULLABLE CameraState::release_up() {
  // @@protoc_insertion_point(field_release:livelinkapi.CameraState.up)
  if (up_set_case() == kUp) {
    clear_has_up_set();
    auto* temp = _impl_.up_set_.up_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.up_set_.up_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livelinkapi::Vec3& CameraState::_internal_up() const {
  return up_set_case() == kUp ? *_impl_.up_set_.up_ : reinterpret_cast<::livelinkapi::Vec3&>(::livelinkapi::_Vec3_default_instance_);
}
inline const ::livelinkapi::Vec3& CameraState::up() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livelinkapi.CameraState.up)
  return _internal_up();
}
inline ::livelinkapi::Vec3* PROTOBUF_NULLABLE CameraState::unsafe_arena_release_up() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livelinkapi.CameraState.up)
  if (up_set_case() == kUp) {
    clear_has_up_set();
    auto* temp = _impl_.up_set_.up_;
    _impl_.up_set_.up_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CameraState::unsafe_arena_set_allocated_up(
    ::livelinkapi::Vec3* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_up_set();
  if (value) {
    set_has_up();
    _impl_.up_set_.up_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livelinkapi.CameraState.up)
}
inline ::livelinkapi::Vec3* PROTOBUF_NONNULL CameraState::_internal_mutable_up() {
  if (up_set_case() != kUp) {
    clear_up_set();
    set_has_up();
    _impl_.up_set_.up_ = 
        ::google::protobuf::Message::DefaultConstruct<::livelinkapi::Vec3>(GetArena());
  }
  return _impl_.up_set_.up_;
}
inline ::livelinkapi::Vec3* PROTOBUF_NONNULL CameraState::mutable_up()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::livelinkapi::Vec3* _msg = _internal_mutable_up();
  // @@protoc_insertion_point(field_mutable:livelinkapi.CameraState.up)
  return _msg;
}

// float fov = 4;
inline bool CameraState::has_fov() const {
  return fov_set_case() == kFov;
}
inline void CameraState::set_has_fov() {
  _impl_._oneof_case_[3] = kFov;
}
inline void CameraState::clear_fov() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (fov_set_case() == kFov) {
    _impl_.fov_set_.fov_ = 0;
    clear_has_fov_set();
  }
}
inline float CameraState::fov() const {
  // @@protoc_insertion_point(field_get:livelinkapi.CameraState.fov)
  return _internal_fov();
}
inline void CameraState::set_fov(float value) {
  if (fov_set_case() != kFov) {
    clear_fov_set();
    set_has_fov();
  }
  _impl_.fov_set_.fov_ = value;
  // @@protoc_insertion_point(field_set:livelinkapi.CameraState.fov)
}
inline float CameraState::_internal_fov() const {
  if (fov_set_case() == kFov) {
    return _impl_.fov_set_.fov_;
  }
  return 0;
}

inline bool CameraState::has_pos_set() const {
  return pos_set_case() != POS_SET_NOT_SET;
}
inline void CameraState::clear_has_pos_set() {
  _impl_._oneof_case_[0] = POS_SET_NOT_SET;
}
inline bool CameraState::has_target_set() const {
  return target_set_case() != TARGET_SET_NOT_SET;
}
inline void CameraState::clear_has_target_set() {
  _impl_._oneof_case_[1] = TARGET_SET_NOT_SET;
}
inline bool CameraState::has_up_set() const {
  return up_set_case() != UP_SET_NOT_SET;
}
inline void CameraState::clear_has_up_set() {
  _impl_._oneof_case_[2] = UP_SET_NOT_SET;
}
inline bool CameraState::has_fov_set() const {
  return fov_set_case() != FOV_SET_NOT_SET;
}
inline void CameraState::clear_has_fov_set() {
  _impl_._oneof_case_[3] = FOV_SET_NOT_SET;
}
inline CameraState::PosSetCase CameraState::pos_set_case() const {
  return CameraState::PosSetCase(_impl_._oneof_case_[0]);
}
inline CameraState::TargetSetCase CameraState::target_set_case() const {
  return CameraState::TargetSetCase(_impl_._oneof_case_[1]);
}
inline CameraState::UpSetCase CameraState::up_set_case() const {
  return CameraState::UpSetCase(_impl_._oneof_case_[2]);
}
inline CameraState::FovSetCase CameraState::fov_set_case() const {
  return CameraState::FovSetCase(_impl_._oneof_case_[3]);
}
// -------------------------------------------------------------------

// FileRequest

// string filepath = 1;
inline void FileRequest::clear_filepath() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.filepath_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& FileRequest::filepath() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livelinkapi.FileRequest.filepath)
  return _internal_filepath();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void FileRequest::set_filepath(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.filepath_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livelinkapi.FileRequest.filepath)
}
inline ::std::string* PROTOBUF_NONNULL FileRequest::mutable_filepath()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_filepath();
  // @@protoc_insertion_point(field_mutable:livelinkapi.FileRequest.filepath)
  return _s;
}
inline const ::std::string& FileRequest::_internal_filepath() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.filepath_.Get();
}
inline void FileRequest::_internal_set_filepath(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.filepath_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL FileRequest::_internal_mutable_filepath() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.filepath_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE FileRequest::release_filepath() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livelinkapi.FileRequest.filepath)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.filepath_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.filepath_.Set("", GetArena());
  }
  return released;
}
inline void FileRequest::set_allocated_filepath(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.filepath_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.filepath_.IsDefault()) {
    _impl_.filepath_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livelinkapi.FileRequest.filepath)
}

// -------------------------------------------------------------------

// FileResponse

// bytes filedata = 1;
inline void FileResponse::clear_filedata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.filedata_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& FileResponse::filedata() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livelinkapi.FileResponse.filedata)
  return _internal_filedata();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void FileResponse::set_filedata(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.filedata_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livelinkapi.FileResponse.filedata)
}
inline ::std::string* PROTOBUF_NONNULL FileResponse::mutable_filedata()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_filedata();
  // @@protoc_insertion_point(field_mutable:livelinkapi.FileResponse.filedata)
  return _s;
}
inline const ::std::string& FileResponse::_internal_filedata() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.filedata_.Get();
}
inline void FileResponse::_internal_set_filedata(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.filedata_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL FileResponse::_internal_mutable_filedata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.filedata_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE FileResponse::release_filedata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livelinkapi.FileResponse.filedata)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.filedata_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.filedata_.Set("", GetArena());
  }
  return released;
}
inline void FileResponse::set_allocated_filedata(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.filedata_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.filedata_.IsDefault()) {
    _impl_.filedata_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livelinkapi.FileResponse.filedata)
}

// -------------------------------------------------------------------

// MeshRequest

// int32 objecthandle = 1;
inline void MeshRequest::clear_objecthandle() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.objecthandle_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t MeshRequest::objecthandle() const {
  // @@protoc_insertion_point(field_get:livelinkapi.MeshRequest.objecthandle)
  return _internal_objecthandle();
}
inline void MeshRequest::set_objecthandle(::int32_t value) {
  _internal_set_objecthandle(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:livelinkapi.MeshRequest.objecthandle)
}
inline ::int32_t MeshRequest::_internal_objecthandle() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.objecthandle_;
}
inline void MeshRequest::_internal_set_objecthandle(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.objecthandle_ = value;
}

// -------------------------------------------------------------------

// StreamStatus

// string message = 1;
inline void StreamStatus::clear_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& StreamStatus::message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livelinkapi.StreamStatus.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void StreamStatus::set_message(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livelinkapi.StreamStatus.message)
}
inline ::std::string* PROTOBUF_NONNULL StreamStatus::mutable_message()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:livelinkapi.StreamStatus.message)
  return _s;
}
inline const ::std::string& StreamStatus::_internal_message() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.message_.Get();
}
inline void StreamStatus::_internal_set_message(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.message_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL StreamStatus::_internal_mutable_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.message_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE StreamStatus::release_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livelinkapi.StreamStatus.message)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.message_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.message_.Set("", GetArena());
  }
  return released;
}
inline void StreamStatus::set_allocated_message(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.message_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livelinkapi.StreamStatus.message)
}

// -------------------------------------------------------------------

// MeshData

// string name = 1;
inline void MeshData::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& MeshData::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livelinkapi.MeshData.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void MeshData::set_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livelinkapi.MeshData.name)
}
inline ::std::string* PROTOBUF_NONNULL MeshData::mutable_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:livelinkapi.MeshData.name)
  return _s;
}
inline const ::std::string& MeshData::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void MeshData::_internal_set_name(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL MeshData::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE MeshData::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livelinkapi.MeshData.name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.name_.Set("", GetArena());
  }
  return released;
}
inline void MeshData::set_allocated_name(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livelinkapi.MeshData.name)
}

// repeated .livelinkapi.Vec3 positions = 2;
inline int MeshData::_internal_positions_size() const {
  return _internal_positions().size();
}
inline int MeshData::positions_size() const {
  return _internal_positions_size();
}
inline void MeshData::clear_positions() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.positions_.Clear();
}
inline ::livelinkapi::Vec3* PROTOBUF_NONNULL MeshData::mutable_positions(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:livelinkapi.MeshData.positions)
  return _internal_mutable_positions()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::livelinkapi::Vec3>* PROTOBUF_NONNULL MeshData::mutable_positions()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:livelinkapi.MeshData.positions)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_positions();
}
inline const ::livelinkapi::Vec3& MeshData::positions(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livelinkapi.MeshData.positions)
  return _internal_positions().Get(index);
}
inline ::livelinkapi::Vec3* PROTOBUF_NONNULL MeshData::add_positions()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::livelinkapi::Vec3* _add = _internal_mutable_positions()->Add();
  // @@protoc_insertion_point(field_add:livelinkapi.MeshData.positions)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::livelinkapi::Vec3>& MeshData::positions() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:livelinkapi.MeshData.positions)
  return _internal_positions();
}
inline const ::google::protobuf::RepeatedPtrField<::livelinkapi::Vec3>&
MeshData::_internal_positions() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.positions_;
}
inline ::google::protobuf::RepeatedPtrField<::livelinkapi::Vec3>* PROTOBUF_NONNULL
MeshData::_internal_mutable_positions() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.positions_;
}

// repeated .livelinkapi.Vec3 normals = 3;
inline int MeshData::_internal_normals_size() const {
  return _internal_normals().size();
}
inline int MeshData::normals_size() const {
  return _internal_normals_size();
}
inline void MeshData::clear_normals() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.normals_.Clear();
}
inline ::livelinkapi::Vec3* PROTOBUF_NONNULL MeshData::mutable_normals(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:livelinkapi.MeshData.normals)
  return _internal_mutable_normals()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::livelinkapi::Vec3>* PROTOBUF_NONNULL MeshData::mutable_normals()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:livelinkapi.MeshData.normals)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_normals();
}
inline const ::livelinkapi::Vec3& MeshData::normals(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livelinkapi.MeshData.normals)
  return _internal_normals().Get(index);
}
inline ::livelinkapi::Vec3* PROTOBUF_NONNULL MeshData::add_normals()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::livelinkapi::Vec3* _add = _internal_mutable_normals()->Add();
  // @@protoc_insertion_point(field_add:livelinkapi.MeshData.normals)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::livelinkapi::Vec3>& MeshData::normals() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:livelinkapi.MeshData.normals)
  return _internal_normals();
}
inline const ::google::protobuf::RepeatedPtrField<::livelinkapi::Vec3>&
MeshData::_internal_normals() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.normals_;
}
inline ::google::protobuf::RepeatedPtrField<::livelinkapi::Vec3>* PROTOBUF_NONNULL
MeshData::_internal_mutable_normals() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.normals_;
}

// repeated uint32 vertsPerPoly = 4;
inline int MeshData::_internal_vertsperpoly_size() const {
  return _internal_vertsperpoly().size();
}
inline int MeshData::vertsperpoly_size() const {
  return _internal_vertsperpoly_size();
}
inline void MeshData::clear_vertsperpoly() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.vertsperpoly_.Clear();
}
inline ::uint32_t MeshData::vertsperpoly(int index) const {
  // @@protoc_insertion_point(field_get:livelinkapi.MeshData.vertsPerPoly)
  return _internal_vertsperpoly().Get(index);
}
inline void MeshData::set_vertsperpoly(int index, ::uint32_t value) {
  _internal_mutable_vertsperpoly()->Set(index, value);
  // @@protoc_insertion_point(field_set:livelinkapi.MeshData.vertsPerPoly)
}
inline void MeshData::add_vertsperpoly(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_vertsperpoly()->Add(value);
  // @@protoc_insertion_point(field_add:livelinkapi.MeshData.vertsPerPoly)
}
inline const ::google::protobuf::RepeatedField<::uint32_t>& MeshData::vertsperpoly() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:livelinkapi.MeshData.vertsPerPoly)
  return _internal_vertsperpoly();
}
inline ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL MeshData::mutable_vertsperpoly()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:livelinkapi.MeshData.vertsPerPoly)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_vertsperpoly();
}
inline const ::google::protobuf::RepeatedField<::uint32_t>&
MeshData::_internal_vertsperpoly() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.vertsperpoly_;
}
inline ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL
MeshData::_internal_mutable_vertsperpoly() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.vertsperpoly_;
}

// repeated uint32 polyVertIndices = 5;
inline int MeshData::_internal_polyvertindices_size() const {
  return _internal_polyvertindices().size();
}
inline int MeshData::polyvertindices_size() const {
  return _internal_polyvertindices_size();
}
inline void MeshData::clear_polyvertindices() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.polyvertindices_.Clear();
}
inline ::uint32_t MeshData::polyvertindices(int index) const {
  // @@protoc_insertion_point(field_get:livelinkapi.MeshData.polyVertIndices)
  return _internal_polyvertindices().Get(index);
}
inline void MeshData::set_polyvertindices(int index, ::uint32_t value) {
  _internal_mutable_polyvertindices()->Set(index, value);
  // @@protoc_insertion_point(field_set:livelinkapi.MeshData.polyVertIndices)
}
inline void MeshData::add_polyvertindices(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_polyvertindices()->Add(value);
  // @@protoc_insertion_point(field_add:livelinkapi.MeshData.polyVertIndices)
}
inline const ::google::protobuf::RepeatedField<::uint32_t>& MeshData::polyvertindices() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:livelinkapi.MeshData.polyVertIndices)
  return _internal_polyvertindices();
}
inline ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL MeshData::mutable_polyvertindices()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:livelinkapi.MeshData.polyVertIndices)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_polyvertindices();
}
inline const ::google::protobuf::RepeatedField<::uint32_t>&
MeshData::_internal_polyvertindices() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.polyvertindices_;
}
inline ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL
MeshData::_internal_mutable_polyvertindices() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.polyvertindices_;
}

// repeated uint32 polyNormalIndices = 6;
inline int MeshData::_internal_polynormalindices_size() const {
  return _internal_polynormalindices().size();
}
inline int MeshData::polynormalindices_size() const {
  return _internal_polynormalindices_size();
}
inline void MeshData::clear_polynormalindices() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.polynormalindices_.Clear();
}
inline ::uint32_t MeshData::polynormalindices(int index) const {
  // @@protoc_insertion_point(field_get:livelinkapi.MeshData.polyNormalIndices)
  return _internal_polynormalindices().Get(index);
}
inline void MeshData::set_polynormalindices(int index, ::uint32_t value) {
  _internal_mutable_polynormalindices()->Set(index, value);
  // @@protoc_insertion_point(field_set:livelinkapi.MeshData.polyNormalIndices)
}
inline void MeshData::add_polynormalindices(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_polynormalindices()->Add(value);
  // @@protoc_insertion_point(field_add:livelinkapi.MeshData.polyNormalIndices)
}
inline const ::google::protobuf::RepeatedField<::uint32_t>& MeshData::polynormalindices() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:livelinkapi.MeshData.polyNormalIndices)
  return _internal_polynormalindices();
}
inline ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL MeshData::mutable_polynormalindices()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:livelinkapi.MeshData.polyNormalIndices)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_polynormalindices();
}
inline const ::google::protobuf::RepeatedField<::uint32_t>&
MeshData::_internal_polynormalindices() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.polynormalindices_;
}
inline ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL
MeshData::_internal_mutable_polynormalindices() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.polynormalindices_;
}

// int32 windingOrder = 7;
inline void MeshData::clear_windingorder() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.windingorder_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t MeshData::windingorder() const {
  // @@protoc_insertion_point(field_get:livelinkapi.MeshData.windingOrder)
  return _internal_windingorder();
}
inline void MeshData::set_windingorder(::int32_t value) {
  _internal_set_windingorder(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:livelinkapi.MeshData.windingOrder)
}
inline ::int32_t MeshData::_internal_windingorder() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.windingorder_;
}
inline void MeshData::_internal_set_windingorder(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.windingorder_ = value;
}

// .livelinkapi.MatrixD worldMatrix = 8;
inline bool MeshData::has_worldmatrix() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.worldmatrix_ != nullptr);
  return value;
}
inline void MeshData::clear_worldmatrix() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.worldmatrix_ != nullptr) _impl_.worldmatrix_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::livelinkapi::MatrixD& MeshData::_internal_worldmatrix() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::livelinkapi::MatrixD* p = _impl_.worldmatrix_;
  return p != nullptr ? *p : reinterpret_cast<const ::livelinkapi::MatrixD&>(::livelinkapi::_MatrixD_default_instance_);
}
inline const ::livelinkapi::MatrixD& MeshData::worldmatrix() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livelinkapi.MeshData.worldMatrix)
  return _internal_worldmatrix();
}
inline void MeshData::unsafe_arena_set_allocated_worldmatrix(
    ::livelinkapi::MatrixD* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.worldmatrix_);
  }
  _impl_.worldmatrix_ = reinterpret_cast<::livelinkapi::MatrixD*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livelinkapi.MeshData.worldMatrix)
}
inline ::livelinkapi::MatrixD* PROTOBUF_NULLABLE MeshData::release_worldmatrix() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::livelinkapi::MatrixD* released = _impl_.worldmatrix_;
  _impl_.worldmatrix_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::livelinkapi::MatrixD* PROTOBUF_NULLABLE MeshData::unsafe_arena_release_worldmatrix() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livelinkapi.MeshData.worldMatrix)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::livelinkapi::MatrixD* temp = _impl_.worldmatrix_;
  _impl_.worldmatrix_ = nullptr;
  return temp;
}
inline ::livelinkapi::MatrixD* PROTOBUF_NONNULL MeshData::_internal_mutable_worldmatrix() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.worldmatrix_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::livelinkapi::MatrixD>(GetArena());
    _impl_.worldmatrix_ = reinterpret_cast<::livelinkapi::MatrixD*>(p);
  }
  return _impl_.worldmatrix_;
}
inline ::livelinkapi::MatrixD* PROTOBUF_NONNULL MeshData::mutable_worldmatrix()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::livelinkapi::MatrixD* _msg = _internal_mutable_worldmatrix();
  // @@protoc_insertion_point(field_mutable:livelinkapi.MeshData.worldMatrix)
  return _msg;
}
inline void MeshData::set_allocated_worldmatrix(::livelinkapi::MatrixD* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.worldmatrix_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.worldmatrix_ = reinterpret_cast<::livelinkapi::MatrixD*>(value);
  // @@protoc_insertion_point(field_set_allocated:livelinkapi.MeshData.worldMatrix)
}

// -------------------------------------------------------------------

// Empty

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace livelinkapi


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // livelink_2eproto_2epb_2eh
