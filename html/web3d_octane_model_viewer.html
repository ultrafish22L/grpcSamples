<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üöÄ 3D Model Viewer - Octane LiveLink Edition</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #0a0a0f;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            color: white;
        }
        
        #canvas {
            display: block;
            cursor: grab;
        }
        
        #canvas:active {
            cursor: grabbing;
        }
        
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 8px;
            font-size: 14px;
            line-height: 1.4;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            max-width: 350px;
        }
        
        #controls {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 8px;
            font-size: 12px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            max-width: 300px;
        }
        
        #grpc-panel {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 8px;
            font-size: 12px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            min-width: 250px;
        }
        
        #model-panel {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 8px;
            font-size: 12px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            min-width: 250px;
        }
        
        #performance {
            position: absolute;
            top: 50%;
            right: 10px;
            transform: translateY(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            border-radius: 8px;
            font-size: 11px;
            font-family: 'Courier New', monospace;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .highlight {
            color: #4fc3f7;
            font-weight: bold;
        }
        
        .status-connected {
            color: #4caf50;
        }
        
        .status-disconnected {
            color: #f44336;
        }
        
        .status-connecting {
            color: #ff9800;
        }
        
        button {
            background: rgba(76, 175, 80, 0.8);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            margin: 2px;
            font-size: 11px;
        }
        
        button:hover {
            background: rgba(76, 175, 80, 1.0);
        }
        
        button:disabled {
            background: rgba(100, 100, 100, 0.5);
            cursor: not-allowed;
        }
        
        input[type="text"] {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 6px;
            border-radius: 4px;
            font-size: 11px;
            width: 200px;
            margin: 2px 0;
        }
        
        input[type="file"] {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 6px;
            border-radius: 4px;
            font-size: 11px;
            width: 100%;
            margin: 2px 0;
        }
        
        .drop-zone {
            border: 2px dashed rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            padding: 20px;
            text-align: center;
            margin: 10px 0;
            transition: all 0.3s ease;
        }
        
        .drop-zone.dragover {
            border-color: #4fc3f7;
            background: rgba(79, 195, 247, 0.1);
        }
        
        .log-entry {
            font-size: 10px;
            margin: 2px 0;
            padding: 2px 4px;
            border-radius: 2px;
        }
        
        .log-info { color: #81c784; }
        .log-warning { color: #ffb74d; }
        .log-error { color: #e57373; }
        .log-success { color: #4fc3f7; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <div id="info">
        <div class="highlight">üöÄ 3D Model Viewer - Octane LiveLink Edition</div>
        <div>Advanced 3D viewer with Octane Render integration</div>
        <div style="margin-top: 8px;">
            <div>‚Ä¢ Load 3D models (OBJ, PLY, STL) with drag & drop</div>
            <div>‚Ä¢ Real-time camera sync with Octane Render</div>
            <div>‚Ä¢ Model transformation tools</div>
            <div>‚Ä¢ Bidirectional LiveLink communication</div>
        </div>
    </div>

    <div id="controls">
        <div class="highlight">Controls:</div>
        <div>üñ±Ô∏è <strong>Left Mouse Drag:</strong> Orbit camera (syncs to Octane)</div>
        <div>üñ±Ô∏è <strong>Right Mouse Drag:</strong> Pan camera left/right/up/down (syncs to Octane)</div>
        <div>üéØ <strong>Mouse Wheel:</strong> Zoom in/out (syncs to Octane)</div>
        <div>üìÅ <strong>L:</strong> Load model file</div>
        <div>üîÑ <strong>R:</strong> Reset to cube</div>
        <div>‚å®Ô∏è <strong>ESC:</strong> Reset camera</div>
        <div>üîÑ <strong>Space:</strong> Toggle auto-rotation</div>
        <div style="margin-top: 8px;">
        <div class="highlight">Model Transform:</div>
        <div>üîß <strong>Q/A:</strong> Scale up/down</div>
        <div>üîÑ <strong>W/S:</strong> Rotate X</div>
        <div>üîÑ <strong>E/D:</strong> Rotate Y</div>
        <div>üîÑ <strong>T/G:</strong> Rotate Z</div>
        <div>üìê <strong>Arrow Keys:</strong> Translate</div>
        </div>
    </div>

    <div id="grpc-panel">
        <div class="highlight">üîó Octane LiveLink Connection</div>
        <div style="margin: 8px 0;">
            <input type="text" id="serverAddress" placeholder="ws://127.0.0.1:51022" value="ws://127.0.0.1:51022">
            <br>
            <button id="connectBtn" onclick="viewer.connectToOctane()">Connect to Octane</button>
            <button id="disconnectBtn" onclick="viewer.disconnectFromOctane()" disabled>Disconnect</button>
        </div>
        
        <div style="margin: 8px 0;">
            <div class="highlight">Status:</div>
            <div>Connection: <span id="connectionStatus" class="status-disconnected">Disconnected</span></div>
            <div>Octane Server: <span id="octaneStatus" class="status-disconnected">Not Ready</span></div>
            <div>Camera Sync: <span id="syncStatus" class="status-disconnected">Disabled</span></div>
            <div>Model Sync: <span id="modelSyncStatus" class="status-disconnected">Disabled</span></div>
        </div>
        
        <div style="margin: 8px 0;">
            <button id="syncCameraBtn" onclick="viewer.toggleCameraSync()" disabled>Start Camera Sync</button>
            <button id="loadToOctaneBtn" onclick="viewer.loadCurrentModelToOctane()" disabled>Load Model to Octane</button>
        </div>
        
        <div style="margin-top: 8px; font-size: 10px;">
            <div class="highlight">Activity Log:</div>
            <div id="activityLog" style="max-height: 80px; overflow-y: auto;">
                <div class="log-entry log-info">Ready to connect...</div>
            </div>
        </div>
    </div>

    <div id="model-panel">
        <div class="highlight">üìÅ 3D Model Loading</div>
        
        <div style="margin: 8px 0;">
            <div class="highlight">Current Model:</div>
            <div id="currentModel">Default Cube</div>
            <div id="modelStats" style="font-size: 10px; color: #aaa;"></div>
        </div>
        
        <div style="margin: 8px 0;">
            <input type="file" id="fileInput" accept=".obj,.ply,.stl" onchange="viewer.handleFileSelect(event)">
            <button onclick="document.getElementById('fileInput').click()">Browse Files</button>
            <button onclick="viewer.resetToDefaultCube()">Reset to Cube</button>
        </div>
        
        <div class="drop-zone" id="dropZone">
            <div>üéØ Drop 3D model files here</div>
            <div style="font-size: 10px; color: #aaa;">Supports OBJ, PLY, STL formats</div>
        </div>
        
        <div style="margin: 8px 0;">
            <div class="highlight">Transform:</div>
            <div style="display: flex; gap: 4px; margin: 4px 0;">
                <button onclick="viewer.scaleModel(1.1)">Scale +</button>
                <button onclick="viewer.scaleModel(0.9)">Scale -</button>
                <button onclick="viewer.resetModelTransform()">Reset</button>
            </div>
        </div>
    </div>

    <div id="performance">
        <div class="highlight">Performance:</div>
        <div>FPS: <span id="fps">--</span></div>
        <div>Frame Time: <span id="frameTime">--</span>ms</div>
        <div>Vertices: <span id="vertexCount">--</span></div>
        <div>Triangles: <span id="triangleCount">--</span></div>
        <div style="margin-top: 4px;">
        <div class="highlight">LiveLink:</div>
        <div>Calls: <span id="grpcCalls">0</span></div>
        <div>Sync Rate: <span id="syncRate">--</span>/s</div>
        </div>
    </div>

    <!-- Include LiveLink.js library -->
    <script src="livelink.js"></script>
    
    <script>
        // Enhanced 3D Model Viewer with Octane LiveLink Integration
        // Combines comprehensive model loading with real-time Octane synchronization

        class OctaneModelViewer {
            constructor() {
                this.canvas = document.getElementById('canvas');
                this.gl = null;
                this.shaderProgram = null;
                this.skyboxProgram = null;

                // Camera parameters (matching C++ versions)
                this.camera = {
                    radius: 5.0,
                    theta: 0.0,  // horizontal angle
                    phi: 0.0,    // vertical angle
                    center: [0.0, 0.0, 0.0]
                };

                // Mouse and input state
                this.mouse = {
                    dragging: false,
                    panning: false,  // Right mouse button for panning
                    lastX: 0,
                    lastY: 0
                };

                this.keys = {};
                this.autoRotate = false;
                this.rotationSpeed = 0.5;

                // Model state
                this.currentModel = {
                    name: 'Default Cube',
                    vertices: [],
                    indices: [],
                    vertexCount: 0,
                    triangleCount: 0,
                    isCustomModel: false
                };

                // Model transformation
                this.modelTransform = {
                    scale: [1.0, 1.0, 1.0],
                    rotation: [0.0, 0.0, 0.0],
                    translation: [0.0, 0.0, 0.0]
                };

                // Performance tracking
                this.frameCount = 0;
                this.lastTime = 0;
                this.fps = 0;
                this.frameTime = 0;

                // LiveLink state
                this.liveLink = new LiveLinkManager('ws://127.0.0.1:51022');
                this.connected = false;
                this.octaneReady = false;
                this.cameraSync = false;
                this.modelSync = false;


                // Setup LiveLink event handlers
                this.setupLiveLinkEvents();

                // WebGL objects
                this.cubeVAO = null;
                this.modelVAO = null;
                this.skyboxVAO = null;
                this.cubeBuffer = null;
                this.modelBuffer = null;
                this.skyboxBuffer = null;
                this.indexBuffer = null;
                this.modelIndexBuffer = null;

                this.init();
            }

            init() {
                this.setupCanvas();
                this.initWebGL();
                this.setupEventListeners();
                this.setupDropZone();
                this.createShaders();
                this.createGeometry();
                this.updateModelInfo();
                this.render();
                
                console.log('üöÄ 3D Model Viewer - Octane LiveLink Edition initialized');
                console.log('üìÅ Load models: L key or drag & drop');
                console.log('üîó Connect to Octane for real-time sync');
            }

            setupCanvas() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                
                window.addEventListener('resize', () => {
                    this.canvas.width = window.innerWidth;
                    this.canvas.height = window.innerHeight;
                    if (this.gl) {
                        this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);
                    }
                });
            }

            initWebGL() {
                this.gl = this.canvas.getContext('webgl2');
                if (!this.gl) {
                    alert('WebGL 2.0 not supported');
                    return;
                }

                this.gl.enable(this.gl.DEPTH_TEST);
                this.gl.enable(this.gl.BLEND);
                this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);
                this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);
            }

            setupEventListeners() {
                // Mouse events
                this.canvas.addEventListener('mousedown', (e) => {
                    if (e.button === 0) { // Left mouse button
                        this.mouse.dragging = true;
                        this.mouse.lastX = e.clientX;
                        this.mouse.lastY = e.clientY;
                    } else if (e.button === 2) { // Right mouse button
                        this.mouse.panning = true;
                        this.mouse.lastX = e.clientX;
                        this.mouse.lastY = e.clientY;
                        e.preventDefault(); // Prevent context menu
                    }
                });

                this.canvas.addEventListener('mousemove', (e) => {
                    if (this.mouse.dragging) {
                        // Left mouse button: orbit camera
                        const deltaX = e.clientX - this.mouse.lastX;
                        const deltaY = e.clientY - this.mouse.lastY;
                        
                        const sensitivity = 0.01;
                        this.camera.theta += deltaX * sensitivity;
                        this.camera.phi -= deltaY * sensitivity;
                        
                        // Clamp phi to prevent flipping
                        this.camera.phi = Math.max(-1.5, Math.min(1.5, this.camera.phi));
                        
                        // Sync camera to Octane if connected
                        if (this.cameraSync) {
                            this.syncCameraToOctane();
                        }
                        
                        this.mouse.lastX = e.clientX;
                        this.mouse.lastY = e.clientY;
                    } else if (this.mouse.panning) {
                        // Right mouse button: pan camera center
                        const deltaX = e.clientX - this.mouse.lastX;
                        const deltaY = e.clientY - this.mouse.lastY;
                        
                        // Pan sensitivity (smaller for more precise control)
                        const panSensitivity = 0.005;
                        
                        // Get camera's right and up vectors for proper panning
                        const position = this.getCameraPosition();
                        const forward = this.normalize([
                            this.camera.center[0] - position[0],
                            this.camera.center[1] - position[1],
                            this.camera.center[2] - position[2]
                        ]);
                        const right = this.normalize(this.cross(forward, [0, 1, 0]));
                        const up = this.normalize(this.cross(right, forward));
                        
                        // Apply panning to camera center
                        const panAmount = panSensitivity * this.camera.radius;
                        this.camera.center[0] -= right[0] * deltaX * panAmount;
                        this.camera.center[1] += up[1] * deltaY * panAmount;
                        this.camera.center[2] -= right[2] * deltaX * panAmount;
                        
                        // Sync camera to Octane if connected
                        if (this.cameraSync) {
                            this.syncCameraToOctane();
                        }
                        
                        this.mouse.lastX = e.clientX;
                        this.mouse.lastY = e.clientY;
                    }
                });

                this.canvas.addEventListener('mouseup', (e) => {
                    if (e.button === 0) { // Left mouse button
                        this.mouse.dragging = false;
                    } else if (e.button === 2) { // Right mouse button
                        this.mouse.panning = false;
                    }
                });

                // Disable context menu on right click
                this.canvas.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                });

                this.canvas.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    this.camera.radius += e.deltaY * 0.01;
                    this.camera.radius = Math.max(1.0, Math.min(20.0, this.camera.radius));
                    
                    // Sync camera to Octane if connected
                    if (this.cameraSync) {
                        this.syncCameraToOctane();
                    }
                });

                // Keyboard events
                document.addEventListener('keydown', (e) => {
                    this.keys[e.code] = true;
                    this.handleKeyPress(e);
                });

                document.addEventListener('keyup', (e) => {
                    this.keys[e.code] = false;
                });
            }

            handleKeyPress(e) {
                switch(e.code) {
                    case 'KeyL':
                        document.getElementById('fileInput').click();
                        break;
                    case 'KeyR':
                        this.resetToDefaultCube();
                        break;
                    case 'Escape':
                        this.resetCamera();
                        break;
                    case 'Space':
                        e.preventDefault();
                        this.autoRotate = !this.autoRotate;
                        break;
                    // Model transformation keys
                    case 'KeyQ':
                        this.scaleModel(1.1);
                        break;
                    case 'KeyA':
                        this.scaleModel(0.9);
                        break;
                    case 'KeyW':
                        this.rotateModel(0.1, 0, 0);
                        break;
                    case 'KeyS':
                        this.rotateModel(-0.1, 0, 0);
                        break;
                    case 'KeyE':
                        this.rotateModel(0, 0.1, 0);
                        break;
                    case 'KeyD':
                        this.rotateModel(0, -0.1, 0);
                        break;
                    case 'KeyT':
                        this.rotateModel(0, 0, 0.1);
                        break;
                    case 'KeyG':
                        this.rotateModel(0, 0, -0.1);
                        break;
                    case 'ArrowUp':
                        this.translateModel(0, 0.1, 0);
                        break;
                    case 'ArrowDown':
                        this.translateModel(0, -0.1, 0);
                        break;
                    case 'ArrowLeft':
                        this.translateModel(-0.1, 0, 0);
                        break;
                    case 'ArrowRight':
                        this.translateModel(0.1, 0, 0);
                        break;
                }
            }

            setupDropZone() {
                const dropZone = document.getElementById('dropZone');
                
                dropZone.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    dropZone.classList.add('dragover');
                });
                
                dropZone.addEventListener('dragleave', () => {
                    dropZone.classList.remove('dragover');
                });
                
                dropZone.addEventListener('drop', (e) => {
                    e.preventDefault();
                    dropZone.classList.remove('dragover');
                    
                    const files = e.dataTransfer.files;
                    if (files.length > 0) {
                        this.loadModelFile(files[0]);
                    }
                });
            }

            createShaders() {
                // Vertex shader for main objects
                const vertexShaderSource = `#version 300 es
                    in vec3 aPosition;
                    in vec3 aNormal;
                    in vec3 aColor;
                    
                    uniform mat4 uModel;
                    uniform mat4 uView;
                    uniform mat4 uProjection;
                    uniform mat3 uNormalMatrix;
                    
                    out vec3 vPosition;
                    out vec3 vNormal;
                    out vec3 vColor;
                    
                    void main() {
                        vec4 worldPos = uModel * vec4(aPosition, 1.0);
                        vPosition = worldPos.xyz;
                        vNormal = normalize(uNormalMatrix * aNormal);
                        vColor = aColor;
                        
                        gl_Position = uProjection * uView * worldPos;
                    }
                `;

                // Fragment shader with enhanced lighting
                const fragmentShaderSource = `#version 300 es
                    precision highp float;
                    
                    in vec3 vPosition;
                    in vec3 vNormal;
                    in vec3 vColor;
                    
                    uniform vec3 uViewPos;
                    uniform float uTime;
                    
                    out vec4 fragColor;
                    
                    void main() {
                        vec3 lightPos = vec3(5.0, 5.0, 5.0);
                        vec3 lightColor = vec3(1.0, 1.0, 1.0);
                        
                        // Ambient
                        vec3 ambient = 0.15 * lightColor;
                        
                        // Diffuse
                        vec3 norm = normalize(vNormal);
                        vec3 lightDir = normalize(lightPos - vPosition);
                        float diff = max(dot(norm, lightDir), 0.0);
                        vec3 diffuse = diff * lightColor;
                        
                        // Specular
                        vec3 viewDir = normalize(uViewPos - vPosition);
                        vec3 reflectDir = reflect(-lightDir, norm);
                        float spec = pow(max(dot(viewDir, reflectDir), 0.0), 64.0);
                        vec3 specular = spec * lightColor * 0.5;
                        
                        // Rim lighting
                        float rim = 1.0 - max(dot(viewDir, norm), 0.0);
                        rim = smoothstep(0.6, 1.0, rim);
                        vec3 rimColor = vec3(0.3, 0.6, 1.0) * rim * 0.5;
                        
                        vec3 result = (ambient + diffuse + specular) * vColor + rimColor;
                        fragColor = vec4(result, 1.0);
                    }
                `;

                // Skybox shaders
                const skyboxVertexSource = `#version 300 es
                    in vec3 aPosition;
                    uniform mat4 uView;
                    uniform mat4 uProjection;
                    out vec3 vDirection;
                    
                    void main() {
                        vDirection = aPosition;
                        vec4 pos = uProjection * mat4(mat3(uView)) * vec4(aPosition, 1.0);
                        gl_Position = pos.xyww;
                    }
                `;

                const skyboxFragmentSource = `#version 300 es
                    precision highp float;
                    in vec3 vDirection;
                    uniform float uTime;
                    out vec4 fragColor;
                    
                    void main() {
                        vec3 dir = normalize(vDirection);
                        
                        // Gradient background
                        float gradient = (dir.y + 1.0) * 0.5;
                        vec3 topColor = vec3(0.1, 0.2, 0.4);
                        vec3 bottomColor = vec3(0.05, 0.05, 0.1);
                        vec3 skyColor = mix(bottomColor, topColor, gradient);
                        
                        // Add some stars
                        float stars = 0.0;
                        vec3 starDir = dir * 100.0;
                        stars += smoothstep(0.99, 1.0, sin(starDir.x * 50.0) * sin(starDir.y * 50.0) * sin(starDir.z * 50.0));
                        skyColor += stars * vec3(1.0, 1.0, 0.8) * 0.5;
                        
                        fragColor = vec4(skyColor, 1.0);
                    }
                `;

                this.shaderProgram = this.createShaderProgram(vertexShaderSource, fragmentShaderSource);
                this.skyboxProgram = this.createShaderProgram(skyboxVertexSource, skyboxFragmentSource);
            }

            createShaderProgram(vertexSource, fragmentSource) {
                const vertexShader = this.createShader(this.gl.VERTEX_SHADER, vertexSource);
                const fragmentShader = this.createShader(this.gl.FRAGMENT_SHADER, fragmentSource);
                
                const program = this.gl.createProgram();
                this.gl.attachShader(program, vertexShader);
                this.gl.attachShader(program, fragmentShader);
                this.gl.linkProgram(program);
                
                if (!this.gl.getProgramParameter(program, this.gl.LINK_STATUS)) {
                    console.error('Shader program linking failed:', this.gl.getProgramInfoLog(program));
                    return null;
                }
                
                return program;
            }

            createShader(type, source) {
                const shader = this.gl.createShader(type);
                this.gl.shaderSource(shader, source);
                this.gl.compileShader(shader);
                
                if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
                    console.error('Shader compilation failed:', this.gl.getShaderInfoLog(shader));
                    this.gl.deleteShader(shader);
                    return null;
                }
                
                return shader;
            }

            createGeometry() {
                this.createCubeGeometry();
                this.createSkyboxGeometry();
            }

            createCubeGeometry() {
                // Enhanced cube with colors and normals
                const cubeVertices = new Float32Array([
                    // Front face (red)
                    -1, -1,  1,  0,  0,  1,  1.0, 0.3, 0.3,
                     1, -1,  1,  0,  0,  1,  1.0, 0.3, 0.3,
                     1,  1,  1,  0,  0,  1,  1.0, 0.3, 0.3,
                    -1,  1,  1,  0,  0,  1,  1.0, 0.3, 0.3,
                    
                    // Back face (green)
                    -1, -1, -1,  0,  0, -1,  0.3, 1.0, 0.3,
                    -1,  1, -1,  0,  0, -1,  0.3, 1.0, 0.3,
                     1,  1, -1,  0,  0, -1,  0.3, 1.0, 0.3,
                     1, -1, -1,  0,  0, -1,  0.3, 1.0, 0.3,
                    
                    // Top face (blue)
                    -1,  1, -1,  0,  1,  0,  0.3, 0.3, 1.0,
                    -1,  1,  1,  0,  1,  0,  0.3, 0.3, 1.0,
                     1,  1,  1,  0,  1,  0,  0.3, 0.3, 1.0,
                     1,  1, -1,  0,  1,  0,  0.3, 0.3, 1.0,
                    
                    // Bottom face (yellow)
                    -1, -1, -1,  0, -1,  0,  1.0, 1.0, 0.3,
                     1, -1, -1,  0, -1,  0,  1.0, 1.0, 0.3,
                     1, -1,  1,  0, -1,  0,  1.0, 1.0, 0.3,
                    -1, -1,  1,  0, -1,  0,  1.0, 1.0, 0.3,
                    
                    // Right face (magenta)
                     1, -1, -1,  1,  0,  0,  1.0, 0.3, 1.0,
                     1,  1, -1,  1,  0,  0,  1.0, 0.3, 1.0,
                     1,  1,  1,  1,  0,  0,  1.0, 0.3, 1.0,
                     1, -1,  1,  1,  0,  0,  1.0, 0.3, 1.0,
                    
                    // Left face (cyan)
                    -1, -1, -1, -1,  0,  0,  0.3, 1.0, 1.0,
                    -1, -1,  1, -1,  0,  0,  0.3, 1.0, 1.0,
                    -1,  1,  1, -1,  0,  0,  0.3, 1.0, 1.0,
                    -1,  1, -1, -1,  0,  0,  0.3, 1.0, 1.0
                ]);

                const cubeIndices = new Uint16Array([
                    0,  1,  2,    0,  2,  3,    // front
                    4,  5,  6,    4,  6,  7,    // back
                    8,  9,  10,   8,  10, 11,   // top
                    12, 13, 14,   12, 14, 15,   // bottom
                    16, 17, 18,   16, 18, 19,   // right
                    20, 21, 22,   20, 22, 23    // left
                ]);

                // Create cube VAO
                this.cubeVAO = this.gl.createVertexArray();
                this.gl.bindVertexArray(this.cubeVAO);

                this.cubeBuffer = this.gl.createBuffer();
                this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.cubeBuffer);
                this.gl.bufferData(this.gl.ARRAY_BUFFER, cubeVertices, this.gl.STATIC_DRAW);

                this.indexBuffer = this.gl.createBuffer();
                this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
                this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, cubeIndices, this.gl.STATIC_DRAW);

                // Position attribute
                this.gl.enableVertexAttribArray(0);
                this.gl.vertexAttribPointer(0, 3, this.gl.FLOAT, false, 9 * 4, 0);

                // Normal attribute
                this.gl.enableVertexAttribArray(1);
                this.gl.vertexAttribPointer(1, 3, this.gl.FLOAT, false, 9 * 4, 3 * 4);

                // Color attribute
                this.gl.enableVertexAttribArray(2);
                this.gl.vertexAttribPointer(2, 3, this.gl.FLOAT, false, 9 * 4, 6 * 4);

                this.gl.bindVertexArray(null);

                // Store cube data
                this.currentModel = {
                    name: 'Default Cube',
                    vertices: cubeVertices,
                    indices: cubeIndices,
                    vertexCount: 24,
                    triangleCount: 12,
                    isCustomModel: false
                };
            }

            createSkyboxGeometry() {
                const skyboxVertices = new Float32Array([
                    -1.0,  1.0, -1.0,
                    -1.0, -1.0, -1.0,
                     1.0, -1.0, -1.0,
                     1.0, -1.0, -1.0,
                     1.0,  1.0, -1.0,
                    -1.0,  1.0, -1.0,

                    -1.0, -1.0,  1.0,
                    -1.0, -1.0, -1.0,
                    -1.0,  1.0, -1.0,
                    -1.0,  1.0, -1.0,
                    -1.0,  1.0,  1.0,
                    -1.0, -1.0,  1.0,

                     1.0, -1.0, -1.0,
                     1.0, -1.0,  1.0,
                     1.0,  1.0,  1.0,
                     1.0,  1.0,  1.0,
                     1.0,  1.0, -1.0,
                     1.0, -1.0, -1.0,

                    -1.0, -1.0,  1.0,
                    -1.0,  1.0,  1.0,
                     1.0,  1.0,  1.0,
                     1.0,  1.0,  1.0,
                     1.0, -1.0,  1.0,
                    -1.0, -1.0,  1.0,

                    -1.0,  1.0, -1.0,
                     1.0,  1.0, -1.0,
                     1.0,  1.0,  1.0,
                     1.0,  1.0,  1.0,
                    -1.0,  1.0,  1.0,
                    -1.0,  1.0, -1.0,

                    -1.0, -1.0, -1.0,
                    -1.0, -1.0,  1.0,
                     1.0, -1.0, -1.0,
                     1.0, -1.0, -1.0,
                    -1.0, -1.0,  1.0,
                     1.0, -1.0,  1.0
                ]);

                this.skyboxVAO = this.gl.createVertexArray();
                this.gl.bindVertexArray(this.skyboxVAO);

                this.skyboxBuffer = this.gl.createBuffer();
                this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.skyboxBuffer);
                this.gl.bufferData(this.gl.ARRAY_BUFFER, skyboxVertices, this.gl.STATIC_DRAW);

                this.gl.enableVertexAttribArray(0);
                this.gl.vertexAttribPointer(0, 3, this.gl.FLOAT, false, 0, 0);

                this.gl.bindVertexArray(null);
            }

            // === MODEL LOADING METHODS ===

            handleFileSelect(event) {
                const file = event.target.files[0];
                if (file) {
                    this.loadModelFile(file);
                }
            }

            loadModelFile(file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const content = e.target.result;
                    const extension = file.name.split('.').pop().toLowerCase();
                    
                    console.log(`Loading ${extension.toUpperCase()} file: ${file.name}`);
                    this.log(`Loading ${file.name}...`, 'info');
                    
                    let modelData = null;
                    
                    switch(extension) {
                        case 'obj':
                            modelData = this.parseOBJ(content, file.name);
                            break;
                        case 'ply':
                            modelData = this.parsePLY(content, file.name);
                            break;
                        case 'stl':
                            modelData = this.parseSTL(content, file.name);
                            break;
                        default:
                            this.log(`Unsupported file format: ${extension}`, 'error');
                            return;
                    }
                    
                    if (modelData && modelData.vertices.length > 0) {
                        this.loadCustomModel(modelData);
                        this.log(`Successfully loaded ${file.name}`, 'success');
                        
                        // Sync model to Octane if connected
                        if (this.connected && this.modelSync) {
                            this.loadCurrentModelToOctane();
                        }
                    } else {
                        this.log(`Failed to parse ${file.name}`, 'error');
                    }
                };
                reader.readAsText(file);
            }

            parseOBJ(content, filename) {
                const lines = content.split('\n');
                const positions = [];
                const normals = [];
                const faces = [];
                
                for (const line of lines) {
                    const parts = line.trim().split(/\s+/);
                    
                    if (parts[0] === 'v') {
                        positions.push([
                            parseFloat(parts[1]),
                            parseFloat(parts[2]),
                            parseFloat(parts[3])
                        ]);
                    } else if (parts[0] === 'vn') {
                        normals.push([
                            parseFloat(parts[1]),
                            parseFloat(parts[2]),
                            parseFloat(parts[3])
                        ]);
                    } else if (parts[0] === 'f') {
                        const face = [];
                        for (let i = 1; i < parts.length; i++) {
                            const indices = parts[i].split('/');
                            face.push({
                                vertex: parseInt(indices[0]) - 1,
                                normal: indices[2] ? parseInt(indices[2]) - 1 : -1
                            });
                        }
                        faces.push(face);
                    }
                }
                
                return this.buildModelFromFaces(positions, normals, faces, filename);
            }

            parsePLY(content, filename) {
                const lines = content.split('\n');
                let vertexCount = 0;
                let faceCount = 0;
                let inHeader = true;
                let lineIndex = 0;
                
                // Parse header
                while (inHeader && lineIndex < lines.length) {
                    const line = lines[lineIndex].trim();
                    if (line.startsWith('element vertex')) {
                        vertexCount = parseInt(line.split(' ')[2]);
                    } else if (line.startsWith('element face')) {
                        faceCount = parseInt(line.split(' ')[2]);
                    } else if (line === 'end_header') {
                        inHeader = false;
                    }
                    lineIndex++;
                }
                
                const positions = [];
                const faces = [];
                
                // Parse vertices
                for (let i = 0; i < vertexCount; i++) {
                    const parts = lines[lineIndex + i].trim().split(/\s+/);
                    positions.push([
                        parseFloat(parts[0]),
                        parseFloat(parts[1]),
                        parseFloat(parts[2])
                    ]);
                }
                lineIndex += vertexCount;
                
                // Parse faces
                for (let i = 0; i < faceCount; i++) {
                    const parts = lines[lineIndex + i].trim().split(/\s+/);
                    const numVertices = parseInt(parts[0]);
                    const face = [];
                    for (let j = 1; j <= numVertices; j++) {
                        face.push({
                            vertex: parseInt(parts[j]),
                            normal: -1
                        });
                    }
                    faces.push(face);
                }
                
                return this.buildModelFromFaces(positions, [], faces, filename);
            }

            parseSTL(content, filename) {
                const lines = content.split('\n');
                const positions = [];
                const faces = [];
                let vertexIndex = 0;
                
                for (const line of lines) {
                    const trimmed = line.trim();
                    if (trimmed.startsWith('vertex')) {
                        const parts = trimmed.split(/\s+/);
                        positions.push([
                            parseFloat(parts[1]),
                            parseFloat(parts[2]),
                            parseFloat(parts[3])
                        ]);
                        
                        if (positions.length % 3 === 0) {
                            // Every 3 vertices form a triangle
                            faces.push([
                                { vertex: vertexIndex - 2, normal: -1 },
                                { vertex: vertexIndex - 1, normal: -1 },
                                { vertex: vertexIndex, normal: -1 }
                            ]);
                        }
                        vertexIndex++;
                    }
                }
                
                return this.buildModelFromFaces(positions, [], faces, filename);
            }

            buildModelFromFaces(positions, normals, faces, filename) {
                const vertices = [];
                const indices = [];
                const vertexMap = new Map();
                let indexCounter = 0;
                
                for (const face of faces) {
                    const faceIndices = [];
                    
                    for (const vertex of face) {
                        const pos = positions[vertex.vertex];
                        if (!pos) continue;
                        
                        let normal = [0, 0, 1];
                        if (vertex.normal >= 0 && normals[vertex.normal]) {
                            normal = normals[vertex.normal];
                        }
                        
                        // Generate procedural color based on position
                        const color = [
                            (pos[0] + 1) * 0.5,
                            (pos[1] + 1) * 0.5,
                            (pos[2] + 1) * 0.5
                        ];
                        
                        const vertexKey = `${pos[0]},${pos[1]},${pos[2]},${normal[0]},${normal[1]},${normal[2]}`;
                        
                        if (vertexMap.has(vertexKey)) {
                            faceIndices.push(vertexMap.get(vertexKey));
                        } else {
                            vertices.push(...pos, ...normal, ...color);
                            vertexMap.set(vertexKey, indexCounter);
                            faceIndices.push(indexCounter);
                            indexCounter++;
                        }
                    }
                    
                    // Triangulate face (assuming convex)
                    for (let i = 1; i < faceIndices.length - 1; i++) {
                        indices.push(faceIndices[0], faceIndices[i], faceIndices[i + 1]);
                    }
                }
                
                // Generate normals if not provided
                if (normals.length === 0) {
                    this.generateNormals(vertices, indices);
                }
                
                return {
                    name: filename,
                    vertices: new Float32Array(vertices),
                    indices: new Uint16Array(indices),
                    vertexCount: vertices.length / 9,
                    triangleCount: indices.length / 3,
                    isCustomModel: true
                };
            }

            generateNormals(vertices, indices) {
                // Reset normals
                for (let i = 0; i < vertices.length; i += 9) {
                    vertices[i + 3] = 0; // nx
                    vertices[i + 4] = 0; // ny
                    vertices[i + 5] = 0; // nz
                }
                
                // Calculate face normals and accumulate
                for (let i = 0; i < indices.length; i += 3) {
                    const i1 = indices[i] * 9;
                    const i2 = indices[i + 1] * 9;
                    const i3 = indices[i + 2] * 9;
                    
                    const v1 = [vertices[i1], vertices[i1 + 1], vertices[i1 + 2]];
                    const v2 = [vertices[i2], vertices[i2 + 1], vertices[i2 + 2]];
                    const v3 = [vertices[i3], vertices[i3 + 1], vertices[i3 + 2]];
                    
                    const edge1 = [v2[0] - v1[0], v2[1] - v1[1], v2[2] - v1[2]];
                    const edge2 = [v3[0] - v1[0], v3[1] - v1[1], v3[2] - v1[2]];
                    
                    const normal = [
                        edge1[1] * edge2[2] - edge1[2] * edge2[1],
                        edge1[2] * edge2[0] - edge1[0] * edge2[2],
                        edge1[0] * edge2[1] - edge1[1] * edge2[0]
                    ];
                    
                    // Add to each vertex
                    for (let j = 0; j < 3; j++) {
                        const idx = indices[i + j] * 9;
                        vertices[idx + 3] += normal[0];
                        vertices[idx + 4] += normal[1];
                        vertices[idx + 5] += normal[2];
                    }
                }
                
                // Normalize
                for (let i = 0; i < vertices.length; i += 9) {
                    const nx = vertices[i + 3];
                    const ny = vertices[i + 4];
                    const nz = vertices[i + 5];
                    const length = Math.sqrt(nx * nx + ny * ny + nz * nz);
                    
                    if (length > 0) {
                        vertices[i + 3] /= length;
                        vertices[i + 4] /= length;
                        vertices[i + 5] /= length;
                    }
                }
            }

            loadCustomModel(modelData) {
                this.currentModel = modelData;
                this.resetModelTransform();
                
                // Create model VAO
                if (this.modelVAO) {
                    this.gl.deleteVertexArray(this.modelVAO);
                }
                if (this.modelBuffer) {
                    this.gl.deleteBuffer(this.modelBuffer);
                }
                if (this.modelIndexBuffer) {
                    this.gl.deleteBuffer(this.modelIndexBuffer);
                }
                
                this.modelVAO = this.gl.createVertexArray();
                this.gl.bindVertexArray(this.modelVAO);
                
                this.modelBuffer = this.gl.createBuffer();
                this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.modelBuffer);
                this.gl.bufferData(this.gl.ARRAY_BUFFER, modelData.vertices, this.gl.STATIC_DRAW);
                
                this.modelIndexBuffer = this.gl.createBuffer();
                this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.modelIndexBuffer);
                this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, modelData.indices, this.gl.STATIC_DRAW);
                
                // Position attribute
                this.gl.enableVertexAttribArray(0);
                this.gl.vertexAttribPointer(0, 3, this.gl.FLOAT, false, 9 * 4, 0);
                
                // Normal attribute
                this.gl.enableVertexAttribArray(1);
                this.gl.vertexAttribPointer(1, 3, this.gl.FLOAT, false, 9 * 4, 3 * 4);
                
                // Color attribute
                this.gl.enableVertexAttribArray(2);
                this.gl.vertexAttribPointer(2, 3, this.gl.FLOAT, false, 9 * 4, 6 * 4);
                
                this.gl.bindVertexArray(null);
                
                this.updateModelInfo();
                console.log(`Loaded model: ${modelData.name} (${modelData.vertexCount} vertices, ${modelData.triangleCount} triangles)`);
            }

            resetToDefaultCube() {
                this.createCubeGeometry();
                this.resetModelTransform();
                this.updateModelInfo();
                this.log('Reset to default cube', 'info');
                
                // Sync to Octane if connected
                if (this.connected && this.modelSync) {
                    this.loadCurrentModelToOctane();
                }
            }

            // === MODEL TRANSFORMATION METHODS ===

            scaleModel(factor) {
                this.modelTransform.scale[0] *= factor;
                this.modelTransform.scale[1] *= factor;
                this.modelTransform.scale[2] *= factor;
            }

            rotateModel(x, y, z) {
                this.modelTransform.rotation[0] += x;
                this.modelTransform.rotation[1] += y;
                this.modelTransform.rotation[2] += z;
            }

            translateModel(x, y, z) {
                this.modelTransform.translation[0] += x;
                this.modelTransform.translation[1] += y;
                this.modelTransform.translation[2] += z;
            }

            resetModelTransform() {
                this.modelTransform = {
                    scale: [1.0, 1.0, 1.0],
                    rotation: [0.0, 0.0, 0.0],
                    translation: [0.0, 0.0, 0.0]
                };
            }

            resetCamera() {
                this.camera.radius = 5.0;
                this.camera.theta = 0.0;
                this.camera.phi = 0.0;
                this.camera.center = [0.0, 0.0, 0.0];
                
                // Sync camera to Octane if connected
                if (this.cameraSync) {
                    this.syncCameraToOctane();
                }
            }

            updateModelInfo() {
                document.getElementById('currentModel').textContent = this.currentModel.name;
                document.getElementById('modelStats').textContent = 
                    `${this.currentModel.vertexCount} vertices, ${this.currentModel.triangleCount} triangles`;
                
                document.getElementById('vertexCount').textContent = this.currentModel.vertexCount;
                document.getElementById('triangleCount').textContent = this.currentModel.triangleCount;
            }

            // === LIVELINK INTEGRATION METHODS ===

            setupLiveLinkEvents() {
                this.liveLink.client.on('connectionStateChanged', (state) => {
                    this.updateConnectionStatus(state, state);
                });

                this.liveLink.client.on('connected', () => {
                    this.connected = true;
                    this.octaneReady = true;
                    this.updateConnectionStatus('Connected', 'connected');
                    this.updateOctaneStatus('Ready', 'connected');
                    this.log('Connected to Octane via LiveLink', 'success');
                    this.enableButton('disconnectBtn');
                    this.enableButton('syncCameraBtn');
                    this.enableButton('loadToOctaneBtn');
                });

                this.liveLink.client.on('disconnected', () => {
                    this.connected = false;
                    this.octaneReady = false;
                    this.cameraSync = false;
                    this.modelSync = false;
                    this.updateConnectionStatus('Disconnected', 'disconnected');
                    this.updateOctaneStatus('Not Ready', 'disconnected');
                    this.updateSyncStatus('Disabled', 'disconnected');
                    this.updateModelSyncStatus('Disabled', 'disconnected');
                    this.disableButton('disconnectBtn');
                    this.disableButton('syncCameraBtn');
                    this.disableButton('loadToOctaneBtn');
                    this.log('Disconnected from Octane', 'warning');
                });

                this.liveLink.client.on('error', (error) => {
                    this.log('LiveLink error: ' + error.message, 'error');
                    this.simulateConnection();
                });
            }

            async connectToOctane() {
                const serverAddress = document.getElementById('serverAddress').value;
                this.log('Connecting to Octane server...', 'info');

                // Create new LiveLinkManager with updated server URL
                this.liveLink = new LiveLinkManager(serverAddress);
                this.setupLiveLinkEvents();

                try {
                    await this.liveLink.connect();
                } catch (error) {
                    this.log('Failed to connect: ' + error.message, 'error');
                    this.simulateConnection();
                }
            }

            disconnectFromOctane() {
                if (this.liveLink) {
                    this.liveLink.disconnect();
                }
            }

            simulateConnection() {
                // For demo purposes when no real LiveLink server is available
                this.log('Simulating Octane connection (demo mode)', 'warning');
                setTimeout(() => {
                    this.connected = true;
                    this.octaneReady = true;
                    this.updateConnectionStatus('Connected (Demo)', 'connected');
                    this.updateOctaneStatus('Ready (Demo)', 'connected');
                    this.enableButton('disconnectBtn');
                    this.enableButton('syncCameraBtn');
                    this.enableButton('loadToOctaneBtn');
                    this.log('Demo mode: Octane server ready', 'success');
                }, 1000);
            }

            toggleCameraSync() {
                if (!this.connected) {
                    this.log('Not connected to Octane server', 'error');
                    return;
                }

                const isActive = this.liveLink.toggleCameraSync(() => this.getCurrentCamera());
                this.cameraSync = isActive;

                if (this.cameraSync) {
                    this.updateSyncStatus('Active', 'connected');
                    document.getElementById('syncCameraBtn').textContent = 'Stop Camera Sync';
                    this.log('Camera sync enabled', 'success');
                } else {
                    this.updateSyncStatus('Disabled', 'disconnected');
                    document.getElementById('syncCameraBtn').textContent = 'Start Camera Sync';
                    this.log('Camera sync disabled', 'info');
                }
            }

            loadCurrentModelToOctane() {
                if (!this.connected) {
                    this.log('Not connected to Octane server', 'error');
                    return;
                }

                this.log(`Loading ${this.currentModel.name} to Octane...`, 'info');

                const modelMessage = {
                    type: 'loadModel',
                    modelData: {
                        name: this.currentModel.name,
                        vertices: Array.from(this.currentModel.vertices),
                        indices: Array.from(this.currentModel.indices),
                        vertexCount: this.currentModel.vertexCount,
                        triangleCount: this.currentModel.triangleCount,
                        transform: this.modelTransform
                    }
                };

                // TODO: Implement model loading via LiveLinkManager
                this.log('Model loading via LiveLink not yet implemented', 'warning');
                this.modelSync = true;
                this.updateModelSyncStatus('Active', 'connected');
            }

            getCurrentCamera() {
                const position = this.getCameraPosition();
                return {
                    position: position,
                    target: { x: 0, y: 0, z: 0 },
                    up: { x: 0, y: 1, z: 0 },
                    fov: this.camera.fov
                };
            }

            syncCameraToOctane() {
                // This method is now handled automatically by LiveLinkManager
                // when camera sync is enabled via toggleCameraSync()
            }





            // Get camera state from Octane via LiveLink
            async getCameraFromOctane() {
                if (!this.connected) {
                    this.log('Not connected to server', 'warning');
                    return;
                }
                
                try {
                    const cameraState = await this.liveLink.getCamera();
                    this.log('Received camera state from Octane', 'success');
                    
                    // Apply camera state to WebGL viewer if needed
                    if (cameraState.position && cameraState.target) {
                        this.log('Camera position: ' + JSON.stringify(cameraState.position), 'info');
                        this.log('Camera target: ' + JSON.stringify(cameraState.target), 'info');
                    }
                } catch (error) {
                    this.log('Failed to get camera: ' + error.message, 'error');
                }
            }

            // Get specific mesh data by ID
            async getMeshData(meshId) {
                if (!this.connected) {
                    this.log('Not connected to server', 'warning');
                    return;
                }
                
                try {
                    const meshData = await this.liveLink.getMesh(meshId);
                    this.log(`Received mesh data for ID ${meshId}`, 'success');
                    return meshData;
                } catch (error) {
                    this.log(`Failed to get mesh data: ${error.message}`, 'error');
                }
            }

            // === UI HELPER METHODS ===

            updateConnectionStatus(status, className) {
                const element = document.getElementById('connectionStatus');
                element.textContent = status;
                element.className = 'status-' + className;
            }

            updateOctaneStatus(status, className) {
                const element = document.getElementById('octaneStatus');
                element.textContent = status;
                element.className = 'status-' + className;
            }

            updateSyncStatus(status, className) {
                const element = document.getElementById('syncStatus');
                element.textContent = status;
                element.className = 'status-' + className;
            }

            updateModelSyncStatus(status, className) {
                const element = document.getElementById('modelSyncStatus');
                element.textContent = status;
                element.className = 'status-' + className;
            }

            enableButton(id) {
                document.getElementById(id).disabled = false;
            }

            disableButton(id) {
                document.getElementById(id).disabled = true;
            }

            log(message, type = 'info') {
                const logElement = document.getElementById('activityLog');
                const entry = document.createElement('div');
                entry.className = `log-entry log-${type}`;
                entry.textContent = `${new Date().toLocaleTimeString()}: ${message}`;
                logElement.appendChild(entry);
                logElement.scrollTop = logElement.scrollHeight;
                
                // Keep only last 20 entries
                while (logElement.children.length > 20) {
                    logElement.removeChild(logElement.firstChild);
                }
            }

            // === RENDERING METHODS ===

            getCameraPosition() {
                const x = this.camera.radius * Math.cos(this.camera.phi) * Math.cos(this.camera.theta);
                const y = this.camera.radius * Math.sin(this.camera.phi);
                const z = this.camera.radius * Math.cos(this.camera.phi) * Math.sin(this.camera.theta);
                return [
                    this.camera.center[0] + x,
                    this.camera.center[1] + y,
                    this.camera.center[2] + z
                ];
            }

            getViewMatrix() {
                const position = this.getCameraPosition();
                const center = this.camera.center;
                const up = [0, 1, 0];
                
                // Create view matrix (lookAt)
                const f = this.normalize([
                    center[0] - position[0],
                    center[1] - position[1],
                    center[2] - position[2]
                ]);
                
                const s = this.normalize(this.cross(f, up));
                const u = this.cross(s, f);
                
                return new Float32Array([
                    s[0], u[0], -f[0], 0,
                    s[1], u[1], -f[1], 0,
                    s[2], u[2], -f[2], 0,
                    -this.dot(s, position), -this.dot(u, position), this.dot(f, position), 1
                ]);
            }

            getProjectionMatrix() {
                const fov = 45 * Math.PI / 180;
                const aspect = this.canvas.width / this.canvas.height;
                const near = 0.1;
                const far = 100.0;
                
                const f = 1.0 / Math.tan(fov / 2);
                const rangeInv = 1 / (near - far);
                
                return new Float32Array([
                    f / aspect, 0, 0, 0,
                    0, f, 0, 0,
                    0, 0, (near + far) * rangeInv, -1,
                    0, 0, near * far * rangeInv * 2, 0
                ]);
            }

            getModelMatrix() {
                // Create transformation matrix
                const scale = this.modelTransform.scale;
                const rotation = this.modelTransform.rotation;
                const translation = this.modelTransform.translation;
                
                // Scale matrix
                const scaleMatrix = new Float32Array([
                    scale[0], 0, 0, 0,
                    0, scale[1], 0, 0,
                    0, 0, scale[2], 0,
                    0, 0, 0, 1
                ]);
                
                // Rotation matrices
                const rotX = this.rotateX(rotation[0]);
                const rotY = this.rotateY(rotation[1]);
                const rotZ = this.rotateZ(rotation[2]);
                
                // Translation matrix
                const transMatrix = new Float32Array([
                    1, 0, 0, 0,
                    0, 1, 0, 0,
                    0, 0, 1, 0,
                    translation[0], translation[1], translation[2], 1
                ]);
                
                // Combine transformations: T * R * S
                let result = this.multiplyMatrices(transMatrix, this.multiplyMatrices(rotZ, this.multiplyMatrices(rotY, rotX)));
                return this.multiplyMatrices(result, scaleMatrix);
            }

            rotateX(angle) {
                const c = Math.cos(angle);
                const s = Math.sin(angle);
                return new Float32Array([
                    1, 0, 0, 0,
                    0, c, s, 0,
                    0, -s, c, 0,
                    0, 0, 0, 1
                ]);
            }

            rotateY(angle) {
                const c = Math.cos(angle);
                const s = Math.sin(angle);
                return new Float32Array([
                    c, 0, -s, 0,
                    0, 1, 0, 0,
                    s, 0, c, 0,
                    0, 0, 0, 1
                ]);
            }

            rotateZ(angle) {
                const c = Math.cos(angle);
                const s = Math.sin(angle);
                return new Float32Array([
                    c, s, 0, 0,
                    -s, c, 0, 0,
                    0, 0, 1, 0,
                    0, 0, 0, 1
                ]);
            }

            multiplyMatrices(a, b) {
                const result = new Float32Array(16);
                for (let i = 0; i < 4; i++) {
                    for (let j = 0; j < 4; j++) {
                        result[i * 4 + j] = 
                            a[i * 4 + 0] * b[0 * 4 + j] +
                            a[i * 4 + 1] * b[1 * 4 + j] +
                            a[i * 4 + 2] * b[2 * 4 + j] +
                            a[i * 4 + 3] * b[3 * 4 + j];
                    }
                }
                return result;
            }

            // Vector math utilities
            normalize(v) {
                const length = Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);
                return length > 0 ? [v[0] / length, v[1] / length, v[2] / length] : [0, 0, 0];
            }

            cross(a, b) {
                return [
                    a[1] * b[2] - a[2] * b[1],
                    a[2] * b[0] - a[0] * b[2],
                    a[0] * b[1] - a[1] * b[0]
                ];
            }

            dot(a, b) {
                return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
            }

            render() {
                const currentTime = performance.now();
                
                // Update performance metrics
                this.frameCount++;
                if (currentTime - this.lastTime >= 1000) {
                    this.fps = this.frameCount;
                    this.frameTime = (currentTime - this.lastTime) / this.frameCount;
                    
                    document.getElementById('fps').textContent = this.fps;
                    document.getElementById('frameTime').textContent = this.frameTime.toFixed(1);
                    
                    // Update LiveLink performance metrics
                    this.updatePerformanceMetrics();
                    
                    this.frameCount = 0;
                    this.lastTime = currentTime;
                }
                
                // Auto-rotation
                if (this.autoRotate) {
                    this.camera.theta += this.rotationSpeed * 0.01;
                    
                    // Sync camera to Octane if connected
                    if (this.cameraSync) {
                        this.syncCameraToOctane();
                    }
                }
                
                // Clear screen
                this.gl.clearColor(0.05, 0.05, 0.1, 1.0);
                this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);
                
                const view = this.getViewMatrix();
                const projection = this.getProjectionMatrix();
                const model = this.getModelMatrix();
                const viewPos = this.getCameraPosition();
                
                // Render skybox
                this.gl.depthFunc(this.gl.LEQUAL);
                this.gl.useProgram(this.skyboxProgram);
                this.gl.bindVertexArray(this.skyboxVAO);
                
                const skyboxViewLoc = this.gl.getUniformLocation(this.skyboxProgram, 'uView');
                const skyboxProjLoc = this.gl.getUniformLocation(this.skyboxProgram, 'uProjection');
                const skyboxTimeLoc = this.gl.getUniformLocation(this.skyboxProgram, 'uTime');
                
                this.gl.uniformMatrix4fv(skyboxViewLoc, false, view);
                this.gl.uniformMatrix4fv(skyboxProjLoc, false, projection);
                this.gl.uniform1f(skyboxTimeLoc, currentTime * 0.001);
                
                this.gl.drawArrays(this.gl.TRIANGLES, 0, 36);
                this.gl.depthFunc(this.gl.LESS);
                
                // Render main object
                this.gl.useProgram(this.shaderProgram);
                
                const modelLoc = this.gl.getUniformLocation(this.shaderProgram, 'uModel');
                const viewLoc = this.gl.getUniformLocation(this.shaderProgram, 'uView');
                const projLoc = this.gl.getUniformLocation(this.shaderProgram, 'uProjection');
                const viewPosLoc = this.gl.getUniformLocation(this.shaderProgram, 'uViewPos');
                const timeLoc = this.gl.getUniformLocation(this.shaderProgram, 'uTime');
                const normalMatrixLoc = this.gl.getUniformLocation(this.shaderProgram, 'uNormalMatrix');
                
                this.gl.uniformMatrix4fv(modelLoc, false, model);
                this.gl.uniformMatrix4fv(viewLoc, false, view);
                this.gl.uniformMatrix4fv(projLoc, false, projection);
                this.gl.uniform3fv(viewPosLoc, viewPos);
                this.gl.uniform1f(timeLoc, currentTime * 0.001);
                
                // Calculate normal matrix (inverse transpose of model matrix)
                const normalMatrix = this.getNormalMatrix(model);
                this.gl.uniformMatrix3fv(normalMatrixLoc, false, normalMatrix);
                
                // Render current model
                if (this.currentModel.isCustomModel && this.modelVAO) {
                    this.gl.bindVertexArray(this.modelVAO);
                    this.gl.drawElements(this.gl.TRIANGLES, this.currentModel.indices.length, this.gl.UNSIGNED_SHORT, 0);
                } else {
                    this.gl.bindVertexArray(this.cubeVAO);
                    this.gl.drawElements(this.gl.TRIANGLES, 36, this.gl.UNSIGNED_SHORT, 0);
                }
                
                requestAnimationFrame(() => this.render());
            }

            updatePerformanceMetrics() {
                if (this.liveLink) {
                    const stats = this.liveLink.getStats();
                    this.grpcCallCount = stats.client.callCount;
                    this.syncCallCount = stats.sync.callCount;

                    document.getElementById('grpcCalls').textContent = this.grpcCallCount;

                    // Update sync rate
                    if (stats.sync.active && stats.sync.lastSyncTime) {
                        const timeDiff = (Date.now() - stats.sync.lastSyncTime) / 1000;
                        const syncRate = timeDiff > 0 ? (1 / timeDiff).toFixed(1) : '--';
                        document.getElementById('syncRate').textContent = syncRate;
                    } else {
                        document.getElementById('syncRate').textContent = '--';
                    }
                }
            }

            getNormalMatrix(modelMatrix) {
                // Extract 3x3 matrix and compute inverse transpose
                const m = modelMatrix;
                const normalMatrix = new Float32Array(9);
                
                // Extract 3x3 part
                normalMatrix[0] = m[0]; normalMatrix[1] = m[1]; normalMatrix[2] = m[2];
                normalMatrix[3] = m[4]; normalMatrix[4] = m[5]; normalMatrix[5] = m[6];
                normalMatrix[6] = m[8]; normalMatrix[7] = m[9]; normalMatrix[8] = m[10];
                
                // For uniform scaling, we can just use the 3x3 part
                // For non-uniform scaling, we'd need proper inverse transpose
                return normalMatrix;
            }
        }

        // Initialize the viewer
        const viewer = new OctaneModelViewer();
    </script>
</body>
</html>