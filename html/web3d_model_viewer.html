<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>‚ú® 3D Model Viewer - Web3D Edition</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #0a0a0f;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            color: white;
        }
        
        #canvas {
            display: block;
            cursor: grab;
        }
        
        #canvas:active {
            cursor: grabbing;
        }
        
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            font-size: 14px;
            line-height: 1.4;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            max-width: 300px;
        }
        
        #controls {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            font-size: 12px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        #dropZone {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 100, 255, 0.1);
            border: 3px dashed rgba(0, 150, 255, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            font-weight: bold;
            color: rgba(0, 150, 255, 1);
            z-index: 1000;
            pointer-events: none;
        }
        
        #dropZone.active {
            display: flex;
            animation: pulse 1s infinite;
        }
        
        @keyframes pulse {
            0% { opacity: 0.6; }
            50% { opacity: 1; }
            100% { opacity: 0.6; }
        }
        
        #performance {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 8px;
            font-size: 12px;
            font-family: 'Courier New', monospace;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        #modelControls {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            font-size: 12px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .highlight {
            color: #4fc3f7;
            font-weight: bold;
        }
        
        .button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            color: white;
            padding: 8px 16px;
            margin: 4px 2px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
            transition: all 0.3s ease;
            display: inline-block;
        }
        
        .button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        
        .button:active {
            transform: translateY(0);
        }
        
        #fileInput {
            display: none;
        }
        
        #currentModel {
            color: #4fc3f7;
            font-weight: bold;
            margin-bottom: 8px;
        }
        
        #loadingIndicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 8px;
            display: none;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .spinner {
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-top: 3px solid #4fc3f7;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <div id="info">
        <div class="highlight">üöÄ WebGL 3D Model Viewer</div>
        <div>Load and view 3D models in your browser</div>
        <div style="margin-top: 8px;">
            <div>‚Ä¢ OBJ, PLY, STL file format support</div>
            <div>‚Ä¢ Drag & drop file loading</div>
            <div>‚Ä¢ Phong lighting with dynamic light source</div>
            <div>‚Ä¢ Procedural skybox with stars and clouds</div>
            <div>‚Ä¢ Automatic normal generation</div>
            <div>‚Ä¢ Procedural vertex coloring</div>
        </div>
    </div>
    
    <div id="controls">
        <div class="highlight">Controls:</div>
        <div>üñ±Ô∏è <strong>Left Mouse Drag:</strong> Orbit camera around model</div>
        <div>üñ±Ô∏è <strong>Right Mouse Drag:</strong> Pan camera left/right/up/down</div>
        <div>üéØ <strong>Mouse Wheel:</strong> Zoom in/out</div>
        <div>üìÅ <strong>Drag & Drop:</strong> Drop 3D files anywhere</div>
        <div>‚å®Ô∏è <strong>L Key:</strong> Load 3D model file</div>
        <div>‚å®Ô∏è <strong>R Key:</strong> Reset to default cube</div>
        <div>‚å®Ô∏è <strong>ESC:</strong> Reset camera position</div>
        <div>üîÑ <strong>Space:</strong> Toggle auto-rotation</div>
        <div style="margin-top: 8px; font-size: 11px; opacity: 0.8;">
            <div class="highlight" style="font-size: 11px;">Model Transform (when loaded):</div>
            <div>üîç <strong>+/- Keys:</strong> Scale model up/down</div>
            <div>üîÑ <strong>X/Y/Z Keys:</strong> Rotate around axis (Shift=reverse)</div>
            <div>‚¨ÖÔ∏è <strong>Arrow Keys:</strong> Move model position</div>
            <div>üîÑ <strong>T Key:</strong> Reset all transformations</div>
        </div>
    </div>
    
    <div id="performance">
        <div>FPS: <span id="fps">--</span></div>
        <div>Frame Time: <span id="frameTime">--</span>ms</div>
        <div>Vertices: <span id="vertices">24</span></div>
        <div>Triangles: <span id="triangles">12</span></div>
    </div>
    
    <div id="modelControls">
        <div id="currentModel">Current: cube (Default)</div>
        <button class="button" onclick="viewer.loadModelFile()">üìÅ Load Model</button>
        <button class="button" onclick="viewer.resetToCube()">üîÑ Reset Cube</button>
        <input type="file" id="fileInput" accept=".obj,.usdz,.usd,.ply,.stl" onchange="viewer.handleFileSelect(event)">
    </div>
    
    <div id="loadingIndicator">
        <div class="spinner"></div>
        <div>Loading model...</div>
    </div>
    
    <div id="dropZone">
        <div>
            üìÅ Drop 3D model files here<br>
            <small>Supports: OBJ, PLY, STL formats</small>
        </div>
    </div>

    <script>
        // WebGL 3D Model Viewer - Enhanced Edition
        // Replicates the enhanced simpleGL functionality using WebGL
        
        class WebGL3DModelViewer {
            constructor() {
                this.canvas = document.getElementById('canvas');
                this.gl = null;
                this.shaderProgram = null;
                this.skyboxProgram = null;
                
                // Camera parameters (matching simpleGL)
                this.camera = {
                    radius: 5.0,
                    theta: 0.0,  // horizontal angle
                    phi: 0.0,    // vertical angle
                    center: [0.0, 0.0, 0.0]
                };
                
                // Mouse state
                this.mouse = {
                    dragging: false,
                    panning: false,  // Right mouse button for panning
                    lastX: 0,
                    lastY: 0
                };
                
                // Animation state
                this.autoRotate = true;
                this.startTime = Date.now();
                
                // Performance tracking
                this.frameCount = 0;
                this.lastTime = 0;
                this.fps = 0;
                this.frameTime = 0;
                
                // Model state
                this.currentModelName = "cube";
                this.hasCustomModel = false;
                this.modelVertices = [];
                this.modelIndices = [];
                
                // Model transformation state
                this.modelTransform = {
                    scale: [1.0, 1.0, 1.0],
                    rotation: [0.0, 0.0, 0.0],
                    translation: [0.0, 0.0, 0.0]
                };
                
                // WebGL objects
                this.cubeVAO = null;
                this.modelVAO = null;
                this.skyboxVAO = null;
                this.cubeBuffer = null;
                this.modelBuffer = null;
                this.skyboxBuffer = null;
                this.cubeIndexBuffer = null;
                this.modelIndexBuffer = null;
                
                this.init();
            }
            
            init() {
                this.setupCanvas();
                this.initWebGL();
                this.createShaders();
                this.createGeometry();
                this.setupEventListeners();
                this.updateModelInfo();
                this.render();
            }
            
            setupCanvas() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                
                window.addEventListener('resize', () => {
                    this.canvas.width = window.innerWidth;
                    this.canvas.height = window.innerHeight;
                    if (this.gl) {
                        this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);
                    }
                });
            }
            
            initWebGL() {
                this.gl = this.canvas.getContext('webgl2');
                if (!this.gl) {
                    alert('WebGL 2.0 not supported');
                    return;
                }
                
                this.gl.enable(this.gl.DEPTH_TEST);
                this.gl.enable(this.gl.BLEND);
                this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);
                this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);
            }
            
            createShaders() {
                // Vertex shader for models
                const vertexShaderSource = `#version 300 es
                    in vec3 aPosition;
                    in vec3 aNormal;
                    in vec3 aColor;
                    
                    uniform mat4 uModel;
                    uniform mat4 uView;
                    uniform mat4 uProjection;
                    uniform mat3 uNormalMatrix;
                    
                    out vec3 vPosition;
                    out vec3 vNormal;
                    out vec3 vColor;
                    
                    void main() {
                        vec4 worldPos = uModel * vec4(aPosition, 1.0);
                        vPosition = worldPos.xyz;
                        vNormal = normalize(uNormalMatrix * aNormal);
                        vColor = aColor;
                        
                        gl_Position = uProjection * uView * worldPos;
                    }
                `;
                
                // Fragment shader for models
                const fragmentShaderSource = `#version 300 es
                    precision highp float;
                    
                    in vec3 vPosition;
                    in vec3 vNormal;
                    in vec3 vColor;
                    
                    uniform vec3 uLightPos;
                    uniform vec3 uLightColor;
                    uniform vec3 uViewPos;
                    uniform float uTime;
                    
                    out vec4 fragColor;
                    
                    void main() {
                        // Ambient lighting
                        float ambientStrength = 0.15;
                        vec3 ambient = ambientStrength * uLightColor;
                        
                        // Diffuse lighting
                        vec3 norm = normalize(vNormal);
                        vec3 lightDir = normalize(uLightPos - vPosition);
                        float diff = max(dot(norm, lightDir), 0.0);
                        vec3 diffuse = diff * uLightColor;
                        
                        // Specular lighting
                        float specularStrength = 0.8;
                        vec3 viewDir = normalize(uViewPos - vPosition);
                        vec3 reflectDir = reflect(-lightDir, norm);
                        float spec = pow(max(dot(viewDir, reflectDir), 0.0), 64.0);
                        vec3 specular = specularStrength * spec * uLightColor;
                        
                        // Rim lighting
                        float rimPower = 2.0;
                        float rimStrength = 0.3;
                        float rim = 1.0 - max(dot(viewDir, norm), 0.0);
                        rim = pow(rim, rimPower);
                        vec3 rimColor = rim * rimStrength * uLightColor;
                        
                        // Time-based color variation
                        vec3 timeColor = vColor + 0.1 * sin(uTime * 0.5 + vPosition.x * 2.0) * vec3(0.2, 0.3, 0.4);
                        
                        vec3 result = (ambient + diffuse + specular + rimColor) * timeColor;
                        fragColor = vec4(result, 1.0);
                    }
                `;
                
                // Skybox shaders
                const skyboxVertexSource = `#version 300 es
                    in vec3 aPosition;
                    
                    uniform mat4 uView;
                    uniform mat4 uProjection;
                    
                    out vec3 vPosition;
                    
                    void main() {
                        vPosition = aPosition;
                        vec4 pos = uProjection * mat4(mat3(uView)) * vec4(aPosition, 1.0);
                        gl_Position = pos.xyww;
                    }
                `;
                
                const skyboxFragmentSource = `#version 300 es
                    precision highp float;
                    
                    in vec3 vPosition;
                    uniform float uTime;
                    
                    out vec4 fragColor;
                    
                    // Noise function for procedural effects
                    float noise(vec3 p) {
                        return fract(sin(dot(p, vec3(12.9898, 78.233, 45.164))) * 43758.5453);
                    }
                    
                    void main() {
                        vec3 dir = normalize(vPosition);
                        
                        // Gradient background
                        float gradient = smoothstep(-1.0, 1.0, dir.y);
                        vec3 topColor = vec3(0.1, 0.2, 0.4);
                        vec3 bottomColor = vec3(0.05, 0.05, 0.15);
                        vec3 skyColor = mix(bottomColor, topColor, gradient);
                        
                        // Add stars
                        float starField = noise(dir * 100.0);
                        if (starField > 0.99) {
                            skyColor += vec3(0.8, 0.9, 1.0) * (starField - 0.99) * 100.0;
                        }
                        
                        // Add moving clouds
                        float cloudNoise = noise(dir * 10.0 + uTime * 0.1);
                        cloudNoise = smoothstep(0.4, 0.6, cloudNoise);
                        skyColor = mix(skyColor, vec3(0.8, 0.8, 0.9), cloudNoise * 0.3);
                        
                        fragColor = vec4(skyColor, 1.0);
                    }
                `;
                
                this.shaderProgram = this.createShaderProgram(vertexShaderSource, fragmentShaderSource);
                this.skyboxProgram = this.createShaderProgram(skyboxVertexSource, skyboxFragmentSource);
            }
            
            createShaderProgram(vertexSource, fragmentSource) {
                const vertexShader = this.compileShader(this.gl.VERTEX_SHADER, vertexSource);
                const fragmentShader = this.compileShader(this.gl.FRAGMENT_SHADER, fragmentSource);
                
                const program = this.gl.createProgram();
                this.gl.attachShader(program, vertexShader);
                this.gl.attachShader(program, fragmentShader);
                this.gl.linkProgram(program);
                
                if (!this.gl.getProgramParameter(program, this.gl.LINK_STATUS)) {
                    console.error('Shader program linking failed:', this.gl.getProgramInfoLog(program));
                    return null;
                }
                
                return program;
            }
            
            compileShader(type, source) {
                const shader = this.gl.createShader(type);
                this.gl.shaderSource(shader, source);
                this.gl.compileShader(shader);
                
                if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
                    console.error('Shader compilation failed:', this.gl.getShaderInfoLog(shader));
                    this.gl.deleteShader(shader);
                    return null;
                }
                
                return shader;
            }
            
            createGeometry() {
                this.createCubeGeometry();
                this.createSkyboxGeometry();
            }
            
            createCubeGeometry() {
                // Enhanced cube with colors and normals (matching simpleGL)
                const vertices = new Float32Array([
                    // Front face
                    -1.0, -1.0,  1.0,   0.0,  0.0,  1.0,   1.0, 0.2, 0.3,
                     1.0, -1.0,  1.0,   0.0,  0.0,  1.0,   0.8, 0.4, 0.6,
                     1.0,  1.0,  1.0,   0.0,  0.0,  1.0,   0.6, 0.8, 0.9,
                    -1.0,  1.0,  1.0,   0.0,  0.0,  1.0,   0.4, 0.6, 0.8,
                    
                    // Back face
                    -1.0, -1.0, -1.0,   0.0,  0.0, -1.0,   0.8, 0.3, 0.4,
                    -1.0,  1.0, -1.0,   0.0,  0.0, -1.0,   0.6, 0.5, 0.7,
                     1.0,  1.0, -1.0,   0.0,  0.0, -1.0,   0.4, 0.7, 0.8,
                     1.0, -1.0, -1.0,   0.0,  0.0, -1.0,   0.9, 0.4, 0.5,
                    
                    // Top face
                    -1.0,  1.0, -1.0,   0.0,  1.0,  0.0,   0.7, 0.8, 0.3,
                    -1.0,  1.0,  1.0,   0.0,  1.0,  0.0,   0.5, 0.9, 0.4,
                     1.0,  1.0,  1.0,   0.0,  1.0,  0.0,   0.3, 0.7, 0.6,
                     1.0,  1.0, -1.0,   0.0,  1.0,  0.0,   0.8, 0.6, 0.5,
                    
                    // Bottom face
                    -1.0, -1.0, -1.0,   0.0, -1.0,  0.0,   0.6, 0.4, 0.8,
                     1.0, -1.0, -1.0,   0.0, -1.0,  0.0,   0.4, 0.6, 0.9,
                     1.0, -1.0,  1.0,   0.0, -1.0,  0.0,   0.7, 0.3, 0.5,
                    -1.0, -1.0,  1.0,   0.0, -1.0,  0.0,   0.9, 0.5, 0.4,
                    
                    // Right face
                     1.0, -1.0, -1.0,   1.0,  0.0,  0.0,   0.5, 0.7, 0.8,
                     1.0,  1.0, -1.0,   1.0,  0.0,  0.0,   0.3, 0.8, 0.6,
                     1.0,  1.0,  1.0,   1.0,  0.0,  0.0,   0.6, 0.5, 0.9,
                     1.0, -1.0,  1.0,   1.0,  0.0,  0.0,   0.8, 0.7, 0.4,
                    
                    // Left face
                    -1.0, -1.0, -1.0,  -1.0,  0.0,  0.0,   0.4, 0.8, 0.7,
                    -1.0, -1.0,  1.0,  -1.0,  0.0,  0.0,   0.7, 0.6, 0.5,
                    -1.0,  1.0,  1.0,  -1.0,  0.0,  0.0,   0.9, 0.4, 0.8,
                    -1.0,  1.0, -1.0,  -1.0,  0.0,  0.0,   0.5, 0.9, 0.6
                ]);
                
                const indices = new Uint16Array([
                    0,  1,  2,    0,  2,  3,    // front
                    4,  5,  6,    4,  6,  7,    // back
                    8,  9,  10,   8,  10, 11,   // top
                    12, 13, 14,   12, 14, 15,   // bottom
                    16, 17, 18,   16, 18, 19,   // right
                    20, 21, 22,   20, 22, 23    // left
                ]);
                
                // Create cube VAO
                this.cubeVAO = this.gl.createVertexArray();
                this.gl.bindVertexArray(this.cubeVAO);
                
                // Create and bind vertex buffer
                this.cubeBuffer = this.gl.createBuffer();
                this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.cubeBuffer);
                this.gl.bufferData(this.gl.ARRAY_BUFFER, vertices, this.gl.STATIC_DRAW);
                
                // Create and bind index buffer
                this.cubeIndexBuffer = this.gl.createBuffer();
                this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.cubeIndexBuffer);
                this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, indices, this.gl.STATIC_DRAW);
                
                // Set up vertex attributes
                const stride = 9 * 4; // 9 floats per vertex * 4 bytes per float
                
                // Position attribute
                this.gl.enableVertexAttribArray(0);
                this.gl.vertexAttribPointer(0, 3, this.gl.FLOAT, false, stride, 0);
                
                // Normal attribute
                this.gl.enableVertexAttribArray(1);
                this.gl.vertexAttribPointer(1, 3, this.gl.FLOAT, false, stride, 3 * 4);
                
                // Color attribute
                this.gl.enableVertexAttribArray(2);
                this.gl.vertexAttribPointer(2, 3, this.gl.FLOAT, false, stride, 6 * 4);
                
                this.gl.bindVertexArray(null);
            }
            
            createSkyboxGeometry() {
                const skyboxVertices = new Float32Array([
                    -1.0,  1.0, -1.0,
                    -1.0, -1.0, -1.0,
                     1.0, -1.0, -1.0,
                     1.0, -1.0, -1.0,
                     1.0,  1.0, -1.0,
                    -1.0,  1.0, -1.0,
                    
                    -1.0, -1.0,  1.0,
                    -1.0, -1.0, -1.0,
                    -1.0,  1.0, -1.0,
                    -1.0,  1.0, -1.0,
                    -1.0,  1.0,  1.0,
                    -1.0, -1.0,  1.0,
                    
                     1.0, -1.0, -1.0,
                     1.0, -1.0,  1.0,
                     1.0,  1.0,  1.0,
                     1.0,  1.0,  1.0,
                     1.0,  1.0, -1.0,
                     1.0, -1.0, -1.0,
                    
                    -1.0, -1.0,  1.0,
                    -1.0,  1.0,  1.0,
                     1.0,  1.0,  1.0,
                     1.0,  1.0,  1.0,
                     1.0, -1.0,  1.0,
                    -1.0, -1.0,  1.0,
                    
                    -1.0,  1.0, -1.0,
                     1.0,  1.0, -1.0,
                     1.0,  1.0,  1.0,
                     1.0,  1.0,  1.0,
                    -1.0,  1.0,  1.0,
                    -1.0,  1.0, -1.0,
                    
                    -1.0, -1.0, -1.0,
                    -1.0, -1.0,  1.0,
                     1.0, -1.0, -1.0,
                     1.0, -1.0, -1.0,
                    -1.0, -1.0,  1.0,
                     1.0, -1.0,  1.0
                ]);
                
                this.skyboxVAO = this.gl.createVertexArray();
                this.gl.bindVertexArray(this.skyboxVAO);
                
                this.skyboxBuffer = this.gl.createBuffer();
                this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.skyboxBuffer);
                this.gl.bufferData(this.gl.ARRAY_BUFFER, skyboxVertices, this.gl.STATIC_DRAW);
                
                this.gl.enableVertexAttribArray(0);
                this.gl.vertexAttribPointer(0, 3, this.gl.FLOAT, false, 0, 0);
                
                this.gl.bindVertexArray(null);
            }
            
            setupEventListeners() {
                // Mouse events
                this.canvas.addEventListener('mousedown', (e) => {
                    if (e.button === 0) { // Left mouse button
                        this.mouse.dragging = true;
                        this.mouse.lastX = e.clientX;
                        this.mouse.lastY = e.clientY;
                    } else if (e.button === 2) { // Right mouse button
                        this.mouse.panning = true;
                        this.mouse.lastX = e.clientX;
                        this.mouse.lastY = e.clientY;
                        e.preventDefault(); // Prevent context menu
                    }
                });
                
                this.canvas.addEventListener('mousemove', (e) => {
                    if (this.mouse.dragging) {
                        // Left mouse button: orbit camera
                        const deltaX = e.clientX - this.mouse.lastX;
                        const deltaY = e.clientY - this.mouse.lastY;
                        
                        this.camera.theta += deltaX * 0.01;
                        this.camera.phi += deltaY * 0.01;
                        
                        // Clamp phi to prevent flipping
                        this.camera.phi = Math.max(-Math.PI/2 + 0.1, Math.min(Math.PI/2 - 0.1, this.camera.phi));
                        
                        this.mouse.lastX = e.clientX;
                        this.mouse.lastY = e.clientY;
                    } else if (this.mouse.panning) {
                        // Right mouse button: pan camera center
                        const deltaX = e.clientX - this.mouse.lastX;
                        const deltaY = e.clientY - this.mouse.lastY;
                        
                        // Pan sensitivity (smaller for more precise control)
                        const panSensitivity = 0.005;
                        
                        // Get camera's right and up vectors for proper panning
                        const position = this.getCameraPosition();
                        const forward = this.normalize([
                            this.camera.center[0] - position[0],
                            this.camera.center[1] - position[1],
                            this.camera.center[2] - position[2]
                        ]);
                        const right = this.normalize(this.cross(forward, [0, 1, 0]));
                        const up = this.normalize(this.cross(right, forward));
                        
                        // Apply panning to camera center
                        const panAmount = panSensitivity * this.camera.radius;
                        this.camera.center[0] -= right[0] * deltaX * panAmount;
                        this.camera.center[1] += up[1] * deltaY * panAmount;
                        this.camera.center[2] -= right[2] * deltaX * panAmount;
                        
                        this.mouse.lastX = e.clientX;
                        this.mouse.lastY = e.clientY;
                    }
                });
                
                this.canvas.addEventListener('mouseup', (e) => {
                    if (e.button === 0) { // Left mouse button
                        this.mouse.dragging = false;
                    } else if (e.button === 2) { // Right mouse button
                        this.mouse.panning = false;
                    }
                });
                
                this.canvas.addEventListener('mouseleave', () => {
                    this.mouse.dragging = false;
                    this.mouse.panning = false;
                });

                // Disable context menu on right click
                this.canvas.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                });
                
                // Wheel event for zooming
                this.canvas.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    this.camera.radius += e.deltaY * 0.01;
                    this.camera.radius = Math.max(1.0, Math.min(20.0, this.camera.radius));
                });
                
                // Keyboard events
                document.addEventListener('keydown', (e) => {
                    switch(e.code) {
                        case 'Escape':
                            this.resetCamera();
                            break;
                        case 'Space':
                            e.preventDefault();
                            this.autoRotate = !this.autoRotate;
                            break;
                        case 'KeyL':
                            this.loadModelFile();
                            break;
                        case 'KeyR':
                            this.resetToCube();
                            break;
                        // Model transformation controls (only for custom models)
                        case 'Equal': // + key
                        case 'NumpadAdd':
                            if (this.hasCustomModel) {
                                this.scaleModel(1.1);
                            }
                            break;
                        case 'Minus':
                        case 'NumpadSubtract':
                            if (this.hasCustomModel) {
                                this.scaleModel(0.9);
                            }
                            break;
                        case 'KeyX':
                            if (this.hasCustomModel) {
                                this.rotateModel('x', e.shiftKey ? -0.1 : 0.1);
                            }
                            break;
                        case 'KeyY':
                            if (this.hasCustomModel) {
                                this.rotateModel('y', e.shiftKey ? -0.1 : 0.1);
                            }
                            break;
                        case 'KeyZ':
                            if (this.hasCustomModel) {
                                this.rotateModel('z', e.shiftKey ? -0.1 : 0.1);
                            }
                            break;
                        case 'ArrowUp':
                            if (this.hasCustomModel) {
                                e.preventDefault();
                                this.translateModel(0, 0.1, 0);
                            }
                            break;
                        case 'ArrowDown':
                            if (this.hasCustomModel) {
                                e.preventDefault();
                                this.translateModel(0, -0.1, 0);
                            }
                            break;
                        case 'ArrowLeft':
                            if (this.hasCustomModel) {
                                e.preventDefault();
                                this.translateModel(-0.1, 0, 0);
                            }
                            break;
                        case 'ArrowRight':
                            if (this.hasCustomModel) {
                                e.preventDefault();
                                this.translateModel(0.1, 0, 0);
                            }
                            break;
                        case 'KeyT':
                            if (this.hasCustomModel) {
                                this.resetModelTransform();
                            }
                            break;
                    }
                });
                
                // Touch events for mobile
                this.canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    if (e.touches.length === 1) {
                        this.mouse.dragging = true;
                        this.mouse.lastX = e.touches[0].clientX;
                        this.mouse.lastY = e.touches[0].clientY;
                    }
                });
                
                this.canvas.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    if (e.touches.length === 1 && this.mouse.dragging) {
                        const deltaX = e.touches[0].clientX - this.mouse.lastX;
                        const deltaY = e.touches[0].clientY - this.mouse.lastY;
                        
                        this.camera.theta += deltaX * 0.01;
                        this.camera.phi += deltaY * 0.01;
                        
                        this.camera.phi = Math.max(-Math.PI/2 + 0.1, Math.min(Math.PI/2 - 0.1, this.camera.phi));
                        
                        this.mouse.lastX = e.touches[0].clientX;
                        this.mouse.lastY = e.touches[0].clientY;
                    }
                });
                
                this.canvas.addEventListener('touchend', () => {
                    this.mouse.dragging = false;
                });
                
                // Drag and drop events
                this.setupDragAndDrop();
            }
            
            setupDragAndDrop() {
                const dropZone = document.getElementById('dropZone');
                
                // Prevent default drag behaviors
                ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                    document.addEventListener(eventName, (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                    });
                });
                
                // Highlight drop zone when item is dragged over it
                ['dragenter', 'dragover'].forEach(eventName => {
                    document.addEventListener(eventName, () => {
                        dropZone.classList.add('active');
                    });
                });
                
                ['dragleave', 'drop'].forEach(eventName => {
                    document.addEventListener(eventName, () => {
                        dropZone.classList.remove('active');
                    });
                });
                
                // Handle dropped files
                document.addEventListener('drop', (e) => {
                    const files = e.dataTransfer.files;
                    if (files.length > 0) {
                        this.handleDroppedFile(files[0]);
                    }
                });
            }
            
            handleDroppedFile(file) {
                // Check if file is a supported 3D model format
                const supportedExtensions = ['.obj', '.ply', '.stl'];
                const fileName = file.name.toLowerCase();
                const isSupported = supportedExtensions.some(ext => fileName.endsWith(ext));
                
                if (!isSupported) {
                    alert('Unsupported file format. Please use OBJ, PLY, or STL files.');
                    return;
                }
                
                // Show loading indicator
                document.getElementById('loadingIndicator').style.display = 'block';
                
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const content = e.target.result;
                        
                        if (fileName.endsWith('.obj')) {
                            this.parseOBJ(content, file.name);
                        } else if (fileName.endsWith('.ply')) {
                            this.parsePLY(content, file.name);
                        } else if (fileName.endsWith('.stl')) {
                            this.parseSTL(content, file.name);
                        }
                        
                        console.log(`Successfully loaded model via drag & drop: ${file.name}`);
                    } catch (error) {
                        console.error('Error loading dropped file:', error);
                        alert('Error loading file: ' + error.message);
                    } finally {
                        document.getElementById('loadingIndicator').style.display = 'none';
                    }
                };
                
                reader.readAsText(file);
            }
            
            // Model transformation methods
            scaleModel(factor) {
                this.modelTransform.scale[0] *= factor;
                this.modelTransform.scale[1] *= factor;
                this.modelTransform.scale[2] *= factor;
                console.log(`Model scaled by ${factor}, new scale: [${this.modelTransform.scale.join(', ')}]`);
            }
            
            rotateModel(axis, angle) {
                const axisIndex = axis === 'x' ? 0 : axis === 'y' ? 1 : 2;
                this.modelTransform.rotation[axisIndex] += angle;
                console.log(`Model rotated ${angle} radians around ${axis}-axis`);
            }
            
            translateModel(x, y, z) {
                this.modelTransform.translation[0] += x;
                this.modelTransform.translation[1] += y;
                this.modelTransform.translation[2] += z;
                console.log(`Model translated by [${x}, ${y}, ${z}]`);
            }
            
            resetModelTransform() {
                this.modelTransform.scale = [1.0, 1.0, 1.0];
                this.modelTransform.rotation = [0.0, 0.0, 0.0];
                this.modelTransform.translation = [0.0, 0.0, 0.0];
                console.log('Model transform reset to default');
            }
            
            resetCamera() {
                this.camera.radius = 5.0;
                this.camera.theta = 0.0;
                this.camera.phi = 0.0;
                this.camera.center = [0.0, 0.0, 0.0];
            }

            getCameraPosition() {
                const x = this.camera.radius * Math.cos(this.camera.phi) * Math.cos(this.camera.theta);
                const y = this.camera.radius * Math.sin(this.camera.phi);
                const z = this.camera.radius * Math.cos(this.camera.phi) * Math.sin(this.camera.theta);
                return [
                    this.camera.center[0] + x,
                    this.camera.center[1] + y,
                    this.camera.center[2] + z
                ];
            }
            
            loadModelFile() {
                document.getElementById('fileInput').click();
            }
            
            handleFileSelect(event) {
                const file = event.target.files[0];
                if (!file) return;
                
                this.showLoadingIndicator(true);
                
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const content = e.target.result;
                        const extension = file.name.toLowerCase().split('.').pop();
                        
                        if (extension === 'obj') {
                            this.loadOBJModel(content, file.name);
                        } else {
                            alert(`Unsupported file format: .${extension}\nCurrently supported: OBJ`);
                        }
                    } catch (error) {
                        console.error('Error loading model:', error);
                        alert('Error loading model file');
                    } finally {
                        this.showLoadingIndicator(false);
                    }
                };
                reader.readAsText(file);
            }
            
            loadOBJModel(content, filename) {
                const vertices = [];
                const normals = [];
                const faces = [];
                
                const lines = content.split('\n');
                
                for (const line of lines) {
                    const parts = line.trim().split(/\s+/);
                    
                    if (parts[0] === 'v') {
                        // Vertex position
                        vertices.push([
                            parseFloat(parts[1]),
                            parseFloat(parts[2]),
                            parseFloat(parts[3])
                        ]);
                    } else if (parts[0] === 'vn') {
                        // Vertex normal
                        normals.push([
                            parseFloat(parts[1]),
                            parseFloat(parts[2]),
                            parseFloat(parts[3])
                        ]);
                    } else if (parts[0] === 'f') {
                        // Face
                        const face = [];
                        for (let i = 1; i < parts.length; i++) {
                            const indices = parts[i].split('/');
                            face.push({
                                vertex: parseInt(indices[0]) - 1,
                                normal: indices[2] ? parseInt(indices[2]) - 1 : -1
                            });
                        }
                        faces.push(face);
                    }
                }
                
                // Convert to triangulated mesh with colors
                const modelVertices = [];
                const modelIndices = [];
                let indexCounter = 0;
                
                for (const face of faces) {
                    if (face.length >= 3) {
                        // Triangulate face (simple fan triangulation)
                        for (let i = 1; i < face.length - 1; i++) {
                            const indices = [0, i, i + 1];
                            
                            for (const idx of indices) {
                                const vertexIdx = face[idx].vertex;
                                const normalIdx = face[idx].normal;
                                
                                if (vertexIdx < vertices.length) {
                                    const pos = vertices[vertexIdx];
                                    
                                    // Position
                                    modelVertices.push(pos[0], pos[1], pos[2]);
                                    
                                    // Normal (use provided or generate)
                                    if (normalIdx >= 0 && normalIdx < normals.length) {
                                        const norm = normals[normalIdx];
                                        modelVertices.push(norm[0], norm[1], norm[2]);
                                    } else {
                                        // Generate face normal
                                        modelVertices.push(0, 1, 0); // Placeholder, will be calculated later
                                    }
                                    
                                    // Procedural color based on position
                                    const color = this.generateVertexColor(pos);
                                    modelVertices.push(color[0], color[1], color[2]);
                                    
                                    modelIndices.push(indexCounter++);
                                }
                            }
                        }
                    }
                }
                
                // Generate normals if needed
                this.generateNormals(modelVertices, modelIndices);
                
                // Create model geometry
                this.createModelGeometry(modelVertices, modelIndices);
                
                // Update state
                this.hasCustomModel = true;
                this.currentModelName = filename.replace(/\.[^/.]+$/, ""); // Remove extension
                this.modelVertices = modelVertices;
                this.modelIndices = modelIndices;
                
                this.updateModelInfo();
                
                console.log(`Loaded model: ${filename} with ${vertices.length} vertices and ${faces.length} faces`);
            }
            
            parsePLY(content, filename) {
                const lines = content.split('\n');
                const vertices = [];
                const faces = [];
                let vertexCount = 0;
                let faceCount = 0;
                let inHeader = true;
                let currentVertex = 0;
                let currentFace = 0;
                
                // Parse PLY header
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i].trim();
                    
                    if (line === 'end_header') {
                        inHeader = false;
                        continue;
                    }
                    
                    if (inHeader) {
                        if (line.startsWith('element vertex')) {
                            vertexCount = parseInt(line.split(' ')[2]);
                        } else if (line.startsWith('element face')) {
                            faceCount = parseInt(line.split(' ')[2]);
                        }
                        continue;
                    }
                    
                    // Parse vertex data
                    if (currentVertex < vertexCount) {
                        const parts = line.split(/\s+/);
                        if (parts.length >= 3) {
                            vertices.push([
                                parseFloat(parts[0]),
                                parseFloat(parts[1]),
                                parseFloat(parts[2])
                            ]);
                            currentVertex++;
                        }
                    }
                    // Parse face data
                    else if (currentFace < faceCount) {
                        const parts = line.split(/\s+/);
                        if (parts.length >= 4) {
                            const numVertices = parseInt(parts[0]);
                            const face = [];
                            for (let j = 1; j <= numVertices; j++) {
                                face.push({ vertex: parseInt(parts[j]), normal: -1 });
                            }
                            faces.push(face);
                            currentFace++;
                        }
                    }
                }
                
                this.processModelData(vertices, faces, filename);
            }
            
            parseSTL(content, filename) {
                const lines = content.split('\n');
                const vertices = [];
                const faces = [];
                let currentFace = [];
                
                for (const line of lines) {
                    const trimmed = line.trim();
                    
                    if (trimmed.startsWith('vertex')) {
                        const parts = trimmed.split(/\s+/);
                        if (parts.length >= 4) {
                            const vertex = [
                                parseFloat(parts[1]),
                                parseFloat(parts[2]),
                                parseFloat(parts[3])
                            ];
                            vertices.push(vertex);
                            currentFace.push({ vertex: vertices.length - 1, normal: -1 });
                        }
                    } else if (trimmed.startsWith('endfacet')) {
                        if (currentFace.length === 3) {
                            faces.push(currentFace);
                        }
                        currentFace = [];
                    }
                }
                
                this.processModelData(vertices, faces, filename);
            }
            
            processModelData(vertices, faces, filename) {
                // Convert to triangulated mesh with colors (shared logic for all formats)
                const modelVertices = [];
                const modelIndices = [];
                let indexCounter = 0;
                
                for (const face of faces) {
                    if (face.length >= 3) {
                        // Triangulate face (simple fan triangulation)
                        for (let i = 1; i < face.length - 1; i++) {
                            const indices = [0, i, i + 1];
                            
                            for (const idx of indices) {
                                const vertexIdx = face[idx].vertex;
                                
                                if (vertexIdx < vertices.length) {
                                    const pos = vertices[vertexIdx];
                                    
                                    // Position
                                    modelVertices.push(pos[0], pos[1], pos[2]);
                                    
                                    // Normal (placeholder, will be calculated)
                                    modelVertices.push(0, 1, 0);
                                    
                                    // Procedural color based on position
                                    const color = this.generateVertexColor(pos);
                                    modelVertices.push(color[0], color[1], color[2]);
                                    
                                    modelIndices.push(indexCounter++);
                                }
                            }
                        }
                    }
                }
                
                // Generate normals
                this.generateNormals(modelVertices, modelIndices);
                
                // Create model geometry
                this.createModelGeometry(modelVertices, modelIndices);
                
                // Update state
                this.hasCustomModel = true;
                this.currentModelName = filename.replace(/\.[^/.]+$/, ""); // Remove extension
                this.modelVertices = modelVertices;
                this.modelIndices = modelIndices;
                
                this.updateModelInfo();
                
                console.log(`Loaded model: ${filename} with ${vertices.length} vertices and ${faces.length} faces`);
            }
            
            generateVertexColor(position) {
                // Generate appealing colors based on vertex position
                const x = position[0];
                const y = position[1];
                const z = position[2];
                
                const r = 0.4 + 0.4 * Math.sin(x * 2.0 + 1.0);
                const g = 0.6 + 0.3 * Math.sin(y * 1.5 + 2.0);
                const b = 0.8 + 0.2 * Math.sin(z * 1.8 + 3.0);
                
                return [r, g, b];
            }
            
            generateNormals(vertices, indices) {
                // Generate face normals for vertices that don't have them
                for (let i = 0; i < indices.length; i += 3) {
                    const i1 = indices[i] * 9;
                    const i2 = indices[i + 1] * 9;
                    const i3 = indices[i + 2] * 9;
                    
                    // Get positions
                    const v1 = [vertices[i1], vertices[i1 + 1], vertices[i1 + 2]];
                    const v2 = [vertices[i2], vertices[i2 + 1], vertices[i2 + 2]];
                    const v3 = [vertices[i3], vertices[i3 + 1], vertices[i3 + 2]];
                    
                    // Calculate face normal
                    const edge1 = [v2[0] - v1[0], v2[1] - v1[1], v2[2] - v1[2]];
                    const edge2 = [v3[0] - v1[0], v3[1] - v1[1], v3[2] - v1[2]];
                    
                    const normal = [
                        edge1[1] * edge2[2] - edge1[2] * edge2[1],
                        edge1[2] * edge2[0] - edge1[0] * edge2[2],
                        edge1[0] * edge2[1] - edge1[1] * edge2[0]
                    ];
                    
                    // Normalize
                    const length = Math.sqrt(normal[0] * normal[0] + normal[1] * normal[1] + normal[2] * normal[2]);
                    if (length > 0) {
                        normal[0] /= length;
                        normal[1] /= length;
                        normal[2] /= length;
                    }
                    
                    // Apply to all three vertices if they have placeholder normals
                    for (let j = 0; j < 3; j++) {
                        const idx = indices[i + j] * 9;
                        if (vertices[idx + 3] === 0 && vertices[idx + 4] === 1 && vertices[idx + 5] === 0) {
                            vertices[idx + 3] = normal[0];
                            vertices[idx + 4] = normal[1];
                            vertices[idx + 5] = normal[2];
                        }
                    }
                }
            }
            
            createModelGeometry(vertices, indices) {
                // Create model VAO
                if (this.modelVAO) {
                    this.gl.deleteVertexArray(this.modelVAO);
                    this.gl.deleteBuffer(this.modelBuffer);
                    this.gl.deleteBuffer(this.modelIndexBuffer);
                }
                
                this.modelVAO = this.gl.createVertexArray();
                this.gl.bindVertexArray(this.modelVAO);
                
                // Create and bind vertex buffer
                this.modelBuffer = this.gl.createBuffer();
                this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.modelBuffer);
                this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(vertices), this.gl.STATIC_DRAW);
                
                // Create and bind index buffer
                this.modelIndexBuffer = this.gl.createBuffer();
                this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.modelIndexBuffer);
                this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), this.gl.STATIC_DRAW);
                
                // Set up vertex attributes
                const stride = 9 * 4; // 9 floats per vertex * 4 bytes per float
                
                // Position attribute
                this.gl.enableVertexAttribArray(0);
                this.gl.vertexAttribPointer(0, 3, this.gl.FLOAT, false, stride, 0);
                
                // Normal attribute
                this.gl.enableVertexAttribArray(1);
                this.gl.vertexAttribPointer(1, 3, this.gl.FLOAT, false, stride, 3 * 4);
                
                // Color attribute
                this.gl.enableVertexAttribArray(2);
                this.gl.vertexAttribPointer(2, 3, this.gl.FLOAT, false, stride, 6 * 4);
                
                this.gl.bindVertexArray(null);
            }
            
            resetToCube() {
                this.hasCustomModel = false;
                this.currentModelName = "cube";
                this.resetModelTransform();
                this.updateModelInfo();
                console.log("Reset to default cube");
            }
            
            updateModelInfo() {
                const currentModelElement = document.getElementById('currentModel');
                const verticesElement = document.getElementById('vertices');
                const trianglesElement = document.getElementById('triangles');
                
                if (this.hasCustomModel) {
                    currentModelElement.textContent = `Current: ${this.currentModelName} (Custom Model)`;
                    const vertexCount = this.modelVertices.length / 9;
                    const triangleCount = this.modelIndices.length / 3;
                    verticesElement.textContent = vertexCount;
                    trianglesElement.textContent = triangleCount;
                } else {
                    currentModelElement.textContent = "Current: cube (Default)";
                    verticesElement.textContent = "24";
                    trianglesElement.textContent = "12";
                }
                
                // Update page title
                document.title = `‚ú® 3D Model Viewer - ${this.currentModelName} ${this.hasCustomModel ? '(Custom Model)' : '(Default Cube)'}`;
            }
            
            showLoadingIndicator(show) {
                document.getElementById('loadingIndicator').style.display = show ? 'block' : 'none';
            }
            
            render() {
                const currentTime = Date.now();
                const deltaTime = currentTime - this.lastTime;
                this.lastTime = currentTime;
                
                // Update performance metrics
                this.frameCount++;
                if (this.frameCount % 60 === 0) {
                    this.fps = Math.round(1000 / deltaTime);
                    this.frameTime = deltaTime.toFixed(1);
                    document.getElementById('fps').textContent = this.fps;
                    document.getElementById('frameTime').textContent = this.frameTime;
                }
                
                const time = (currentTime - this.startTime) / 1000.0;
                
                // Clear screen
                this.gl.clearColor(0.05, 0.05, 0.1, 1.0);
                this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);
                
                // Calculate camera position
                const camX = this.camera.radius * Math.cos(this.camera.phi) * Math.cos(this.camera.theta);
                const camY = this.camera.radius * Math.sin(this.camera.phi);
                const camZ = this.camera.radius * Math.cos(this.camera.phi) * Math.sin(this.camera.theta);
                
                // Create matrices
                const viewMatrix = this.lookAt([camX, camY, camZ], this.camera.center, [0, 1, 0]);
                const projectionMatrix = this.perspective(45 * Math.PI / 180, this.canvas.width / this.canvas.height, 0.1, 100.0);
                
                // Render skybox first
                this.renderSkybox(viewMatrix, projectionMatrix, time);
                
                // Render model (cube or custom)
                this.renderModel(viewMatrix, projectionMatrix, [camX, camY, camZ], time);
                
                requestAnimationFrame(() => this.render());
            }
            
            renderSkybox(viewMatrix, projectionMatrix, time) {
                this.gl.depthFunc(this.gl.LEQUAL);
                this.gl.useProgram(this.skyboxProgram);
                
                // Remove translation from view matrix for skybox
                const skyboxView = [...viewMatrix];
                skyboxView[12] = skyboxView[13] = skyboxView[14] = 0;
                
                const uView = this.gl.getUniformLocation(this.skyboxProgram, 'uView');
                const uProjection = this.gl.getUniformLocation(this.skyboxProgram, 'uProjection');
                const uTime = this.gl.getUniformLocation(this.skyboxProgram, 'uTime');
                
                this.gl.uniformMatrix4fv(uView, false, skyboxView);
                this.gl.uniformMatrix4fv(uProjection, false, projectionMatrix);
                this.gl.uniform1f(uTime, time);
                
                this.gl.bindVertexArray(this.skyboxVAO);
                this.gl.drawArrays(this.gl.TRIANGLES, 0, 36);
                
                this.gl.depthFunc(this.gl.LESS);
            }
            
            renderModel(viewMatrix, projectionMatrix, viewPos, time) {
                this.gl.useProgram(this.shaderProgram);
                
                // Create model matrix
                let modelMatrix = this.identity();
                
                // Apply custom model transformations
                if (this.hasCustomModel) {
                    // Apply translation
                    modelMatrix = this.multiply(modelMatrix, this.translate(
                        this.modelTransform.translation[0],
                        this.modelTransform.translation[1],
                        this.modelTransform.translation[2]
                    ));
                    
                    // Apply rotations
                    modelMatrix = this.multiply(modelMatrix, this.rotateX(this.modelTransform.rotation[0]));
                    modelMatrix = this.multiply(modelMatrix, this.rotateY(this.modelTransform.rotation[1]));
                    modelMatrix = this.multiply(modelMatrix, this.rotateZ(this.modelTransform.rotation[2]));
                    
                    // Apply scaling
                    modelMatrix = this.multiply(modelMatrix, this.scale(
                        this.modelTransform.scale[0],
                        this.modelTransform.scale[1],
                        this.modelTransform.scale[2]
                    ));
                    
                    // Optional auto-rotation for custom models
                    if (this.autoRotate) {
                        modelMatrix = this.multiply(modelMatrix, this.rotateY(time * 0.1));
                    }
                } else {
                    // Only rotate if showing the default cube
                    if (this.autoRotate) {
                        modelMatrix = this.multiply(modelMatrix, this.rotateY(time * 0.3));
                        modelMatrix = this.multiply(modelMatrix, this.rotateX(time * 0.2));
                    }
                }
                
                // Calculate normal matrix
                const normalMatrix = this.transpose(this.inverse3x3(this.getMatrix3x3(modelMatrix)));
                
                // Dynamic light position
                const lightPos = [
                    3.0 * Math.cos(time * 0.5),
                    2.0 + Math.sin(time * 0.7),
                    3.0 * Math.sin(time * 0.5)
                ];
                const lightColor = [1.0, 0.95, 0.8];
                
                // Set uniforms
                const uModel = this.gl.getUniformLocation(this.shaderProgram, 'uModel');
                const uView = this.gl.getUniformLocation(this.shaderProgram, 'uView');
                const uProjection = this.gl.getUniformLocation(this.shaderProgram, 'uProjection');
                const uNormalMatrix = this.gl.getUniformLocation(this.shaderProgram, 'uNormalMatrix');
                const uLightPos = this.gl.getUniformLocation(this.shaderProgram, 'uLightPos');
                const uLightColor = this.gl.getUniformLocation(this.shaderProgram, 'uLightColor');
                const uViewPos = this.gl.getUniformLocation(this.shaderProgram, 'uViewPos');
                const uTime = this.gl.getUniformLocation(this.shaderProgram, 'uTime');
                
                this.gl.uniformMatrix4fv(uModel, false, modelMatrix);
                this.gl.uniformMatrix4fv(uView, false, viewMatrix);
                this.gl.uniformMatrix4fv(uProjection, false, projectionMatrix);
                this.gl.uniformMatrix3fv(uNormalMatrix, false, normalMatrix);
                this.gl.uniform3fv(uLightPos, lightPos);
                this.gl.uniform3fv(uLightColor, lightColor);
                this.gl.uniform3fv(uViewPos, viewPos);
                this.gl.uniform1f(uTime, time);
                
                // Render appropriate model
                if (this.hasCustomModel && this.modelVAO) {
                    this.gl.bindVertexArray(this.modelVAO);
                    this.gl.drawElements(this.gl.TRIANGLES, this.modelIndices.length, this.gl.UNSIGNED_SHORT, 0);
                } else {
                    this.gl.bindVertexArray(this.cubeVAO);
                    this.gl.drawElements(this.gl.TRIANGLES, 36, this.gl.UNSIGNED_SHORT, 0);
                }
            }
            
            // Matrix utility functions
            identity() {
                return new Float32Array([
                    1, 0, 0, 0,
                    0, 1, 0, 0,
                    0, 0, 1, 0,
                    0, 0, 0, 1
                ]);
            }
            
            multiply(a, b) {
                const result = new Float32Array(16);
                for (let i = 0; i < 4; i++) {
                    for (let j = 0; j < 4; j++) {
                        result[i * 4 + j] = 
                            a[i * 4 + 0] * b[0 * 4 + j] +
                            a[i * 4 + 1] * b[1 * 4 + j] +
                            a[i * 4 + 2] * b[2 * 4 + j] +
                            a[i * 4 + 3] * b[3 * 4 + j];
                    }
                }
                return result;
            }
            
            rotateX(angle) {
                const c = Math.cos(angle);
                const s = Math.sin(angle);
                return new Float32Array([
                    1, 0, 0, 0,
                    0, c, -s, 0,
                    0, s, c, 0,
                    0, 0, 0, 1
                ]);
            }
            
            rotateY(angle) {
                const c = Math.cos(angle);
                const s = Math.sin(angle);
                return new Float32Array([
                    c, 0, s, 0,
                    0, 1, 0, 0,
                    -s, 0, c, 0,
                    0, 0, 0, 1
                ]);
            }
            
            rotateZ(angle) {
                const c = Math.cos(angle);
                const s = Math.sin(angle);
                return new Float32Array([
                    c, -s, 0, 0,
                    s, c, 0, 0,
                    0, 0, 1, 0,
                    0, 0, 0, 1
                ]);
            }
            
            scale(x, y, z) {
                return new Float32Array([
                    x, 0, 0, 0,
                    0, y, 0, 0,
                    0, 0, z, 0,
                    0, 0, 0, 1
                ]);
            }
            
            translate(x, y, z) {
                return new Float32Array([
                    1, 0, 0, 0,
                    0, 1, 0, 0,
                    0, 0, 1, 0,
                    x, y, z, 1
                ]);
            }
            
            perspective(fovy, aspect, near, far) {
                const f = 1.0 / Math.tan(fovy / 2);
                const nf = 1 / (near - far);
                
                return new Float32Array([
                    f / aspect, 0, 0, 0,
                    0, f, 0, 0,
                    0, 0, (far + near) * nf, -1,
                    0, 0, 2 * far * near * nf, 0
                ]);
            }
            
            lookAt(eye, center, up) {
                const f = this.normalize(this.subtract(center, eye));
                const s = this.normalize(this.cross(f, up));
                const u = this.cross(s, f);
                
                return new Float32Array([
                    s[0], u[0], -f[0], 0,
                    s[1], u[1], -f[1], 0,
                    s[2], u[2], -f[2], 0,
                    -this.dot(s, eye), -this.dot(u, eye), this.dot(f, eye), 1
                ]);
            }
            
            normalize(v) {
                const length = Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);
                return length > 0 ? [v[0] / length, v[1] / length, v[2] / length] : [0, 0, 0];
            }
            
            subtract(a, b) {
                return [a[0] - b[0], a[1] - b[1], a[2] - b[2]];
            }
            
            cross(a, b) {
                return [
                    a[1] * b[2] - a[2] * b[1],
                    a[2] * b[0] - a[0] * b[2],
                    a[0] * b[1] - a[1] * b[0]
                ];
            }
            
            dot(a, b) {
                return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
            }
            
            getMatrix3x3(mat4) {
                return new Float32Array([
                    mat4[0], mat4[1], mat4[2],
                    mat4[4], mat4[5], mat4[6],
                    mat4[8], mat4[9], mat4[10]
                ]);
            }
            
            inverse3x3(mat) {
                const det = mat[0] * (mat[4] * mat[8] - mat[7] * mat[5]) -
                           mat[1] * (mat[3] * mat[8] - mat[5] * mat[6]) +
                           mat[2] * (mat[3] * mat[7] - mat[4] * mat[6]);
                
                if (Math.abs(det) < 1e-10) return mat;
                
                const invDet = 1.0 / det;
                
                return new Float32Array([
                    (mat[4] * mat[8] - mat[7] * mat[5]) * invDet,
                    (mat[2] * mat[7] - mat[1] * mat[8]) * invDet,
                    (mat[1] * mat[5] - mat[2] * mat[4]) * invDet,
                    (mat[5] * mat[6] - mat[3] * mat[8]) * invDet,
                    (mat[0] * mat[8] - mat[2] * mat[6]) * invDet,
                    (mat[2] * mat[3] - mat[0] * mat[5]) * invDet,
                    (mat[3] * mat[7] - mat[4] * mat[6]) * invDet,
                    (mat[1] * mat[6] - mat[0] * mat[7]) * invDet,
                    (mat[0] * mat[4] - mat[1] * mat[3]) * invDet
                ]);
            }
            
            transpose(mat) {
                return new Float32Array([
                    mat[0], mat[3], mat[6],
                    mat[1], mat[4], mat[7],
                    mat[2], mat[5], mat[8]
                ]);
            }
        }
        
        // Initialize the viewer
        const viewer = new WebGL3DModelViewer();
        
        // Print instructions
        console.log("=== WebGL 3D Model Viewer - Enhanced Edition ===");
        console.log("Controls:");
        console.log("- Mouse: Drag to orbit camera");
        console.log("- Mouse Wheel: Zoom in/out");
        console.log("- Drag & Drop: Drop OBJ/PLY/STL files anywhere");
        console.log("- L Key: Load 3D model file");
        console.log("- R Key: Reset to default cube");
        console.log("- ESC: Reset camera position");
        console.log("- Space: Toggle auto-rotation");
        console.log("Model Transform (when loaded):");
        console.log("- +/- Keys: Scale model up/down");
        console.log("- X/Y/Z Keys: Rotate around axis (Shift=reverse)");
        console.log("- Arrow Keys: Move model position");
        console.log("- T Key: Reset all transformations");
        console.log("- Click 'Load Model' button to browse files");
        console.log("==============================================");
    </script>
</body>
</html>