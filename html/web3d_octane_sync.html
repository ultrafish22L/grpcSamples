<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGL-Octane LiveLink Sync</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: white;
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 1fr 350px;
            gap: 20px;
            height: calc(100vh - 40px);
        }

        .main-content {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .sidebar {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 15px;
            backdrop-filter: blur(10px);
            overflow-y: auto;
        }

        h1 {
            text-align: center;
            margin: 0 0 20px 0;
            font-size: 2.2em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        .viewer-container {
            flex: 1;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            padding: 10px;
            display: flex;
            flex-direction: column;
        }

        #canvas {
            flex: 1;
            border-radius: 8px;
            background: #000;
            min-height: 400px;
        }

        .controls {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 15px;
            margin-top: 10px;
        }

        .control-section {
            margin-bottom: 15px;
        }

        .control-section:last-child {
            margin-bottom: 0;
        }

        .section-title {
            font-weight: bold;
            margin-bottom: 8px;
            color: #4fc3f7;
            font-size: 0.9em;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .button-group {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
        }

        button {
            padding: 6px 12px;
            font-size: 11px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            font-weight: 500;
        }

        button:enabled {
            background: linear-gradient(135deg, #4fc3f7 0%, #29b6f6 100%);
            color: white;
        }

        button:enabled:hover {
            background: linear-gradient(135deg, #29b6f6 0%, #0288d1 100%);
            transform: translateY(-1px);
        }

        button:disabled {
            background: #555;
            color: #999;
            cursor: not-allowed;
        }

        .status-section {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 6px;
            padding: 10px;
            margin-bottom: 10px;
        }

        .status-connected {
            background: rgba(76, 175, 80, 0.2);
            border-left: 4px solid #4caf50;
        }

        .status-disconnected {
            background: rgba(244, 67, 54, 0.2);
            border-left: 4px solid #f44336;
        }

        .status-connecting {
            background: rgba(255, 193, 7, 0.2);
            border-left: 4px solid #ffc107;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            font-size: 0.85em;
        }

        .stat-item {
            background: rgba(255, 255, 255, 0.1);
            padding: 6px 8px;
            border-radius: 4px;
            display: flex;
            justify-content: space-between;
        }

        .stat-label {
            color: #b0bec5;
        }

        .stat-value {
            font-weight: bold;
            color: #4fc3f7;
        }

        .activity-log {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 6px;
            padding: 10px;
            height: 200px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.8em;
            line-height: 1.4;
        }

        .log-entry {
            margin-bottom: 4px;
            padding: 2px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .log-entry:last-child {
            border-bottom: none;
        }

        .log-info { color: #e3f2fd; }
        .log-success { color: #c8e6c9; }
        .log-warning { color: #fff3e0; }
        .log-error { color: #ffcdd2; }
        .log-debug { color: #f3e5f5; }

        .log-emoji {
            margin-right: 6px;
        }

        .input-group {
            display: flex;
            gap: 5px;
            margin-bottom: 8px;
        }

        input[type="text"] {
            flex: 1;
            padding: 6px 8px;
            border: 1px solid #555;
            border-radius: 4px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 11px;
        }

        input[type="text"]:focus {
            outline: none;
            border-color: #4fc3f7;
            background: rgba(255, 255, 255, 0.15);
        }

        .performance-info {
            font-size: 0.8em;
            color: #b0bec5;
            margin-top: 5px;
        }

        /* Responsive design */
        @media (max-width: 1200px) {
            .container {
                grid-template-columns: 1fr;
                grid-template-rows: 1fr auto;
            }
            
            .sidebar {
                max-height: 300px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="main-content">
            <h1>ðŸ”— WebGL-Octane LiveLink Sync</h1>
            
            <div class="viewer-container">
                <canvas id="canvas"></canvas>
                
                <div class="controls">
                    <div class="control-section">
                        <div class="section-title">Connection</div>
                        <div class="input-group">
                            <input type="text" id="serverAddress" value="http://127.0.0.1:51023" placeholder="Server address">
                            <button id="connectBtn">Connect</button>
                            <button id="disconnectBtn" disabled>Disconnect</button>
                        </div>
                    </div>
                    
                    <div class="control-section">
                        <div class="section-title">LiveLink Operations</div>
                        <div class="button-group">
                            <button id="getCameraBtn" disabled>Get Camera</button>
                            <button id="setCameraBtn" disabled>Set Camera</button>
                            <button id="getMeshesBtn" disabled>Get Meshes</button>
                            <button id="loadTeapotBtn" disabled>Load Teapot</button>
                            <button id="syncCameraBtn" disabled>Start Sync</button>
                        </div>
                    </div>
                    
                    <div class="control-section">
                        <div class="section-title">View Controls</div>
                        <div class="button-group">
                            <button id="autoRotateBtn">Toggle Auto-Rotate</button>
                            <button id="resetCameraBtn">Reset Camera</button>
                            <button id="clearLogBtn">Clear Log</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="sidebar">
            <div class="control-section">
                <div class="section-title">Connection Status</div>
                <div id="connectionStatus" class="status-section status-disconnected">
                    <div id="statusText">Disconnected</div>
                </div>
            </div>

            <div class="control-section">
                <div class="section-title">Performance Stats</div>
                <div class="stats-grid">
                    <div class="stat-item">
                        <span class="stat-label">FPS:</span>
                        <span class="stat-value" id="fpsValue">0</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Frame Time:</span>
                        <span class="stat-value" id="frameTimeValue">0ms</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">gRPC Calls:</span>
                        <span class="stat-value" id="grpcCallsValue">0</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Avg Response:</span>
                        <span class="stat-value" id="avgResponseValue">0ms</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Sync Rate:</span>
                        <span class="stat-value" id="syncRateValue">0/s</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Errors:</span>
                        <span class="stat-value" id="errorCountValue">0</span>
                    </div>
                </div>
            </div>

            <div class="control-section">
                <div class="section-title">Activity Log</div>
                <div id="activityLog" class="activity-log"></div>
            </div>
        </div>
    </div>

    <!-- Include shared utilities -->
    <script src="shared-utils.js"></script>
    <script src="webgl-utils.js"></script>
    <script src="livelink.js"></script>

    <script>
        /**
         * WebGL-Octane LiveLink Synchronization Viewer
         * Demonstrates real-time camera sync between WebGL and Octane Render using LiveLink protocol
         * 
         * This application combines:
         * - WebGL 3D rendering with interactive camera controls
         * - gRPC-Web communication with Octane Render via proxy server
         * - Real-time camera synchronization
         * - Performance monitoring and logging
         */

        class OctaneGrpcSync {
            constructor() {
                // Initialize logging and UI utilities
                this.logger = new ActivityLogger('activityLog');
                this.performanceTracker = new PerformanceTracker();
                this.connectionState = new ConnectionStateManager('statusText', this.logger);
                
                // WebGL and rendering state
                this.canvas = document.getElementById('canvas');
                this.gl = null;
                this.shaderProgram = null;
                this.skyboxProgram = null;
                this.camera = new CameraController();
                
                // Geometry and rendering objects
                this.cubeVAO = null;
                this.skyboxVAO = null;
                this.cubeVertexBuffer = null;
                this.cubeIndexBuffer = null;
                this.skyboxVertexBuffer = null;
                
                // Mouse interaction state
                this.mouse = {
                    dragging: false,
                    panning: false,
                    lastX: 0,
                    lastY: 0
                };
                
                // Animation and performance tracking
                this.startTime = Date.now();
                this.frameCount = 0;
                this.lastTime = 0;
                this.fps = 0;
                this.frameTime = 0;
                
                // LiveLink connection state
                this.liveLink = null;
                this.connected = false;
                this.octaneReady = false;
                this.cameraSync = false;
                this.syncInterval = null;
                this.teapotLoaded = false;
                
                // Initialize the application
                this.init();
            }

            /**
             * Initialize the WebGL viewer and set up event handlers
             */
            async init() {
                try {
                    this.logger.log('Initializing WebGL-Octane LiveLink Sync viewer...', 'info');
                    
                    // Initialize WebGL
                    await this.initWebGL();
                    
                    // Set up event handlers
                    this.setupEventHandlers();
                    
                    // Start render loop
                    this.render();
                    
                    // Initialize performance monitoring
                    this.startPerformanceMonitoring();
                    
                    this.logger.log('Viewer initialized successfully. Ready to connect to Octane.', 'success');
                    
                } catch (error) {
                    this.logger.log(`Failed to initialize viewer: ${error.message}`, 'error');
                    console.error('Initialization error:', error);
                }
            }

            /**
             * Initialize WebGL context and create shaders/geometry
             */
            async initWebGL() {
                // Get WebGL context
                this.gl = this.canvas.getContext('webgl2');
                if (!this.gl) {
                    throw new Error('WebGL 2.0 not supported');
                }

                // Configure WebGL state
                this.gl.enable(this.gl.DEPTH_TEST);
                this.gl.enable(this.gl.CULL_FACE);
                this.gl.cullFace(this.gl.BACK);
                this.gl.clearColor(0.1, 0.1, 0.2, 1.0);

                // Create shaders
                await this.createShaders();
                
                // Create geometry
                this.createGeometry();
                
                // Set up viewport
                this.resizeCanvas();
            }

            /**
             * Create and compile shaders
             */
            async createShaders() {
                const gl = this.gl;
                
                try {
                    // Create main object shaders
                    const vertexShader = ShaderUtils.createShader(gl, gl.VERTEX_SHADER, ShaderUtils.getStandardVertexShader());
                    const fragmentShader = ShaderUtils.createShader(gl, gl.FRAGMENT_SHADER, ShaderUtils.getStandardFragmentShader());
                    this.shaderProgram = ShaderUtils.createProgram(gl, vertexShader, fragmentShader);
                    
                    // Create skybox shaders
                    const skyboxVertexShader = ShaderUtils.createShader(gl, gl.VERTEX_SHADER, ShaderUtils.getSkyboxVertexShader());
                    const skyboxFragmentShader = ShaderUtils.createShader(gl, gl.FRAGMENT_SHADER, ShaderUtils.getSkyboxFragmentShader());
                    this.skyboxProgram = ShaderUtils.createProgram(gl, skyboxVertexShader, skyboxFragmentShader);
                    
                    // Clean up individual shaders
                    gl.deleteShader(vertexShader);
                    gl.deleteShader(fragmentShader);
                    gl.deleteShader(skyboxVertexShader);
                    gl.deleteShader(skyboxFragmentShader);
                    
                } catch (error) {
                    throw new Error(`Shader creation failed: ${error.message}`);
                }
            }

            /**
             * Create geometry buffers and VAOs
             */
            createGeometry() {
                const gl = this.gl;
                
                // Create cube geometry
                const cubeGeometry = GeometryUtils.createCubeGeometry();
                
                this.cubeVAO = gl.createVertexArray();
                gl.bindVertexArray(this.cubeVAO);
                
                // Vertex buffer (position, normal, color)
                this.cubeVertexBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, this.cubeVertexBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, cubeGeometry.vertices, gl.STATIC_DRAW);
                
                // Position attribute (location 0)
                gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 9 * 4, 0);
                gl.enableVertexAttribArray(0);
                
                // Normal attribute (location 1)
                gl.vertexAttribPointer(1, 3, gl.FLOAT, false, 9 * 4, 3 * 4);
                gl.enableVertexAttribArray(1);
                
                // Color attribute (location 2)
                gl.vertexAttribPointer(2, 3, gl.FLOAT, false, 9 * 4, 6 * 4);
                gl.enableVertexAttribArray(2);
                
                // Index buffer
                this.cubeIndexBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.cubeIndexBuffer);
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, cubeGeometry.indices, gl.STATIC_DRAW);
                
                // Create skybox geometry
                const skyboxGeometry = GeometryUtils.createSkyboxGeometry();
                
                this.skyboxVAO = gl.createVertexArray();
                gl.bindVertexArray(this.skyboxVAO);
                
                this.skyboxVertexBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, this.skyboxVertexBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, skyboxGeometry.vertices, gl.STATIC_DRAW);
                
                // Position attribute for skybox
                gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(0);
                
                // Unbind VAO
                gl.bindVertexArray(null);
            }

            /**
             * Set up event handlers for user interaction
             */
            setupEventHandlers() {
                // Canvas mouse events
                this.canvas.addEventListener('mousedown', (e) => this.handleMouseDown(e));
                this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
                this.canvas.addEventListener('mouseup', (e) => this.handleMouseUp(e));
                this.canvas.addEventListener('wheel', (e) => this.handleWheel(e));
                this.canvas.addEventListener('contextmenu', (e) => e.preventDefault());
                
                // Window resize
                window.addEventListener('resize', () => this.resizeCanvas());
                
                // Button event handlers
                document.getElementById('connectBtn').addEventListener('click', () => this.connect());
                document.getElementById('disconnectBtn').addEventListener('click', () => this.disconnect());
                document.getElementById('getCameraBtn').addEventListener('click', () => this.getCameraFromOctane());
                document.getElementById('setCameraBtn').addEventListener('click', () => this.setCameraToOctane());
                document.getElementById('getMeshesBtn').addEventListener('click', () => this.getMeshList());
                document.getElementById('loadTeapotBtn').addEventListener('click', () => this.loadTeapot());
                document.getElementById('syncCameraBtn').addEventListener('click', () => this.toggleCameraSync());
                document.getElementById('autoRotateBtn').addEventListener('click', () => this.toggleAutoRotate());
                document.getElementById('resetCameraBtn').addEventListener('click', () => this.resetCamera());
                document.getElementById('clearLogBtn').addEventListener('click', () => this.clearLog());
                
                // Connection state change handlers
                this.connectionState.onStateChange('connected', () => {
                    UIUtils.setButtonEnabled('connectBtn', false);
                    UIUtils.setButtonEnabled('disconnectBtn', true);
                    UIUtils.setButtonEnabled('getCameraBtn', true);
                    UIUtils.setButtonEnabled('setCameraBtn', true);
                    UIUtils.setButtonEnabled('getMeshesBtn', true);
                    UIUtils.setButtonEnabled('loadTeapotBtn', true);
                    UIUtils.setButtonEnabled('syncCameraBtn', true);
                    
                    document.getElementById('connectionStatus').className = 'status-section status-connected';
                });
                
                this.connectionState.onStateChange('disconnected', () => {
                    UIUtils.setButtonEnabled('connectBtn', true);
                    UIUtils.setButtonEnabled('disconnectBtn', false);
                    UIUtils.setButtonEnabled('getCameraBtn', false);
                    UIUtils.setButtonEnabled('setCameraBtn', false);
                    UIUtils.setButtonEnabled('getMeshesBtn', false);
                    UIUtils.setButtonEnabled('loadTeapotBtn', false);
                    UIUtils.setButtonEnabled('syncCameraBtn', false);
                    
                    document.getElementById('connectionStatus').className = 'status-section status-disconnected';
                    
                    // Stop camera sync if active
                    if (this.cameraSync) {
                        this.toggleCameraSync();
                    }
                });
                
                this.connectionState.onStateChange('connecting', () => {
                    document.getElementById('connectionStatus').className = 'status-section status-connecting';
                });
            }

            /**
             * Connect to Octane via gRPC proxy
             */
            async connect() {
                try {
                    this.connectionState.setState('connecting', 'Connecting to Octane...');
                    this.performanceTracker.recordConnectionAttempt();
                    
                    // Get server address
                    const serverAddress = document.getElementById('serverAddress').value.trim();
                    if (!serverAddress) {
                        throw new Error('Server address is required');
                    }
                    
                    // Initialize LiveLink client
                    if (typeof liveLinkManager === 'undefined') {
                        throw new Error('LiveLink manager not available');
                    }
                    
                    this.liveLink = liveLinkManager.getClient(serverAddress);
                    
                    // Set up event handlers with proper cleanup
                    if (this.liveLink.removeAllListeners) {
                        this.liveLink.removeAllListeners();
                    }
                    
                    // Connection state events
                    this.liveLink.on('connected', () => {
                        this.connected = true;
                        this.connectionState.setState('connected', 'Connected to Octane successfully');
                    });
                    
                    this.liveLink.on('disconnected', () => {
                        this.connected = false;
                        this.connectionState.setState('disconnected', 'Disconnected from Octane');
                    });
                    
                    this.liveLink.on('error', (error) => {
                        this.performanceTracker.recordError();
                        ErrorHandler.handleGrpcError(error, this.logger, 'Connection error');
                        this.connectionState.setState('disconnected');
                    });
                    
                    // Attempt connection
                    await this.liveLink.connect();
                    
                } catch (error) {
                    this.performanceTracker.recordError();
                    ErrorHandler.handleGrpcError(error, this.logger, 'Failed to connect');
                    this.connectionState.setState('disconnected');
                }
            }

            /**
             * Disconnect from Octane
             */
            async disconnect() {
                try {
                    if (this.liveLink && this.connected) {
                        await this.liveLink.disconnect();
                    }
                    this.liveLink = null;
                    this.connected = false;
                    this.connectionState.setState('disconnected', 'Disconnected from Octane');
                } catch (error) {
                    ErrorHandler.handleGrpcError(error, this.logger, 'Disconnect error');
                }
            }

            /**
             * Get camera state from Octane
             */
            async getCameraFromOctane() {
                if (!this.connected || !this.liveLink) {
                    this.logger.log('Not connected to Octane', 'warning');
                    return;
                }

                try {
                    const startTime = Date.now();
                    const cameraState = await this.liveLink.getCamera();
                    const responseTime = Date.now() - startTime;
                    
                    this.performanceTracker.recordCall(responseTime);
                    
                    if (cameraState && cameraState.position) {
                        this.logger.log(`Camera position: (${cameraState.position.x.toFixed(2)}, ${cameraState.position.y.toFixed(2)}, ${cameraState.position.z.toFixed(2)})`, 'success');
                        this.logger.log(`Camera target: (${cameraState.target.x.toFixed(2)}, ${cameraState.target.y.toFixed(2)}, ${cameraState.target.z.toFixed(2)})`, 'info');
                        this.logger.log(`Camera FOV: ${cameraState.fov.toFixed(2)}Â°`, 'info');
                        
                        // Update our camera to match Octane's camera
                        this.camera.setFromOctaneCamera(
                            [cameraState.position.x, cameraState.position.y, cameraState.position.z],
                            [cameraState.target.x, cameraState.target.y, cameraState.target.z],
                            [cameraState.up.x, cameraState.up.y, cameraState.up.z],
                            cameraState.fov
                        );
                    }
                } catch (error) {
                    this.performanceTracker.recordError();
                    ErrorHandler.handleGrpcError(error, this.logger, 'Failed to get camera');
                }
            }

            /**
             * Set camera state in Octane
             */
            async setCameraToOctane() {
                if (!this.connected || !this.liveLink) {
                    this.logger.log('Not connected to Octane', 'warning');
                    return;
                }

                try {
                    const startTime = Date.now();
                    const cameraPos = this.camera.getPosition();
                    
                    const cameraState = {
                        position: { x: cameraPos[0], y: cameraPos[1], z: cameraPos[2] },
                        target: { x: this.camera.center[0], y: this.camera.center[1], z: this.camera.center[2] },
                        up: { x: 0, y: 1, z: 0 },
                        fov: 45.0
                    };
                    
                    await this.liveLink.setCamera(cameraState);
                    const responseTime = Date.now() - startTime;
                    
                    this.performanceTracker.recordCall(responseTime);
                    this.logger.log('Camera sent to Octane successfully', 'success');
                    
                } catch (error) {
                    this.performanceTracker.recordError();
                    ErrorHandler.handleGrpcError(error, this.logger, 'Failed to set camera');
                }
            }

            /**
             * Get mesh list from Octane
             */
            async getMeshList() {
                if (!this.connected || !this.liveLink) {
                    this.logger.log('Not connected to Octane', 'warning');
                    return;
                }

                try {
                    const startTime = Date.now();
                    const meshList = await this.liveLink.getMeshes();
                    const responseTime = Date.now() - startTime;
                    
                    this.performanceTracker.recordCall(responseTime);
                    this.logger.log(`Received ${meshList.meshes ? meshList.meshes.length : 0} meshes from Octane`, 'success');
                    
                    if (meshList.meshes && meshList.meshes.length > 0) {
                        meshList.meshes.forEach((mesh, index) => {
                            this.logger.log(`Mesh ${index + 1}: ${mesh.name} (ID: ${mesh.id})`, 'info');
                        });
                    }
                } catch (error) {
                    this.performanceTracker.recordError();
                    ErrorHandler.handleGrpcError(error, this.logger, 'Failed to get meshes');
                }
            }

            /**
             * Load teapot mesh from Octane
             */
            async loadTeapot() {
                if (!this.connected || !this.liveLink) {
                    this.logger.log('Not connected to Octane', 'warning');
                    return;
                }

                try {
                    const startTime = Date.now();
                    const meshData = await this.liveLink.getMesh({ id: 'teapot' });
                    const responseTime = Date.now() - startTime;
                    
                    this.performanceTracker.recordCall(responseTime);
                    
                    if (meshData && meshData.positions) {
                        this.logger.log(`Loaded teapot: ${meshData.positions.length} vertices, ${meshData.vertsPerPoly ? meshData.vertsPerPoly.length : 0} polygons`, 'success');
                        this.teapotLoaded = true;
                        // TODO: Replace cube with teapot geometry
                    } else {
                        this.logger.log('No teapot data received', 'warning');
                    }
                } catch (error) {
                    this.performanceTracker.recordError();
                    ErrorHandler.handleGrpcError(error, this.logger, 'Failed to load teapot');
                }
            }

            /**
             * Toggle camera synchronization with Octane
             */
            toggleCameraSync() {
                if (!this.connected) {
                    this.logger.log('Not connected to Octane', 'warning');
                    return;
                }

                this.cameraSync = !this.cameraSync;
                const syncBtn = document.getElementById('syncCameraBtn');
                
                if (this.cameraSync) {
                    syncBtn.textContent = 'Stop Sync';
                    this.logger.log('Camera sync started', 'success');
                    
                    // Start sync interval (30 FPS)
                    this.syncInterval = setInterval(() => {
                        if (this.connected && this.cameraSync) {
                            this.setCameraToOctane();
                        }
                    }, 1000 / 30);
                } else {
                    syncBtn.textContent = 'Start Sync';
                    this.logger.log('Camera sync stopped', 'info');
                    
                    if (this.syncInterval) {
                        clearInterval(this.syncInterval);
                        this.syncInterval = null;
                    }
                }
            }

            /**
             * Toggle auto-rotation
             */
            toggleAutoRotate() {
                this.camera.autoRotate = !this.camera.autoRotate;
                const btn = document.getElementById('autoRotateBtn');
                btn.textContent = this.camera.autoRotate ? 'Stop Auto-Rotate' : 'Start Auto-Rotate';
                this.logger.log(`Auto-rotation ${this.camera.autoRotate ? 'enabled' : 'disabled'}`, 'info');
            }

            /**
             * Reset camera to default position
             */
            resetCamera() {
                this.camera.radius = 5.0;
                this.camera.theta = 0.0;
                this.camera.phi = 0.0;
                this.camera.center = [0.0, 0.0, 0.0];
                this.camera.autoRotate = true;
                
                document.getElementById('autoRotateBtn').textContent = 'Stop Auto-Rotate';
                this.logger.log('Camera reset to default position', 'info');
            }

            /**
             * Clear activity log
             */
            clearLog() {
                this.logger.clear();
                this.logger.log('Activity log cleared', 'info');
            }

            /**
             * Handle mouse down events
             */
            handleMouseDown(event) {
                this.mouse.dragging = event.button === 0; // Left button
                this.mouse.panning = event.button === 2;  // Right button
                this.mouse.lastX = event.clientX;
                this.mouse.lastY = event.clientY;
                
                if (this.mouse.dragging || this.mouse.panning) {
                    this.canvas.style.cursor = this.mouse.panning ? 'move' : 'grabbing';
                }
            }

            /**
             * Handle mouse move events
             */
            handleMouseMove(event) {
                if (this.mouse.dragging || this.mouse.panning) {
                    const deltaX = event.clientX - this.mouse.lastX;
                    const deltaY = event.clientY - this.mouse.lastY;
                    
                    this.camera.handleMouseMove(deltaX, deltaY, this.mouse.dragging, this.mouse.panning);
                    
                    this.mouse.lastX = event.clientX;
                    this.mouse.lastY = event.clientY;
                }
            }

            /**
             * Handle mouse up events
             */
            handleMouseUp(event) {
                this.mouse.dragging = false;
                this.mouse.panning = false;
                this.canvas.style.cursor = 'default';
            }

            /**
             * Handle mouse wheel events
             */
            handleWheel(event) {
                event.preventDefault();
                this.camera.handleWheel(event.deltaY);
            }

            /**
             * Resize canvas to match container
             */
            resizeCanvas() {
                const rect = this.canvas.parentElement.getBoundingClientRect();
                const width = rect.width - 20; // Account for padding
                const height = rect.height - 60; // Account for controls
                
                this.canvas.width = width;
                this.canvas.height = height;
                
                if (this.gl) {
                    this.gl.viewport(0, 0, width, height);
                }
            }

            /**
             * Start performance monitoring
             */
            startPerformanceMonitoring() {
                setInterval(() => {
                    const stats = this.performanceTracker.getStats();
                    
                    UIUtils.updateElement('fpsValue', Math.round(this.fps));
                    UIUtils.updateElement('frameTimeValue', `${this.frameTime}ms`);
                    UIUtils.updateElement('grpcCallsValue', stats.calls);
                    UIUtils.updateElement('avgResponseValue', `${stats.averageResponseTime}ms`);
                    UIUtils.updateElement('errorCountValue', stats.errorCount);
                    
                    // Calculate sync rate if syncing
                    const syncRate = this.cameraSync ? '30' : '0';
                    UIUtils.updateElement('syncRateValue', `${syncRate}/s`);
                    
                }, 1000);
            }

            /**
             * Main render loop
             */
            render() {
                const currentTime = Date.now();
                const deltaTime = (currentTime - this.lastTime) / 1000.0;
                this.lastTime = currentTime;
                
                // Update camera
                this.camera.update(deltaTime);
                
                // Calculate performance metrics
                this.frameCount++;
                if (this.frameCount % 60 === 0) {
                    const elapsed = currentTime - this.startTime;
                    this.fps = (this.frameCount * 1000) / elapsed;
                    this.frameTime = Math.round(deltaTime * 1000);
                }
                
                // Render scene
                this.renderScene(currentTime / 1000.0);
                
                // Continue render loop
                requestAnimationFrame(() => this.render());
            }

            /**
             * Render the 3D scene
             */
            renderScene(time) {
                const gl = this.gl;
                
                // Clear buffers
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
                
                // Create matrices
                const aspect = this.canvas.width / this.canvas.height;
                const projectionMatrix = MatrixUtils.createPerspectiveMatrix(Math.PI / 4, aspect, 0.1, 100.0);
                const viewMatrix = this.camera.getViewMatrix();
                const modelMatrix = MatrixUtils.createRotationMatrix(time * 0.5, time * 0.3, 0);
                const normalMatrix = MatrixUtils.transpose(modelMatrix);
                
                // Render skybox first
                gl.depthMask(false);
                gl.useProgram(this.skyboxProgram);
                gl.bindVertexArray(this.skyboxVAO);
                
                gl.uniformMatrix4fv(gl.getUniformLocation(this.skyboxProgram, 'uView'), false, viewMatrix);
                gl.uniformMatrix4fv(gl.getUniformLocation(this.skyboxProgram, 'uProjection'), false, projectionMatrix);
                gl.uniform1f(gl.getUniformLocation(this.skyboxProgram, 'uTime'), time);
                
                gl.drawArrays(gl.TRIANGLES, 0, 36);
                
                // Render main object
                gl.depthMask(true);
                gl.useProgram(this.shaderProgram);
                gl.bindVertexArray(this.cubeVAO);
                
                // Set uniforms
                gl.uniformMatrix4fv(gl.getUniformLocation(this.shaderProgram, 'uModel'), false, modelMatrix);
                gl.uniformMatrix4fv(gl.getUniformLocation(this.shaderProgram, 'uView'), false, viewMatrix);
                gl.uniformMatrix4fv(gl.getUniformLocation(this.shaderProgram, 'uProjection'), false, projectionMatrix);
                gl.uniformMatrix3fv(gl.getUniformLocation(this.shaderProgram, 'uNormalMatrix'), false, normalMatrix);
                
                // Lighting uniforms
                const cameraPos = this.camera.getPosition();
                gl.uniform3fv(gl.getUniformLocation(this.shaderProgram, 'uLightPos'), [5.0, 5.0, 5.0]);
                gl.uniform3fv(gl.getUniformLocation(this.shaderProgram, 'uLightColor'), [1.0, 1.0, 1.0]);
                gl.uniform3fv(gl.getUniformLocation(this.shaderProgram, 'uViewPos'), cameraPos);
                gl.uniform1f(gl.getUniformLocation(this.shaderProgram, 'uTime'), time);
                
                // Draw cube
                gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);
                
                // Unbind
                gl.bindVertexArray(null);
            }
        }

        // Global viewer instance
        let viewer;

        // Initialize viewer when page loads
        window.addEventListener('load', async () => {
            console.log('Page loaded, initializing WebGL-Octane LiveLink Sync viewer...');
            
            try {
                viewer = new OctaneGrpcSync();
                console.log('Viewer initialized successfully');
                
                // Add global debug functions for testing
                window.debugViewer = viewer;
                window.testConnect = () => viewer.connect();
                
            } catch (error) {
                console.error('Failed to initialize viewer:', error);
                alert(`Failed to initialize viewer: ${error.message}`);
            }
        });

        // Handle page unload
        window.addEventListener('beforeunload', () => {
            if (viewer && viewer.connected) {
                viewer.disconnect();
            }
        });

    </script>
</body>
</html>