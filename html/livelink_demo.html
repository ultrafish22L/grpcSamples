<!DOCTYPE html>
<!-- 
    Octane LiveLink gRPC-Web Demo
    Main demonstration page for connecting to Octane Render via gRPC-Web
    Shows connection status, server info, and basic LiveLink functionality
-->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Octane LiveLink gRPC-Web Demo</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .header {
            text-align: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid #eee;
        }
        .status-panel {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
            border-left: 4px solid #007bff;
        }
        .controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        .control-group {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
        }
        .control-group h3 {
            margin-top: 0;
            color: #333;
        }
        .input-group {
            margin-bottom: 10px;
        }
        .input-group label {
            display: inline-block;
            width: 80px;
            font-weight: bold;
        }
        .input-group input {
            width: 100px;
            padding: 5px;
            border: 1px solid #ddd;
            border-radius: 3px;
        }
        button {
            background: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
        }
        button:hover {
            background: #0056b3;
        }
        button:disabled {
            background: #6c757d;
            cursor: not-allowed;
        }
        .log {
            background: #000;
            color: #0f0;
            padding: 15px;
            border-radius: 5px;
            height: 200px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            margin-top: 20px;
        }
        .mesh-list {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
            margin-top: 20px;
        }
        .mesh-item {
            background: white;
            padding: 10px;
            margin: 5px 0;
            border-radius: 3px;
            border: 1px solid #ddd;
            cursor: pointer;
        }
        .mesh-item:hover {
            background: #e9ecef;
        }
        .connected { color: #28a745; }
        .disconnected { color: #dc3545; }
        .mock-mode { color: #ffc107; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üé¨ Octane LiveLink gRPC-Web Demo</h1>
            <p>Real-time communication with Octane Render via gRPC-Web</p>
        </div>

        <div class="status-panel">
            <h3>Connection Status</h3>
            <div id="status">
                <span id="connection-status" class="disconnected">Disconnected</span> |
                <span id="mode-status">Unknown</span> |
                Server: <span id="server-url">http://127.0.0.1:51022</span>
            </div>
            <div style="margin-top: 10px;">
                <strong>Stats:</strong>
                Calls: <span id="call-count">0</span> |
                Avg Response: <span id="avg-response">0ms</span> |
                Last Call: <span id="last-call">0ms</span>
            </div>
        </div>

        <div class="controls">
            <div class="control-group">
                <h3>üîå Connection</h3>
                <div>
                    <input type="text" id="server-input" value="http://127.0.0.1:51022" placeholder="Server URL">
                    <button id="connect-btn" onclick="connectToServer()">Connect</button>
                    <button id="disconnect-btn" onclick="disconnectFromServer()" disabled>Disconnect</button>
                </div>
                <div style="margin-top: 10px;">
                    <button onclick="testConnection()">Test Connection</button>
                    <button onclick="clearLog()">Clear Log</button>
                </div>
            </div>

            <div class="control-group">
                <h3>üì∑ Camera Control</h3>
                <div class="input-group">
                    <label>Pos X:</label>
                    <input type="number" id="pos-x" value="0" step="0.1">
                    <label>Y:</label>
                    <input type="number" id="pos-y" value="0" step="0.1">
                    <label>Z:</label>
                    <input type="number" id="pos-z" value="5" step="0.1">
                </div>
                <div class="input-group">
                    <label>Target X:</label>
                    <input type="number" id="target-x" value="0" step="0.1">
                    <label>Y:</label>
                    <input type="number" id="target-y" value="0" step="0.1">
                    <label>Z:</label>
                    <input type="number" id="target-z" value="0" step="0.1">
                </div>
                <div class="input-group">
                    <label>FOV:</label>
                    <input type="number" id="fov" value="45" min="1" max="179">
                </div>
                <div>
                    <button onclick="setCamera()">Set Camera</button>
                    <button onclick="getCamera()">Get Camera</button>
                    <button id="sync-btn" onclick="toggleCameraSync()">Start Sync</button>
                </div>
            </div>
        </div>

        <div class="mesh-list">
            <h3>üé≠ Mesh Management</h3>
            <div>
                <button onclick="getMeshes()">Get Meshes</button>
                <button onclick="getMeshData()">Get Selected Mesh Data</button>
            </div>
            <div id="mesh-container" style="margin-top: 10px;">
                <p>Click "Get Meshes" to load available meshes</p>
            </div>
        </div>

        <div class="log" id="log">
            <div>LiveLink gRPC-Web Demo initialized</div>
            <div>Click Connect to start communicating with Octane</div>
        </div>
    </div>

    <!-- Using custom gRPC-Web implementation - no external dependencies needed -->
    <!-- <script src="https://unpkg.com/google-protobuf@3.21.2/google-protobuf.js"></script> -->
    
    <!-- Module loader disabled - using standalone implementation -->
    <!-- <script src="module-loader.js"></script> -->
    
    <!-- Generated gRPC-Web files disabled for now - using custom implementation -->
    <!-- <script src="generated/livelink_pb.js"></script> -->
    <!-- <script src="generated/livelink_grpc_web_pb.js"></script> -->
    
    <!-- Proto namespace setup disabled - using custom implementation -->

    
    <!-- Include our LiveLink client -->
    <script src="livelink.js"></script>

    <script>
        let client = null;
        let selectedMeshId = null;
        let cameraSyncActive = false;

        // Initialize the demo
        function init() {
            log('Demo initialized');
            log('Using custom gRPC-Web implementation');
            updateStatus();
        }

        // Connect to Octane server
        async function connectToServer() {
            const serverUrl = document.getElementById('server-input').value;
            log(`Connecting to ${serverUrl}...`);
            
            try {
                client = liveLinkManager.getClient(serverUrl);
                
                // Set up event listeners
                client.on('connected', () => {
                    log('‚úÖ Connected to Octane LiveLink');
                    updateStatus();
                    document.getElementById('connect-btn').disabled = true;
                    document.getElementById('disconnect-btn').disabled = false;
                });
                
                client.on('disconnected', () => {
                    log('‚ùå Disconnected from Octane LiveLink');
                    updateStatus();
                    document.getElementById('connect-btn').disabled = false;
                    document.getElementById('disconnect-btn').disabled = true;
                });
                
                client.on('connectionStateChanged', (state) => {
                    log(`Connection state: ${state}`);
                    updateStatus();
                });
                
                client.on('error', (error) => {
                    log(`‚ùå Connection error: ${error.message}`);
                    updateStatus();
                    document.getElementById('connect-btn').disabled = false;
                    document.getElementById('disconnect-btn').disabled = true;
                });
                
                client.on('debug', (message) => {
                    log(`üêõ DEBUG: ${message}`);
                });
                
                await client.connect();
                
            } catch (error) {
                log(`‚ùå Connection failed: ${error.message}`);
                updateStatus();
            }
        }

        // Disconnect from server
        async function disconnectFromServer() {
            if (client) {
                await client.disconnect();
                client = null;
            }
        }

        // Test connection
        async function testConnection() {
            if (!client || !client.isReady()) {
                log('‚ùå Not connected');
                return;
            }
            
            try {
                log('üîç Testing connection...');
                const camera = await client.getCamera();
                log('‚úÖ Connection test successful');
                log(`Camera: pos(${camera.position?.x}, ${camera.position?.y}, ${camera.position?.z})`);
            } catch (error) {
                log(`‚ùå Connection test failed: ${error.message}`);
            }
        }

        // Set camera position
        async function setCamera() {
            if (!client || !client.isReady()) {
                log('‚ùå Not connected');
                return;
            }
            
            const cameraState = {
                position: {
                    x: parseFloat(document.getElementById('pos-x').value),
                    y: parseFloat(document.getElementById('pos-y').value),
                    z: parseFloat(document.getElementById('pos-z').value)
                },
                target: {
                    x: parseFloat(document.getElementById('target-x').value),
                    y: parseFloat(document.getElementById('target-y').value),
                    z: parseFloat(document.getElementById('target-z').value)
                },
                up: { x: 0, y: 1, z: 0 },
                fov: parseFloat(document.getElementById('fov').value)
            };
            
            try {
                log('üì∑ Setting camera...');
                await client.setCamera(cameraState);
                log('‚úÖ Camera set successfully');
            } catch (error) {
                log(`‚ùå Set camera failed: ${error.message}`);
            }
        }

        // Get camera position
        async function getCamera() {
            if (!client || !client.isReady()) {
                log('‚ùå Not connected');
                return;
            }
            
            try {
                log('üì∑ Getting camera...');
                const camera = await client.getCamera();
                log('‚úÖ Camera retrieved');
                
                if (camera.position) {
                    document.getElementById('pos-x').value = camera.position.x || 0;
                    document.getElementById('pos-y').value = camera.position.y || 0;
                    document.getElementById('pos-z').value = camera.position.z || 0;
                }
                if (camera.target) {
                    document.getElementById('target-x').value = camera.target.x || 0;
                    document.getElementById('target-y').value = camera.target.y || 0;
                    document.getElementById('target-z').value = camera.target.z || 0;
                }
                if (camera.fov !== undefined) {
                    document.getElementById('fov').value = camera.fov;
                }
                
                log(`Position: (${camera.position?.x}, ${camera.position?.y}, ${camera.position?.z})`);
                log(`Target: (${camera.target?.x}, ${camera.target?.y}, ${camera.target?.z})`);
                log(`FOV: ${camera.fov}`);
                
            } catch (error) {
                log(`‚ùå Get camera failed: ${error.message}`);
            }
        }

        // Toggle camera synchronization
        function toggleCameraSync() {
            if (!client || !client.isReady()) {
                log('‚ùå Not connected');
                return;
            }
            
            const getCurrentCamera = () => ({
                position: {
                    x: parseFloat(document.getElementById('pos-x').value),
                    y: parseFloat(document.getElementById('pos-y').value),
                    z: parseFloat(document.getElementById('pos-z').value)
                },
                target: {
                    x: parseFloat(document.getElementById('target-x').value),
                    y: parseFloat(document.getElementById('target-y').value),
                    z: parseFloat(document.getElementById('target-z').value)
                },
                up: { x: 0, y: 1, z: 0 },
                fov: parseFloat(document.getElementById('fov').value)
            });
            
            cameraSyncActive = client.toggleCameraSync(getCurrentCamera);
            document.getElementById('sync-btn').textContent = cameraSyncActive ? 'Stop Sync' : 'Start Sync';
            log(cameraSyncActive ? 'üîÑ Camera sync started' : '‚èπÔ∏è Camera sync stopped');
        }

        // Get list of meshes
        async function getMeshes() {
            if (!client || !client.isReady()) {
                log('‚ùå Not connected');
                return;
            }
            
            try {
                log('üé≠ Getting meshes...');
                const result = await client.getMeshes();
                log('‚úÖ Meshes retrieved');
                
                const meshes = result.meshes || [];
                const container = document.getElementById('mesh-container');
                
                if (meshes.length === 0) {
                    container.innerHTML = '<p>No meshes found</p>';
                } else {
                    container.innerHTML = meshes.map(mesh => 
                        `<div class="mesh-item" onclick="selectMesh(${mesh.objectHandle || mesh.id}, '${mesh.name}')">
                            <strong>${mesh.name}</strong> (ID: ${mesh.id}, Handle: ${mesh.objectHandle || mesh.id})
                        </div>`
                    ).join('');
                }
                
                log(`Found ${meshes.length} meshes`);
                
            } catch (error) {
                log(`‚ùå Get meshes failed: ${error.message}`);
            }
        }

        // Select a mesh
        function selectMesh(meshId, meshName) {
            selectedMeshId = meshId;
            log(`Selected mesh: ${meshName} (ID: ${meshId})`);
            
            // Highlight selected mesh
            document.querySelectorAll('.mesh-item').forEach(item => {
                item.style.backgroundColor = '';
            });
            event.target.style.backgroundColor = '#e3f2fd';
        }

        // Get mesh data
        async function getMeshData() {
            if (!client || !client.isReady()) {
                log('‚ùå Not connected');
                return;
            }
            
            if (!selectedMeshId) {
                log('‚ùå No mesh selected');
                return;
            }
            
            try {
                log(`üé≠ Getting mesh data for ID ${selectedMeshId}...`);
                const meshData = await client.getMesh(selectedMeshId);
                log('‚úÖ Mesh data retrieved');
                
                log(`Name: ${meshData.name}`);
                log(`Positions: ${meshData.positions?.length || 0} vertices`);
                log(`Normals: ${meshData.normals?.length || 0} normals`);
                log(`Polygons: ${meshData.vertsPerPoly?.length || 0} polygons`);
                log(`Winding order: ${meshData.windingOrder}`);
                
            } catch (error) {
                log(`‚ùå Get mesh data failed: ${error.message}`);
            }
        }

        // Update status display
        function updateStatus() {
            const stats = client ? client.getStats() : {
                connected: false,
                connectionState: 'disconnected',
                serverUrl: 'N/A',
                callCount: 0,
                avgResponseTime: 0,
                lastCallTime: 0
            };
            
            document.getElementById('connection-status').textContent = stats.connectionState;
            
            // Set status color based on connection state
            if (stats.connectionState === 'connected') {
                document.getElementById('connection-status').className = 'connected';
            } else if (stats.connectionState === 'error') {
                document.getElementById('connection-status').className = 'disconnected';
            } else {
                document.getElementById('connection-status').className = 'disconnected';
            }
            
            document.getElementById('mode-status').textContent = 'gRPC-Web';
            document.getElementById('mode-status').className = stats.connected ? 'connected' : 'disconnected';
            
            document.getElementById('server-url').textContent = stats.serverUrl;
            document.getElementById('call-count').textContent = stats.callCount;
            document.getElementById('avg-response').textContent = stats.avgResponseTime + 'ms';
            document.getElementById('last-call').textContent = stats.lastCallTime + 'ms';
        }

        // Log message to console
        function log(message) {
            const logDiv = document.getElementById('log');
            const timestamp = new Date().toLocaleTimeString();
            logDiv.innerHTML += `<div>[${timestamp}] ${message}</div>`;
            logDiv.scrollTop = logDiv.scrollHeight;
            console.log(`[LiveLink] ${message}`);
        }

        // Clear log
        function clearLog() {
            document.getElementById('log').innerHTML = '';
        }

        // Update status every second
        setInterval(updateStatus, 1000);

        // Initialize when page loads
        window.addEventListener('load', init);
    </script>
</body>
</html>