<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>‚ú® Shiny 3D Cube Viewer - Web3D Edition</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #0a0a0f;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            color: white;
        }
        
        #canvas {
            display: block;
            cursor: grab;
        }
        
        #canvas:active {
            cursor: grabbing;
        }
        
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            font-size: 14px;
            line-height: 1.4;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        #controls {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            font-size: 12px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        #performance {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 8px;
            font-size: 12px;
            font-family: 'Courier New', monospace;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .highlight {
            color: #4fc3f7;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <div id="info">
        <div class="highlight">üöÄ Modern WebGL 3D Cube Viewer</div>
        <div>Replicating simpleGL with Web3D technology</div>
        <div style="margin-top: 8px;">
            <div>‚Ä¢ Phong lighting with dynamic light source</div>
            <div>‚Ä¢ Procedural skybox with stars and clouds</div>
            <div>‚Ä¢ Rim lighting and specular highlights</div>
            <div>‚Ä¢ Time-based color variations</div>
        </div>
    </div>
    
    <div id="controls">
        <div class="highlight">Controls:</div>
        <div>üñ±Ô∏è <strong>Mouse Drag:</strong> Orbit camera around cube</div>
        <div>üéØ <strong>Mouse Wheel:</strong> Zoom in/out</div>
        <div>‚å®Ô∏è <strong>ESC:</strong> Reset camera position</div>
        <div>üîÑ <strong>Space:</strong> Toggle auto-rotation</div>
    </div>
    
    <div id="performance">
        <div>FPS: <span id="fps">--</span></div>
        <div>Frame Time: <span id="frameTime">--</span>ms</div>
        <div>Triangles: <span id="triangles">36</span></div>
    </div>

    <script>
        // WebGL 3D Cube Viewer - Modern Edition
        // Replicates the functionality of simpleGL using WebGL
        
        class WebGL3DCubeViewer {
            constructor() {
                this.canvas = document.getElementById('canvas');
                this.gl = null;
                this.shaderProgram = null;
                this.skyboxProgram = null;
                
                // Camera parameters (matching simpleGL)
                this.camera = {
                    radius: 5.0,
                    theta: 0.0,  // horizontal angle
                    phi: 0.0,    // vertical angle
                    center: [0.0, 0.0, 0.0]
                };
                
                // Mouse state
                this.mouse = {
                    dragging: false,
                    lastX: 0,
                    lastY: 0
                };
                
                // Animation state
                this.autoRotate = true;
                this.startTime = Date.now();
                
                // Performance tracking
                this.frameCount = 0;
                this.lastTime = 0;
                this.fps = 0;
                this.frameTime = 0;
                
                // WebGL objects
                this.cubeVAO = null;
                this.skyboxVAO = null;
                this.cubeBuffer = null;
                this.skyboxBuffer = null;
                this.indexBuffer = null;
                
                this.init();
            }
            
            init() {
                this.setupCanvas();
                this.initWebGL();
                this.createShaders();
                this.createGeometry();
                this.setupEventListeners();
                this.render();
            }
            
            setupCanvas() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                
                window.addEventListener('resize', () => {
                    this.canvas.width = window.innerWidth;
                    this.canvas.height = window.innerHeight;
                    this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);
                });
            }
            
            initWebGL() {
                this.gl = this.canvas.getContext('webgl2', {
                    antialias: true,
                    alpha: false,
                    depth: true,
                    stencil: true
                });
                
                if (!this.gl) {
                    alert('WebGL 2.0 not supported in your browser!');
                    return;
                }
                
                // Enable features
                this.gl.enable(this.gl.DEPTH_TEST);
                this.gl.enable(this.gl.BLEND);
                this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);
                
                // Set viewport
                this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);
            }
            
            createShaders() {
                // Vertex shader for cube (matching the C++ version)
                const cubeVertexShader = `#version 300 es
                    precision highp float;
                    
                    layout (location = 0) in vec3 aPos;
                    layout (location = 1) in vec3 aNormal;
                    layout (location = 2) in vec3 aColor;
                    
                    uniform mat4 uModel;
                    uniform mat4 uView;
                    uniform mat4 uProjection;
                    uniform mat3 uNormalMatrix;
                    
                    out vec3 vFragPos;
                    out vec3 vNormal;
                    out vec3 vVertexColor;
                    
                    void main() {
                        vFragPos = vec3(uModel * vec4(aPos, 1.0));
                        vNormal = uNormalMatrix * aNormal;
                        vVertexColor = aColor;
                        
                        gl_Position = uProjection * uView * vec4(vFragPos, 1.0);
                    }
                `;
                
                // Fragment shader for cube (matching the C++ version)
                const cubeFragmentShader = `#version 300 es
                    precision highp float;
                    
                    in vec3 vFragPos;
                    in vec3 vNormal;
                    in vec3 vVertexColor;
                    
                    out vec4 fragColor;
                    
                    uniform vec3 uLightPos;
                    uniform vec3 uLightColor;
                    uniform vec3 uViewPos;
                    uniform float uTime;
                    
                    void main() {
                        // Ambient lighting
                        float ambientStrength = 0.15;
                        vec3 ambient = ambientStrength * uLightColor;
                        
                        // Diffuse lighting
                        vec3 norm = normalize(vNormal);
                        vec3 lightDir = normalize(uLightPos - vFragPos);
                        float diff = max(dot(norm, lightDir), 0.0);
                        vec3 diffuse = diff * uLightColor;
                        
                        // Specular lighting (shiny effect)
                        float specularStrength = 0.8;
                        vec3 viewDir = normalize(uViewPos - vFragPos);
                        vec3 reflectDir = reflect(-lightDir, norm);
                        float spec = pow(max(dot(viewDir, reflectDir), 0.0), 64.0);
                        vec3 specular = specularStrength * spec * uLightColor;
                        
                        // Add subtle color variation based on time
                        vec3 baseColor = vVertexColor;
                        baseColor += 0.1 * sin(uTime + vFragPos.x * 2.0) * vec3(0.2, 0.3, 0.4);
                        
                        // Rim lighting for extra shine
                        float rimPower = 2.0;
                        float rim = 1.0 - max(dot(viewDir, norm), 0.0);
                        rim = pow(rim, rimPower);
                        vec3 rimColor = vec3(0.3, 0.6, 1.0) * rim * 0.5;
                        
                        vec3 result = (ambient + diffuse + specular) * baseColor + rimColor;
                        fragColor = vec4(result, 1.0);
                    }
                `;
                
                // Skybox vertex shader
                const skyboxVertexShader = `#version 300 es
                    precision highp float;
                    
                    layout (location = 0) in vec3 aPos;
                    
                    out vec3 vTexCoords;
                    
                    uniform mat4 uProjection;
                    uniform mat4 uView;
                    
                    void main() {
                        vTexCoords = aPos;
                        vec4 pos = uProjection * uView * vec4(aPos, 1.0);
                        gl_Position = pos.xyww;
                    }
                `;
                
                // Skybox fragment shader (matching the C++ version)
                const skyboxFragmentShader = `#version 300 es
                    precision highp float;
                    
                    out vec4 fragColor;
                    
                    in vec3 vTexCoords;
                    uniform float uTime;
                    
                    vec3 getSkyColor(vec3 direction) {
                        float y = direction.y;
                        
                        // Create a beautiful gradient from horizon to zenith
                        vec3 horizonColor = vec3(1.0, 0.7, 0.4);  // Warm orange
                        vec3 zenithColor = vec3(0.2, 0.4, 0.8);   // Deep blue
                        vec3 nadirColor = vec3(0.1, 0.1, 0.2);    // Dark blue-purple
                        
                        // Add some dynamic color variation
                        float timeOffset = sin(uTime * 0.1) * 0.1;
                        horizonColor += vec3(timeOffset, timeOffset * 0.5, -timeOffset * 0.3);
                        
                        // Smooth transitions
                        float t1 = smoothstep(-0.2, 0.3, y);  // Horizon to zenith
                        float t2 = smoothstep(-1.0, -0.2, y); // Nadir to horizon
                        
                        vec3 color = mix(nadirColor, horizonColor, t2);
                        color = mix(color, zenithColor, t1);
                        
                        // Add some stars/sparkles
                        float stars = 0.0;
                        vec3 starPos = direction * 50.0;
                        stars += smoothstep(0.99, 1.0, sin(starPos.x * 127.1) * sin(starPos.y * 311.7) * sin(starPos.z * 74.7));
                        stars *= smoothstep(0.2, 1.0, y); // Only show stars in upper hemisphere
                        
                        color += vec3(stars * 0.8);
                        
                        // Add subtle cloud-like patterns
                        float clouds = sin(direction.x * 3.0 + uTime * 0.05) * sin(direction.z * 2.0 + uTime * 0.03);
                        clouds = smoothstep(0.3, 0.7, clouds) * 0.1;
                        clouds *= smoothstep(-0.1, 0.5, y); // Only in upper part
                        
                        color += vec3(clouds);
                        
                        return color;
                    }
                    
                    void main() {
                        vec3 color = getSkyColor(normalize(vTexCoords));
                        fragColor = vec4(color, 1.0);
                    }
                `;
                
                this.shaderProgram = this.createShaderProgram(cubeVertexShader, cubeFragmentShader);
                this.skyboxProgram = this.createShaderProgram(skyboxVertexShader, skyboxFragmentShader);
            }
            
            createShaderProgram(vertexSource, fragmentSource) {
                const vertexShader = this.compileShader(this.gl.VERTEX_SHADER, vertexSource);
                const fragmentShader = this.compileShader(this.gl.FRAGMENT_SHADER, fragmentSource);
                
                const program = this.gl.createProgram();
                this.gl.attachShader(program, vertexShader);
                this.gl.attachShader(program, fragmentShader);
                this.gl.linkProgram(program);
                
                if (!this.gl.getProgramParameter(program, this.gl.LINK_STATUS)) {
                    console.error('Shader program linking failed:', this.gl.getProgramInfoLog(program));
                    return null;
                }
                
                this.gl.deleteShader(vertexShader);
                this.gl.deleteShader(fragmentShader);
                
                return program;
            }
            
            compileShader(type, source) {
                const shader = this.gl.createShader(type);
                this.gl.shaderSource(shader, source);
                this.gl.compileShader(shader);
                
                if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
                    console.error('Shader compilation failed:', this.gl.getShaderInfoLog(shader));
                    this.gl.deleteShader(shader);
                    return null;
                }
                
                return shader;
            }
            
            createGeometry() {
                // Enhanced cube vertices with positions, normals, and beautiful colors (matching C++ version)
                const vertices = new Float32Array([
                    // Front face (warm coral) - Normal: (0, 0, 1)
                    -0.5, -0.5,  0.5,  0.0, 0.0, 1.0,  1.0, 0.5, 0.3,
                     0.5, -0.5,  0.5,  0.0, 0.0, 1.0,  1.0, 0.5, 0.3,
                     0.5,  0.5,  0.5,  0.0, 0.0, 1.0,  1.0, 0.5, 0.3,
                    -0.5,  0.5,  0.5,  0.0, 0.0, 1.0,  1.0, 0.5, 0.3,
                    
                    // Back face (emerald green) - Normal: (0, 0, -1)
                    -0.5, -0.5, -0.5,  0.0, 0.0, -1.0,  0.2, 0.8, 0.4,
                     0.5, -0.5, -0.5,  0.0, 0.0, -1.0,  0.2, 0.8, 0.4,
                     0.5,  0.5, -0.5,  0.0, 0.0, -1.0,  0.2, 0.8, 0.4,
                    -0.5,  0.5, -0.5,  0.0, 0.0, -1.0,  0.2, 0.8, 0.4,
                    
                    // Left face (royal blue) - Normal: (-1, 0, 0)
                    -0.5, -0.5, -0.5,  -1.0, 0.0, 0.0,  0.2, 0.4, 1.0,
                    -0.5, -0.5,  0.5,  -1.0, 0.0, 0.0,  0.2, 0.4, 1.0,
                    -0.5,  0.5,  0.5,  -1.0, 0.0, 0.0,  0.2, 0.4, 1.0,
                    -0.5,  0.5, -0.5,  -1.0, 0.0, 0.0,  0.2, 0.4, 1.0,
                    
                    // Right face (golden yellow) - Normal: (1, 0, 0)
                     0.5, -0.5, -0.5,  1.0, 0.0, 0.0,  1.0, 0.8, 0.2,
                     0.5, -0.5,  0.5,  1.0, 0.0, 0.0,  1.0, 0.8, 0.2,
                     0.5,  0.5,  0.5,  1.0, 0.0, 0.0,  1.0, 0.8, 0.2,
                     0.5,  0.5, -0.5,  1.0, 0.0, 0.0,  1.0, 0.8, 0.2,
                    
                    // Top face (violet purple) - Normal: (0, 1, 0)
                    -0.5,  0.5, -0.5,  0.0, 1.0, 0.0,  0.8, 0.3, 1.0,
                     0.5,  0.5, -0.5,  0.0, 1.0, 0.0,  0.8, 0.3, 1.0,
                     0.5,  0.5,  0.5,  0.0, 1.0, 0.0,  0.8, 0.3, 1.0,
                    -0.5,  0.5,  0.5,  0.0, 1.0, 0.0,  0.8, 0.3, 1.0,
                    
                    // Bottom face (turquoise cyan) - Normal: (0, -1, 0)
                    -0.5, -0.5, -0.5,  0.0, -1.0, 0.0,  0.2, 0.9, 0.8,
                     0.5, -0.5, -0.5,  0.0, -1.0, 0.0,  0.2, 0.9, 0.8,
                     0.5, -0.5,  0.5,  0.0, -1.0, 0.0,  0.2, 0.9, 0.8,
                    -0.5, -0.5,  0.5,  0.0, -1.0, 0.0,  0.2, 0.9, 0.8
                ]);
                
                const indices = new Uint16Array([
                    // Front face
                    0, 1, 2,   2, 3, 0,
                    // Back face
                    4, 5, 6,   6, 7, 4,
                    // Left face
                    8, 9, 10,  10, 11, 8,
                    // Right face
                    12, 13, 14, 14, 15, 12,
                    // Top face
                    16, 17, 18, 18, 19, 16,
                    // Bottom face
                    20, 21, 22, 22, 23, 20
                ]);
                
                // Skybox vertices
                const skyboxVertices = new Float32Array([
                    // positions          
                    -1.0,  1.0, -1.0,
                    -1.0, -1.0, -1.0,
                     1.0, -1.0, -1.0,
                     1.0, -1.0, -1.0,
                     1.0,  1.0, -1.0,
                    -1.0,  1.0, -1.0,

                    -1.0, -1.0,  1.0,
                    -1.0, -1.0, -1.0,
                    -1.0,  1.0, -1.0,
                    -1.0,  1.0, -1.0,
                    -1.0,  1.0,  1.0,
                    -1.0, -1.0,  1.0,

                     1.0, -1.0, -1.0,
                     1.0, -1.0,  1.0,
                     1.0,  1.0,  1.0,
                     1.0,  1.0,  1.0,
                     1.0,  1.0, -1.0,
                     1.0, -1.0, -1.0,

                    -1.0, -1.0,  1.0,
                    -1.0,  1.0,  1.0,
                     1.0,  1.0,  1.0,
                     1.0,  1.0,  1.0,
                     1.0, -1.0,  1.0,
                    -1.0, -1.0,  1.0,

                    -1.0,  1.0, -1.0,
                     1.0,  1.0, -1.0,
                     1.0,  1.0,  1.0,
                     1.0,  1.0,  1.0,
                    -1.0,  1.0,  1.0,
                    -1.0,  1.0, -1.0,

                    -1.0, -1.0, -1.0,
                    -1.0, -1.0,  1.0,
                     1.0, -1.0, -1.0,
                     1.0, -1.0, -1.0,
                    -1.0, -1.0,  1.0,
                     1.0, -1.0,  1.0
                ]);
                
                // Create cube VAO
                this.cubeVAO = this.gl.createVertexArray();
                this.gl.bindVertexArray(this.cubeVAO);
                
                this.cubeBuffer = this.gl.createBuffer();
                this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.cubeBuffer);
                this.gl.bufferData(this.gl.ARRAY_BUFFER, vertices, this.gl.STATIC_DRAW);
                
                this.indexBuffer = this.gl.createBuffer();
                this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
                this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, indices, this.gl.STATIC_DRAW);
                
                // Position attribute
                this.gl.vertexAttribPointer(0, 3, this.gl.FLOAT, false, 9 * 4, 0);
                this.gl.enableVertexAttribArray(0);
                
                // Normal attribute
                this.gl.vertexAttribPointer(1, 3, this.gl.FLOAT, false, 9 * 4, 3 * 4);
                this.gl.enableVertexAttribArray(1);
                
                // Color attribute
                this.gl.vertexAttribPointer(2, 3, this.gl.FLOAT, false, 9 * 4, 6 * 4);
                this.gl.enableVertexAttribArray(2);
                
                // Create skybox VAO
                this.skyboxVAO = this.gl.createVertexArray();
                this.gl.bindVertexArray(this.skyboxVAO);
                
                this.skyboxBuffer = this.gl.createBuffer();
                this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.skyboxBuffer);
                this.gl.bufferData(this.gl.ARRAY_BUFFER, skyboxVertices, this.gl.STATIC_DRAW);
                
                this.gl.vertexAttribPointer(0, 3, this.gl.FLOAT, false, 3 * 4, 0);
                this.gl.enableVertexAttribArray(0);
                
                this.gl.bindVertexArray(null);
            }
            
            setupEventListeners() {
                // Mouse controls
                this.canvas.addEventListener('mousedown', (e) => {
                    if (e.button === 0) {
                        this.mouse.dragging = true;
                        this.mouse.lastX = e.clientX;
                        this.mouse.lastY = e.clientY;
                    }
                });
                
                this.canvas.addEventListener('mouseup', (e) => {
                    if (e.button === 0) {
                        this.mouse.dragging = false;
                    }
                });
                
                this.canvas.addEventListener('mousemove', (e) => {
                    if (this.mouse.dragging) {
                        const deltaX = e.clientX - this.mouse.lastX;
                        const deltaY = e.clientY - this.mouse.lastY;
                        
                        const sensitivity = 0.01;
                        
                        this.camera.theta += deltaX * sensitivity;
                        this.camera.phi -= deltaY * sensitivity;
                        
                        // Clamp phi to prevent flipping
                        this.camera.phi = Math.max(-1.5, Math.min(1.5, this.camera.phi));
                        
                        this.mouse.lastX = e.clientX;
                        this.mouse.lastY = e.clientY;
                    }
                });
                
                // Zoom controls
                this.canvas.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    this.camera.radius -= e.deltaY * 0.01;
                    this.camera.radius = Math.max(1.0, Math.min(20.0, this.camera.radius));
                });
                
                // Keyboard controls
                document.addEventListener('keydown', (e) => {
                    switch(e.code) {
                        case 'Escape':
                            // Reset camera
                            this.camera.radius = 5.0;
                            this.camera.theta = 0.0;
                            this.camera.phi = 0.0;
                            break;
                        case 'Space':
                            e.preventDefault();
                            this.autoRotate = !this.autoRotate;
                            break;
                    }
                });
            }
            
            getCameraPosition() {
                const x = this.camera.radius * Math.cos(this.camera.phi) * Math.cos(this.camera.theta);
                const y = this.camera.radius * Math.sin(this.camera.phi);
                const z = this.camera.radius * Math.cos(this.camera.phi) * Math.sin(this.camera.theta);
                return [x, y, z];
            }
            
            createMatrix4() {
                return new Float32Array(16);
            }
            
            identity(out) {
                out[0] = 1; out[1] = 0; out[2] = 0; out[3] = 0;
                out[4] = 0; out[5] = 1; out[6] = 0; out[7] = 0;
                out[8] = 0; out[9] = 0; out[10] = 1; out[11] = 0;
                out[12] = 0; out[13] = 0; out[14] = 0; out[15] = 1;
                return out;
            }
            
            perspective(out, fovy, aspect, near, far) {
                const f = 1.0 / Math.tan(fovy / 2);
                const nf = 1 / (near - far);
                
                out[0] = f / aspect; out[1] = 0; out[2] = 0; out[3] = 0;
                out[4] = 0; out[5] = f; out[6] = 0; out[7] = 0;
                out[8] = 0; out[9] = 0; out[10] = (far + near) * nf; out[11] = -1;
                out[12] = 0; out[13] = 0; out[14] = 2 * far * near * nf; out[15] = 0;
                return out;
            }
            
            lookAt(out, eye, center, up) {
                const eyex = eye[0], eyey = eye[1], eyez = eye[2];
                const upx = up[0], upy = up[1], upz = up[2];
                const centerx = center[0], centery = center[1], centerz = center[2];
                
                let z0 = eyex - centerx, z1 = eyey - centery, z2 = eyez - centerz;
                let len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
                z0 *= len; z1 *= len; z2 *= len;
                
                let x0 = upy * z2 - upz * z1, x1 = upz * z0 - upx * z2, x2 = upx * z1 - upy * z0;
                len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
                if (!len) {
                    x0 = 0; x1 = 0; x2 = 0;
                } else {
                    len = 1 / len;
                    x0 *= len; x1 *= len; x2 *= len;
                }
                
                let y0 = z1 * x2 - z2 * x1, y1 = z2 * x0 - z0 * x2, y2 = z0 * x1 - z1 * x0;
                len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
                if (!len) {
                    y0 = 0; y1 = 0; y2 = 0;
                } else {
                    len = 1 / len;
                    y0 *= len; y1 *= len; y2 *= len;
                }
                
                out[0] = x0; out[1] = y0; out[2] = z0; out[3] = 0;
                out[4] = x1; out[5] = y1; out[6] = z1; out[7] = 0;
                out[8] = x2; out[9] = y2; out[10] = z2; out[11] = 0;
                out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
                out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
                out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
                out[15] = 1;
                return out;
            }
            
            rotateX(out, a, rad) {
                const s = Math.sin(rad), c = Math.cos(rad);
                const a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
                const a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
                
                if (a !== out) {
                    out[0] = a[0]; out[1] = a[1]; out[2] = a[2]; out[3] = a[3];
                    out[12] = a[12]; out[13] = a[13]; out[14] = a[14]; out[15] = a[15];
                }
                
                out[4] = a10 * c + a20 * s;
                out[5] = a11 * c + a21 * s;
                out[6] = a12 * c + a22 * s;
                out[7] = a13 * c + a23 * s;
                out[8] = a20 * c - a10 * s;
                out[9] = a21 * c - a11 * s;
                out[10] = a22 * c - a12 * s;
                out[11] = a23 * c - a13 * s;
                return out;
            }
            
            rotateY(out, a, rad) {
                const s = Math.sin(rad), c = Math.cos(rad);
                const a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
                const a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
                
                if (a !== out) {
                    out[4] = a[4]; out[5] = a[5]; out[6] = a[6]; out[7] = a[7];
                    out[12] = a[12]; out[13] = a[13]; out[14] = a[14]; out[15] = a[15];
                }
                
                out[0] = a00 * c - a20 * s;
                out[1] = a01 * c - a21 * s;
                out[2] = a02 * c - a22 * s;
                out[3] = a03 * c - a23 * s;
                out[8] = a00 * s + a20 * c;
                out[9] = a01 * s + a21 * c;
                out[10] = a02 * s + a22 * c;
                out[11] = a03 * s + a23 * c;
                return out;
            }
            
            normalFromMat4(out, a) {
                const a00 = a[0], a01 = a[1], a02 = a[2];
                const a10 = a[4], a11 = a[5], a12 = a[6];
                const a20 = a[8], a21 = a[9], a22 = a[10];
                
                const b01 = a22 * a11 - a12 * a21;
                const b11 = -a22 * a10 + a12 * a20;
                const b21 = a21 * a10 - a11 * a20;
                
                let det = a00 * b01 + a01 * b11 + a02 * b21;
                if (!det) return null;
                det = 1.0 / det;
                
                out[0] = b01 * det;
                out[1] = (-a22 * a01 + a02 * a21) * det;
                out[2] = (a12 * a01 - a02 * a11) * det;
                out[3] = b11 * det;
                out[4] = (a22 * a00 - a02 * a20) * det;
                out[5] = (-a12 * a00 + a02 * a10) * det;
                out[6] = b21 * det;
                out[7] = (-a21 * a00 + a01 * a20) * det;
                out[8] = (a11 * a00 - a01 * a10) * det;
                return out;
            }
            
            render() {
                const currentTime = Date.now();
                const deltaTime = currentTime - this.lastTime;
                this.lastTime = currentTime;
                
                // Update performance metrics
                this.frameCount++;
                if (this.frameCount % 60 === 0) {
                    this.fps = Math.round(1000 / deltaTime);
                    this.frameTime = deltaTime.toFixed(1);
                    document.getElementById('fps').textContent = this.fps;
                    document.getElementById('frameTime').textContent = this.frameTime;
                }
                
                const time = (currentTime - this.startTime) / 1000.0;
                
                // Clear screen with a subtle dark color
                this.gl.clearColor(0.05, 0.05, 0.1, 1.0);
                this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);
                
                // Create transformation matrices
                const view = this.createMatrix4();
                const projection = this.createMatrix4();
                const model = this.createMatrix4();
                const normalMatrix = new Float32Array(9);
                
                const cameraPos = this.getCameraPosition();
                this.lookAt(view, cameraPos, this.camera.center, [0, 1, 0]);
                this.perspective(projection, Math.PI / 4, this.canvas.width / this.canvas.height, 0.1, 100.0);
                
                // === RENDER SKYBOX FIRST ===
                this.gl.depthFunc(this.gl.LEQUAL);
                this.gl.useProgram(this.skyboxProgram);
                
                // Remove translation from view matrix for skybox
                const skyboxView = new Float32Array(view);
                skyboxView[12] = skyboxView[13] = skyboxView[14] = 0;
                
                this.gl.uniformMatrix4fv(this.gl.getUniformLocation(this.skyboxProgram, 'uView'), false, skyboxView);
                this.gl.uniformMatrix4fv(this.gl.getUniformLocation(this.skyboxProgram, 'uProjection'), false, projection);
                this.gl.uniform1f(this.gl.getUniformLocation(this.skyboxProgram, 'uTime'), time);
                
                this.gl.bindVertexArray(this.skyboxVAO);
                this.gl.drawArrays(this.gl.TRIANGLES, 0, 36);
                this.gl.depthFunc(this.gl.LESS);
                
                // === RENDER CUBE ===
                this.gl.useProgram(this.shaderProgram);
                
                this.identity(model);
                if (this.autoRotate) {
                    this.rotateY(model, model, time * 0.3);
                    this.rotateX(model, model, time * 0.2);
                }
                
                this.normalFromMat4(normalMatrix, model);
                
                // Dynamic light position
                const lightPos = [
                    3.0 * Math.cos(time * 0.5),
                    2.0 + Math.sin(time * 0.7),
                    3.0 * Math.sin(time * 0.5)
                ];
                const lightColor = [1.0, 0.95, 0.8];
                
                this.gl.uniformMatrix4fv(this.gl.getUniformLocation(this.shaderProgram, 'uModel'), false, model);
                this.gl.uniformMatrix4fv(this.gl.getUniformLocation(this.shaderProgram, 'uView'), false, view);
                this.gl.uniformMatrix4fv(this.gl.getUniformLocation(this.shaderProgram, 'uProjection'), false, projection);
                this.gl.uniformMatrix3fv(this.gl.getUniformLocation(this.shaderProgram, 'uNormalMatrix'), false, normalMatrix);
                this.gl.uniform3fv(this.gl.getUniformLocation(this.shaderProgram, 'uLightPos'), lightPos);
                this.gl.uniform3fv(this.gl.getUniformLocation(this.shaderProgram, 'uLightColor'), lightColor);
                this.gl.uniform3fv(this.gl.getUniformLocation(this.shaderProgram, 'uViewPos'), cameraPos);
                this.gl.uniform1f(this.gl.getUniformLocation(this.shaderProgram, 'uTime'), time);
                
                this.gl.bindVertexArray(this.cubeVAO);
                this.gl.drawElements(this.gl.TRIANGLES, 36, this.gl.UNSIGNED_SHORT, 0);
                
                requestAnimationFrame(() => this.render());
            }
        }
        
        // Initialize the viewer when the page loads
        window.addEventListener('load', () => {
            new WebGL3DCubeViewer();
        });
    </script>
</body>
</html>