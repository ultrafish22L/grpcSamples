<!DOCTYPE html>
<html>
<head>
    <title>WebGL-Octane LiveLink Test (No CSS)</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #222;
            color: white;
            font-family: monospace;
            font-size: 14px;
        }
        canvas {
            border: 1px solid #666;
            display: block;
            margin: 20px 0;
        }
        .controls {
            margin: 10px 0;
        }
        .controls button {
            margin: 5px;
            padding: 8px 12px;
            background: #444;
            color: white;
            border: 1px solid #666;
            cursor: pointer;
        }
        .controls button:hover {
            background: #555;
        }
        .controls input[type="text"] {
            background: #333;
            color: white;
            border: 1px solid #666;
            padding: 5px;
            margin: 5px;
        }
        .controls input[type="checkbox"] {
            margin: 5px;
        }
        .status {
            margin: 10px 0;
            padding: 10px;
            background: #333;
            border: 1px solid #666;
        }
        .log {
            height: 200px;
            overflow-y: auto;
            background: #111;
            border: 1px solid #666;
            padding: 10px;
            margin: 10px 0;
            font-size: 12px;
        }
        .log-entry {
            margin: 2px 0;
        }
    </style>
</head>
<body>
    <h1>WebGL-Octane LiveLink Test (No CSS)</h1>
    
    <div class="controls">
        <input type="text" id="serverAddress" value="http://127.0.0.1:51023" placeholder="Server address">
        <button onclick="connect()">üîå CONNECT</button>
        <button onclick="disconnect()">‚èπÔ∏è DISCONNECT</button>
    </div>
    
    <div class="controls">
        <label><input type="checkbox" id="cameraSyncToggle" checked onchange="toggleCameraSync()"> Camera Sync</label>
        <label><input type="checkbox" id="autoRotateToggle" checked onchange="toggleAutoRotate()"> Auto-Rotate</label>
        <button onclick="getCamera()">üì• Get Camera</button>
        <button onclick="setCamera()">üì§ Set Camera</button>
        <button onclick="resetCamera()">üîÑ Reset Camera</button>
    </div>
    
    <canvas id="canvas" width="800" height="600"></canvas>
    
    <div class="status">
        Status: <span id="connectionStatus">Disconnected</span> | 
        FPS: <span id="fps">0</span> | 
        Frame: <span id="frameTime">0ms</span> | 
        Calls: <span id="callCount">0</span> | 
        Response: <span id="responseTime">0ms</span> | 
        Sync: <span id="syncRate">0/s</span>
    </div>
    
    <div class="log" id="activityLog"></div>
    
    <div class="controls">
        <button onclick="clearLog()">üóëÔ∏è Clear Log</button>
        <button onclick="showInfo()">üìä Show Info</button>
    </div>

    <script src="shared.js"></script>
    <script src="webgl-utils.js"></script>
    <script src="livelink.js"></script>
    
    <script>
        /**
         * WebGL-Octane LiveLink Sync Test (No CSS)
         * Simplified version without complex CSS containers
         */
        class OctaneGrpcSyncTest {
            constructor() {
                console.log('üîó Initializing WebGL-Octane LiveLink Sync Test (No CSS)...');
                
                // Core components
                this.logger = new ActivityLogger('activityLog');
                this.statsManager = new StatsManager();
                this.connectionState = new ConnectionState();
                this.grpcOperations = new GrpcTestOperations(this.logger, this.statsManager);
                this.debugUtils = new DebugUtils(this.logger);
                this.connectionManager = new ConnectionManager(this.logger, this.connectionState);

                // WebGL and rendering state
                this.canvas = document.getElementById('canvas');
                this.gl = null;
                this.shaderProgram = null;
                this.skyboxProgram = null;
                this.camera = new CameraController();

                // Geometry data
                this.cubeVAO = null;
                this.skyboxVAO = null;

                // Mouse interaction
                this.mouse = {
                    dragging: false,
                    panning: false,
                    lastX: 0,
                    lastY: 0
                };

                // Animation and performance tracking
                this.startTime = Date.now();
                this.frameCount = 0;
                this.lastTime = 0;
                this.fps = 0;
                this.frameTime = 0;
                this.autoRotate = true; // cube rotation

                // LiveLink connection state
                this.liveLink = null;
                this.connected = false;
                this.cameraSync = true;
                this.lastCameraSync = 0;
                this.cameraSyncInterval = 100; // ms

                this.init();
            }

            async init() {
                this.logger.log('Initializing WebGL-Octane LiveLink Sync viewer...', 'info');

                try {
                    await this.initWebGL();
                    this.setupEventHandlers();
                    this.startPerformanceMonitoring();
                    this.startRenderLoop();
                    
                    this.logger.log('Viewer initialized successfully. Ready to connect to Octane.', 'success');
                    this.logger.log('Camera sync enabled (will start when connected)', 'info');
                    
                } catch (error) {
                    console.error('‚ùå Initialization failed:', error);
                    this.logger.log(`‚ùå Initialization failed: ${error.message}`, 'error');
                }
            }

            /**
             * Initialize WebGL context and create shaders/geometry
             */
            async initWebGL() {
                // Check WebGL availability
                const webgl2 = this.canvas.getContext('webgl2');
                const webgl1 = this.canvas.getContext('webgl');

                console.log('üîç WebGL Support Check:');
                console.log('WebGL 2.0 available:', !!webgl2);
                console.log('WebGL 1.0 available:', !!webgl1);

                this.logger.log(`WebGL 2.0 available: ${!!webgl2}`, 'info');
                this.logger.log(`WebGL 1.0 available: ${!!webgl1}`, 'info');

                if (webgl2) {
                    this.gl = webgl2;
                    this.logger.log('Using WebGL 2.0', 'success');
                } else if (webgl1) {
                    this.gl = webgl1;
                    this.logger.log('Using WebGL 1.0', 'info');
                } else {
                    throw new Error('WebGL not supported');
                }

                const gl = this.gl;

                // Configure WebGL state
                gl.enable(gl.DEPTH_TEST);
                gl.enable(gl.CULL_FACE);
                gl.cullFace(gl.BACK);
                gl.clearColor(0.1, 0.1, 0.1, 1.0);
                
                this.logger.log('WebGL state configured', 'debug');

                // Create shaders and programs
                await this.createShaders();
                this.logger.log('Shaders created successfully', 'debug');

                // Create geometry
                this.createGeometry();
                this.logger.log('Geometry created successfully', 'debug');

                // Initial resize
                this.resizeCanvas();
            }

            /**
             * Create vertex and fragment shaders
             */
            async createShaders() {
                const gl = this.gl;

                // Main object vertex shader
                const mainVertexShader = `
                    attribute vec3 aPosition;
                    attribute vec3 aNormal;
                    attribute vec3 aColor;
                    
                    uniform mat4 uModel;
                    uniform mat4 uView;
                    uniform mat4 uProjection;
                    uniform mat3 uNormalMatrix;
                    
                    varying vec3 vPosition;
                    varying vec3 vNormal;
                    varying vec3 vColor;
                    
                    void main() {
                        vec4 worldPosition = uModel * vec4(aPosition, 1.0);
                        vPosition = worldPosition.xyz;
                        vNormal = normalize(uNormalMatrix * aNormal);
                        vColor = aColor;
                        
                        gl_Position = uProjection * uView * worldPosition;
                    }
                `;

                // Main object fragment shader
                const mainFragmentShader = `
                    precision mediump float;
                    
                    varying vec3 vPosition;
                    varying vec3 vNormal;
                    varying vec3 vColor;
                    
                    uniform vec3 uLightPos;
                    uniform vec3 uLightColor;
                    uniform vec3 uViewPos;
                    uniform float uTime;
                    
                    void main() {
                        // Ambient
                        float ambientStrength = 0.3;
                        vec3 ambient = ambientStrength * uLightColor;
                        
                        // Diffuse
                        vec3 norm = normalize(vNormal);
                        vec3 lightDir = normalize(uLightPos - vPosition);
                        float diff = max(dot(norm, lightDir), 0.0);
                        vec3 diffuse = diff * uLightColor;
                        
                        // Specular
                        float specularStrength = 0.5;
                        vec3 viewDir = normalize(uViewPos - vPosition);
                        vec3 reflectDir = reflect(-lightDir, norm);
                        float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32.0);
                        vec3 specular = specularStrength * spec * uLightColor;
                        
                        vec3 result = (ambient + diffuse + specular) * vColor;
                        gl_FragColor = vec4(result, 1.0);
                    }
                `;

                // Skybox vertex shader
                const skyboxVertexShader = `
                    attribute vec3 aPosition;
                    uniform mat4 uView;
                    uniform mat4 uProjection;
                    varying vec3 vTexCoord;
                    
                    void main() {
                        vTexCoord = aPosition;
                        vec4 pos = uProjection * uView * vec4(aPosition, 1.0);
                        gl_Position = pos.xyww;
                    }
                `;

                // Skybox fragment shader
                const skyboxFragmentShader = `
                    precision mediump float;
                    varying vec3 vTexCoord;
                    uniform float uTime;
                    
                    void main() {
                        vec3 color = normalize(vTexCoord) * 0.5 + 0.5;
                        color *= 0.3 + 0.1 * sin(uTime);
                        gl_FragColor = vec4(color, 1.0);
                    }
                `;

                // Create main shader program
                this.shaderProgram = this.createShaderProgram(mainVertexShader, mainFragmentShader);
                if (!this.shaderProgram) {
                    throw new Error('Failed to create main shader program');
                }

                // Create skybox shader program
                this.skyboxProgram = this.createShaderProgram(skyboxVertexShader, skyboxFragmentShader);
                if (!this.skyboxProgram) {
                    throw new Error('Failed to create skybox shader program');
                }
            }

            /**
             * Create a shader program from vertex and fragment shader source
             */
            createShaderProgram(vertexSource, fragmentSource) {
                const gl = this.gl;

                const vertexShader = this.createShader(gl.VERTEX_SHADER, vertexSource);
                const fragmentShader = this.createShader(gl.FRAGMENT_SHADER, fragmentSource);

                if (!vertexShader || !fragmentShader) {
                    return null;
                }

                const program = gl.createProgram();
                gl.attachShader(program, vertexShader);
                gl.attachShader(program, fragmentShader);
                gl.linkProgram(program);

                if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                    console.error('Shader program link error:', gl.getProgramInfoLog(program));
                    gl.deleteProgram(program);
                    return null;
                }

                return program;
            }

            /**
             * Create a shader from source code
             */
            createShader(type, source) {
                const gl = this.gl;
                const shader = gl.createShader(type);
                gl.shaderSource(shader, source);
                gl.compileShader(shader);

                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    console.error('Shader compile error:', gl.getShaderInfoLog(shader));
                    gl.deleteShader(shader);
                    return null;
                }

                return shader;
            }

            /**
             * Create cube and skybox geometry
             */
            createGeometry() {
                const gl = this.gl;

                // Cube vertices with colors
                const cubeVertices = new Float32Array([
                    // Front face (red)
                    -1, -1,  1,  0, 0, 1,  1, 0, 0,
                     1, -1,  1,  0, 0, 1,  1, 0, 0,
                     1,  1,  1,  0, 0, 1,  1, 0, 0,
                    -1,  1,  1,  0, 0, 1,  1, 0, 0,

                    // Back face (green)
                    -1, -1, -1,  0, 0, -1,  0, 1, 0,
                    -1,  1, -1,  0, 0, -1,  0, 1, 0,
                     1,  1, -1,  0, 0, -1,  0, 1, 0,
                     1, -1, -1,  0, 0, -1,  0, 1, 0,

                    // Top face (blue)
                    -1,  1, -1,  0, 1, 0,  0, 0, 1,
                    -1,  1,  1,  0, 1, 0,  0, 0, 1,
                     1,  1,  1,  0, 1, 0,  0, 0, 1,
                     1,  1, -1,  0, 1, 0,  0, 0, 1,

                    // Bottom face (yellow)
                    -1, -1, -1,  0, -1, 0,  1, 1, 0,
                     1, -1, -1,  0, -1, 0,  1, 1, 0,
                     1, -1,  1,  0, -1, 0,  1, 1, 0,
                    -1, -1,  1,  0, -1, 0,  1, 1, 0,

                    // Right face (magenta)
                     1, -1, -1,  1, 0, 0,  1, 0, 1,
                     1,  1, -1,  1, 0, 0,  1, 0, 1,
                     1,  1,  1,  1, 0, 0,  1, 0, 1,
                     1, -1,  1,  1, 0, 0,  1, 0, 1,

                    // Left face (cyan)
                    -1, -1, -1, -1, 0, 0,  0, 1, 1,
                    -1, -1,  1, -1, 0, 0,  0, 1, 1,
                    -1,  1,  1, -1, 0, 0,  0, 1, 1,
                    -1,  1, -1, -1, 0, 0,  0, 1, 1
                ]);

                const cubeIndices = new Uint16Array([
                    0,  1,  2,    0,  2,  3,    // front
                    4,  5,  6,    4,  6,  7,    // back
                    8,  9,  10,   8,  10, 11,   // top
                    12, 13, 14,   12, 14, 15,   // bottom
                    16, 17, 18,   16, 18, 19,   // right
                    20, 21, 22,   20, 22, 23    // left
                ]);

                // Create cube VAO (check WebGL 2.0 support)
                if (gl.createVertexArray) {
                    this.cubeVAO = gl.createVertexArray();
                    gl.bindVertexArray(this.cubeVAO);
                } else {
                    // WebGL 1.0 fallback - no VAO support
                    this.cubeVAO = null;
                }

                this.cubeVBO = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, this.cubeVBO);
                gl.bufferData(gl.ARRAY_BUFFER, cubeVertices, gl.STATIC_DRAW);

                this.cubeEBO = gl.createBuffer();
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.cubeEBO);
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, cubeIndices, gl.STATIC_DRAW);

                // Position attribute
                gl.enableVertexAttribArray(0);
                gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 36, 0);

                // Normal attribute
                gl.enableVertexAttribArray(1);
                gl.vertexAttribPointer(1, 3, gl.FLOAT, false, 36, 12);

                // Color attribute
                gl.enableVertexAttribArray(2);
                gl.vertexAttribPointer(2, 3, gl.FLOAT, false, 36, 24);

                // Skybox vertices
                const skyboxVertices = new Float32Array([
                    -1.0,  1.0, -1.0,
                    -1.0, -1.0, -1.0,
                     1.0, -1.0, -1.0,
                     1.0, -1.0, -1.0,
                     1.0,  1.0, -1.0,
                    -1.0,  1.0, -1.0,

                    -1.0, -1.0,  1.0,
                    -1.0, -1.0, -1.0,
                    -1.0,  1.0, -1.0,
                    -1.0,  1.0, -1.0,
                    -1.0,  1.0,  1.0,
                    -1.0, -1.0,  1.0,

                     1.0, -1.0, -1.0,
                     1.0, -1.0,  1.0,
                     1.0,  1.0,  1.0,
                     1.0,  1.0,  1.0,
                     1.0,  1.0, -1.0,
                     1.0, -1.0, -1.0,

                    -1.0, -1.0,  1.0,
                    -1.0,  1.0,  1.0,
                     1.0,  1.0,  1.0,
                     1.0,  1.0,  1.0,
                     1.0, -1.0,  1.0,
                    -1.0, -1.0,  1.0,

                    -1.0,  1.0, -1.0,
                     1.0,  1.0, -1.0,
                     1.0,  1.0,  1.0,
                     1.0,  1.0,  1.0,
                    -1.0,  1.0,  1.0,
                    -1.0,  1.0, -1.0,

                    -1.0, -1.0, -1.0,
                    -1.0, -1.0,  1.0,
                     1.0, -1.0, -1.0,
                     1.0, -1.0, -1.0,
                    -1.0, -1.0,  1.0,
                     1.0, -1.0,  1.0
                ]);

                // Create skybox VAO (check WebGL 2.0 support)
                if (gl.createVertexArray) {
                    this.skyboxVAO = gl.createVertexArray();
                    gl.bindVertexArray(this.skyboxVAO);
                } else {
                    // WebGL 1.0 fallback - no VAO support
                    this.skyboxVAO = null;
                }

                const skyboxVBO = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, skyboxVBO);
                gl.bufferData(gl.ARRAY_BUFFER, skyboxVertices, gl.STATIC_DRAW);

                gl.enableVertexAttribArray(0);
                gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);

                if (gl.bindVertexArray) {
                    gl.bindVertexArray(null);
                }
            }

            /**
             * Set up event handlers for user interaction
             */
            setupEventHandlers() {
                // Canvas mouse events
                this.canvas.addEventListener('mousedown', (e) => this.handleMouseDown(e));
                this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
                this.canvas.addEventListener('mouseup', (e) => this.handleMouseUp(e));
                this.canvas.addEventListener('wheel', (e) => this.handleWheel(e));
                this.canvas.addEventListener('contextmenu', (e) => e.preventDefault());

                // Window resize - keep canvas size fixed for this test
                window.addEventListener('resize', () => {
                    console.log('Window resized, canvas size unchanged');
                });
            }

            /**
             * Handle mouse down events
             */
            handleMouseDown(event) {
                this.mouse.dragging = event.button === 0;  // Left button
                this.mouse.panning = event.button === 2;  // Right button
                this.mouse.lastX = event.clientX;
                this.mouse.lastY = event.clientY;

                if (this.mouse.dragging || this.mouse.panning) {
                    this.canvas.style.cursor = this.mouse.panning ? 'move' : 'grabbing';
                }
            }

            /**
             * Handle mouse move events
             */
            handleMouseMove(event) {
                if (!this.mouse.dragging && !this.mouse.panning) return;

                const deltaX = event.clientX - this.mouse.lastX;
                const deltaY = event.clientY - this.mouse.lastY;

                if (this.mouse.dragging) {
                    this.camera.handleMouseMove(deltaX, deltaY);
                } else if (this.mouse.panning) {
                    this.camera.handlePan(deltaX, deltaY);
                }

                this.mouse.lastX = event.clientX;
                this.mouse.lastY = event.clientY;
            }

            /**
             * Handle mouse up events
             */
            handleMouseUp(event) {
                this.mouse.dragging = false;
                this.mouse.panning = false;
                this.canvas.style.cursor = 'default';
            }

            /**
             * Handle mouse wheel events
             */
            handleWheel(event) {
                event.preventDefault();
                this.camera.handleWheel(event.deltaY);
            }

            /**
             * Resize canvas to match container
             */
            resizeCanvas() {
                // Keep canvas size fixed for this test
                const width = 800;
                const height = 600;

                if (this.canvas.width !== width || this.canvas.height !== height) {
                    this.canvas.width = width;
                    this.canvas.height = height;

                    if (this.gl) {
                        this.gl.viewport(0, 0, width, height);
                        this.gl.clearColor(0.1, 0.1, 0.1, 1.0);
                        this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);
                    }
                }
            }

            /**
             * Start performance monitoring
             */
            startPerformanceMonitoring() {
                setInterval(() => {
                    document.getElementById('fps').textContent = Math.round(this.fps);
                    document.getElementById('frameTime').textContent = this.frameTime + 'ms';
                    document.getElementById('callCount').textContent = this.statsManager.getTotalCalls();
                    document.getElementById('responseTime').textContent = this.statsManager.getAverageResponseTime() + 'ms';
                    document.getElementById('syncRate').textContent = this.statsManager.getSyncRate() + '/s';
                }, 1000);
            }

            /**
             * Start the render loop
             */
            startRenderLoop() {
                this.logger.log('üé¨ Starting render loop...', 'debug');
                this.render();
            }

            /**
             * Main render loop
             */
            render() {
                try {
                    const currentTime = Date.now();
                    const deltaTime = (currentTime - this.lastTime) / 1000.0;
                    this.lastTime = currentTime;

                    // Update camera
                    this.camera.update(deltaTime);

                    // Calculate performance metrics
                    this.frameCount++;
                    if (this.frameCount % 60 === 0) {
                        const elapsed = currentTime - this.startTime;
                        this.fps = (this.frameCount * 1000) / elapsed;
                        this.frameTime = Math.round(deltaTime * 1000);
                    }

                    // Render scene
                    this.renderScene(currentTime / 1000.0);

                    // Continue render loop
                    requestAnimationFrame(() => this.render());

                } catch (error) {
                    console.error('‚ùå Render loop error:', error);
                    this.checkWebGLError('Render loop exception');
                }
            }

            /**
             * Render the 3D scene
             */
            renderScene(time) {
                const gl = this.gl;

                // Create matrices
                const aspect = this.canvas.width / this.canvas.height;
                const projectionMatrix = MatrixUtils.createPerspectiveMatrix(Math.PI / 4, aspect, 0.1, 100.0);
                const viewMatrix = this.camera.getViewMatrix();

                // Model matrix with rotation
                const rotationX = this.autoRotate ? time * 0.5 : 0;
                const rotationY = this.autoRotate ? time * 0.3 : 0;
                const modelMatrix = MatrixUtils.createModelMatrix([0, 0, 0], [rotationX, rotationY, 0], [1, 1, 1]);
                const normalMatrix = MatrixUtils.transpose(MatrixUtils.inverse(modelMatrix));
                // Extract 3x3 normal matrix from 4x4 matrix for WebGL
                const normalMatrix3x3 = new Float32Array([
                    normalMatrix[0], normalMatrix[1], normalMatrix[2],
                    normalMatrix[4], normalMatrix[5], normalMatrix[6], 
                    normalMatrix[8], normalMatrix[9], normalMatrix[10]
                ]);

                // Clear buffers
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

                // Render skybox first
                gl.depthMask(false);
                gl.useProgram(this.skyboxProgram);
                
                if (this.skyboxVAO) {
                    gl.bindVertexArray(this.skyboxVAO);
                } else {
                    // WebGL 1.0 fallback - manually bind buffers
                    // Note: skybox buffers would need to be stored for this to work
                }

                const skyboxUView = gl.getUniformLocation(this.skyboxProgram, 'uView');
                const skyboxUProjection = gl.getUniformLocation(this.skyboxProgram, 'uProjection');

                const skyboxViewMat = viewMatrix instanceof Float32Array ? viewMatrix : new Float32Array(viewMatrix);
                const skyboxProjMat = projectionMatrix instanceof Float32Array ? projectionMatrix : new Float32Array(projectionMatrix);

                if (skyboxUView) {
                    gl.uniformMatrix4fv(skyboxUView, false, skyboxViewMat);
                }
                if (skyboxUProjection) {
                    gl.uniformMatrix4fv(skyboxUProjection, false, skyboxProjMat);
                }
                gl.uniform1f(gl.getUniformLocation(this.skyboxProgram, 'uTime'), time);

                gl.drawArrays(gl.TRIANGLES, 0, 36);

                // Render main object
                gl.depthMask(true);
                gl.useProgram(this.shaderProgram);
                
                if (this.cubeVAO) {
                    gl.bindVertexArray(this.cubeVAO);
                } else {
                    // WebGL 1.0 fallback - manually bind buffers and set attributes
                    gl.bindBuffer(gl.ARRAY_BUFFER, this.cubeVBO);
                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.cubeEBO);
                    
                    // Position attribute
                    gl.enableVertexAttribArray(0);
                    gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 36, 0);
                    
                    // Normal attribute
                    gl.enableVertexAttribArray(1);
                    gl.vertexAttribPointer(1, 3, gl.FLOAT, false, 36, 12);
                    
                    // Color attribute
                    gl.enableVertexAttribArray(2);
                    gl.vertexAttribPointer(2, 3, gl.FLOAT, false, 36, 24);
                }

                // Set uniforms
                const uModel = gl.getUniformLocation(this.shaderProgram, 'uModel');
                const uView = gl.getUniformLocation(this.shaderProgram, 'uView');
                const uProjection = gl.getUniformLocation(this.shaderProgram, 'uProjection');
                const uNormalMatrix = gl.getUniformLocation(this.shaderProgram, 'uNormalMatrix');

                const modelMat = modelMatrix instanceof Float32Array ? modelMatrix : new Float32Array(modelMatrix);
                const viewMat = viewMatrix instanceof Float32Array ? viewMatrix : new Float32Array(viewMatrix);
                const projMat = projectionMatrix instanceof Float32Array ? projectionMatrix : new Float32Array(projectionMatrix);
                const normalMat = normalMatrix3x3;

                if (uModel) {
                    gl.uniformMatrix4fv(uModel, false, modelMat);
                }
                if (uView) {
                    gl.uniformMatrix4fv(uView, false, viewMat);
                }
                if (uProjection) {
                    gl.uniformMatrix4fv(uProjection, false, projMat);
                }
                if (uNormalMatrix) {
                    gl.uniformMatrix3fv(uNormalMatrix, false, normalMat);
                }

                // Lighting uniforms
                const cameraPos = this.camera.getPosition();
                gl.uniform3fv(gl.getUniformLocation(this.shaderProgram, 'uLightPos'), [5.0, 5.0, 5.0]);
                gl.uniform3fv(gl.getUniformLocation(this.shaderProgram, 'uLightColor'), [1.0, 1.0, 1.0]);
                gl.uniform3fv(gl.getUniformLocation(this.shaderProgram, 'uViewPos'), cameraPos);
                gl.uniform1f(gl.getUniformLocation(this.shaderProgram, 'uTime'), time);

                // Draw cube
                gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

                // Unbind
                if (this.cubeVAO) {
                    gl.bindVertexArray(null);
                }
            }

            /**
             * Check for WebGL errors
             */
            checkWebGLError(operation) {
                const gl = this.gl;
                const error = gl.getError();
                if (error !== gl.NO_ERROR) {
                    console.error(`WebGL error during ${operation}:`, error);
                    return false;
                }
                return true;
            }

            // Connection methods
            async connect() {
                const serverAddress = document.getElementById('serverAddress').value;
                this.logger.log(`üîå Connecting to ${serverAddress}...`, 'info');
                
                try {
                    this.liveLink = new LiveLinkClient(serverAddress);
                    this.connected = true;
                    this.connectionState.setConnected(true);
                    document.getElementById('connectionStatus').textContent = 'Connected';
                    this.logger.log('‚úÖ Connected to Octane LiveLink', 'success');
                } catch (error) {
                    this.logger.log(`‚ùå Connection failed: ${error.message}`, 'error');
                }
            }

            disconnect() {
                if (this.liveLink) {
                    this.liveLink = null;
                    this.connected = false;
                    this.connectionState.setConnected(false);
                    document.getElementById('connectionStatus').textContent = 'Disconnected';
                    this.logger.log('‚èπÔ∏è Disconnected from Octane LiveLink', 'info');
                }
            }

            async getCamera() {
                if (!this.connected) {
                    this.logger.log('‚ùå Not connected to Octane', 'error');
                    return;
                }
                
                try {
                    const camera = await this.grpcOperations.getCamera();
                    this.logger.log('üì• Camera retrieved from Octane', 'success');
                } catch (error) {
                    this.logger.log(`‚ùå Get camera failed: ${error.message}`, 'error');
                }
            }

            async setCamera() {
                if (!this.connected) {
                    this.logger.log('‚ùå Not connected to Octane', 'error');
                    return;
                }
                
                try {
                    const cameraData = this.camera.getCameraData();
                    await this.grpcOperations.setCamera(cameraData);
                    this.logger.log('üì§ Camera sent to Octane', 'success');
                } catch (error) {
                    this.logger.log(`‚ùå Set camera failed: ${error.message}`, 'error');
                }
            }

            resetCamera() {
                this.camera.reset();
                this.logger.log('üîÑ Camera reset to default position', 'info');
            }

            toggleCameraSync() {
                this.cameraSync = document.getElementById('cameraSyncToggle').checked;
                this.logger.log(`üîÑ Camera sync ${this.cameraSync ? 'enabled' : 'disabled'}`, 'info');
            }

            toggleAutoRotate() {
                this.autoRotate = document.getElementById('autoRotateToggle').checked;
                this.logger.log(`üîÅ Auto-rotate ${this.autoRotate ? 'enabled' : 'disabled'}`, 'info');
            }
        }

        // Global functions
        let viewer;

        function connect() {
            if (viewer) viewer.connect();
        }

        function disconnect() {
            if (viewer) viewer.disconnect();
        }

        function getCamera() {
            if (viewer) viewer.getCamera();
        }

        function setCamera() {
            if (viewer) viewer.setCamera();
        }

        function resetCamera() {
            if (viewer) viewer.resetCamera();
        }

        function toggleCameraSync() {
            if (viewer) viewer.toggleCameraSync();
        }

        function toggleAutoRotate() {
            if (viewer) viewer.toggleAutoRotate();
        }

        function clearLog() {
            const log = document.getElementById('activityLog');
            log.innerHTML = '';
        }

        function showInfo() {
            if (viewer) {
                viewer.logger.log('=== System Information ===', 'info');
                viewer.logger.log(`Canvas Size: ${viewer.canvas.width}x${viewer.canvas.height}`, 'info');
                viewer.logger.log(`WebGL Version: ${viewer.gl instanceof WebGL2RenderingContext ? 'WebGL 2.0' : 'WebGL 1.0'}`, 'info');
                viewer.logger.log(`FPS: ${Math.round(viewer.fps)}`, 'info');
                viewer.logger.log(`Frame Count: ${viewer.frameCount}`, 'info');
                viewer.logger.log(`Connected: ${viewer.connected}`, 'info');
                viewer.logger.log(`Camera Sync: ${viewer.cameraSync}`, 'info');
                viewer.logger.log(`Auto Rotate: ${viewer.autoRotate}`, 'info');
            }
        }

        // Initialize when page loads
        window.addEventListener('load', async () => {
            console.log('Page loaded, initializing WebGL-Octane LiveLink Test...');
            
            try {
                viewer = new OctaneGrpcSyncTest();
                console.log('Test viewer initialized successfully');
            } catch (error) {
                console.error('Failed to initialize test viewer:', error);
            }
        });
    </script>
</body>
</html>