<!DOCTYPE html>
<!-- 
    WebGL-Octane LiveLink Sync
    3D WebGL viewer with real-time Octane synchronization
    Based on grpc_test.html connection logic with 3D visualization
-->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>🔗 OTOY WebGL-Octane LiveLink Sync</title>
    <link rel="stylesheet" href="otoy-theme.css">
</head>
<body>
    <div class="container">
        <!-- OTOY Branding -->
        <div class="otoy-branding">
            <img src="https://home.otoy.com/wp-content/themes/otoy/assets/images/otoy-logo-white.svg" alt="OTOY" class="otoy-logo" style="width: 40px; height: 40px;">
            <h1>🔗 Octane WebGL LiveLink Sync</h1>
        </div>
        
        <!-- Ultra-Tight Controls Layout -->
        <div class="controls-container">
            <div class="control-section">
                <div class="section-title">Connection & Debug</div>
                <div class="button-group">
                    <input type="text" id="serverAddress" placeholder="Server address" value="http://127.0.0.1:51023">
                    <button id="connectBtn" onclick="testConnection()">Connect</button>
                    <button onclick="disconnect()">Disconnect</button>
                    <button onclick="exportDebugInfo()">Export</button>
                </div>
                <div class="button-group">
                    <button onclick="showSystemInfo()">System</button>
                    <button onclick="showDebugInfo()">Debug</button>
                    <button onclick="refreshStats()">Stats</button>
                    <button onclick="clearLog()">Clear</button>
                </div>
            </div>
            
            <div class="control-section">
                <div class="section-title">LiveLink & View Controls</div>
                <div class="button-group">
                    <button onclick="testGetCamera()">Get Camera</button>
                    <button onclick="testSetCamera()">Set Camera</button>
                    <button onclick="testGetMeshes()">Get Meshes</button>
                    <button onclick="toggleCameraSync()">Sync</button>
                </div>
                <div class="button-group">
                    <button onclick="toggleAutoRotate()">Auto-Rotate</button>
                    <button onclick="resetCamera()">Reset</button>
                    <button onclick="loadModel()">Load Model</button>
                    <button onclick="testLoadTeapot()">Teapot</button>
                </div>
            </div>
        </div>
        

        
        <!-- 3D Canvas and Info Panel below -->
        <div class="content-area">
            <div class="canvas-container">
                <canvas id="canvas"></canvas>
            </div>
            
            <div class="info-panel">
                <div class="activity-section glass-panel">
                    <div class="activity-title">Activity Log</div>
                    <div id="log" class="activity-log"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Include shared utilities and LiveLink client -->
    <script src="shared.js"></script>
    <script src="livelink.js"></script>
    <script src="webgl-utils.js"></script>
    <script>
        /**
         * WebGL-Octane LiveLink Sync
         * 3D WebGL viewer with real-time Octane synchronization
         * Based on grpc_test.html connection logic
         */
        
        // Application state
        let client = null;
        let logger = null;
        let statsManager = null;
        let grpcOperations = null;
        let debugUtils = null;
        
        // 3D viewer state
        let canvas = null;
        let gl = null;
        let webglRenderer = null;
        let mouseControls = null;
        let cameraSyncManager = null;
        let autoRotate = false;
        let lastFrameTime = 0;
        let frameCount = 0;
        let fpsUpdateTime = 0;
        
        // Initialize application when page loads
        document.addEventListener('DOMContentLoaded', () => {
            logger = new ActivityLogger('log');
            statsManager = new StatsDisplayManager();
            grpcOperations = new GrpcTestOperations(logger, statsManager);
            debugUtils = new DebugUtils(logger);
            
            // Initialize LED status to "All Systems Ready"
            if (statsManager) {
                statsManager.updateConnectionStatus(false);
            }
            
            // Initialize 3D viewer
            initWebGL();
            
            logger.log('🔗 WebGL-Octane LiveLink Sync initialized', 'info');
        });

        // WebGL initialization and rendering
        function initWebGL() {
            canvas = document.getElementById('canvas');
            if (!canvas) {
                logger.log('❌ Canvas element not found', 'error');
                return;
            }
            
            // Set canvas size
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            try {
                gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                if (!gl) {
                    throw new Error('WebGL not supported');
                }
                
                webglRenderer = new SimpleWebGLRenderer(gl, logger);
                webglRenderer.init();
                
                // Setup mouse controls
                mouseControls = new MouseControls(canvas, webglRenderer, logger);
                
                // Setup camera sync manager
                cameraSyncManager = new CameraSyncManager(webglRenderer, null, logger);
                
                // Start render loop
                requestAnimationFrame(renderLoop);
                
                logger.log('✅ WebGL initialized successfully', 'success');
                
            } catch (error) {
                logger.log(`❌ WebGL initialization failed: ${error.message}`, 'error');
            }
        }
        
        function resizeCanvas() {
            if (!canvas) return;
            
            const container = canvas.parentElement;
            const rect = container.getBoundingClientRect();
            
            canvas.width = rect.width;
            canvas.height = rect.height;
            
            if (gl) {
                gl.viewport(0, 0, canvas.width, canvas.height);
            }
            
            if (webglRenderer) {
                webglRenderer.updateProjection(canvas.width, canvas.height);
            }
        }
        
        function renderLoop(currentTime) {
            if (webglRenderer) {
                // Update FPS
                frameCount++;
                if (currentTime - fpsUpdateTime >= 1000) {
                    const fps = Math.round((frameCount * 1000) / (currentTime - fpsUpdateTime));
                    document.getElementById('fpsValue').textContent = fps;
                    frameCount = 0;
                    fpsUpdateTime = currentTime;
                }
                
                // Update frame time
                const frameTime = currentTime - lastFrameTime;
                document.getElementById('frameTimeValue').textContent = Math.round(frameTime) + 'ms';
                lastFrameTime = currentTime;
                
                // Auto-rotate if enabled
                if (autoRotate) {
                    webglRenderer.rotateCamera(currentTime * 0.001);
                }
                
                // Render frame
                webglRenderer.render();
                
                // Sync camera with Octane if enabled
                if (cameraSyncManager) {
                    cameraSyncManager.syncToOctane();
                }
            }
            
            requestAnimationFrame(renderLoop);
        }

        // Connection functions (based on grpc_test.html)
        function updateStatus(status, mode = '') {
            const statusSpan = document.getElementById('connectionStatus');
            const connectBtn = document.getElementById('connectBtn');
            
            if (statusSpan) {
                statusSpan.className = `status-indicator status-${status}`;
                
                switch (status) {
                    case 'connected':
                        statusSpan.textContent = `Connected${mode ? ` (${mode})` : ''}`;
                        break;
                    case 'disconnected':
                        statusSpan.textContent = 'Disconnected';
                        break;
                    case 'error':
                        statusSpan.textContent = 'Connection Error';
                        break;
                    default:
                        statusSpan.textContent = status;
                }
            }

            if (connectBtn) {
                switch (status) {
                    case 'connected':
                        connectBtn.textContent = 'RECONNECT';
                        break;
                    case 'disconnected':
                        connectBtn.textContent = 'CONNECT';
                        break;
                    case 'error':
                        connectBtn.textContent = 'RETRY';
                        break;
                }
            }

            // Update OTOY LED status - detect proxy availability from error type
            if (statsManager) {
                const isProxyError = client && client.lastError && 
                    (client.lastError.message.includes('fetch') || 
                     client.lastError.message.includes('ERR_CONNECTION_REFUSED') ||
                     client.lastError.message.includes('ERR_NETWORK_CHANGED'));
                
                const proxyAvailable = status !== 'error' || !isProxyError;
                statsManager.updateConnectionStatus(status === 'connected', proxyAvailable);
            }
        }

        function updateStats() {
            if (statsManager && client) {
                statsManager.updateStats(client);
            }
        }

        function clearLog() {
            if (logger) {
                logger.clear();
                logger.log('Activity log cleared', 'info');
            }
        }

        function exportDebugInfo() {
            if (debugUtils && client) {
                debugUtils.exportDebugInfo(client);
            }
        }

        function showSystemInfo() {
            if (debugUtils && client) {
                debugUtils.showSystemInfo(client);
            }
        }

        function showDebugInfo() {
            if (debugUtils && client) {
                debugUtils.showDebugInfo(client);
            }
        }

        async function testConnection() {
            try {
                const serverAddress = document.getElementById('serverAddress').value;
                logger.log('🔗 Connecting to Octane LiveLink...', 'info');
                
                client = liveLinkManager.getClient(serverAddress);
                
                // Setup event handlers
                client.removeAllListeners();
                
                client.on('log', (logEntry) => {
                    const displayMessage = logEntry.cleanMessage || logEntry.message;
                    logger.log(displayMessage, logEntry.level);
                });
                
                client.on('connected', () => {
                    logger.log('✅ Connected to Octane LiveLink!', 'success');
                    updateStatus('connected', 'Live');
                    updateStats();
                    
                    // Update camera sync manager with client
                    if (cameraSyncManager) {
                        cameraSyncManager.client = client;
                    }
                });
                
                client.on('disconnected', () => {
                    logger.log('Disconnected from server', 'info');
                    updateStatus('disconnected');
                    updateStats();
                });
                
                client.on('error', (error) => {
                    logger.log(`❌ Connection error: ${error.message}`, 'error');
                    updateStatus('error');
                    updateStats();
                });
                
                await client.connect();
                
                const stats = client.getStats();
                if (stats.connected) {
                    updateStatus('connected', 'Live');
                } else {
                    updateStatus('error');
                }
                updateStats();
                
            } catch (error) {
                logger.log(`❌ Connection error: ${error.message}`, 'error');
                updateStatus('error');
            }
        }

        async function disconnect() {
            if (client) {
                await client.disconnect();
                logger.log('Disconnected from server', 'info');
                updateStatus('disconnected');
                updateStats();
            } else {
                logger.log('No connection to disconnect', 'warning');
            }
        }

        // LiveLink operations (based on grpc_test.html)
        async function testGetCamera() {
            if (grpcOperations && client) {
                const cameraData = await grpcOperations.testGetCamera(client);
                if (cameraData && webglRenderer) {
                    webglRenderer.setCameraFromOctane(cameraData);
                }
            }
        }

        async function testSetCamera() {
            if (grpcOperations && client && webglRenderer) {
                const cameraState = webglRenderer.getCameraState();
                await grpcOperations.testSetCamera(client, cameraState);
            }
        }

        async function testGetMeshes() {
            if (grpcOperations && client) {
                await grpcOperations.testGetMeshes(client);
            }
        }

        async function testGetMesh() {
            if (grpcOperations && client) {
                const meshData = await grpcOperations.testGetMesh(client);
                if (meshData && webglRenderer) {
                    webglRenderer.loadMeshData(meshData);
                }
            }
        }

        async function testLoadTeapot() {
            if (grpcOperations && client) {
                await grpcOperations.testLoadTeapot(client);
            }
        }

        // 3D viewer controls
        function toggleAutoRotate() {
            autoRotate = !autoRotate;
            logger.log(`Auto-rotate ${autoRotate ? 'enabled' : 'disabled'}`, 'info');
        }

        function resetCamera() {
            if (webglRenderer) {
                webglRenderer.resetCamera();
                logger.log('Camera reset to default position', 'info');
            }
        }

        function toggleCameraSync() {
            if (cameraSyncManager) {
                const enabled = cameraSyncManager.toggle();
                document.getElementById('syncRate').textContent = enabled ? 'Active' : '0/s';
            }
        }

        function loadModel() {
            // Create file input for model loading
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.obj,.ply,.stl';
            input.onchange = (e) => {
                const file = e.target.files[0];
                if (file && webglRenderer) {
                    webglRenderer.loadModelFile(file);
                    logger.log(`Loading model: ${file.name}`, 'info');
                }
            };
            input.click();
        }


    </script>
    
    <!-- Status Footer -->
    <div class="status-footer">
        <div class="footer-stats">
            <span>Status: <span id="connectionStatus" class="status-indicator">Disconnected</span></span>
            <span>FPS: <span id="fps">0</span></span>
            <span>Frame: <span id="frameTime">0ms</span></span>
            <span>Calls: <span id="callCount">0</span></span>
            <span>Response: <span id="lastTime">0ms</span></span>
            <span>Sync: <span id="syncRate">0/s</span></span>
            <span>Errors: <span id="errorCount">0</span></span>
        </div>
    </div>

    <!-- OTOY Footer -->
    <div class="otoy-footer">
        <div class="otoy-status">
            <span class="status-led"></span>
            <span>All Systems Ready</span>
        </div>
        <div class="otoy-copyright">
            © OTOY Inc. – 2020 All Rights Reserved. 
            <a href="https://otoy.com/terms" target="_blank">Terms & Conditions</a> | 
            <a href="https://otoy.com/privacy" target="_blank">OTOY Privacy Policy</a>
        </div>
    </div>

</body>
</html>