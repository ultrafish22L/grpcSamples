<!DOCTYPE html>
<html>
<head>
    <title>Simple Rotating Cube Test</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #222;
            color: white;
            font-family: monospace;
        }
        canvas {
            border: 1px solid #666;
            display: block;
            margin: 20px 0;
        }
        #info {
            font-size: 14px;
        }
    </style>
</head>
<body>
    <h1>Simple Rotating Cube Test</h1>
    <div id="info">
        FPS: <span id="fps">0</span> | 
        Frame: <span id="frameTime">0ms</span> | 
        Frames: <span id="frameCount">0</span>
    </div>
    <canvas id="canvas" width="800" height="600"></canvas>
    
    <script>
        class SimpleCubeTest {
            constructor() {
                this.canvas = document.getElementById('canvas');
                this.gl = this.canvas.getContext('webgl2') || this.canvas.getContext('webgl');
                
                if (!this.gl) {
                    alert('WebGL not supported');
                    return;
                }
                
                // Performance tracking
                this.frameCount = 0;
                this.startTime = Date.now();
                this.lastTime = Date.now();
                this.fps = 0;
                
                this.init();
                this.render();
            }
            
            init() {
                const gl = this.gl;
                
                // Vertex shader
                const vertexShaderSource = `
                    attribute vec3 aPosition;
                    attribute vec3 aColor;
                    uniform mat4 uProjection;
                    uniform mat4 uView;
                    uniform mat4 uModel;
                    varying vec3 vColor;
                    
                    void main() {
                        gl_Position = uProjection * uView * uModel * vec4(aPosition, 1.0);
                        vColor = aColor;
                    }
                `;
                
                // Fragment shader
                const fragmentShaderSource = `
                    precision mediump float;
                    varying vec3 vColor;
                    
                    void main() {
                        gl_FragColor = vec4(vColor, 1.0);
                    }
                `;
                
                // Create shaders
                const vertexShader = this.createShader(gl.VERTEX_SHADER, vertexShaderSource);
                const fragmentShader = this.createShader(gl.FRAGMENT_SHADER, fragmentShaderSource);
                
                // Create program
                this.program = gl.createProgram();
                gl.attachShader(this.program, vertexShader);
                gl.attachShader(this.program, fragmentShader);
                gl.linkProgram(this.program);
                
                if (!gl.getProgramParameter(this.program, gl.LINK_STATUS)) {
                    console.error('Program link error:', gl.getProgramInfoLog(this.program));
                    return;
                }
                
                // Cube vertices (position + color)
                const vertices = new Float32Array([
                    // Front face (red)
                    -1, -1,  1,  1, 0, 0,
                     1, -1,  1,  1, 0, 0,
                     1,  1,  1,  1, 0, 0,
                    -1,  1,  1,  1, 0, 0,
                    
                    // Back face (green)
                    -1, -1, -1,  0, 1, 0,
                    -1,  1, -1,  0, 1, 0,
                     1,  1, -1,  0, 1, 0,
                     1, -1, -1,  0, 1, 0,
                    
                    // Top face (blue)
                    -1,  1, -1,  0, 0, 1,
                    -1,  1,  1,  0, 0, 1,
                     1,  1,  1,  0, 0, 1,
                     1,  1, -1,  0, 0, 1,
                    
                    // Bottom face (yellow)
                    -1, -1, -1,  1, 1, 0,
                     1, -1, -1,  1, 1, 0,
                     1, -1,  1,  1, 1, 0,
                    -1, -1,  1,  1, 1, 0,
                    
                    // Right face (magenta)
                     1, -1, -1,  1, 0, 1,
                     1,  1, -1,  1, 0, 1,
                     1,  1,  1,  1, 0, 1,
                     1, -1,  1,  1, 0, 1,
                    
                    // Left face (cyan)
                    -1, -1, -1,  0, 1, 1,
                    -1, -1,  1,  0, 1, 1,
                    -1,  1,  1,  0, 1, 1,
                    -1,  1, -1,  0, 1, 1
                ]);
                
                const indices = new Uint16Array([
                    0,  1,  2,    0,  2,  3,    // front
                    4,  5,  6,    4,  6,  7,    // back
                    8,  9,  10,   8,  10, 11,   // top
                    12, 13, 14,   12, 14, 15,   // bottom
                    16, 17, 18,   16, 18, 19,   // right
                    20, 21, 22,   20, 22, 23    // left
                ]);
                
                // Create buffers
                this.vertexBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
                
                this.indexBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);
                
                // Get attribute locations
                this.aPosition = gl.getAttribLocation(this.program, 'aPosition');
                this.aColor = gl.getAttribLocation(this.program, 'aColor');
                
                // Get uniform locations
                this.uProjection = gl.getUniformLocation(this.program, 'uProjection');
                this.uView = gl.getUniformLocation(this.program, 'uView');
                this.uModel = gl.getUniformLocation(this.program, 'uModel');
                
                // Setup WebGL state
                gl.enable(gl.DEPTH_TEST);
                gl.clearColor(0.1, 0.1, 0.1, 1.0);
                gl.viewport(0, 0, this.canvas.width, this.canvas.height);
                
                console.log('Simple cube test initialized');
            }
            
            createShader(type, source) {
                const gl = this.gl;
                const shader = gl.createShader(type);
                gl.shaderSource(shader, source);
                gl.compileShader(shader);
                
                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    console.error('Shader compile error:', gl.getShaderInfoLog(shader));
                    gl.deleteShader(shader);
                    return null;
                }
                
                return shader;
            }
            
            createMatrix4() {
                return new Float32Array(16);
            }
            
            identity(out) {
                out[0] = 1; out[1] = 0; out[2] = 0; out[3] = 0;
                out[4] = 0; out[5] = 1; out[6] = 0; out[7] = 0;
                out[8] = 0; out[9] = 0; out[10] = 1; out[11] = 0;
                out[12] = 0; out[13] = 0; out[14] = 0; out[15] = 1;
                return out;
            }
            
            perspective(out, fovy, aspect, near, far) {
                const f = 1.0 / Math.tan(fovy / 2);
                const nf = 1 / (near - far);
                
                out[0] = f / aspect; out[1] = 0; out[2] = 0; out[3] = 0;
                out[4] = 0; out[5] = f; out[6] = 0; out[7] = 0;
                out[8] = 0; out[9] = 0; out[10] = (far + near) * nf; out[11] = -1;
                out[12] = 0; out[13] = 0; out[14] = 2 * far * near * nf; out[15] = 0;
                return out;
            }
            
            translate(out, a, v) {
                const x = v[0], y = v[1], z = v[2];
                out[0] = a[0]; out[1] = a[1]; out[2] = a[2]; out[3] = a[3];
                out[4] = a[4]; out[5] = a[5]; out[6] = a[6]; out[7] = a[7];
                out[8] = a[8]; out[9] = a[9]; out[10] = a[10]; out[11] = a[11];
                out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
                out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
                out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
                out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
                return out;
            }
            
            rotateX(out, a, rad) {
                const s = Math.sin(rad);
                const c = Math.cos(rad);
                const a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
                const a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
                
                out[0] = a[0]; out[1] = a[1]; out[2] = a[2]; out[3] = a[3];
                out[4] = a10 * c + a20 * s;
                out[5] = a11 * c + a21 * s;
                out[6] = a12 * c + a22 * s;
                out[7] = a13 * c + a23 * s;
                out[8] = a20 * c - a10 * s;
                out[9] = a21 * c - a11 * s;
                out[10] = a22 * c - a12 * s;
                out[11] = a23 * c - a13 * s;
                out[12] = a[12]; out[13] = a[13]; out[14] = a[14]; out[15] = a[15];
                return out;
            }
            
            rotateY(out, a, rad) {
                const s = Math.sin(rad);
                const c = Math.cos(rad);
                const a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
                const a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
                
                out[0] = a00 * c - a20 * s;
                out[1] = a01 * c - a21 * s;
                out[2] = a02 * c - a22 * s;
                out[3] = a03 * c - a23 * s;
                out[4] = a[4]; out[5] = a[5]; out[6] = a[6]; out[7] = a[7];
                out[8] = a00 * s + a20 * c;
                out[9] = a01 * s + a21 * c;
                out[10] = a02 * s + a22 * c;
                out[11] = a03 * s + a23 * c;
                out[12] = a[12]; out[13] = a[13]; out[14] = a[14]; out[15] = a[15];
                return out;
            }
            
            render() {
                const gl = this.gl;
                const currentTime = Date.now();
                const time = currentTime / 1000.0;
                
                // Update performance stats
                this.frameCount++;
                if (this.frameCount % 60 === 0) {
                    const elapsed = currentTime - this.startTime;
                    this.fps = Math.round((this.frameCount * 1000) / elapsed);
                    const frameTime = Math.round((currentTime - this.lastTime));
                    
                    document.getElementById('fps').textContent = this.fps;
                    document.getElementById('frameTime').textContent = frameTime + 'ms';
                    document.getElementById('frameCount').textContent = this.frameCount;
                }
                this.lastTime = currentTime;
                
                // Clear
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
                
                // Use program
                gl.useProgram(this.program);
                
                // Bind buffers and setup attributes
                gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
                
                gl.enableVertexAttribArray(this.aPosition);
                gl.vertexAttribPointer(this.aPosition, 3, gl.FLOAT, false, 24, 0);
                
                gl.enableVertexAttribArray(this.aColor);
                gl.vertexAttribPointer(this.aColor, 3, gl.FLOAT, false, 24, 12);
                
                // Create matrices
                const projection = this.createMatrix4();
                const view = this.createMatrix4();
                const model = this.createMatrix4();
                
                // Setup projection matrix
                const aspect = this.canvas.width / this.canvas.height;
                this.perspective(projection, Math.PI / 4, aspect, 0.1, 100.0);
                
                // Setup view matrix (camera at z=5, looking at origin)
                this.identity(view);
                this.translate(view, view, [0, 0, -5]);
                
                // Setup model matrix (rotating cube)
                this.identity(model);
                this.rotateX(model, model, time * 0.5);
                this.rotateY(model, model, time * 0.3);
                
                // Set uniforms
                gl.uniformMatrix4fv(this.uProjection, false, projection);
                gl.uniformMatrix4fv(this.uView, false, view);
                gl.uniformMatrix4fv(this.uModel, false, model);
                
                // Draw
                gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);
                
                // Continue render loop
                requestAnimationFrame(() => this.render());
            }
        }
        
        // Start when page loads
        window.addEventListener('load', () => {
            new SimpleCubeTest();
        });
        
        // Handle window resize
        window.addEventListener('resize', () => {
            const canvas = document.getElementById('canvas');
            // Keep canvas size fixed for this test
            console.log('Window resized, canvas size unchanged');
        });
    </script>
</body>
</html>