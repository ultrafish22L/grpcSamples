// Copyright (C) 2025 OTOY NZ Ltd.

// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: apiimageinfo.proto
// Original file comments:
// ////////////////////////////////////////////////////////////////////////////
// WARNING: This code is machine generated. Manual changes will be overridden.
//
#ifndef GRPC_apiimageinfo_2eproto__INCLUDED
#define GRPC_apiimageinfo_2eproto__INCLUDED

#include "apiimageinfo.pb.h"

#include <functional>
#include <grpcpp/generic/async_generic_service.h>
#include <grpcpp/support/async_stream.h>
#include <grpcpp/support/async_unary_call.h>
#include <grpcpp/support/client_callback.h>
#include <grpcpp/client_context.h>
#include <grpcpp/completion_queue.h>
#include <grpcpp/support/message_allocator.h>
#include <grpcpp/support/method_handler.h>
#include <grpcpp/impl/proto_utils.h>
#include <grpcpp/impl/rpc_method.h>
#include <grpcpp/support/server_callback.h>
#include <grpcpp/impl/server_callback_handlers.h>
#include <grpcpp/server_context.h>
#include <grpcpp/impl/service_type.h>
#include <grpcpp/support/status.h>
#include <grpcpp/support/stub_options.h>
#include <grpcpp/support/sync_stream.h>
#include <grpcpp/ports_def.inc>

namespace octaneapi {

// GRPC interface definition for class 'ImageInfo' from 'apiimageinfo.h'
class ImageInfoService final {
 public:
  static constexpr char const* service_full_name() {
    return "octaneapi.ImageInfoService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // / Initializes the current ImageInfo object with the image file at the given path
    // /
    // / 
    virtual ::grpc::Status initFromFile(::grpc::ClientContext* context, const ::octaneapi::ImageInfo_initFromFileRequest& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncinitFromFile(::grpc::ClientContext* context, const ::octaneapi::ImageInfo_initFromFileRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncinitFromFileRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncinitFromFile(::grpc::ClientContext* context, const ::octaneapi::ImageInfo_initFromFileRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncinitFromFileRaw(context, request, cq));
    }
    // / Initializes the current ImageInfo object from the given buffer with the given length
    // /
    // / 
    virtual ::grpc::Status initFromBuffer(::grpc::ClientContext* context, const ::octaneapi::ImageInfo_initFromBufferRequest& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncinitFromBuffer(::grpc::ClientContext* context, const ::octaneapi::ImageInfo_initFromBufferRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncinitFromBufferRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncinitFromBuffer(::grpc::ClientContext* context, const ::octaneapi::ImageInfo_initFromBufferRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncinitFromBufferRaw(context, request, cq));
    }
    // / Gets the layer info using the given layer index
    // /
    // / 
    virtual ::grpc::Status layerInfo(::grpc::ClientContext* context, const ::octaneapi::ImageInfo_layerInfoRequest& request, ::octaneapi::ImageInfo_layerInfoResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ImageInfo_layerInfoResponse>> AsynclayerInfo(::grpc::ClientContext* context, const ::octaneapi::ImageInfo_layerInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ImageInfo_layerInfoResponse>>(AsynclayerInfoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ImageInfo_layerInfoResponse>> PrepareAsynclayerInfo(::grpc::ClientContext* context, const ::octaneapi::ImageInfo_layerInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ImageInfo_layerInfoResponse>>(PrepareAsynclayerInfoRaw(context, request, cq));
    }
    // / Gets the layer count of the current image
    virtual ::grpc::Status layerCount(::grpc::ClientContext* context, const ::octaneapi::ImageInfo_layerCountRequest& request, ::octaneapi::ImageInfo_layerCountResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ImageInfo_layerCountResponse>> AsynclayerCount(::grpc::ClientContext* context, const ::octaneapi::ImageInfo_layerCountRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ImageInfo_layerCountResponse>>(AsynclayerCountRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ImageInfo_layerCountResponse>> PrepareAsynclayerCount(::grpc::ClientContext* context, const ::octaneapi::ImageInfo_layerCountRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ImageInfo_layerCountResponse>>(PrepareAsynclayerCountRaw(context, request, cq));
    }
    // / Gets the size of the image in pixel
    virtual ::grpc::Status size(::grpc::ClientContext* context, const ::octaneapi::ImageInfo_sizeRequest& request, ::octaneapi::ImageInfo_sizeResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ImageInfo_sizeResponse>> Asyncsize(::grpc::ClientContext* context, const ::octaneapi::ImageInfo_sizeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ImageInfo_sizeResponse>>(AsyncsizeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ImageInfo_sizeResponse>> PrepareAsyncsize(::grpc::ClientContext* context, const ::octaneapi::ImageInfo_sizeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ImageInfo_sizeResponse>>(PrepareAsyncsizeRaw(context, request, cq));
    }
    // / Checks if the current image is a HDR image
    virtual ::grpc::Status isHdr(::grpc::ClientContext* context, const ::octaneapi::ImageInfo_isHdrRequest& request, ::octaneapi::ImageInfo_isHdrResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ImageInfo_isHdrResponse>> AsyncisHdr(::grpc::ClientContext* context, const ::octaneapi::ImageInfo_isHdrRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ImageInfo_isHdrResponse>>(AsyncisHdrRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ImageInfo_isHdrResponse>> PrepareAsyncisHdr(::grpc::ClientContext* context, const ::octaneapi::ImageInfo_isHdrRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ImageInfo_isHdrResponse>>(PrepareAsyncisHdrRaw(context, request, cq));
    }
    // / Checks if the current image is compressed
    virtual ::grpc::Status isCompressed(::grpc::ClientContext* context, const ::octaneapi::ImageInfo_isCompressedRequest& request, ::octaneapi::ImageInfo_isCompressedResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ImageInfo_isCompressedResponse>> AsyncisCompressed(::grpc::ClientContext* context, const ::octaneapi::ImageInfo_isCompressedRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ImageInfo_isCompressedResponse>>(AsyncisCompressedRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ImageInfo_isCompressedResponse>> PrepareAsyncisCompressed(::grpc::ClientContext* context, const ::octaneapi::ImageInfo_isCompressedRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ImageInfo_isCompressedResponse>>(PrepareAsyncisCompressedRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      // / Initializes the current ImageInfo object with the image file at the given path
      // /
      // / 
      virtual void initFromFile(::grpc::ClientContext* context, const ::octaneapi::ImageInfo_initFromFileRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void initFromFile(::grpc::ClientContext* context, const ::octaneapi::ImageInfo_initFromFileRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Initializes the current ImageInfo object from the given buffer with the given length
      // /
      // / 
      virtual void initFromBuffer(::grpc::ClientContext* context, const ::octaneapi::ImageInfo_initFromBufferRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void initFromBuffer(::grpc::ClientContext* context, const ::octaneapi::ImageInfo_initFromBufferRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Gets the layer info using the given layer index
      // /
      // / 
      virtual void layerInfo(::grpc::ClientContext* context, const ::octaneapi::ImageInfo_layerInfoRequest* request, ::octaneapi::ImageInfo_layerInfoResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void layerInfo(::grpc::ClientContext* context, const ::octaneapi::ImageInfo_layerInfoRequest* request, ::octaneapi::ImageInfo_layerInfoResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Gets the layer count of the current image
      virtual void layerCount(::grpc::ClientContext* context, const ::octaneapi::ImageInfo_layerCountRequest* request, ::octaneapi::ImageInfo_layerCountResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void layerCount(::grpc::ClientContext* context, const ::octaneapi::ImageInfo_layerCountRequest* request, ::octaneapi::ImageInfo_layerCountResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Gets the size of the image in pixel
      virtual void size(::grpc::ClientContext* context, const ::octaneapi::ImageInfo_sizeRequest* request, ::octaneapi::ImageInfo_sizeResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void size(::grpc::ClientContext* context, const ::octaneapi::ImageInfo_sizeRequest* request, ::octaneapi::ImageInfo_sizeResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Checks if the current image is a HDR image
      virtual void isHdr(::grpc::ClientContext* context, const ::octaneapi::ImageInfo_isHdrRequest* request, ::octaneapi::ImageInfo_isHdrResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void isHdr(::grpc::ClientContext* context, const ::octaneapi::ImageInfo_isHdrRequest* request, ::octaneapi::ImageInfo_isHdrResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Checks if the current image is compressed
      virtual void isCompressed(::grpc::ClientContext* context, const ::octaneapi::ImageInfo_isCompressedRequest* request, ::octaneapi::ImageInfo_isCompressedResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void isCompressed(::grpc::ClientContext* context, const ::octaneapi::ImageInfo_isCompressedRequest* request, ::octaneapi::ImageInfo_isCompressedResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncinitFromFileRaw(::grpc::ClientContext* context, const ::octaneapi::ImageInfo_initFromFileRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncinitFromFileRaw(::grpc::ClientContext* context, const ::octaneapi::ImageInfo_initFromFileRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncinitFromBufferRaw(::grpc::ClientContext* context, const ::octaneapi::ImageInfo_initFromBufferRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncinitFromBufferRaw(::grpc::ClientContext* context, const ::octaneapi::ImageInfo_initFromBufferRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ImageInfo_layerInfoResponse>* AsynclayerInfoRaw(::grpc::ClientContext* context, const ::octaneapi::ImageInfo_layerInfoRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ImageInfo_layerInfoResponse>* PrepareAsynclayerInfoRaw(::grpc::ClientContext* context, const ::octaneapi::ImageInfo_layerInfoRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ImageInfo_layerCountResponse>* AsynclayerCountRaw(::grpc::ClientContext* context, const ::octaneapi::ImageInfo_layerCountRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ImageInfo_layerCountResponse>* PrepareAsynclayerCountRaw(::grpc::ClientContext* context, const ::octaneapi::ImageInfo_layerCountRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ImageInfo_sizeResponse>* AsyncsizeRaw(::grpc::ClientContext* context, const ::octaneapi::ImageInfo_sizeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ImageInfo_sizeResponse>* PrepareAsyncsizeRaw(::grpc::ClientContext* context, const ::octaneapi::ImageInfo_sizeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ImageInfo_isHdrResponse>* AsyncisHdrRaw(::grpc::ClientContext* context, const ::octaneapi::ImageInfo_isHdrRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ImageInfo_isHdrResponse>* PrepareAsyncisHdrRaw(::grpc::ClientContext* context, const ::octaneapi::ImageInfo_isHdrRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ImageInfo_isCompressedResponse>* AsyncisCompressedRaw(::grpc::ClientContext* context, const ::octaneapi::ImageInfo_isCompressedRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ImageInfo_isCompressedResponse>* PrepareAsyncisCompressedRaw(::grpc::ClientContext* context, const ::octaneapi::ImageInfo_isCompressedRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status initFromFile(::grpc::ClientContext* context, const ::octaneapi::ImageInfo_initFromFileRequest& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncinitFromFile(::grpc::ClientContext* context, const ::octaneapi::ImageInfo_initFromFileRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncinitFromFileRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncinitFromFile(::grpc::ClientContext* context, const ::octaneapi::ImageInfo_initFromFileRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncinitFromFileRaw(context, request, cq));
    }
    ::grpc::Status initFromBuffer(::grpc::ClientContext* context, const ::octaneapi::ImageInfo_initFromBufferRequest& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncinitFromBuffer(::grpc::ClientContext* context, const ::octaneapi::ImageInfo_initFromBufferRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncinitFromBufferRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncinitFromBuffer(::grpc::ClientContext* context, const ::octaneapi::ImageInfo_initFromBufferRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncinitFromBufferRaw(context, request, cq));
    }
    ::grpc::Status layerInfo(::grpc::ClientContext* context, const ::octaneapi::ImageInfo_layerInfoRequest& request, ::octaneapi::ImageInfo_layerInfoResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ImageInfo_layerInfoResponse>> AsynclayerInfo(::grpc::ClientContext* context, const ::octaneapi::ImageInfo_layerInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ImageInfo_layerInfoResponse>>(AsynclayerInfoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ImageInfo_layerInfoResponse>> PrepareAsynclayerInfo(::grpc::ClientContext* context, const ::octaneapi::ImageInfo_layerInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ImageInfo_layerInfoResponse>>(PrepareAsynclayerInfoRaw(context, request, cq));
    }
    ::grpc::Status layerCount(::grpc::ClientContext* context, const ::octaneapi::ImageInfo_layerCountRequest& request, ::octaneapi::ImageInfo_layerCountResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ImageInfo_layerCountResponse>> AsynclayerCount(::grpc::ClientContext* context, const ::octaneapi::ImageInfo_layerCountRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ImageInfo_layerCountResponse>>(AsynclayerCountRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ImageInfo_layerCountResponse>> PrepareAsynclayerCount(::grpc::ClientContext* context, const ::octaneapi::ImageInfo_layerCountRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ImageInfo_layerCountResponse>>(PrepareAsynclayerCountRaw(context, request, cq));
    }
    ::grpc::Status size(::grpc::ClientContext* context, const ::octaneapi::ImageInfo_sizeRequest& request, ::octaneapi::ImageInfo_sizeResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ImageInfo_sizeResponse>> Asyncsize(::grpc::ClientContext* context, const ::octaneapi::ImageInfo_sizeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ImageInfo_sizeResponse>>(AsyncsizeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ImageInfo_sizeResponse>> PrepareAsyncsize(::grpc::ClientContext* context, const ::octaneapi::ImageInfo_sizeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ImageInfo_sizeResponse>>(PrepareAsyncsizeRaw(context, request, cq));
    }
    ::grpc::Status isHdr(::grpc::ClientContext* context, const ::octaneapi::ImageInfo_isHdrRequest& request, ::octaneapi::ImageInfo_isHdrResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ImageInfo_isHdrResponse>> AsyncisHdr(::grpc::ClientContext* context, const ::octaneapi::ImageInfo_isHdrRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ImageInfo_isHdrResponse>>(AsyncisHdrRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ImageInfo_isHdrResponse>> PrepareAsyncisHdr(::grpc::ClientContext* context, const ::octaneapi::ImageInfo_isHdrRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ImageInfo_isHdrResponse>>(PrepareAsyncisHdrRaw(context, request, cq));
    }
    ::grpc::Status isCompressed(::grpc::ClientContext* context, const ::octaneapi::ImageInfo_isCompressedRequest& request, ::octaneapi::ImageInfo_isCompressedResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ImageInfo_isCompressedResponse>> AsyncisCompressed(::grpc::ClientContext* context, const ::octaneapi::ImageInfo_isCompressedRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ImageInfo_isCompressedResponse>>(AsyncisCompressedRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ImageInfo_isCompressedResponse>> PrepareAsyncisCompressed(::grpc::ClientContext* context, const ::octaneapi::ImageInfo_isCompressedRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ImageInfo_isCompressedResponse>>(PrepareAsyncisCompressedRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void initFromFile(::grpc::ClientContext* context, const ::octaneapi::ImageInfo_initFromFileRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      void initFromFile(::grpc::ClientContext* context, const ::octaneapi::ImageInfo_initFromFileRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void initFromBuffer(::grpc::ClientContext* context, const ::octaneapi::ImageInfo_initFromBufferRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      void initFromBuffer(::grpc::ClientContext* context, const ::octaneapi::ImageInfo_initFromBufferRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void layerInfo(::grpc::ClientContext* context, const ::octaneapi::ImageInfo_layerInfoRequest* request, ::octaneapi::ImageInfo_layerInfoResponse* response, std::function<void(::grpc::Status)>) override;
      void layerInfo(::grpc::ClientContext* context, const ::octaneapi::ImageInfo_layerInfoRequest* request, ::octaneapi::ImageInfo_layerInfoResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void layerCount(::grpc::ClientContext* context, const ::octaneapi::ImageInfo_layerCountRequest* request, ::octaneapi::ImageInfo_layerCountResponse* response, std::function<void(::grpc::Status)>) override;
      void layerCount(::grpc::ClientContext* context, const ::octaneapi::ImageInfo_layerCountRequest* request, ::octaneapi::ImageInfo_layerCountResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void size(::grpc::ClientContext* context, const ::octaneapi::ImageInfo_sizeRequest* request, ::octaneapi::ImageInfo_sizeResponse* response, std::function<void(::grpc::Status)>) override;
      void size(::grpc::ClientContext* context, const ::octaneapi::ImageInfo_sizeRequest* request, ::octaneapi::ImageInfo_sizeResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void isHdr(::grpc::ClientContext* context, const ::octaneapi::ImageInfo_isHdrRequest* request, ::octaneapi::ImageInfo_isHdrResponse* response, std::function<void(::grpc::Status)>) override;
      void isHdr(::grpc::ClientContext* context, const ::octaneapi::ImageInfo_isHdrRequest* request, ::octaneapi::ImageInfo_isHdrResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void isCompressed(::grpc::ClientContext* context, const ::octaneapi::ImageInfo_isCompressedRequest* request, ::octaneapi::ImageInfo_isCompressedResponse* response, std::function<void(::grpc::Status)>) override;
      void isCompressed(::grpc::ClientContext* context, const ::octaneapi::ImageInfo_isCompressedRequest* request, ::octaneapi::ImageInfo_isCompressedResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncinitFromFileRaw(::grpc::ClientContext* context, const ::octaneapi::ImageInfo_initFromFileRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncinitFromFileRaw(::grpc::ClientContext* context, const ::octaneapi::ImageInfo_initFromFileRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncinitFromBufferRaw(::grpc::ClientContext* context, const ::octaneapi::ImageInfo_initFromBufferRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncinitFromBufferRaw(::grpc::ClientContext* context, const ::octaneapi::ImageInfo_initFromBufferRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ImageInfo_layerInfoResponse>* AsynclayerInfoRaw(::grpc::ClientContext* context, const ::octaneapi::ImageInfo_layerInfoRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ImageInfo_layerInfoResponse>* PrepareAsynclayerInfoRaw(::grpc::ClientContext* context, const ::octaneapi::ImageInfo_layerInfoRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ImageInfo_layerCountResponse>* AsynclayerCountRaw(::grpc::ClientContext* context, const ::octaneapi::ImageInfo_layerCountRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ImageInfo_layerCountResponse>* PrepareAsynclayerCountRaw(::grpc::ClientContext* context, const ::octaneapi::ImageInfo_layerCountRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ImageInfo_sizeResponse>* AsyncsizeRaw(::grpc::ClientContext* context, const ::octaneapi::ImageInfo_sizeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ImageInfo_sizeResponse>* PrepareAsyncsizeRaw(::grpc::ClientContext* context, const ::octaneapi::ImageInfo_sizeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ImageInfo_isHdrResponse>* AsyncisHdrRaw(::grpc::ClientContext* context, const ::octaneapi::ImageInfo_isHdrRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ImageInfo_isHdrResponse>* PrepareAsyncisHdrRaw(::grpc::ClientContext* context, const ::octaneapi::ImageInfo_isHdrRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ImageInfo_isCompressedResponse>* AsyncisCompressedRaw(::grpc::ClientContext* context, const ::octaneapi::ImageInfo_isCompressedRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ImageInfo_isCompressedResponse>* PrepareAsyncisCompressedRaw(::grpc::ClientContext* context, const ::octaneapi::ImageInfo_isCompressedRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_initFromFile_;
    const ::grpc::internal::RpcMethod rpcmethod_initFromBuffer_;
    const ::grpc::internal::RpcMethod rpcmethod_layerInfo_;
    const ::grpc::internal::RpcMethod rpcmethod_layerCount_;
    const ::grpc::internal::RpcMethod rpcmethod_size_;
    const ::grpc::internal::RpcMethod rpcmethod_isHdr_;
    const ::grpc::internal::RpcMethod rpcmethod_isCompressed_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // / Initializes the current ImageInfo object with the image file at the given path
    // /
    // / 
    virtual ::grpc::Status initFromFile(::grpc::ServerContext* context, const ::octaneapi::ImageInfo_initFromFileRequest* request, ::google::protobuf::Empty* response);
    // / Initializes the current ImageInfo object from the given buffer with the given length
    // /
    // / 
    virtual ::grpc::Status initFromBuffer(::grpc::ServerContext* context, const ::octaneapi::ImageInfo_initFromBufferRequest* request, ::google::protobuf::Empty* response);
    // / Gets the layer info using the given layer index
    // /
    // / 
    virtual ::grpc::Status layerInfo(::grpc::ServerContext* context, const ::octaneapi::ImageInfo_layerInfoRequest* request, ::octaneapi::ImageInfo_layerInfoResponse* response);
    // / Gets the layer count of the current image
    virtual ::grpc::Status layerCount(::grpc::ServerContext* context, const ::octaneapi::ImageInfo_layerCountRequest* request, ::octaneapi::ImageInfo_layerCountResponse* response);
    // / Gets the size of the image in pixel
    virtual ::grpc::Status size(::grpc::ServerContext* context, const ::octaneapi::ImageInfo_sizeRequest* request, ::octaneapi::ImageInfo_sizeResponse* response);
    // / Checks if the current image is a HDR image
    virtual ::grpc::Status isHdr(::grpc::ServerContext* context, const ::octaneapi::ImageInfo_isHdrRequest* request, ::octaneapi::ImageInfo_isHdrResponse* response);
    // / Checks if the current image is compressed
    virtual ::grpc::Status isCompressed(::grpc::ServerContext* context, const ::octaneapi::ImageInfo_isCompressedRequest* request, ::octaneapi::ImageInfo_isCompressedResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_initFromFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_initFromFile() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_initFromFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status initFromFile(::grpc::ServerContext* /*context*/, const ::octaneapi::ImageInfo_initFromFileRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestinitFromFile(::grpc::ServerContext* context, ::octaneapi::ImageInfo_initFromFileRequest* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_initFromBuffer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_initFromBuffer() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_initFromBuffer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status initFromBuffer(::grpc::ServerContext* /*context*/, const ::octaneapi::ImageInfo_initFromBufferRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestinitFromBuffer(::grpc::ServerContext* context, ::octaneapi::ImageInfo_initFromBufferRequest* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_layerInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_layerInfo() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_layerInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status layerInfo(::grpc::ServerContext* /*context*/, const ::octaneapi::ImageInfo_layerInfoRequest* /*request*/, ::octaneapi::ImageInfo_layerInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestlayerInfo(::grpc::ServerContext* context, ::octaneapi::ImageInfo_layerInfoRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ImageInfo_layerInfoResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_layerCount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_layerCount() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_layerCount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status layerCount(::grpc::ServerContext* /*context*/, const ::octaneapi::ImageInfo_layerCountRequest* /*request*/, ::octaneapi::ImageInfo_layerCountResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestlayerCount(::grpc::ServerContext* context, ::octaneapi::ImageInfo_layerCountRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ImageInfo_layerCountResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_size : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_size() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_size() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status size(::grpc::ServerContext* /*context*/, const ::octaneapi::ImageInfo_sizeRequest* /*request*/, ::octaneapi::ImageInfo_sizeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestsize(::grpc::ServerContext* context, ::octaneapi::ImageInfo_sizeRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ImageInfo_sizeResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_isHdr : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_isHdr() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_isHdr() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isHdr(::grpc::ServerContext* /*context*/, const ::octaneapi::ImageInfo_isHdrRequest* /*request*/, ::octaneapi::ImageInfo_isHdrResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestisHdr(::grpc::ServerContext* context, ::octaneapi::ImageInfo_isHdrRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ImageInfo_isHdrResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_isCompressed : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_isCompressed() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_isCompressed() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isCompressed(::grpc::ServerContext* /*context*/, const ::octaneapi::ImageInfo_isCompressedRequest* /*request*/, ::octaneapi::ImageInfo_isCompressedResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestisCompressed(::grpc::ServerContext* context, ::octaneapi::ImageInfo_isCompressedRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ImageInfo_isCompressedResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_initFromFile<WithAsyncMethod_initFromBuffer<WithAsyncMethod_layerInfo<WithAsyncMethod_layerCount<WithAsyncMethod_size<WithAsyncMethod_isHdr<WithAsyncMethod_isCompressed<Service > > > > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_initFromFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_initFromFile() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ImageInfo_initFromFileRequest, ::google::protobuf::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ImageInfo_initFromFileRequest* request, ::google::protobuf::Empty* response) { return this->initFromFile(context, request, response); }));}
    void SetMessageAllocatorFor_initFromFile(
        ::grpc::MessageAllocator< ::octaneapi::ImageInfo_initFromFileRequest, ::google::protobuf::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ImageInfo_initFromFileRequest, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_initFromFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status initFromFile(::grpc::ServerContext* /*context*/, const ::octaneapi::ImageInfo_initFromFileRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* initFromFile(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ImageInfo_initFromFileRequest* /*request*/, ::google::protobuf::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_initFromBuffer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_initFromBuffer() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ImageInfo_initFromBufferRequest, ::google::protobuf::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ImageInfo_initFromBufferRequest* request, ::google::protobuf::Empty* response) { return this->initFromBuffer(context, request, response); }));}
    void SetMessageAllocatorFor_initFromBuffer(
        ::grpc::MessageAllocator< ::octaneapi::ImageInfo_initFromBufferRequest, ::google::protobuf::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ImageInfo_initFromBufferRequest, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_initFromBuffer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status initFromBuffer(::grpc::ServerContext* /*context*/, const ::octaneapi::ImageInfo_initFromBufferRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* initFromBuffer(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ImageInfo_initFromBufferRequest* /*request*/, ::google::protobuf::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_layerInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_layerInfo() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ImageInfo_layerInfoRequest, ::octaneapi::ImageInfo_layerInfoResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ImageInfo_layerInfoRequest* request, ::octaneapi::ImageInfo_layerInfoResponse* response) { return this->layerInfo(context, request, response); }));}
    void SetMessageAllocatorFor_layerInfo(
        ::grpc::MessageAllocator< ::octaneapi::ImageInfo_layerInfoRequest, ::octaneapi::ImageInfo_layerInfoResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ImageInfo_layerInfoRequest, ::octaneapi::ImageInfo_layerInfoResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_layerInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status layerInfo(::grpc::ServerContext* /*context*/, const ::octaneapi::ImageInfo_layerInfoRequest* /*request*/, ::octaneapi::ImageInfo_layerInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* layerInfo(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ImageInfo_layerInfoRequest* /*request*/, ::octaneapi::ImageInfo_layerInfoResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_layerCount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_layerCount() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ImageInfo_layerCountRequest, ::octaneapi::ImageInfo_layerCountResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ImageInfo_layerCountRequest* request, ::octaneapi::ImageInfo_layerCountResponse* response) { return this->layerCount(context, request, response); }));}
    void SetMessageAllocatorFor_layerCount(
        ::grpc::MessageAllocator< ::octaneapi::ImageInfo_layerCountRequest, ::octaneapi::ImageInfo_layerCountResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ImageInfo_layerCountRequest, ::octaneapi::ImageInfo_layerCountResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_layerCount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status layerCount(::grpc::ServerContext* /*context*/, const ::octaneapi::ImageInfo_layerCountRequest* /*request*/, ::octaneapi::ImageInfo_layerCountResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* layerCount(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ImageInfo_layerCountRequest* /*request*/, ::octaneapi::ImageInfo_layerCountResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_size : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_size() {
      ::grpc::Service::MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ImageInfo_sizeRequest, ::octaneapi::ImageInfo_sizeResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ImageInfo_sizeRequest* request, ::octaneapi::ImageInfo_sizeResponse* response) { return this->size(context, request, response); }));}
    void SetMessageAllocatorFor_size(
        ::grpc::MessageAllocator< ::octaneapi::ImageInfo_sizeRequest, ::octaneapi::ImageInfo_sizeResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ImageInfo_sizeRequest, ::octaneapi::ImageInfo_sizeResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_size() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status size(::grpc::ServerContext* /*context*/, const ::octaneapi::ImageInfo_sizeRequest* /*request*/, ::octaneapi::ImageInfo_sizeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* size(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ImageInfo_sizeRequest* /*request*/, ::octaneapi::ImageInfo_sizeResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_isHdr : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_isHdr() {
      ::grpc::Service::MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ImageInfo_isHdrRequest, ::octaneapi::ImageInfo_isHdrResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ImageInfo_isHdrRequest* request, ::octaneapi::ImageInfo_isHdrResponse* response) { return this->isHdr(context, request, response); }));}
    void SetMessageAllocatorFor_isHdr(
        ::grpc::MessageAllocator< ::octaneapi::ImageInfo_isHdrRequest, ::octaneapi::ImageInfo_isHdrResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ImageInfo_isHdrRequest, ::octaneapi::ImageInfo_isHdrResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_isHdr() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isHdr(::grpc::ServerContext* /*context*/, const ::octaneapi::ImageInfo_isHdrRequest* /*request*/, ::octaneapi::ImageInfo_isHdrResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* isHdr(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ImageInfo_isHdrRequest* /*request*/, ::octaneapi::ImageInfo_isHdrResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_isCompressed : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_isCompressed() {
      ::grpc::Service::MarkMethodCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ImageInfo_isCompressedRequest, ::octaneapi::ImageInfo_isCompressedResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ImageInfo_isCompressedRequest* request, ::octaneapi::ImageInfo_isCompressedResponse* response) { return this->isCompressed(context, request, response); }));}
    void SetMessageAllocatorFor_isCompressed(
        ::grpc::MessageAllocator< ::octaneapi::ImageInfo_isCompressedRequest, ::octaneapi::ImageInfo_isCompressedResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ImageInfo_isCompressedRequest, ::octaneapi::ImageInfo_isCompressedResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_isCompressed() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isCompressed(::grpc::ServerContext* /*context*/, const ::octaneapi::ImageInfo_isCompressedRequest* /*request*/, ::octaneapi::ImageInfo_isCompressedResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* isCompressed(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ImageInfo_isCompressedRequest* /*request*/, ::octaneapi::ImageInfo_isCompressedResponse* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_initFromFile<WithCallbackMethod_initFromBuffer<WithCallbackMethod_layerInfo<WithCallbackMethod_layerCount<WithCallbackMethod_size<WithCallbackMethod_isHdr<WithCallbackMethod_isCompressed<Service > > > > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_initFromFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_initFromFile() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_initFromFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status initFromFile(::grpc::ServerContext* /*context*/, const ::octaneapi::ImageInfo_initFromFileRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_initFromBuffer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_initFromBuffer() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_initFromBuffer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status initFromBuffer(::grpc::ServerContext* /*context*/, const ::octaneapi::ImageInfo_initFromBufferRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_layerInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_layerInfo() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_layerInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status layerInfo(::grpc::ServerContext* /*context*/, const ::octaneapi::ImageInfo_layerInfoRequest* /*request*/, ::octaneapi::ImageInfo_layerInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_layerCount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_layerCount() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_layerCount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status layerCount(::grpc::ServerContext* /*context*/, const ::octaneapi::ImageInfo_layerCountRequest* /*request*/, ::octaneapi::ImageInfo_layerCountResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_size : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_size() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_size() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status size(::grpc::ServerContext* /*context*/, const ::octaneapi::ImageInfo_sizeRequest* /*request*/, ::octaneapi::ImageInfo_sizeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_isHdr : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_isHdr() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_isHdr() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isHdr(::grpc::ServerContext* /*context*/, const ::octaneapi::ImageInfo_isHdrRequest* /*request*/, ::octaneapi::ImageInfo_isHdrResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_isCompressed : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_isCompressed() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_isCompressed() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isCompressed(::grpc::ServerContext* /*context*/, const ::octaneapi::ImageInfo_isCompressedRequest* /*request*/, ::octaneapi::ImageInfo_isCompressedResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_initFromFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_initFromFile() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_initFromFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status initFromFile(::grpc::ServerContext* /*context*/, const ::octaneapi::ImageInfo_initFromFileRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestinitFromFile(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_initFromBuffer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_initFromBuffer() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_initFromBuffer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status initFromBuffer(::grpc::ServerContext* /*context*/, const ::octaneapi::ImageInfo_initFromBufferRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestinitFromBuffer(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_layerInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_layerInfo() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_layerInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status layerInfo(::grpc::ServerContext* /*context*/, const ::octaneapi::ImageInfo_layerInfoRequest* /*request*/, ::octaneapi::ImageInfo_layerInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestlayerInfo(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_layerCount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_layerCount() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_layerCount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status layerCount(::grpc::ServerContext* /*context*/, const ::octaneapi::ImageInfo_layerCountRequest* /*request*/, ::octaneapi::ImageInfo_layerCountResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestlayerCount(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_size : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_size() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_size() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status size(::grpc::ServerContext* /*context*/, const ::octaneapi::ImageInfo_sizeRequest* /*request*/, ::octaneapi::ImageInfo_sizeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestsize(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_isHdr : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_isHdr() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_isHdr() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isHdr(::grpc::ServerContext* /*context*/, const ::octaneapi::ImageInfo_isHdrRequest* /*request*/, ::octaneapi::ImageInfo_isHdrResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestisHdr(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_isCompressed : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_isCompressed() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_isCompressed() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isCompressed(::grpc::ServerContext* /*context*/, const ::octaneapi::ImageInfo_isCompressedRequest* /*request*/, ::octaneapi::ImageInfo_isCompressedResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestisCompressed(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_initFromFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_initFromFile() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->initFromFile(context, request, response); }));
    }
    ~WithRawCallbackMethod_initFromFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status initFromFile(::grpc::ServerContext* /*context*/, const ::octaneapi::ImageInfo_initFromFileRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* initFromFile(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_initFromBuffer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_initFromBuffer() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->initFromBuffer(context, request, response); }));
    }
    ~WithRawCallbackMethod_initFromBuffer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status initFromBuffer(::grpc::ServerContext* /*context*/, const ::octaneapi::ImageInfo_initFromBufferRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* initFromBuffer(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_layerInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_layerInfo() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->layerInfo(context, request, response); }));
    }
    ~WithRawCallbackMethod_layerInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status layerInfo(::grpc::ServerContext* /*context*/, const ::octaneapi::ImageInfo_layerInfoRequest* /*request*/, ::octaneapi::ImageInfo_layerInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* layerInfo(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_layerCount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_layerCount() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->layerCount(context, request, response); }));
    }
    ~WithRawCallbackMethod_layerCount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status layerCount(::grpc::ServerContext* /*context*/, const ::octaneapi::ImageInfo_layerCountRequest* /*request*/, ::octaneapi::ImageInfo_layerCountResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* layerCount(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_size : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_size() {
      ::grpc::Service::MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->size(context, request, response); }));
    }
    ~WithRawCallbackMethod_size() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status size(::grpc::ServerContext* /*context*/, const ::octaneapi::ImageInfo_sizeRequest* /*request*/, ::octaneapi::ImageInfo_sizeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* size(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_isHdr : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_isHdr() {
      ::grpc::Service::MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->isHdr(context, request, response); }));
    }
    ~WithRawCallbackMethod_isHdr() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isHdr(::grpc::ServerContext* /*context*/, const ::octaneapi::ImageInfo_isHdrRequest* /*request*/, ::octaneapi::ImageInfo_isHdrResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* isHdr(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_isCompressed : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_isCompressed() {
      ::grpc::Service::MarkMethodRawCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->isCompressed(context, request, response); }));
    }
    ~WithRawCallbackMethod_isCompressed() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isCompressed(::grpc::ServerContext* /*context*/, const ::octaneapi::ImageInfo_isCompressedRequest* /*request*/, ::octaneapi::ImageInfo_isCompressedResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* isCompressed(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_initFromFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_initFromFile() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ImageInfo_initFromFileRequest, ::google::protobuf::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ImageInfo_initFromFileRequest, ::google::protobuf::Empty>* streamer) {
                       return this->StreamedinitFromFile(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_initFromFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status initFromFile(::grpc::ServerContext* /*context*/, const ::octaneapi::ImageInfo_initFromFileRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedinitFromFile(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ImageInfo_initFromFileRequest,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_initFromBuffer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_initFromBuffer() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ImageInfo_initFromBufferRequest, ::google::protobuf::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ImageInfo_initFromBufferRequest, ::google::protobuf::Empty>* streamer) {
                       return this->StreamedinitFromBuffer(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_initFromBuffer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status initFromBuffer(::grpc::ServerContext* /*context*/, const ::octaneapi::ImageInfo_initFromBufferRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedinitFromBuffer(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ImageInfo_initFromBufferRequest,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_layerInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_layerInfo() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ImageInfo_layerInfoRequest, ::octaneapi::ImageInfo_layerInfoResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ImageInfo_layerInfoRequest, ::octaneapi::ImageInfo_layerInfoResponse>* streamer) {
                       return this->StreamedlayerInfo(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_layerInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status layerInfo(::grpc::ServerContext* /*context*/, const ::octaneapi::ImageInfo_layerInfoRequest* /*request*/, ::octaneapi::ImageInfo_layerInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedlayerInfo(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ImageInfo_layerInfoRequest,::octaneapi::ImageInfo_layerInfoResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_layerCount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_layerCount() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ImageInfo_layerCountRequest, ::octaneapi::ImageInfo_layerCountResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ImageInfo_layerCountRequest, ::octaneapi::ImageInfo_layerCountResponse>* streamer) {
                       return this->StreamedlayerCount(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_layerCount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status layerCount(::grpc::ServerContext* /*context*/, const ::octaneapi::ImageInfo_layerCountRequest* /*request*/, ::octaneapi::ImageInfo_layerCountResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedlayerCount(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ImageInfo_layerCountRequest,::octaneapi::ImageInfo_layerCountResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_size : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_size() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ImageInfo_sizeRequest, ::octaneapi::ImageInfo_sizeResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ImageInfo_sizeRequest, ::octaneapi::ImageInfo_sizeResponse>* streamer) {
                       return this->Streamedsize(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_size() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status size(::grpc::ServerContext* /*context*/, const ::octaneapi::ImageInfo_sizeRequest* /*request*/, ::octaneapi::ImageInfo_sizeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedsize(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ImageInfo_sizeRequest,::octaneapi::ImageInfo_sizeResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_isHdr : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_isHdr() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ImageInfo_isHdrRequest, ::octaneapi::ImageInfo_isHdrResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ImageInfo_isHdrRequest, ::octaneapi::ImageInfo_isHdrResponse>* streamer) {
                       return this->StreamedisHdr(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_isHdr() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status isHdr(::grpc::ServerContext* /*context*/, const ::octaneapi::ImageInfo_isHdrRequest* /*request*/, ::octaneapi::ImageInfo_isHdrResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedisHdr(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ImageInfo_isHdrRequest,::octaneapi::ImageInfo_isHdrResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_isCompressed : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_isCompressed() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ImageInfo_isCompressedRequest, ::octaneapi::ImageInfo_isCompressedResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ImageInfo_isCompressedRequest, ::octaneapi::ImageInfo_isCompressedResponse>* streamer) {
                       return this->StreamedisCompressed(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_isCompressed() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status isCompressed(::grpc::ServerContext* /*context*/, const ::octaneapi::ImageInfo_isCompressedRequest* /*request*/, ::octaneapi::ImageInfo_isCompressedResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedisCompressed(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ImageInfo_isCompressedRequest,::octaneapi::ImageInfo_isCompressedResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_initFromFile<WithStreamedUnaryMethod_initFromBuffer<WithStreamedUnaryMethod_layerInfo<WithStreamedUnaryMethod_layerCount<WithStreamedUnaryMethod_size<WithStreamedUnaryMethod_isHdr<WithStreamedUnaryMethod_isCompressed<Service > > > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_initFromFile<WithStreamedUnaryMethod_initFromBuffer<WithStreamedUnaryMethod_layerInfo<WithStreamedUnaryMethod_layerCount<WithStreamedUnaryMethod_size<WithStreamedUnaryMethod_isHdr<WithStreamedUnaryMethod_isCompressed<Service > > > > > > > StreamedService;
};

// GRPC interface definition for class 'LayerInfo' from 'apiimageinfo.h'
class LayerInfoService final {
 public:
  static constexpr char const* service_full_name() {
    return "octaneapi.LayerInfoService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // / Checks if the current layer has alpha data
    virtual ::grpc::Status hasTransparency(::grpc::ClientContext* context, const ::octaneapi::LayerInfo_hasTransparencyRequest& request, ::octaneapi::LayerInfo_hasTransparencyResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::LayerInfo_hasTransparencyResponse>> AsynchasTransparency(::grpc::ClientContext* context, const ::octaneapi::LayerInfo_hasTransparencyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::LayerInfo_hasTransparencyResponse>>(AsynchasTransparencyRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::LayerInfo_hasTransparencyResponse>> PrepareAsynchasTransparency(::grpc::ClientContext* context, const ::octaneapi::LayerInfo_hasTransparencyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::LayerInfo_hasTransparencyResponse>>(PrepareAsynchasTransparencyRaw(context, request, cq));
    }
    // / Checks if the current layer is gray scale data
    virtual ::grpc::Status isGrayscale(::grpc::ClientContext* context, const ::octaneapi::LayerInfo_isGrayscaleRequest& request, ::octaneapi::LayerInfo_isGrayscaleResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::LayerInfo_isGrayscaleResponse>> AsyncisGrayscale(::grpc::ClientContext* context, const ::octaneapi::LayerInfo_isGrayscaleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::LayerInfo_isGrayscaleResponse>>(AsyncisGrayscaleRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::LayerInfo_isGrayscaleResponse>> PrepareAsyncisGrayscale(::grpc::ClientContext* context, const ::octaneapi::LayerInfo_isGrayscaleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::LayerInfo_isGrayscaleResponse>>(PrepareAsyncisGrayscaleRaw(context, request, cq));
    }
    // / Gets the name of this layer
    virtual ::grpc::Status name(::grpc::ClientContext* context, const ::octaneapi::LayerInfo_nameRequest& request, ::octaneapi::LayerInfo_nameResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::LayerInfo_nameResponse>> Asyncname(::grpc::ClientContext* context, const ::octaneapi::LayerInfo_nameRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::LayerInfo_nameResponse>>(AsyncnameRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::LayerInfo_nameResponse>> PrepareAsyncname(::grpc::ClientContext* context, const ::octaneapi::LayerInfo_nameRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::LayerInfo_nameResponse>>(PrepareAsyncnameRaw(context, request, cq));
    }
    // / Gets the type of this layer's data
    virtual ::grpc::Status type(::grpc::ClientContext* context, const ::octaneapi::LayerInfo_typeRequest& request, ::octaneapi::LayerInfo_typeResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::LayerInfo_typeResponse>> Asynctype(::grpc::ClientContext* context, const ::octaneapi::LayerInfo_typeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::LayerInfo_typeResponse>>(AsynctypeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::LayerInfo_typeResponse>> PrepareAsynctype(::grpc::ClientContext* context, const ::octaneapi::LayerInfo_typeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::LayerInfo_typeResponse>>(PrepareAsynctypeRaw(context, request, cq));
    }
    // / Gets the preferred BC compression type
    virtual ::grpc::Status prefCompressType(::grpc::ClientContext* context, const ::octaneapi::LayerInfo_prefCompressTypeRequest& request, ::octaneapi::LayerInfo_prefCompressTypeResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::LayerInfo_prefCompressTypeResponse>> AsyncprefCompressType(::grpc::ClientContext* context, const ::octaneapi::LayerInfo_prefCompressTypeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::LayerInfo_prefCompressTypeResponse>>(AsyncprefCompressTypeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::LayerInfo_prefCompressTypeResponse>> PrepareAsyncprefCompressType(::grpc::ClientContext* context, const ::octaneapi::LayerInfo_prefCompressTypeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::LayerInfo_prefCompressTypeResponse>>(PrepareAsyncprefCompressTypeRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      // / Checks if the current layer has alpha data
      virtual void hasTransparency(::grpc::ClientContext* context, const ::octaneapi::LayerInfo_hasTransparencyRequest* request, ::octaneapi::LayerInfo_hasTransparencyResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void hasTransparency(::grpc::ClientContext* context, const ::octaneapi::LayerInfo_hasTransparencyRequest* request, ::octaneapi::LayerInfo_hasTransparencyResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Checks if the current layer is gray scale data
      virtual void isGrayscale(::grpc::ClientContext* context, const ::octaneapi::LayerInfo_isGrayscaleRequest* request, ::octaneapi::LayerInfo_isGrayscaleResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void isGrayscale(::grpc::ClientContext* context, const ::octaneapi::LayerInfo_isGrayscaleRequest* request, ::octaneapi::LayerInfo_isGrayscaleResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Gets the name of this layer
      virtual void name(::grpc::ClientContext* context, const ::octaneapi::LayerInfo_nameRequest* request, ::octaneapi::LayerInfo_nameResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void name(::grpc::ClientContext* context, const ::octaneapi::LayerInfo_nameRequest* request, ::octaneapi::LayerInfo_nameResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Gets the type of this layer's data
      virtual void type(::grpc::ClientContext* context, const ::octaneapi::LayerInfo_typeRequest* request, ::octaneapi::LayerInfo_typeResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void type(::grpc::ClientContext* context, const ::octaneapi::LayerInfo_typeRequest* request, ::octaneapi::LayerInfo_typeResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Gets the preferred BC compression type
      virtual void prefCompressType(::grpc::ClientContext* context, const ::octaneapi::LayerInfo_prefCompressTypeRequest* request, ::octaneapi::LayerInfo_prefCompressTypeResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void prefCompressType(::grpc::ClientContext* context, const ::octaneapi::LayerInfo_prefCompressTypeRequest* request, ::octaneapi::LayerInfo_prefCompressTypeResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::LayerInfo_hasTransparencyResponse>* AsynchasTransparencyRaw(::grpc::ClientContext* context, const ::octaneapi::LayerInfo_hasTransparencyRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::LayerInfo_hasTransparencyResponse>* PrepareAsynchasTransparencyRaw(::grpc::ClientContext* context, const ::octaneapi::LayerInfo_hasTransparencyRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::LayerInfo_isGrayscaleResponse>* AsyncisGrayscaleRaw(::grpc::ClientContext* context, const ::octaneapi::LayerInfo_isGrayscaleRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::LayerInfo_isGrayscaleResponse>* PrepareAsyncisGrayscaleRaw(::grpc::ClientContext* context, const ::octaneapi::LayerInfo_isGrayscaleRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::LayerInfo_nameResponse>* AsyncnameRaw(::grpc::ClientContext* context, const ::octaneapi::LayerInfo_nameRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::LayerInfo_nameResponse>* PrepareAsyncnameRaw(::grpc::ClientContext* context, const ::octaneapi::LayerInfo_nameRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::LayerInfo_typeResponse>* AsynctypeRaw(::grpc::ClientContext* context, const ::octaneapi::LayerInfo_typeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::LayerInfo_typeResponse>* PrepareAsynctypeRaw(::grpc::ClientContext* context, const ::octaneapi::LayerInfo_typeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::LayerInfo_prefCompressTypeResponse>* AsyncprefCompressTypeRaw(::grpc::ClientContext* context, const ::octaneapi::LayerInfo_prefCompressTypeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::LayerInfo_prefCompressTypeResponse>* PrepareAsyncprefCompressTypeRaw(::grpc::ClientContext* context, const ::octaneapi::LayerInfo_prefCompressTypeRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status hasTransparency(::grpc::ClientContext* context, const ::octaneapi::LayerInfo_hasTransparencyRequest& request, ::octaneapi::LayerInfo_hasTransparencyResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::LayerInfo_hasTransparencyResponse>> AsynchasTransparency(::grpc::ClientContext* context, const ::octaneapi::LayerInfo_hasTransparencyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::LayerInfo_hasTransparencyResponse>>(AsynchasTransparencyRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::LayerInfo_hasTransparencyResponse>> PrepareAsynchasTransparency(::grpc::ClientContext* context, const ::octaneapi::LayerInfo_hasTransparencyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::LayerInfo_hasTransparencyResponse>>(PrepareAsynchasTransparencyRaw(context, request, cq));
    }
    ::grpc::Status isGrayscale(::grpc::ClientContext* context, const ::octaneapi::LayerInfo_isGrayscaleRequest& request, ::octaneapi::LayerInfo_isGrayscaleResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::LayerInfo_isGrayscaleResponse>> AsyncisGrayscale(::grpc::ClientContext* context, const ::octaneapi::LayerInfo_isGrayscaleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::LayerInfo_isGrayscaleResponse>>(AsyncisGrayscaleRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::LayerInfo_isGrayscaleResponse>> PrepareAsyncisGrayscale(::grpc::ClientContext* context, const ::octaneapi::LayerInfo_isGrayscaleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::LayerInfo_isGrayscaleResponse>>(PrepareAsyncisGrayscaleRaw(context, request, cq));
    }
    ::grpc::Status name(::grpc::ClientContext* context, const ::octaneapi::LayerInfo_nameRequest& request, ::octaneapi::LayerInfo_nameResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::LayerInfo_nameResponse>> Asyncname(::grpc::ClientContext* context, const ::octaneapi::LayerInfo_nameRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::LayerInfo_nameResponse>>(AsyncnameRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::LayerInfo_nameResponse>> PrepareAsyncname(::grpc::ClientContext* context, const ::octaneapi::LayerInfo_nameRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::LayerInfo_nameResponse>>(PrepareAsyncnameRaw(context, request, cq));
    }
    ::grpc::Status type(::grpc::ClientContext* context, const ::octaneapi::LayerInfo_typeRequest& request, ::octaneapi::LayerInfo_typeResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::LayerInfo_typeResponse>> Asynctype(::grpc::ClientContext* context, const ::octaneapi::LayerInfo_typeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::LayerInfo_typeResponse>>(AsynctypeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::LayerInfo_typeResponse>> PrepareAsynctype(::grpc::ClientContext* context, const ::octaneapi::LayerInfo_typeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::LayerInfo_typeResponse>>(PrepareAsynctypeRaw(context, request, cq));
    }
    ::grpc::Status prefCompressType(::grpc::ClientContext* context, const ::octaneapi::LayerInfo_prefCompressTypeRequest& request, ::octaneapi::LayerInfo_prefCompressTypeResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::LayerInfo_prefCompressTypeResponse>> AsyncprefCompressType(::grpc::ClientContext* context, const ::octaneapi::LayerInfo_prefCompressTypeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::LayerInfo_prefCompressTypeResponse>>(AsyncprefCompressTypeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::LayerInfo_prefCompressTypeResponse>> PrepareAsyncprefCompressType(::grpc::ClientContext* context, const ::octaneapi::LayerInfo_prefCompressTypeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::LayerInfo_prefCompressTypeResponse>>(PrepareAsyncprefCompressTypeRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void hasTransparency(::grpc::ClientContext* context, const ::octaneapi::LayerInfo_hasTransparencyRequest* request, ::octaneapi::LayerInfo_hasTransparencyResponse* response, std::function<void(::grpc::Status)>) override;
      void hasTransparency(::grpc::ClientContext* context, const ::octaneapi::LayerInfo_hasTransparencyRequest* request, ::octaneapi::LayerInfo_hasTransparencyResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void isGrayscale(::grpc::ClientContext* context, const ::octaneapi::LayerInfo_isGrayscaleRequest* request, ::octaneapi::LayerInfo_isGrayscaleResponse* response, std::function<void(::grpc::Status)>) override;
      void isGrayscale(::grpc::ClientContext* context, const ::octaneapi::LayerInfo_isGrayscaleRequest* request, ::octaneapi::LayerInfo_isGrayscaleResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void name(::grpc::ClientContext* context, const ::octaneapi::LayerInfo_nameRequest* request, ::octaneapi::LayerInfo_nameResponse* response, std::function<void(::grpc::Status)>) override;
      void name(::grpc::ClientContext* context, const ::octaneapi::LayerInfo_nameRequest* request, ::octaneapi::LayerInfo_nameResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void type(::grpc::ClientContext* context, const ::octaneapi::LayerInfo_typeRequest* request, ::octaneapi::LayerInfo_typeResponse* response, std::function<void(::grpc::Status)>) override;
      void type(::grpc::ClientContext* context, const ::octaneapi::LayerInfo_typeRequest* request, ::octaneapi::LayerInfo_typeResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void prefCompressType(::grpc::ClientContext* context, const ::octaneapi::LayerInfo_prefCompressTypeRequest* request, ::octaneapi::LayerInfo_prefCompressTypeResponse* response, std::function<void(::grpc::Status)>) override;
      void prefCompressType(::grpc::ClientContext* context, const ::octaneapi::LayerInfo_prefCompressTypeRequest* request, ::octaneapi::LayerInfo_prefCompressTypeResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::octaneapi::LayerInfo_hasTransparencyResponse>* AsynchasTransparencyRaw(::grpc::ClientContext* context, const ::octaneapi::LayerInfo_hasTransparencyRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::LayerInfo_hasTransparencyResponse>* PrepareAsynchasTransparencyRaw(::grpc::ClientContext* context, const ::octaneapi::LayerInfo_hasTransparencyRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::LayerInfo_isGrayscaleResponse>* AsyncisGrayscaleRaw(::grpc::ClientContext* context, const ::octaneapi::LayerInfo_isGrayscaleRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::LayerInfo_isGrayscaleResponse>* PrepareAsyncisGrayscaleRaw(::grpc::ClientContext* context, const ::octaneapi::LayerInfo_isGrayscaleRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::LayerInfo_nameResponse>* AsyncnameRaw(::grpc::ClientContext* context, const ::octaneapi::LayerInfo_nameRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::LayerInfo_nameResponse>* PrepareAsyncnameRaw(::grpc::ClientContext* context, const ::octaneapi::LayerInfo_nameRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::LayerInfo_typeResponse>* AsynctypeRaw(::grpc::ClientContext* context, const ::octaneapi::LayerInfo_typeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::LayerInfo_typeResponse>* PrepareAsynctypeRaw(::grpc::ClientContext* context, const ::octaneapi::LayerInfo_typeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::LayerInfo_prefCompressTypeResponse>* AsyncprefCompressTypeRaw(::grpc::ClientContext* context, const ::octaneapi::LayerInfo_prefCompressTypeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::LayerInfo_prefCompressTypeResponse>* PrepareAsyncprefCompressTypeRaw(::grpc::ClientContext* context, const ::octaneapi::LayerInfo_prefCompressTypeRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_hasTransparency_;
    const ::grpc::internal::RpcMethod rpcmethod_isGrayscale_;
    const ::grpc::internal::RpcMethod rpcmethod_name_;
    const ::grpc::internal::RpcMethod rpcmethod_type_;
    const ::grpc::internal::RpcMethod rpcmethod_prefCompressType_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // / Checks if the current layer has alpha data
    virtual ::grpc::Status hasTransparency(::grpc::ServerContext* context, const ::octaneapi::LayerInfo_hasTransparencyRequest* request, ::octaneapi::LayerInfo_hasTransparencyResponse* response);
    // / Checks if the current layer is gray scale data
    virtual ::grpc::Status isGrayscale(::grpc::ServerContext* context, const ::octaneapi::LayerInfo_isGrayscaleRequest* request, ::octaneapi::LayerInfo_isGrayscaleResponse* response);
    // / Gets the name of this layer
    virtual ::grpc::Status name(::grpc::ServerContext* context, const ::octaneapi::LayerInfo_nameRequest* request, ::octaneapi::LayerInfo_nameResponse* response);
    // / Gets the type of this layer's data
    virtual ::grpc::Status type(::grpc::ServerContext* context, const ::octaneapi::LayerInfo_typeRequest* request, ::octaneapi::LayerInfo_typeResponse* response);
    // / Gets the preferred BC compression type
    virtual ::grpc::Status prefCompressType(::grpc::ServerContext* context, const ::octaneapi::LayerInfo_prefCompressTypeRequest* request, ::octaneapi::LayerInfo_prefCompressTypeResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_hasTransparency : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_hasTransparency() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_hasTransparency() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status hasTransparency(::grpc::ServerContext* /*context*/, const ::octaneapi::LayerInfo_hasTransparencyRequest* /*request*/, ::octaneapi::LayerInfo_hasTransparencyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequesthasTransparency(::grpc::ServerContext* context, ::octaneapi::LayerInfo_hasTransparencyRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::LayerInfo_hasTransparencyResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_isGrayscale : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_isGrayscale() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_isGrayscale() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isGrayscale(::grpc::ServerContext* /*context*/, const ::octaneapi::LayerInfo_isGrayscaleRequest* /*request*/, ::octaneapi::LayerInfo_isGrayscaleResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestisGrayscale(::grpc::ServerContext* context, ::octaneapi::LayerInfo_isGrayscaleRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::LayerInfo_isGrayscaleResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_name : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_name() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_name() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status name(::grpc::ServerContext* /*context*/, const ::octaneapi::LayerInfo_nameRequest* /*request*/, ::octaneapi::LayerInfo_nameResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestname(::grpc::ServerContext* context, ::octaneapi::LayerInfo_nameRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::LayerInfo_nameResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_type : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_type() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_type() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status type(::grpc::ServerContext* /*context*/, const ::octaneapi::LayerInfo_typeRequest* /*request*/, ::octaneapi::LayerInfo_typeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requesttype(::grpc::ServerContext* context, ::octaneapi::LayerInfo_typeRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::LayerInfo_typeResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_prefCompressType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_prefCompressType() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_prefCompressType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status prefCompressType(::grpc::ServerContext* /*context*/, const ::octaneapi::LayerInfo_prefCompressTypeRequest* /*request*/, ::octaneapi::LayerInfo_prefCompressTypeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestprefCompressType(::grpc::ServerContext* context, ::octaneapi::LayerInfo_prefCompressTypeRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::LayerInfo_prefCompressTypeResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_hasTransparency<WithAsyncMethod_isGrayscale<WithAsyncMethod_name<WithAsyncMethod_type<WithAsyncMethod_prefCompressType<Service > > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_hasTransparency : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_hasTransparency() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::LayerInfo_hasTransparencyRequest, ::octaneapi::LayerInfo_hasTransparencyResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::LayerInfo_hasTransparencyRequest* request, ::octaneapi::LayerInfo_hasTransparencyResponse* response) { return this->hasTransparency(context, request, response); }));}
    void SetMessageAllocatorFor_hasTransparency(
        ::grpc::MessageAllocator< ::octaneapi::LayerInfo_hasTransparencyRequest, ::octaneapi::LayerInfo_hasTransparencyResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::LayerInfo_hasTransparencyRequest, ::octaneapi::LayerInfo_hasTransparencyResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_hasTransparency() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status hasTransparency(::grpc::ServerContext* /*context*/, const ::octaneapi::LayerInfo_hasTransparencyRequest* /*request*/, ::octaneapi::LayerInfo_hasTransparencyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* hasTransparency(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::LayerInfo_hasTransparencyRequest* /*request*/, ::octaneapi::LayerInfo_hasTransparencyResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_isGrayscale : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_isGrayscale() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::LayerInfo_isGrayscaleRequest, ::octaneapi::LayerInfo_isGrayscaleResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::LayerInfo_isGrayscaleRequest* request, ::octaneapi::LayerInfo_isGrayscaleResponse* response) { return this->isGrayscale(context, request, response); }));}
    void SetMessageAllocatorFor_isGrayscale(
        ::grpc::MessageAllocator< ::octaneapi::LayerInfo_isGrayscaleRequest, ::octaneapi::LayerInfo_isGrayscaleResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::LayerInfo_isGrayscaleRequest, ::octaneapi::LayerInfo_isGrayscaleResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_isGrayscale() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isGrayscale(::grpc::ServerContext* /*context*/, const ::octaneapi::LayerInfo_isGrayscaleRequest* /*request*/, ::octaneapi::LayerInfo_isGrayscaleResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* isGrayscale(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::LayerInfo_isGrayscaleRequest* /*request*/, ::octaneapi::LayerInfo_isGrayscaleResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_name : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_name() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::LayerInfo_nameRequest, ::octaneapi::LayerInfo_nameResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::LayerInfo_nameRequest* request, ::octaneapi::LayerInfo_nameResponse* response) { return this->name(context, request, response); }));}
    void SetMessageAllocatorFor_name(
        ::grpc::MessageAllocator< ::octaneapi::LayerInfo_nameRequest, ::octaneapi::LayerInfo_nameResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::LayerInfo_nameRequest, ::octaneapi::LayerInfo_nameResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_name() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status name(::grpc::ServerContext* /*context*/, const ::octaneapi::LayerInfo_nameRequest* /*request*/, ::octaneapi::LayerInfo_nameResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* name(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::LayerInfo_nameRequest* /*request*/, ::octaneapi::LayerInfo_nameResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_type : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_type() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::LayerInfo_typeRequest, ::octaneapi::LayerInfo_typeResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::LayerInfo_typeRequest* request, ::octaneapi::LayerInfo_typeResponse* response) { return this->type(context, request, response); }));}
    void SetMessageAllocatorFor_type(
        ::grpc::MessageAllocator< ::octaneapi::LayerInfo_typeRequest, ::octaneapi::LayerInfo_typeResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::LayerInfo_typeRequest, ::octaneapi::LayerInfo_typeResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_type() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status type(::grpc::ServerContext* /*context*/, const ::octaneapi::LayerInfo_typeRequest* /*request*/, ::octaneapi::LayerInfo_typeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* type(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::LayerInfo_typeRequest* /*request*/, ::octaneapi::LayerInfo_typeResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_prefCompressType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_prefCompressType() {
      ::grpc::Service::MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::LayerInfo_prefCompressTypeRequest, ::octaneapi::LayerInfo_prefCompressTypeResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::LayerInfo_prefCompressTypeRequest* request, ::octaneapi::LayerInfo_prefCompressTypeResponse* response) { return this->prefCompressType(context, request, response); }));}
    void SetMessageAllocatorFor_prefCompressType(
        ::grpc::MessageAllocator< ::octaneapi::LayerInfo_prefCompressTypeRequest, ::octaneapi::LayerInfo_prefCompressTypeResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::LayerInfo_prefCompressTypeRequest, ::octaneapi::LayerInfo_prefCompressTypeResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_prefCompressType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status prefCompressType(::grpc::ServerContext* /*context*/, const ::octaneapi::LayerInfo_prefCompressTypeRequest* /*request*/, ::octaneapi::LayerInfo_prefCompressTypeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* prefCompressType(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::LayerInfo_prefCompressTypeRequest* /*request*/, ::octaneapi::LayerInfo_prefCompressTypeResponse* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_hasTransparency<WithCallbackMethod_isGrayscale<WithCallbackMethod_name<WithCallbackMethod_type<WithCallbackMethod_prefCompressType<Service > > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_hasTransparency : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_hasTransparency() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_hasTransparency() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status hasTransparency(::grpc::ServerContext* /*context*/, const ::octaneapi::LayerInfo_hasTransparencyRequest* /*request*/, ::octaneapi::LayerInfo_hasTransparencyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_isGrayscale : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_isGrayscale() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_isGrayscale() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isGrayscale(::grpc::ServerContext* /*context*/, const ::octaneapi::LayerInfo_isGrayscaleRequest* /*request*/, ::octaneapi::LayerInfo_isGrayscaleResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_name : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_name() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_name() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status name(::grpc::ServerContext* /*context*/, const ::octaneapi::LayerInfo_nameRequest* /*request*/, ::octaneapi::LayerInfo_nameResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_type : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_type() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_type() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status type(::grpc::ServerContext* /*context*/, const ::octaneapi::LayerInfo_typeRequest* /*request*/, ::octaneapi::LayerInfo_typeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_prefCompressType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_prefCompressType() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_prefCompressType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status prefCompressType(::grpc::ServerContext* /*context*/, const ::octaneapi::LayerInfo_prefCompressTypeRequest* /*request*/, ::octaneapi::LayerInfo_prefCompressTypeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_hasTransparency : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_hasTransparency() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_hasTransparency() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status hasTransparency(::grpc::ServerContext* /*context*/, const ::octaneapi::LayerInfo_hasTransparencyRequest* /*request*/, ::octaneapi::LayerInfo_hasTransparencyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequesthasTransparency(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_isGrayscale : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_isGrayscale() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_isGrayscale() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isGrayscale(::grpc::ServerContext* /*context*/, const ::octaneapi::LayerInfo_isGrayscaleRequest* /*request*/, ::octaneapi::LayerInfo_isGrayscaleResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestisGrayscale(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_name : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_name() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_name() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status name(::grpc::ServerContext* /*context*/, const ::octaneapi::LayerInfo_nameRequest* /*request*/, ::octaneapi::LayerInfo_nameResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestname(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_type : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_type() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_type() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status type(::grpc::ServerContext* /*context*/, const ::octaneapi::LayerInfo_typeRequest* /*request*/, ::octaneapi::LayerInfo_typeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requesttype(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_prefCompressType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_prefCompressType() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_prefCompressType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status prefCompressType(::grpc::ServerContext* /*context*/, const ::octaneapi::LayerInfo_prefCompressTypeRequest* /*request*/, ::octaneapi::LayerInfo_prefCompressTypeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestprefCompressType(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_hasTransparency : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_hasTransparency() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->hasTransparency(context, request, response); }));
    }
    ~WithRawCallbackMethod_hasTransparency() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status hasTransparency(::grpc::ServerContext* /*context*/, const ::octaneapi::LayerInfo_hasTransparencyRequest* /*request*/, ::octaneapi::LayerInfo_hasTransparencyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* hasTransparency(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_isGrayscale : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_isGrayscale() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->isGrayscale(context, request, response); }));
    }
    ~WithRawCallbackMethod_isGrayscale() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isGrayscale(::grpc::ServerContext* /*context*/, const ::octaneapi::LayerInfo_isGrayscaleRequest* /*request*/, ::octaneapi::LayerInfo_isGrayscaleResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* isGrayscale(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_name : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_name() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->name(context, request, response); }));
    }
    ~WithRawCallbackMethod_name() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status name(::grpc::ServerContext* /*context*/, const ::octaneapi::LayerInfo_nameRequest* /*request*/, ::octaneapi::LayerInfo_nameResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* name(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_type : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_type() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->type(context, request, response); }));
    }
    ~WithRawCallbackMethod_type() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status type(::grpc::ServerContext* /*context*/, const ::octaneapi::LayerInfo_typeRequest* /*request*/, ::octaneapi::LayerInfo_typeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* type(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_prefCompressType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_prefCompressType() {
      ::grpc::Service::MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->prefCompressType(context, request, response); }));
    }
    ~WithRawCallbackMethod_prefCompressType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status prefCompressType(::grpc::ServerContext* /*context*/, const ::octaneapi::LayerInfo_prefCompressTypeRequest* /*request*/, ::octaneapi::LayerInfo_prefCompressTypeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* prefCompressType(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_hasTransparency : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_hasTransparency() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::LayerInfo_hasTransparencyRequest, ::octaneapi::LayerInfo_hasTransparencyResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::LayerInfo_hasTransparencyRequest, ::octaneapi::LayerInfo_hasTransparencyResponse>* streamer) {
                       return this->StreamedhasTransparency(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_hasTransparency() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status hasTransparency(::grpc::ServerContext* /*context*/, const ::octaneapi::LayerInfo_hasTransparencyRequest* /*request*/, ::octaneapi::LayerInfo_hasTransparencyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedhasTransparency(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::LayerInfo_hasTransparencyRequest,::octaneapi::LayerInfo_hasTransparencyResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_isGrayscale : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_isGrayscale() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::LayerInfo_isGrayscaleRequest, ::octaneapi::LayerInfo_isGrayscaleResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::LayerInfo_isGrayscaleRequest, ::octaneapi::LayerInfo_isGrayscaleResponse>* streamer) {
                       return this->StreamedisGrayscale(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_isGrayscale() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status isGrayscale(::grpc::ServerContext* /*context*/, const ::octaneapi::LayerInfo_isGrayscaleRequest* /*request*/, ::octaneapi::LayerInfo_isGrayscaleResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedisGrayscale(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::LayerInfo_isGrayscaleRequest,::octaneapi::LayerInfo_isGrayscaleResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_name : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_name() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::LayerInfo_nameRequest, ::octaneapi::LayerInfo_nameResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::LayerInfo_nameRequest, ::octaneapi::LayerInfo_nameResponse>* streamer) {
                       return this->Streamedname(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_name() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status name(::grpc::ServerContext* /*context*/, const ::octaneapi::LayerInfo_nameRequest* /*request*/, ::octaneapi::LayerInfo_nameResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedname(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::LayerInfo_nameRequest,::octaneapi::LayerInfo_nameResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_type : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_type() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::LayerInfo_typeRequest, ::octaneapi::LayerInfo_typeResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::LayerInfo_typeRequest, ::octaneapi::LayerInfo_typeResponse>* streamer) {
                       return this->Streamedtype(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_type() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status type(::grpc::ServerContext* /*context*/, const ::octaneapi::LayerInfo_typeRequest* /*request*/, ::octaneapi::LayerInfo_typeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedtype(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::LayerInfo_typeRequest,::octaneapi::LayerInfo_typeResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_prefCompressType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_prefCompressType() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::LayerInfo_prefCompressTypeRequest, ::octaneapi::LayerInfo_prefCompressTypeResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::LayerInfo_prefCompressTypeRequest, ::octaneapi::LayerInfo_prefCompressTypeResponse>* streamer) {
                       return this->StreamedprefCompressType(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_prefCompressType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status prefCompressType(::grpc::ServerContext* /*context*/, const ::octaneapi::LayerInfo_prefCompressTypeRequest* /*request*/, ::octaneapi::LayerInfo_prefCompressTypeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedprefCompressType(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::LayerInfo_prefCompressTypeRequest,::octaneapi::LayerInfo_prefCompressTypeResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_hasTransparency<WithStreamedUnaryMethod_isGrayscale<WithStreamedUnaryMethod_name<WithStreamedUnaryMethod_type<WithStreamedUnaryMethod_prefCompressType<Service > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_hasTransparency<WithStreamedUnaryMethod_isGrayscale<WithStreamedUnaryMethod_name<WithStreamedUnaryMethod_type<WithStreamedUnaryMethod_prefCompressType<Service > > > > > StreamedService;
};

}  // namespace octaneapi


#include <grpcpp/ports_undef.inc>
#endif  // GRPC_apiimageinfo_2eproto__INCLUDED
