// Copyright (C) 2025 OTOY NZ Ltd.

// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: apiimagebuffer.proto
// Original file comments:
// ////////////////////////////////////////////////////////////////////////////
// WARNING: This code is machine generated. Manual changes will be overridden.
//
#ifndef GRPC_apiimagebuffer_2eproto__INCLUDED
#define GRPC_apiimagebuffer_2eproto__INCLUDED

#include "apiimagebuffer.pb.h"

#include <functional>
#include <grpcpp/generic/async_generic_service.h>
#include <grpcpp/support/async_stream.h>
#include <grpcpp/support/async_unary_call.h>
#include <grpcpp/support/client_callback.h>
#include <grpcpp/client_context.h>
#include <grpcpp/completion_queue.h>
#include <grpcpp/support/message_allocator.h>
#include <grpcpp/support/method_handler.h>
#include <grpcpp/impl/proto_utils.h>
#include <grpcpp/impl/rpc_method.h>
#include <grpcpp/support/server_callback.h>
#include <grpcpp/impl/server_callback_handlers.h>
#include <grpcpp/server_context.h>
#include <grpcpp/impl/service_type.h>
#include <grpcpp/support/status.h>
#include <grpcpp/support/stub_options.h>
#include <grpcpp/support/sync_stream.h>
#include <grpcpp/ports_def.inc>

namespace octaneapi {

// GRPC interface definition for class 'ApiImageBuffer' from 'apiimagebuffer.h'
class ApiImageBufferService final {
 public:
  static constexpr char const* service_full_name() {
    return "octaneapi.ApiImageBufferService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // / Creates an empty image buffer
    // / 
    virtual ::grpc::Status create(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_createRequest& request, ::octaneapi::ApiImageBuffer_createResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_createResponse>> Asynccreate(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_createRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_createResponse>>(AsynccreateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_createResponse>> PrepareAsynccreate(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_createRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_createResponse>>(PrepareAsynccreateRaw(context, request, cq));
    }
    // / Creates an image buffer using the given data
    // /
    // / 
    virtual ::grpc::Status create1(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_create1Request& request, ::octaneapi::ApiImageBuffer_create1Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_create1Response>> Asynccreate1(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_create1Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_create1Response>>(Asynccreate1Raw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_create1Response>> PrepareAsynccreate1(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_create1Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_create1Response>>(PrepareAsynccreate1Raw(context, request, cq));
    }
    // / Loads an image from file
    // / 
    virtual ::grpc::Status load(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_loadRequest& request, ::octaneapi::ApiImageBuffer_loadResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_loadResponse>> Asyncload(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_loadRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_loadResponse>>(AsyncloadRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_loadResponse>> PrepareAsyncload(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_loadRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_loadResponse>>(PrepareAsyncloadRaw(context, request, cq));
    }
    // / Loads an image from encoded data(for instance, from a memory block of a png file)
    virtual ::grpc::Status load1(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_load1Request& request, ::octaneapi::ApiImageBuffer_load1Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_load1Response>> Asyncload1(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_load1Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_load1Response>>(Asyncload1Raw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_load1Response>> PrepareAsyncload1(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_load1Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_load1Response>>(PrepareAsyncload1Raw(context, request, cq));
    }
    // / Convert the source image buffer to another one using the destination type
    // / NOTE: Only works for uncompressed images
    // / Meta data (like wrapping and alpha flags) are copied to the returned image
    // /
    // / 
    virtual ::grpc::Status convertTo(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_convertToRequest& request, ::octaneapi::ApiImageBuffer_convertToResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_convertToResponse>> AsyncconvertTo(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_convertToRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_convertToResponse>>(AsyncconvertToRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_convertToResponse>> PrepareAsyncconvertTo(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_convertToRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_convertToResponse>>(PrepareAsyncconvertToRaw(context, request, cq));
    }
    // / Destroys the ApiImageBuffer object created by create()
    virtual ::grpc::Status destroy(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_destroyRequest& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> Asyncdestroy(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_destroyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncdestroyRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncdestroy(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_destroyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncdestroyRaw(context, request, cq));
    }
    // / Returns the bytes per pixel
    // /
    // / 
    virtual ::grpc::Status bytesPerPixel(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_bytesPerPixelRequest& request, ::octaneapi::ApiImageBuffer_bytesPerPixelResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_bytesPerPixelResponse>> AsyncbytesPerPixel(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_bytesPerPixelRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_bytesPerPixelResponse>>(AsyncbytesPerPixelRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_bytesPerPixelResponse>> PrepareAsyncbytesPerPixel(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_bytesPerPixelRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_bytesPerPixelResponse>>(PrepareAsyncbytesPerPixelRaw(context, request, cq));
    }
    // / Returns the bytes per pixel channel
    virtual ::grpc::Status bytesPerChannel(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_bytesPerChannelRequest& request, ::octaneapi::ApiImageBuffer_bytesPerChannelResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_bytesPerChannelResponse>> AsyncbytesPerChannel(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_bytesPerChannelRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_bytesPerChannelResponse>>(AsyncbytesPerChannelRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_bytesPerChannelResponse>> PrepareAsyncbytesPerChannel(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_bytesPerChannelRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_bytesPerChannelResponse>>(PrepareAsyncbytesPerChannelRaw(context, request, cq));
    }
    // / Returns the number of channels of a pixel
    virtual ::grpc::Status channelCount(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_channelCountRequest& request, ::octaneapi::ApiImageBuffer_channelCountResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_channelCountResponse>> AsyncchannelCount(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_channelCountRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_channelCountResponse>>(AsyncchannelCountRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_channelCountResponse>> PrepareAsyncchannelCount(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_channelCountRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_channelCountResponse>>(PrepareAsyncchannelCountRaw(context, request, cq));
    }
    // / Returns the dimensions of the image in pixels
    virtual ::grpc::Status size(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_sizeRequest& request, ::octaneapi::ApiImageBuffer_sizeResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_sizeResponse>> Asyncsize(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_sizeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_sizeResponse>>(AsyncsizeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_sizeResponse>> PrepareAsyncsize(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_sizeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_sizeResponse>>(PrepareAsyncsizeRaw(context, request, cq));
    }
    // / Returns the size in bytes of the image data
    virtual ::grpc::Status sizeInBytes(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_sizeInBytesRequest& request, ::octaneapi::ApiImageBuffer_sizeInBytesResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_sizeInBytesResponse>> AsyncsizeInBytes(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_sizeInBytesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_sizeInBytesResponse>>(AsyncsizeInBytesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_sizeInBytesResponse>> PrepareAsyncsizeInBytes(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_sizeInBytesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_sizeInBytesResponse>>(PrepareAsyncsizeInBytesRaw(context, request, cq));
    }
    // / Returns the image buffer's type
    virtual ::grpc::Status type(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_typeRequest& request, ::octaneapi::ApiImageBuffer_typeResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_typeResponse>> Asynctype(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_typeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_typeResponse>>(AsynctypeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_typeResponse>> PrepareAsynctype(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_typeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_typeResponse>>(PrepareAsynctypeRaw(context, request, cq));
    }
    // / Returns the image source information string
    virtual ::grpc::Status sourceInfo(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_sourceInfoRequest& request, ::octaneapi::ApiImageBuffer_sourceInfoResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_sourceInfoResponse>> AsyncsourceInfo(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_sourceInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_sourceInfoResponse>>(AsyncsourceInfoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_sourceInfoResponse>> PrepareAsyncsourceInfo(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_sourceInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_sourceInfoResponse>>(PrepareAsyncsourceInfoRaw(context, request, cq));
    }
    // / TRUE if the image can wrap in horizontal direction
    virtual ::grpc::Status canWrapX(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_canWrapXRequest& request, ::octaneapi::ApiImageBuffer_canWrapXResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_canWrapXResponse>> AsynccanWrapX(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_canWrapXRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_canWrapXResponse>>(AsynccanWrapXRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_canWrapXResponse>> PrepareAsynccanWrapX(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_canWrapXRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_canWrapXResponse>>(PrepareAsynccanWrapXRaw(context, request, cq));
    }
    // / TRUE if the image can wrap in vertical direction
    virtual ::grpc::Status canWrapY(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_canWrapYRequest& request, ::octaneapi::ApiImageBuffer_canWrapYResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_canWrapYResponse>> AsynccanWrapY(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_canWrapYRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_canWrapYResponse>>(AsynccanWrapYRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_canWrapYResponse>> PrepareAsynccanWrapY(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_canWrapYRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_canWrapYResponse>>(PrepareAsynccanWrapYRaw(context, request, cq));
    }
    // / TRUE if the image has Y down (currently only for BC compressed images)
    virtual ::grpc::Status needsFlip(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_needsFlipRequest& request, ::octaneapi::ApiImageBuffer_needsFlipResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_needsFlipResponse>> AsyncneedsFlip(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_needsFlipRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_needsFlipResponse>>(AsyncneedsFlipRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_needsFlipResponse>> PrepareAsyncneedsFlip(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_needsFlipRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_needsFlipResponse>>(PrepareAsyncneedsFlipRaw(context, request, cq));
    }
    // / TRUE for a transparent image
    virtual ::grpc::Status hasAlpha(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_hasAlphaRequest& request, ::octaneapi::ApiImageBuffer_hasAlphaResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_hasAlphaResponse>> AsynchasAlpha(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_hasAlphaRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_hasAlphaResponse>>(AsynchasAlphaRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_hasAlphaResponse>> PrepareAsynchasAlpha(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_hasAlphaRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_hasAlphaResponse>>(PrepareAsynchasAlphaRaw(context, request, cq));
    }
    // / TRUE for a chormatic image
    virtual ::grpc::Status hasColor(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_hasColorRequest& request, ::octaneapi::ApiImageBuffer_hasColorResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_hasColorResponse>> AsynchasColor(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_hasColorRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_hasColorResponse>>(AsynchasColorRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_hasColorResponse>> PrepareAsynchasColor(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_hasColorRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_hasColorResponse>>(PrepareAsynchasColorRaw(context, request, cq));
    }
    // / TRUE for a compressed image
    virtual ::grpc::Status isCompressed(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_isCompressedRequest& request, ::octaneapi::ApiImageBuffer_isCompressedResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_isCompressedResponse>> AsyncisCompressed(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_isCompressedRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_isCompressedResponse>>(AsyncisCompressedRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_isCompressedResponse>> PrepareAsyncisCompressed(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_isCompressedRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_isCompressedResponse>>(PrepareAsyncisCompressedRaw(context, request, cq));
    }
    // / Checks if this image has data
    virtual ::grpc::Status isEmpty(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_isEmptyRequest& request, ::octaneapi::ApiImageBuffer_isEmptyResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_isEmptyResponse>> AsyncisEmpty(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_isEmptyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_isEmptyResponse>>(AsyncisEmptyRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_isEmptyResponse>> PrepareAsyncisEmpty(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_isEmptyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_isEmptyResponse>>(PrepareAsyncisEmptyRaw(context, request, cq));
    }
    // / TRUE for a 16bits Hdr image
    virtual ::grpc::Status isHalf(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_isHalfRequest& request, ::octaneapi::ApiImageBuffer_isHalfResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_isHalfResponse>> AsyncisHalf(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_isHalfRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_isHalfResponse>>(AsyncisHalfRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_isHalfResponse>> PrepareAsyncisHalf(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_isHalfRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_isHalfResponse>>(PrepareAsyncisHalfRaw(context, request, cq));
    }
    // / TRUE for a Hdr image
    virtual ::grpc::Status isHdr(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_isHdrRequest& request, ::octaneapi::ApiImageBuffer_isHdrResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_isHdrResponse>> AsyncisHdr(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_isHdrRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_isHdrResponse>>(AsyncisHdrRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_isHdrResponse>> PrepareAsyncisHdr(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_isHdrRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_isHdrResponse>>(PrepareAsyncisHdrRaw(context, request, cq));
    }
    // / TRUE for a single channel image
    virtual ::grpc::Status isMono(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_isMonoRequest& request, ::octaneapi::ApiImageBuffer_isMonoResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_isMonoResponse>> AsyncisMono(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_isMonoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_isMonoResponse>>(AsyncisMonoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_isMonoResponse>> PrepareAsyncisMono(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_isMonoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_isMonoResponse>>(PrepareAsyncisMonoRaw(context, request, cq));
    }
    // / TRUE is the given pixel location is valid
    virtual ::grpc::Status isPixelValid(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_isPixelValidRequest& request, ::octaneapi::ApiImageBuffer_isPixelValidResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_isPixelValidResponse>> AsyncisPixelValid(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_isPixelValidRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_isPixelValidResponse>>(AsyncisPixelValidRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_isPixelValidResponse>> PrepareAsyncisPixelValid(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_isPixelValidRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_isPixelValidResponse>>(PrepareAsyncisPixelValidRaw(context, request, cq));
    }
    // / Compresses this image buffer
    // / NOTE: Only works for uncompressed images
    // /
    // / 
    virtual ::grpc::Status compress(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_compressRequest& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> Asynccompress(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_compressRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsynccompressRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsynccompress(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_compressRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsynccompressRaw(context, request, cq));
    }
    // / Modifies a pixel in a Ldr image buffer
    // / NOTE: This assumes that the buffer represents a un-compressed Ldr image and
    // /       image that goes bottom-to-top (y points down)
    // /
    // / 
    virtual ::grpc::Status setPixelLdr(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_setPixelLdrRequest& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncsetPixelLdr(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_setPixelLdrRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncsetPixelLdrRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncsetPixelLdr(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_setPixelLdrRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncsetPixelLdrRaw(context, request, cq));
    }
    // / Modifies a pixel in a 16bits Hdr image buffer
    // / NOTE: This assumes that the buffer represents a 16bits un-compressed Hdr image and
    // /       image that goes bottom-to-top (y points down)
    // /
    // / 
    virtual ::grpc::Status setPixelHalf(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_setPixelHalfRequest& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncsetPixelHalf(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_setPixelHalfRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncsetPixelHalfRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncsetPixelHalf(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_setPixelHalfRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncsetPixelHalfRaw(context, request, cq));
    }
    // / Modifies a pixel in a 326bits Hdr image buffer
    // / NOTE: This assumes that the buffer represents a 32bits un-compressed Hdr image and
    // /       image that goes bottom-to-top (y points down)
    // /
    // / 
    virtual ::grpc::Status setPixelHdr(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_setPixelHdrRequest& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncsetPixelHdr(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_setPixelHdrRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncsetPixelHdrRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncsetPixelHdr(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_setPixelHdrRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncsetPixelHdrRaw(context, request, cq));
    }
    // / Copies a region from another ImageBuffer
    virtual ::grpc::Status copyRegion(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_copyRegionRequest& request, ::octaneapi::ApiImageBuffer_copyRegionResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_copyRegionResponse>> AsynccopyRegion(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_copyRegionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_copyRegionResponse>>(AsynccopyRegionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_copyRegionResponse>> PrepareAsynccopyRegion(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_copyRegionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_copyRegionResponse>>(PrepareAsynccopyRegionRaw(context, request, cq));
    }
    // / eliminates the alpha channel by multiplying the color channels by the alpha channel, and
    // / setting the alpha channel to 1
    virtual ::grpc::Status compositeOnBlack(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_compositeOnBlackRequest& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsynccompositeOnBlack(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_compositeOnBlackRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsynccompositeOnBlackRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsynccompositeOnBlack(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_compositeOnBlackRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsynccompositeOnBlackRaw(context, request, cq));
    }
    // / vertical flip (in place)
    virtual ::grpc::Status flipVertical(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_flipVerticalRequest& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncflipVertical(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_flipVerticalRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncflipVerticalRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncflipVertical(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_flipVerticalRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncflipVerticalRaw(context, request, cq));
    }
    // / Convert the current image bufer to another type
    // / NOTE: Only works for uncompressed images
    // /
    // / 
    virtual ::grpc::Status convert(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_convertRequest& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> Asyncconvert(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_convertRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncconvertRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncconvert(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_convertRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncconvertRaw(context, request, cq));
    }
    // / Applies gaussian filter to the image
    // / NOTE: Only works for uncompressed images
    // /
    // / 
    virtual ::grpc::Status applyGaussianFilter(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_applyGaussianFilterRequest& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncapplyGaussianFilter(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_applyGaussianFilterRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncapplyGaussianFilterRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncapplyGaussianFilter(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_applyGaussianFilterRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncapplyGaussianFilterRaw(context, request, cq));
    }
    // / Applies Box filter to the image
    virtual ::grpc::Status applyBoxFilter(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_applyBoxFilterRequest& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncapplyBoxFilter(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_applyBoxFilterRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncapplyBoxFilterRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncapplyBoxFilter(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_applyBoxFilterRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncapplyBoxFilterRaw(context, request, cq));
    }
    // / Applies level correction to the image
    // / NOTE: the image must be un-compressed image and have float channels
    // /
    // / 
    virtual ::grpc::Status applyLevels(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_applyLevelsRequest& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncapplyLevels(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_applyLevelsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncapplyLevelsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncapplyLevels(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_applyLevelsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncapplyLevelsRaw(context, request, cq));
    }
    // / Compares this image to another image, and puts the difference in this image
    // /
    // / 
    virtual ::grpc::Status compareValues(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_compareValuesRequest& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsynccompareValues(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_compareValuesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsynccompareValuesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsynccompareValues(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_compareValuesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsynccompareValuesRaw(context, request, cq));
    }
    // / Compares this image to another image, and returns the mean square error for it
    // /
    // / 
    virtual ::grpc::Status calculateMeanSquareError(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_calculateMeanSquareErrorRequest& request, ::octaneapi::ApiImageBuffer_calculateMeanSquareErrorResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_calculateMeanSquareErrorResponse>> AsynccalculateMeanSquareError(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_calculateMeanSquareErrorRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_calculateMeanSquareErrorResponse>>(AsynccalculateMeanSquareErrorRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_calculateMeanSquareErrorResponse>> PrepareAsynccalculateMeanSquareError(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_calculateMeanSquareErrorRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_calculateMeanSquareErrorResponse>>(PrepareAsynccalculateMeanSquareErrorRaw(context, request, cq));
    }
    // / Saves an image to disk
    virtual ::grpc::Status save(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_saveRequest& request, ::octaneapi::ApiImageBuffer_saveResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_saveResponse>> Asyncsave(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_saveRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_saveResponse>>(AsyncsaveRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_saveResponse>> PrepareAsyncsave(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_saveRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_saveResponse>>(PrepareAsyncsaveRaw(context, request, cq));
    }
    // / Starts saving an image to disk on a background thread
    // / Compressed images are saved as DDS, HDR images are saved as EXR and LDR images are saved as PNG
    // / NOTE:  The correct extension is added to the path (if it didn't exist yet)
    // /
    // / 
    virtual ::grpc::Status saveAsync(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_saveAsyncRequest& request, ::octaneapi::ApiImageBuffer_saveAsyncResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_saveAsyncResponse>> AsyncsaveAsync(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_saveAsyncRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_saveAsyncResponse>>(AsyncsaveAsyncRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_saveAsyncResponse>> PrepareAsyncsaveAsync(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_saveAsyncRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_saveAsyncResponse>>(PrepareAsyncsaveAsyncRaw(context, request, cq));
    }
    // / Gets the constant reference to the memory location of a pixel
    virtual ::grpc::Status pixelAddr(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_pixelAddrRequest& request, ::octaneapi::ApiImageBuffer_pixelAddrResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_pixelAddrResponse>> AsyncpixelAddr(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_pixelAddrRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_pixelAddrResponse>>(AsyncpixelAddrRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_pixelAddrResponse>> PrepareAsyncpixelAddr(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_pixelAddrRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_pixelAddrResponse>>(PrepareAsyncpixelAddrRaw(context, request, cq));
    }
    // / Gets the mutable reference to the memory location of a pixel
    virtual ::grpc::Status pixelAddr1(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_pixelAddr1Request& request, ::octaneapi::ApiImageBuffer_pixelAddr1Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_pixelAddr1Response>> AsyncpixelAddr1(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_pixelAddr1Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_pixelAddr1Response>>(AsyncpixelAddr1Raw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_pixelAddr1Response>> PrepareAsyncpixelAddr1(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_pixelAddr1Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_pixelAddr1Response>>(PrepareAsyncpixelAddr1Raw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      // / Creates an empty image buffer
      // / 
      virtual void create(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_createRequest* request, ::octaneapi::ApiImageBuffer_createResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void create(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_createRequest* request, ::octaneapi::ApiImageBuffer_createResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Creates an image buffer using the given data
      // /
      // / 
      virtual void create1(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_create1Request* request, ::octaneapi::ApiImageBuffer_create1Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void create1(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_create1Request* request, ::octaneapi::ApiImageBuffer_create1Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Loads an image from file
      // / 
      virtual void load(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_loadRequest* request, ::octaneapi::ApiImageBuffer_loadResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void load(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_loadRequest* request, ::octaneapi::ApiImageBuffer_loadResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Loads an image from encoded data(for instance, from a memory block of a png file)
      virtual void load1(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_load1Request* request, ::octaneapi::ApiImageBuffer_load1Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void load1(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_load1Request* request, ::octaneapi::ApiImageBuffer_load1Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Convert the source image buffer to another one using the destination type
      // / NOTE: Only works for uncompressed images
      // / Meta data (like wrapping and alpha flags) are copied to the returned image
      // /
      // / 
      virtual void convertTo(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_convertToRequest* request, ::octaneapi::ApiImageBuffer_convertToResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void convertTo(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_convertToRequest* request, ::octaneapi::ApiImageBuffer_convertToResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Destroys the ApiImageBuffer object created by create()
      virtual void destroy(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_destroyRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void destroy(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_destroyRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Returns the bytes per pixel
      // /
      // / 
      virtual void bytesPerPixel(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_bytesPerPixelRequest* request, ::octaneapi::ApiImageBuffer_bytesPerPixelResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void bytesPerPixel(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_bytesPerPixelRequest* request, ::octaneapi::ApiImageBuffer_bytesPerPixelResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Returns the bytes per pixel channel
      virtual void bytesPerChannel(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_bytesPerChannelRequest* request, ::octaneapi::ApiImageBuffer_bytesPerChannelResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void bytesPerChannel(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_bytesPerChannelRequest* request, ::octaneapi::ApiImageBuffer_bytesPerChannelResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Returns the number of channels of a pixel
      virtual void channelCount(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_channelCountRequest* request, ::octaneapi::ApiImageBuffer_channelCountResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void channelCount(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_channelCountRequest* request, ::octaneapi::ApiImageBuffer_channelCountResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Returns the dimensions of the image in pixels
      virtual void size(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_sizeRequest* request, ::octaneapi::ApiImageBuffer_sizeResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void size(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_sizeRequest* request, ::octaneapi::ApiImageBuffer_sizeResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Returns the size in bytes of the image data
      virtual void sizeInBytes(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_sizeInBytesRequest* request, ::octaneapi::ApiImageBuffer_sizeInBytesResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void sizeInBytes(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_sizeInBytesRequest* request, ::octaneapi::ApiImageBuffer_sizeInBytesResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Returns the image buffer's type
      virtual void type(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_typeRequest* request, ::octaneapi::ApiImageBuffer_typeResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void type(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_typeRequest* request, ::octaneapi::ApiImageBuffer_typeResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Returns the image source information string
      virtual void sourceInfo(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_sourceInfoRequest* request, ::octaneapi::ApiImageBuffer_sourceInfoResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void sourceInfo(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_sourceInfoRequest* request, ::octaneapi::ApiImageBuffer_sourceInfoResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / TRUE if the image can wrap in horizontal direction
      virtual void canWrapX(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_canWrapXRequest* request, ::octaneapi::ApiImageBuffer_canWrapXResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void canWrapX(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_canWrapXRequest* request, ::octaneapi::ApiImageBuffer_canWrapXResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / TRUE if the image can wrap in vertical direction
      virtual void canWrapY(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_canWrapYRequest* request, ::octaneapi::ApiImageBuffer_canWrapYResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void canWrapY(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_canWrapYRequest* request, ::octaneapi::ApiImageBuffer_canWrapYResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / TRUE if the image has Y down (currently only for BC compressed images)
      virtual void needsFlip(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_needsFlipRequest* request, ::octaneapi::ApiImageBuffer_needsFlipResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void needsFlip(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_needsFlipRequest* request, ::octaneapi::ApiImageBuffer_needsFlipResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / TRUE for a transparent image
      virtual void hasAlpha(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_hasAlphaRequest* request, ::octaneapi::ApiImageBuffer_hasAlphaResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void hasAlpha(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_hasAlphaRequest* request, ::octaneapi::ApiImageBuffer_hasAlphaResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / TRUE for a chormatic image
      virtual void hasColor(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_hasColorRequest* request, ::octaneapi::ApiImageBuffer_hasColorResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void hasColor(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_hasColorRequest* request, ::octaneapi::ApiImageBuffer_hasColorResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / TRUE for a compressed image
      virtual void isCompressed(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_isCompressedRequest* request, ::octaneapi::ApiImageBuffer_isCompressedResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void isCompressed(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_isCompressedRequest* request, ::octaneapi::ApiImageBuffer_isCompressedResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Checks if this image has data
      virtual void isEmpty(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_isEmptyRequest* request, ::octaneapi::ApiImageBuffer_isEmptyResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void isEmpty(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_isEmptyRequest* request, ::octaneapi::ApiImageBuffer_isEmptyResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / TRUE for a 16bits Hdr image
      virtual void isHalf(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_isHalfRequest* request, ::octaneapi::ApiImageBuffer_isHalfResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void isHalf(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_isHalfRequest* request, ::octaneapi::ApiImageBuffer_isHalfResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / TRUE for a Hdr image
      virtual void isHdr(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_isHdrRequest* request, ::octaneapi::ApiImageBuffer_isHdrResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void isHdr(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_isHdrRequest* request, ::octaneapi::ApiImageBuffer_isHdrResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / TRUE for a single channel image
      virtual void isMono(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_isMonoRequest* request, ::octaneapi::ApiImageBuffer_isMonoResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void isMono(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_isMonoRequest* request, ::octaneapi::ApiImageBuffer_isMonoResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / TRUE is the given pixel location is valid
      virtual void isPixelValid(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_isPixelValidRequest* request, ::octaneapi::ApiImageBuffer_isPixelValidResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void isPixelValid(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_isPixelValidRequest* request, ::octaneapi::ApiImageBuffer_isPixelValidResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Compresses this image buffer
      // / NOTE: Only works for uncompressed images
      // /
      // / 
      virtual void compress(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_compressRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void compress(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_compressRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Modifies a pixel in a Ldr image buffer
      // / NOTE: This assumes that the buffer represents a un-compressed Ldr image and
      // /       image that goes bottom-to-top (y points down)
      // /
      // / 
      virtual void setPixelLdr(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_setPixelLdrRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void setPixelLdr(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_setPixelLdrRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Modifies a pixel in a 16bits Hdr image buffer
      // / NOTE: This assumes that the buffer represents a 16bits un-compressed Hdr image and
      // /       image that goes bottom-to-top (y points down)
      // /
      // / 
      virtual void setPixelHalf(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_setPixelHalfRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void setPixelHalf(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_setPixelHalfRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Modifies a pixel in a 326bits Hdr image buffer
      // / NOTE: This assumes that the buffer represents a 32bits un-compressed Hdr image and
      // /       image that goes bottom-to-top (y points down)
      // /
      // / 
      virtual void setPixelHdr(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_setPixelHdrRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void setPixelHdr(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_setPixelHdrRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Copies a region from another ImageBuffer
      virtual void copyRegion(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_copyRegionRequest* request, ::octaneapi::ApiImageBuffer_copyRegionResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void copyRegion(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_copyRegionRequest* request, ::octaneapi::ApiImageBuffer_copyRegionResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / eliminates the alpha channel by multiplying the color channels by the alpha channel, and
      // / setting the alpha channel to 1
      virtual void compositeOnBlack(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_compositeOnBlackRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void compositeOnBlack(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_compositeOnBlackRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / vertical flip (in place)
      virtual void flipVertical(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_flipVerticalRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void flipVertical(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_flipVerticalRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Convert the current image bufer to another type
      // / NOTE: Only works for uncompressed images
      // /
      // / 
      virtual void convert(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_convertRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void convert(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_convertRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Applies gaussian filter to the image
      // / NOTE: Only works for uncompressed images
      // /
      // / 
      virtual void applyGaussianFilter(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_applyGaussianFilterRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void applyGaussianFilter(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_applyGaussianFilterRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Applies Box filter to the image
      virtual void applyBoxFilter(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_applyBoxFilterRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void applyBoxFilter(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_applyBoxFilterRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Applies level correction to the image
      // / NOTE: the image must be un-compressed image and have float channels
      // /
      // / 
      virtual void applyLevels(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_applyLevelsRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void applyLevels(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_applyLevelsRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Compares this image to another image, and puts the difference in this image
      // /
      // / 
      virtual void compareValues(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_compareValuesRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void compareValues(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_compareValuesRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Compares this image to another image, and returns the mean square error for it
      // /
      // / 
      virtual void calculateMeanSquareError(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_calculateMeanSquareErrorRequest* request, ::octaneapi::ApiImageBuffer_calculateMeanSquareErrorResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void calculateMeanSquareError(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_calculateMeanSquareErrorRequest* request, ::octaneapi::ApiImageBuffer_calculateMeanSquareErrorResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Saves an image to disk
      virtual void save(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_saveRequest* request, ::octaneapi::ApiImageBuffer_saveResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void save(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_saveRequest* request, ::octaneapi::ApiImageBuffer_saveResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Starts saving an image to disk on a background thread
      // / Compressed images are saved as DDS, HDR images are saved as EXR and LDR images are saved as PNG
      // / NOTE:  The correct extension is added to the path (if it didn't exist yet)
      // /
      // / 
      virtual void saveAsync(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_saveAsyncRequest* request, ::octaneapi::ApiImageBuffer_saveAsyncResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void saveAsync(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_saveAsyncRequest* request, ::octaneapi::ApiImageBuffer_saveAsyncResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Gets the constant reference to the memory location of a pixel
      virtual void pixelAddr(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_pixelAddrRequest* request, ::octaneapi::ApiImageBuffer_pixelAddrResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void pixelAddr(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_pixelAddrRequest* request, ::octaneapi::ApiImageBuffer_pixelAddrResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Gets the mutable reference to the memory location of a pixel
      virtual void pixelAddr1(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_pixelAddr1Request* request, ::octaneapi::ApiImageBuffer_pixelAddr1Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void pixelAddr1(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_pixelAddr1Request* request, ::octaneapi::ApiImageBuffer_pixelAddr1Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_createResponse>* AsynccreateRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_createRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_createResponse>* PrepareAsynccreateRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_createRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_create1Response>* Asynccreate1Raw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_create1Request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_create1Response>* PrepareAsynccreate1Raw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_create1Request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_loadResponse>* AsyncloadRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_loadRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_loadResponse>* PrepareAsyncloadRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_loadRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_load1Response>* Asyncload1Raw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_load1Request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_load1Response>* PrepareAsyncload1Raw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_load1Request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_convertToResponse>* AsyncconvertToRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_convertToRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_convertToResponse>* PrepareAsyncconvertToRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_convertToRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncdestroyRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_destroyRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncdestroyRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_destroyRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_bytesPerPixelResponse>* AsyncbytesPerPixelRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_bytesPerPixelRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_bytesPerPixelResponse>* PrepareAsyncbytesPerPixelRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_bytesPerPixelRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_bytesPerChannelResponse>* AsyncbytesPerChannelRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_bytesPerChannelRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_bytesPerChannelResponse>* PrepareAsyncbytesPerChannelRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_bytesPerChannelRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_channelCountResponse>* AsyncchannelCountRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_channelCountRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_channelCountResponse>* PrepareAsyncchannelCountRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_channelCountRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_sizeResponse>* AsyncsizeRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_sizeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_sizeResponse>* PrepareAsyncsizeRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_sizeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_sizeInBytesResponse>* AsyncsizeInBytesRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_sizeInBytesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_sizeInBytesResponse>* PrepareAsyncsizeInBytesRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_sizeInBytesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_typeResponse>* AsynctypeRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_typeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_typeResponse>* PrepareAsynctypeRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_typeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_sourceInfoResponse>* AsyncsourceInfoRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_sourceInfoRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_sourceInfoResponse>* PrepareAsyncsourceInfoRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_sourceInfoRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_canWrapXResponse>* AsynccanWrapXRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_canWrapXRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_canWrapXResponse>* PrepareAsynccanWrapXRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_canWrapXRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_canWrapYResponse>* AsynccanWrapYRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_canWrapYRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_canWrapYResponse>* PrepareAsynccanWrapYRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_canWrapYRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_needsFlipResponse>* AsyncneedsFlipRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_needsFlipRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_needsFlipResponse>* PrepareAsyncneedsFlipRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_needsFlipRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_hasAlphaResponse>* AsynchasAlphaRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_hasAlphaRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_hasAlphaResponse>* PrepareAsynchasAlphaRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_hasAlphaRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_hasColorResponse>* AsynchasColorRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_hasColorRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_hasColorResponse>* PrepareAsynchasColorRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_hasColorRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_isCompressedResponse>* AsyncisCompressedRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_isCompressedRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_isCompressedResponse>* PrepareAsyncisCompressedRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_isCompressedRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_isEmptyResponse>* AsyncisEmptyRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_isEmptyRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_isEmptyResponse>* PrepareAsyncisEmptyRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_isEmptyRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_isHalfResponse>* AsyncisHalfRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_isHalfRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_isHalfResponse>* PrepareAsyncisHalfRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_isHalfRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_isHdrResponse>* AsyncisHdrRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_isHdrRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_isHdrResponse>* PrepareAsyncisHdrRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_isHdrRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_isMonoResponse>* AsyncisMonoRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_isMonoRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_isMonoResponse>* PrepareAsyncisMonoRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_isMonoRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_isPixelValidResponse>* AsyncisPixelValidRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_isPixelValidRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_isPixelValidResponse>* PrepareAsyncisPixelValidRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_isPixelValidRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsynccompressRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_compressRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsynccompressRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_compressRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncsetPixelLdrRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_setPixelLdrRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncsetPixelLdrRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_setPixelLdrRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncsetPixelHalfRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_setPixelHalfRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncsetPixelHalfRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_setPixelHalfRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncsetPixelHdrRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_setPixelHdrRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncsetPixelHdrRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_setPixelHdrRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_copyRegionResponse>* AsynccopyRegionRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_copyRegionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_copyRegionResponse>* PrepareAsynccopyRegionRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_copyRegionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsynccompositeOnBlackRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_compositeOnBlackRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsynccompositeOnBlackRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_compositeOnBlackRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncflipVerticalRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_flipVerticalRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncflipVerticalRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_flipVerticalRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncconvertRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_convertRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncconvertRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_convertRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncapplyGaussianFilterRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_applyGaussianFilterRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncapplyGaussianFilterRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_applyGaussianFilterRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncapplyBoxFilterRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_applyBoxFilterRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncapplyBoxFilterRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_applyBoxFilterRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncapplyLevelsRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_applyLevelsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncapplyLevelsRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_applyLevelsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsynccompareValuesRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_compareValuesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsynccompareValuesRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_compareValuesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_calculateMeanSquareErrorResponse>* AsynccalculateMeanSquareErrorRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_calculateMeanSquareErrorRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_calculateMeanSquareErrorResponse>* PrepareAsynccalculateMeanSquareErrorRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_calculateMeanSquareErrorRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_saveResponse>* AsyncsaveRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_saveRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_saveResponse>* PrepareAsyncsaveRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_saveRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_saveAsyncResponse>* AsyncsaveAsyncRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_saveAsyncRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_saveAsyncResponse>* PrepareAsyncsaveAsyncRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_saveAsyncRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_pixelAddrResponse>* AsyncpixelAddrRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_pixelAddrRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_pixelAddrResponse>* PrepareAsyncpixelAddrRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_pixelAddrRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_pixelAddr1Response>* AsyncpixelAddr1Raw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_pixelAddr1Request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiImageBuffer_pixelAddr1Response>* PrepareAsyncpixelAddr1Raw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_pixelAddr1Request& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status create(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_createRequest& request, ::octaneapi::ApiImageBuffer_createResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_createResponse>> Asynccreate(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_createRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_createResponse>>(AsynccreateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_createResponse>> PrepareAsynccreate(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_createRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_createResponse>>(PrepareAsynccreateRaw(context, request, cq));
    }
    ::grpc::Status create1(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_create1Request& request, ::octaneapi::ApiImageBuffer_create1Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_create1Response>> Asynccreate1(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_create1Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_create1Response>>(Asynccreate1Raw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_create1Response>> PrepareAsynccreate1(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_create1Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_create1Response>>(PrepareAsynccreate1Raw(context, request, cq));
    }
    ::grpc::Status load(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_loadRequest& request, ::octaneapi::ApiImageBuffer_loadResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_loadResponse>> Asyncload(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_loadRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_loadResponse>>(AsyncloadRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_loadResponse>> PrepareAsyncload(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_loadRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_loadResponse>>(PrepareAsyncloadRaw(context, request, cq));
    }
    ::grpc::Status load1(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_load1Request& request, ::octaneapi::ApiImageBuffer_load1Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_load1Response>> Asyncload1(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_load1Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_load1Response>>(Asyncload1Raw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_load1Response>> PrepareAsyncload1(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_load1Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_load1Response>>(PrepareAsyncload1Raw(context, request, cq));
    }
    ::grpc::Status convertTo(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_convertToRequest& request, ::octaneapi::ApiImageBuffer_convertToResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_convertToResponse>> AsyncconvertTo(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_convertToRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_convertToResponse>>(AsyncconvertToRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_convertToResponse>> PrepareAsyncconvertTo(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_convertToRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_convertToResponse>>(PrepareAsyncconvertToRaw(context, request, cq));
    }
    ::grpc::Status destroy(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_destroyRequest& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> Asyncdestroy(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_destroyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncdestroyRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncdestroy(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_destroyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncdestroyRaw(context, request, cq));
    }
    ::grpc::Status bytesPerPixel(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_bytesPerPixelRequest& request, ::octaneapi::ApiImageBuffer_bytesPerPixelResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_bytesPerPixelResponse>> AsyncbytesPerPixel(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_bytesPerPixelRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_bytesPerPixelResponse>>(AsyncbytesPerPixelRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_bytesPerPixelResponse>> PrepareAsyncbytesPerPixel(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_bytesPerPixelRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_bytesPerPixelResponse>>(PrepareAsyncbytesPerPixelRaw(context, request, cq));
    }
    ::grpc::Status bytesPerChannel(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_bytesPerChannelRequest& request, ::octaneapi::ApiImageBuffer_bytesPerChannelResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_bytesPerChannelResponse>> AsyncbytesPerChannel(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_bytesPerChannelRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_bytesPerChannelResponse>>(AsyncbytesPerChannelRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_bytesPerChannelResponse>> PrepareAsyncbytesPerChannel(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_bytesPerChannelRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_bytesPerChannelResponse>>(PrepareAsyncbytesPerChannelRaw(context, request, cq));
    }
    ::grpc::Status channelCount(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_channelCountRequest& request, ::octaneapi::ApiImageBuffer_channelCountResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_channelCountResponse>> AsyncchannelCount(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_channelCountRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_channelCountResponse>>(AsyncchannelCountRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_channelCountResponse>> PrepareAsyncchannelCount(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_channelCountRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_channelCountResponse>>(PrepareAsyncchannelCountRaw(context, request, cq));
    }
    ::grpc::Status size(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_sizeRequest& request, ::octaneapi::ApiImageBuffer_sizeResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_sizeResponse>> Asyncsize(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_sizeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_sizeResponse>>(AsyncsizeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_sizeResponse>> PrepareAsyncsize(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_sizeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_sizeResponse>>(PrepareAsyncsizeRaw(context, request, cq));
    }
    ::grpc::Status sizeInBytes(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_sizeInBytesRequest& request, ::octaneapi::ApiImageBuffer_sizeInBytesResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_sizeInBytesResponse>> AsyncsizeInBytes(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_sizeInBytesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_sizeInBytesResponse>>(AsyncsizeInBytesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_sizeInBytesResponse>> PrepareAsyncsizeInBytes(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_sizeInBytesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_sizeInBytesResponse>>(PrepareAsyncsizeInBytesRaw(context, request, cq));
    }
    ::grpc::Status type(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_typeRequest& request, ::octaneapi::ApiImageBuffer_typeResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_typeResponse>> Asynctype(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_typeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_typeResponse>>(AsynctypeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_typeResponse>> PrepareAsynctype(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_typeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_typeResponse>>(PrepareAsynctypeRaw(context, request, cq));
    }
    ::grpc::Status sourceInfo(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_sourceInfoRequest& request, ::octaneapi::ApiImageBuffer_sourceInfoResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_sourceInfoResponse>> AsyncsourceInfo(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_sourceInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_sourceInfoResponse>>(AsyncsourceInfoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_sourceInfoResponse>> PrepareAsyncsourceInfo(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_sourceInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_sourceInfoResponse>>(PrepareAsyncsourceInfoRaw(context, request, cq));
    }
    ::grpc::Status canWrapX(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_canWrapXRequest& request, ::octaneapi::ApiImageBuffer_canWrapXResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_canWrapXResponse>> AsynccanWrapX(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_canWrapXRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_canWrapXResponse>>(AsynccanWrapXRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_canWrapXResponse>> PrepareAsynccanWrapX(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_canWrapXRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_canWrapXResponse>>(PrepareAsynccanWrapXRaw(context, request, cq));
    }
    ::grpc::Status canWrapY(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_canWrapYRequest& request, ::octaneapi::ApiImageBuffer_canWrapYResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_canWrapYResponse>> AsynccanWrapY(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_canWrapYRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_canWrapYResponse>>(AsynccanWrapYRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_canWrapYResponse>> PrepareAsynccanWrapY(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_canWrapYRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_canWrapYResponse>>(PrepareAsynccanWrapYRaw(context, request, cq));
    }
    ::grpc::Status needsFlip(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_needsFlipRequest& request, ::octaneapi::ApiImageBuffer_needsFlipResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_needsFlipResponse>> AsyncneedsFlip(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_needsFlipRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_needsFlipResponse>>(AsyncneedsFlipRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_needsFlipResponse>> PrepareAsyncneedsFlip(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_needsFlipRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_needsFlipResponse>>(PrepareAsyncneedsFlipRaw(context, request, cq));
    }
    ::grpc::Status hasAlpha(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_hasAlphaRequest& request, ::octaneapi::ApiImageBuffer_hasAlphaResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_hasAlphaResponse>> AsynchasAlpha(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_hasAlphaRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_hasAlphaResponse>>(AsynchasAlphaRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_hasAlphaResponse>> PrepareAsynchasAlpha(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_hasAlphaRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_hasAlphaResponse>>(PrepareAsynchasAlphaRaw(context, request, cq));
    }
    ::grpc::Status hasColor(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_hasColorRequest& request, ::octaneapi::ApiImageBuffer_hasColorResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_hasColorResponse>> AsynchasColor(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_hasColorRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_hasColorResponse>>(AsynchasColorRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_hasColorResponse>> PrepareAsynchasColor(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_hasColorRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_hasColorResponse>>(PrepareAsynchasColorRaw(context, request, cq));
    }
    ::grpc::Status isCompressed(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_isCompressedRequest& request, ::octaneapi::ApiImageBuffer_isCompressedResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_isCompressedResponse>> AsyncisCompressed(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_isCompressedRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_isCompressedResponse>>(AsyncisCompressedRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_isCompressedResponse>> PrepareAsyncisCompressed(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_isCompressedRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_isCompressedResponse>>(PrepareAsyncisCompressedRaw(context, request, cq));
    }
    ::grpc::Status isEmpty(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_isEmptyRequest& request, ::octaneapi::ApiImageBuffer_isEmptyResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_isEmptyResponse>> AsyncisEmpty(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_isEmptyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_isEmptyResponse>>(AsyncisEmptyRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_isEmptyResponse>> PrepareAsyncisEmpty(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_isEmptyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_isEmptyResponse>>(PrepareAsyncisEmptyRaw(context, request, cq));
    }
    ::grpc::Status isHalf(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_isHalfRequest& request, ::octaneapi::ApiImageBuffer_isHalfResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_isHalfResponse>> AsyncisHalf(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_isHalfRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_isHalfResponse>>(AsyncisHalfRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_isHalfResponse>> PrepareAsyncisHalf(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_isHalfRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_isHalfResponse>>(PrepareAsyncisHalfRaw(context, request, cq));
    }
    ::grpc::Status isHdr(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_isHdrRequest& request, ::octaneapi::ApiImageBuffer_isHdrResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_isHdrResponse>> AsyncisHdr(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_isHdrRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_isHdrResponse>>(AsyncisHdrRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_isHdrResponse>> PrepareAsyncisHdr(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_isHdrRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_isHdrResponse>>(PrepareAsyncisHdrRaw(context, request, cq));
    }
    ::grpc::Status isMono(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_isMonoRequest& request, ::octaneapi::ApiImageBuffer_isMonoResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_isMonoResponse>> AsyncisMono(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_isMonoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_isMonoResponse>>(AsyncisMonoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_isMonoResponse>> PrepareAsyncisMono(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_isMonoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_isMonoResponse>>(PrepareAsyncisMonoRaw(context, request, cq));
    }
    ::grpc::Status isPixelValid(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_isPixelValidRequest& request, ::octaneapi::ApiImageBuffer_isPixelValidResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_isPixelValidResponse>> AsyncisPixelValid(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_isPixelValidRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_isPixelValidResponse>>(AsyncisPixelValidRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_isPixelValidResponse>> PrepareAsyncisPixelValid(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_isPixelValidRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_isPixelValidResponse>>(PrepareAsyncisPixelValidRaw(context, request, cq));
    }
    ::grpc::Status compress(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_compressRequest& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> Asynccompress(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_compressRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsynccompressRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsynccompress(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_compressRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsynccompressRaw(context, request, cq));
    }
    ::grpc::Status setPixelLdr(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_setPixelLdrRequest& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncsetPixelLdr(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_setPixelLdrRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncsetPixelLdrRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncsetPixelLdr(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_setPixelLdrRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncsetPixelLdrRaw(context, request, cq));
    }
    ::grpc::Status setPixelHalf(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_setPixelHalfRequest& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncsetPixelHalf(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_setPixelHalfRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncsetPixelHalfRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncsetPixelHalf(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_setPixelHalfRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncsetPixelHalfRaw(context, request, cq));
    }
    ::grpc::Status setPixelHdr(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_setPixelHdrRequest& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncsetPixelHdr(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_setPixelHdrRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncsetPixelHdrRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncsetPixelHdr(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_setPixelHdrRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncsetPixelHdrRaw(context, request, cq));
    }
    ::grpc::Status copyRegion(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_copyRegionRequest& request, ::octaneapi::ApiImageBuffer_copyRegionResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_copyRegionResponse>> AsynccopyRegion(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_copyRegionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_copyRegionResponse>>(AsynccopyRegionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_copyRegionResponse>> PrepareAsynccopyRegion(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_copyRegionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_copyRegionResponse>>(PrepareAsynccopyRegionRaw(context, request, cq));
    }
    ::grpc::Status compositeOnBlack(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_compositeOnBlackRequest& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsynccompositeOnBlack(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_compositeOnBlackRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsynccompositeOnBlackRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsynccompositeOnBlack(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_compositeOnBlackRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsynccompositeOnBlackRaw(context, request, cq));
    }
    ::grpc::Status flipVertical(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_flipVerticalRequest& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncflipVertical(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_flipVerticalRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncflipVerticalRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncflipVertical(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_flipVerticalRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncflipVerticalRaw(context, request, cq));
    }
    ::grpc::Status convert(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_convertRequest& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> Asyncconvert(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_convertRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncconvertRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncconvert(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_convertRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncconvertRaw(context, request, cq));
    }
    ::grpc::Status applyGaussianFilter(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_applyGaussianFilterRequest& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncapplyGaussianFilter(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_applyGaussianFilterRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncapplyGaussianFilterRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncapplyGaussianFilter(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_applyGaussianFilterRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncapplyGaussianFilterRaw(context, request, cq));
    }
    ::grpc::Status applyBoxFilter(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_applyBoxFilterRequest& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncapplyBoxFilter(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_applyBoxFilterRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncapplyBoxFilterRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncapplyBoxFilter(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_applyBoxFilterRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncapplyBoxFilterRaw(context, request, cq));
    }
    ::grpc::Status applyLevels(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_applyLevelsRequest& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncapplyLevels(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_applyLevelsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncapplyLevelsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncapplyLevels(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_applyLevelsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncapplyLevelsRaw(context, request, cq));
    }
    ::grpc::Status compareValues(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_compareValuesRequest& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsynccompareValues(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_compareValuesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsynccompareValuesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsynccompareValues(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_compareValuesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsynccompareValuesRaw(context, request, cq));
    }
    ::grpc::Status calculateMeanSquareError(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_calculateMeanSquareErrorRequest& request, ::octaneapi::ApiImageBuffer_calculateMeanSquareErrorResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_calculateMeanSquareErrorResponse>> AsynccalculateMeanSquareError(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_calculateMeanSquareErrorRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_calculateMeanSquareErrorResponse>>(AsynccalculateMeanSquareErrorRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_calculateMeanSquareErrorResponse>> PrepareAsynccalculateMeanSquareError(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_calculateMeanSquareErrorRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_calculateMeanSquareErrorResponse>>(PrepareAsynccalculateMeanSquareErrorRaw(context, request, cq));
    }
    ::grpc::Status save(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_saveRequest& request, ::octaneapi::ApiImageBuffer_saveResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_saveResponse>> Asyncsave(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_saveRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_saveResponse>>(AsyncsaveRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_saveResponse>> PrepareAsyncsave(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_saveRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_saveResponse>>(PrepareAsyncsaveRaw(context, request, cq));
    }
    ::grpc::Status saveAsync(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_saveAsyncRequest& request, ::octaneapi::ApiImageBuffer_saveAsyncResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_saveAsyncResponse>> AsyncsaveAsync(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_saveAsyncRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_saveAsyncResponse>>(AsyncsaveAsyncRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_saveAsyncResponse>> PrepareAsyncsaveAsync(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_saveAsyncRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_saveAsyncResponse>>(PrepareAsyncsaveAsyncRaw(context, request, cq));
    }
    ::grpc::Status pixelAddr(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_pixelAddrRequest& request, ::octaneapi::ApiImageBuffer_pixelAddrResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_pixelAddrResponse>> AsyncpixelAddr(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_pixelAddrRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_pixelAddrResponse>>(AsyncpixelAddrRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_pixelAddrResponse>> PrepareAsyncpixelAddr(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_pixelAddrRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_pixelAddrResponse>>(PrepareAsyncpixelAddrRaw(context, request, cq));
    }
    ::grpc::Status pixelAddr1(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_pixelAddr1Request& request, ::octaneapi::ApiImageBuffer_pixelAddr1Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_pixelAddr1Response>> AsyncpixelAddr1(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_pixelAddr1Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_pixelAddr1Response>>(AsyncpixelAddr1Raw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_pixelAddr1Response>> PrepareAsyncpixelAddr1(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_pixelAddr1Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_pixelAddr1Response>>(PrepareAsyncpixelAddr1Raw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void create(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_createRequest* request, ::octaneapi::ApiImageBuffer_createResponse* response, std::function<void(::grpc::Status)>) override;
      void create(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_createRequest* request, ::octaneapi::ApiImageBuffer_createResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void create1(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_create1Request* request, ::octaneapi::ApiImageBuffer_create1Response* response, std::function<void(::grpc::Status)>) override;
      void create1(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_create1Request* request, ::octaneapi::ApiImageBuffer_create1Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void load(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_loadRequest* request, ::octaneapi::ApiImageBuffer_loadResponse* response, std::function<void(::grpc::Status)>) override;
      void load(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_loadRequest* request, ::octaneapi::ApiImageBuffer_loadResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void load1(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_load1Request* request, ::octaneapi::ApiImageBuffer_load1Response* response, std::function<void(::grpc::Status)>) override;
      void load1(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_load1Request* request, ::octaneapi::ApiImageBuffer_load1Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void convertTo(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_convertToRequest* request, ::octaneapi::ApiImageBuffer_convertToResponse* response, std::function<void(::grpc::Status)>) override;
      void convertTo(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_convertToRequest* request, ::octaneapi::ApiImageBuffer_convertToResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void destroy(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_destroyRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      void destroy(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_destroyRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void bytesPerPixel(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_bytesPerPixelRequest* request, ::octaneapi::ApiImageBuffer_bytesPerPixelResponse* response, std::function<void(::grpc::Status)>) override;
      void bytesPerPixel(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_bytesPerPixelRequest* request, ::octaneapi::ApiImageBuffer_bytesPerPixelResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void bytesPerChannel(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_bytesPerChannelRequest* request, ::octaneapi::ApiImageBuffer_bytesPerChannelResponse* response, std::function<void(::grpc::Status)>) override;
      void bytesPerChannel(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_bytesPerChannelRequest* request, ::octaneapi::ApiImageBuffer_bytesPerChannelResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void channelCount(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_channelCountRequest* request, ::octaneapi::ApiImageBuffer_channelCountResponse* response, std::function<void(::grpc::Status)>) override;
      void channelCount(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_channelCountRequest* request, ::octaneapi::ApiImageBuffer_channelCountResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void size(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_sizeRequest* request, ::octaneapi::ApiImageBuffer_sizeResponse* response, std::function<void(::grpc::Status)>) override;
      void size(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_sizeRequest* request, ::octaneapi::ApiImageBuffer_sizeResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void sizeInBytes(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_sizeInBytesRequest* request, ::octaneapi::ApiImageBuffer_sizeInBytesResponse* response, std::function<void(::grpc::Status)>) override;
      void sizeInBytes(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_sizeInBytesRequest* request, ::octaneapi::ApiImageBuffer_sizeInBytesResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void type(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_typeRequest* request, ::octaneapi::ApiImageBuffer_typeResponse* response, std::function<void(::grpc::Status)>) override;
      void type(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_typeRequest* request, ::octaneapi::ApiImageBuffer_typeResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void sourceInfo(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_sourceInfoRequest* request, ::octaneapi::ApiImageBuffer_sourceInfoResponse* response, std::function<void(::grpc::Status)>) override;
      void sourceInfo(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_sourceInfoRequest* request, ::octaneapi::ApiImageBuffer_sourceInfoResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void canWrapX(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_canWrapXRequest* request, ::octaneapi::ApiImageBuffer_canWrapXResponse* response, std::function<void(::grpc::Status)>) override;
      void canWrapX(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_canWrapXRequest* request, ::octaneapi::ApiImageBuffer_canWrapXResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void canWrapY(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_canWrapYRequest* request, ::octaneapi::ApiImageBuffer_canWrapYResponse* response, std::function<void(::grpc::Status)>) override;
      void canWrapY(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_canWrapYRequest* request, ::octaneapi::ApiImageBuffer_canWrapYResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void needsFlip(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_needsFlipRequest* request, ::octaneapi::ApiImageBuffer_needsFlipResponse* response, std::function<void(::grpc::Status)>) override;
      void needsFlip(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_needsFlipRequest* request, ::octaneapi::ApiImageBuffer_needsFlipResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void hasAlpha(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_hasAlphaRequest* request, ::octaneapi::ApiImageBuffer_hasAlphaResponse* response, std::function<void(::grpc::Status)>) override;
      void hasAlpha(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_hasAlphaRequest* request, ::octaneapi::ApiImageBuffer_hasAlphaResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void hasColor(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_hasColorRequest* request, ::octaneapi::ApiImageBuffer_hasColorResponse* response, std::function<void(::grpc::Status)>) override;
      void hasColor(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_hasColorRequest* request, ::octaneapi::ApiImageBuffer_hasColorResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void isCompressed(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_isCompressedRequest* request, ::octaneapi::ApiImageBuffer_isCompressedResponse* response, std::function<void(::grpc::Status)>) override;
      void isCompressed(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_isCompressedRequest* request, ::octaneapi::ApiImageBuffer_isCompressedResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void isEmpty(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_isEmptyRequest* request, ::octaneapi::ApiImageBuffer_isEmptyResponse* response, std::function<void(::grpc::Status)>) override;
      void isEmpty(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_isEmptyRequest* request, ::octaneapi::ApiImageBuffer_isEmptyResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void isHalf(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_isHalfRequest* request, ::octaneapi::ApiImageBuffer_isHalfResponse* response, std::function<void(::grpc::Status)>) override;
      void isHalf(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_isHalfRequest* request, ::octaneapi::ApiImageBuffer_isHalfResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void isHdr(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_isHdrRequest* request, ::octaneapi::ApiImageBuffer_isHdrResponse* response, std::function<void(::grpc::Status)>) override;
      void isHdr(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_isHdrRequest* request, ::octaneapi::ApiImageBuffer_isHdrResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void isMono(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_isMonoRequest* request, ::octaneapi::ApiImageBuffer_isMonoResponse* response, std::function<void(::grpc::Status)>) override;
      void isMono(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_isMonoRequest* request, ::octaneapi::ApiImageBuffer_isMonoResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void isPixelValid(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_isPixelValidRequest* request, ::octaneapi::ApiImageBuffer_isPixelValidResponse* response, std::function<void(::grpc::Status)>) override;
      void isPixelValid(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_isPixelValidRequest* request, ::octaneapi::ApiImageBuffer_isPixelValidResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void compress(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_compressRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      void compress(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_compressRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void setPixelLdr(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_setPixelLdrRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      void setPixelLdr(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_setPixelLdrRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void setPixelHalf(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_setPixelHalfRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      void setPixelHalf(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_setPixelHalfRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void setPixelHdr(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_setPixelHdrRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      void setPixelHdr(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_setPixelHdrRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void copyRegion(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_copyRegionRequest* request, ::octaneapi::ApiImageBuffer_copyRegionResponse* response, std::function<void(::grpc::Status)>) override;
      void copyRegion(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_copyRegionRequest* request, ::octaneapi::ApiImageBuffer_copyRegionResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void compositeOnBlack(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_compositeOnBlackRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      void compositeOnBlack(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_compositeOnBlackRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void flipVertical(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_flipVerticalRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      void flipVertical(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_flipVerticalRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void convert(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_convertRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      void convert(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_convertRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void applyGaussianFilter(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_applyGaussianFilterRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      void applyGaussianFilter(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_applyGaussianFilterRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void applyBoxFilter(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_applyBoxFilterRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      void applyBoxFilter(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_applyBoxFilterRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void applyLevels(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_applyLevelsRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      void applyLevels(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_applyLevelsRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void compareValues(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_compareValuesRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      void compareValues(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_compareValuesRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void calculateMeanSquareError(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_calculateMeanSquareErrorRequest* request, ::octaneapi::ApiImageBuffer_calculateMeanSquareErrorResponse* response, std::function<void(::grpc::Status)>) override;
      void calculateMeanSquareError(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_calculateMeanSquareErrorRequest* request, ::octaneapi::ApiImageBuffer_calculateMeanSquareErrorResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void save(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_saveRequest* request, ::octaneapi::ApiImageBuffer_saveResponse* response, std::function<void(::grpc::Status)>) override;
      void save(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_saveRequest* request, ::octaneapi::ApiImageBuffer_saveResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void saveAsync(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_saveAsyncRequest* request, ::octaneapi::ApiImageBuffer_saveAsyncResponse* response, std::function<void(::grpc::Status)>) override;
      void saveAsync(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_saveAsyncRequest* request, ::octaneapi::ApiImageBuffer_saveAsyncResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void pixelAddr(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_pixelAddrRequest* request, ::octaneapi::ApiImageBuffer_pixelAddrResponse* response, std::function<void(::grpc::Status)>) override;
      void pixelAddr(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_pixelAddrRequest* request, ::octaneapi::ApiImageBuffer_pixelAddrResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void pixelAddr1(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_pixelAddr1Request* request, ::octaneapi::ApiImageBuffer_pixelAddr1Response* response, std::function<void(::grpc::Status)>) override;
      void pixelAddr1(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_pixelAddr1Request* request, ::octaneapi::ApiImageBuffer_pixelAddr1Response* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_createResponse>* AsynccreateRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_createRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_createResponse>* PrepareAsynccreateRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_createRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_create1Response>* Asynccreate1Raw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_create1Request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_create1Response>* PrepareAsynccreate1Raw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_create1Request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_loadResponse>* AsyncloadRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_loadRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_loadResponse>* PrepareAsyncloadRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_loadRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_load1Response>* Asyncload1Raw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_load1Request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_load1Response>* PrepareAsyncload1Raw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_load1Request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_convertToResponse>* AsyncconvertToRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_convertToRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_convertToResponse>* PrepareAsyncconvertToRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_convertToRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncdestroyRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_destroyRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncdestroyRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_destroyRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_bytesPerPixelResponse>* AsyncbytesPerPixelRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_bytesPerPixelRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_bytesPerPixelResponse>* PrepareAsyncbytesPerPixelRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_bytesPerPixelRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_bytesPerChannelResponse>* AsyncbytesPerChannelRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_bytesPerChannelRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_bytesPerChannelResponse>* PrepareAsyncbytesPerChannelRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_bytesPerChannelRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_channelCountResponse>* AsyncchannelCountRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_channelCountRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_channelCountResponse>* PrepareAsyncchannelCountRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_channelCountRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_sizeResponse>* AsyncsizeRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_sizeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_sizeResponse>* PrepareAsyncsizeRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_sizeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_sizeInBytesResponse>* AsyncsizeInBytesRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_sizeInBytesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_sizeInBytesResponse>* PrepareAsyncsizeInBytesRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_sizeInBytesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_typeResponse>* AsynctypeRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_typeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_typeResponse>* PrepareAsynctypeRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_typeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_sourceInfoResponse>* AsyncsourceInfoRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_sourceInfoRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_sourceInfoResponse>* PrepareAsyncsourceInfoRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_sourceInfoRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_canWrapXResponse>* AsynccanWrapXRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_canWrapXRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_canWrapXResponse>* PrepareAsynccanWrapXRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_canWrapXRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_canWrapYResponse>* AsynccanWrapYRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_canWrapYRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_canWrapYResponse>* PrepareAsynccanWrapYRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_canWrapYRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_needsFlipResponse>* AsyncneedsFlipRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_needsFlipRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_needsFlipResponse>* PrepareAsyncneedsFlipRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_needsFlipRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_hasAlphaResponse>* AsynchasAlphaRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_hasAlphaRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_hasAlphaResponse>* PrepareAsynchasAlphaRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_hasAlphaRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_hasColorResponse>* AsynchasColorRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_hasColorRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_hasColorResponse>* PrepareAsynchasColorRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_hasColorRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_isCompressedResponse>* AsyncisCompressedRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_isCompressedRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_isCompressedResponse>* PrepareAsyncisCompressedRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_isCompressedRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_isEmptyResponse>* AsyncisEmptyRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_isEmptyRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_isEmptyResponse>* PrepareAsyncisEmptyRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_isEmptyRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_isHalfResponse>* AsyncisHalfRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_isHalfRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_isHalfResponse>* PrepareAsyncisHalfRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_isHalfRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_isHdrResponse>* AsyncisHdrRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_isHdrRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_isHdrResponse>* PrepareAsyncisHdrRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_isHdrRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_isMonoResponse>* AsyncisMonoRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_isMonoRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_isMonoResponse>* PrepareAsyncisMonoRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_isMonoRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_isPixelValidResponse>* AsyncisPixelValidRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_isPixelValidRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_isPixelValidResponse>* PrepareAsyncisPixelValidRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_isPixelValidRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsynccompressRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_compressRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsynccompressRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_compressRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncsetPixelLdrRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_setPixelLdrRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncsetPixelLdrRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_setPixelLdrRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncsetPixelHalfRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_setPixelHalfRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncsetPixelHalfRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_setPixelHalfRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncsetPixelHdrRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_setPixelHdrRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncsetPixelHdrRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_setPixelHdrRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_copyRegionResponse>* AsynccopyRegionRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_copyRegionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_copyRegionResponse>* PrepareAsynccopyRegionRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_copyRegionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsynccompositeOnBlackRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_compositeOnBlackRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsynccompositeOnBlackRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_compositeOnBlackRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncflipVerticalRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_flipVerticalRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncflipVerticalRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_flipVerticalRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncconvertRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_convertRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncconvertRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_convertRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncapplyGaussianFilterRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_applyGaussianFilterRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncapplyGaussianFilterRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_applyGaussianFilterRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncapplyBoxFilterRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_applyBoxFilterRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncapplyBoxFilterRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_applyBoxFilterRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncapplyLevelsRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_applyLevelsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncapplyLevelsRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_applyLevelsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsynccompareValuesRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_compareValuesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsynccompareValuesRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_compareValuesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_calculateMeanSquareErrorResponse>* AsynccalculateMeanSquareErrorRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_calculateMeanSquareErrorRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_calculateMeanSquareErrorResponse>* PrepareAsynccalculateMeanSquareErrorRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_calculateMeanSquareErrorRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_saveResponse>* AsyncsaveRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_saveRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_saveResponse>* PrepareAsyncsaveRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_saveRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_saveAsyncResponse>* AsyncsaveAsyncRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_saveAsyncRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_saveAsyncResponse>* PrepareAsyncsaveAsyncRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_saveAsyncRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_pixelAddrResponse>* AsyncpixelAddrRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_pixelAddrRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_pixelAddrResponse>* PrepareAsyncpixelAddrRaw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_pixelAddrRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_pixelAddr1Response>* AsyncpixelAddr1Raw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_pixelAddr1Request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiImageBuffer_pixelAddr1Response>* PrepareAsyncpixelAddr1Raw(::grpc::ClientContext* context, const ::octaneapi::ApiImageBuffer_pixelAddr1Request& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_create_;
    const ::grpc::internal::RpcMethod rpcmethod_create1_;
    const ::grpc::internal::RpcMethod rpcmethod_load_;
    const ::grpc::internal::RpcMethod rpcmethod_load1_;
    const ::grpc::internal::RpcMethod rpcmethod_convertTo_;
    const ::grpc::internal::RpcMethod rpcmethod_destroy_;
    const ::grpc::internal::RpcMethod rpcmethod_bytesPerPixel_;
    const ::grpc::internal::RpcMethod rpcmethod_bytesPerChannel_;
    const ::grpc::internal::RpcMethod rpcmethod_channelCount_;
    const ::grpc::internal::RpcMethod rpcmethod_size_;
    const ::grpc::internal::RpcMethod rpcmethod_sizeInBytes_;
    const ::grpc::internal::RpcMethod rpcmethod_type_;
    const ::grpc::internal::RpcMethod rpcmethod_sourceInfo_;
    const ::grpc::internal::RpcMethod rpcmethod_canWrapX_;
    const ::grpc::internal::RpcMethod rpcmethod_canWrapY_;
    const ::grpc::internal::RpcMethod rpcmethod_needsFlip_;
    const ::grpc::internal::RpcMethod rpcmethod_hasAlpha_;
    const ::grpc::internal::RpcMethod rpcmethod_hasColor_;
    const ::grpc::internal::RpcMethod rpcmethod_isCompressed_;
    const ::grpc::internal::RpcMethod rpcmethod_isEmpty_;
    const ::grpc::internal::RpcMethod rpcmethod_isHalf_;
    const ::grpc::internal::RpcMethod rpcmethod_isHdr_;
    const ::grpc::internal::RpcMethod rpcmethod_isMono_;
    const ::grpc::internal::RpcMethod rpcmethod_isPixelValid_;
    const ::grpc::internal::RpcMethod rpcmethod_compress_;
    const ::grpc::internal::RpcMethod rpcmethod_setPixelLdr_;
    const ::grpc::internal::RpcMethod rpcmethod_setPixelHalf_;
    const ::grpc::internal::RpcMethod rpcmethod_setPixelHdr_;
    const ::grpc::internal::RpcMethod rpcmethod_copyRegion_;
    const ::grpc::internal::RpcMethod rpcmethod_compositeOnBlack_;
    const ::grpc::internal::RpcMethod rpcmethod_flipVertical_;
    const ::grpc::internal::RpcMethod rpcmethod_convert_;
    const ::grpc::internal::RpcMethod rpcmethod_applyGaussianFilter_;
    const ::grpc::internal::RpcMethod rpcmethod_applyBoxFilter_;
    const ::grpc::internal::RpcMethod rpcmethod_applyLevels_;
    const ::grpc::internal::RpcMethod rpcmethod_compareValues_;
    const ::grpc::internal::RpcMethod rpcmethod_calculateMeanSquareError_;
    const ::grpc::internal::RpcMethod rpcmethod_save_;
    const ::grpc::internal::RpcMethod rpcmethod_saveAsync_;
    const ::grpc::internal::RpcMethod rpcmethod_pixelAddr_;
    const ::grpc::internal::RpcMethod rpcmethod_pixelAddr1_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // / Creates an empty image buffer
    // / 
    virtual ::grpc::Status create(::grpc::ServerContext* context, const ::octaneapi::ApiImageBuffer_createRequest* request, ::octaneapi::ApiImageBuffer_createResponse* response);
    // / Creates an image buffer using the given data
    // /
    // / 
    virtual ::grpc::Status create1(::grpc::ServerContext* context, const ::octaneapi::ApiImageBuffer_create1Request* request, ::octaneapi::ApiImageBuffer_create1Response* response);
    // / Loads an image from file
    // / 
    virtual ::grpc::Status load(::grpc::ServerContext* context, const ::octaneapi::ApiImageBuffer_loadRequest* request, ::octaneapi::ApiImageBuffer_loadResponse* response);
    // / Loads an image from encoded data(for instance, from a memory block of a png file)
    virtual ::grpc::Status load1(::grpc::ServerContext* context, const ::octaneapi::ApiImageBuffer_load1Request* request, ::octaneapi::ApiImageBuffer_load1Response* response);
    // / Convert the source image buffer to another one using the destination type
    // / NOTE: Only works for uncompressed images
    // / Meta data (like wrapping and alpha flags) are copied to the returned image
    // /
    // / 
    virtual ::grpc::Status convertTo(::grpc::ServerContext* context, const ::octaneapi::ApiImageBuffer_convertToRequest* request, ::octaneapi::ApiImageBuffer_convertToResponse* response);
    // / Destroys the ApiImageBuffer object created by create()
    virtual ::grpc::Status destroy(::grpc::ServerContext* context, const ::octaneapi::ApiImageBuffer_destroyRequest* request, ::google::protobuf::Empty* response);
    // / Returns the bytes per pixel
    // /
    // / 
    virtual ::grpc::Status bytesPerPixel(::grpc::ServerContext* context, const ::octaneapi::ApiImageBuffer_bytesPerPixelRequest* request, ::octaneapi::ApiImageBuffer_bytesPerPixelResponse* response);
    // / Returns the bytes per pixel channel
    virtual ::grpc::Status bytesPerChannel(::grpc::ServerContext* context, const ::octaneapi::ApiImageBuffer_bytesPerChannelRequest* request, ::octaneapi::ApiImageBuffer_bytesPerChannelResponse* response);
    // / Returns the number of channels of a pixel
    virtual ::grpc::Status channelCount(::grpc::ServerContext* context, const ::octaneapi::ApiImageBuffer_channelCountRequest* request, ::octaneapi::ApiImageBuffer_channelCountResponse* response);
    // / Returns the dimensions of the image in pixels
    virtual ::grpc::Status size(::grpc::ServerContext* context, const ::octaneapi::ApiImageBuffer_sizeRequest* request, ::octaneapi::ApiImageBuffer_sizeResponse* response);
    // / Returns the size in bytes of the image data
    virtual ::grpc::Status sizeInBytes(::grpc::ServerContext* context, const ::octaneapi::ApiImageBuffer_sizeInBytesRequest* request, ::octaneapi::ApiImageBuffer_sizeInBytesResponse* response);
    // / Returns the image buffer's type
    virtual ::grpc::Status type(::grpc::ServerContext* context, const ::octaneapi::ApiImageBuffer_typeRequest* request, ::octaneapi::ApiImageBuffer_typeResponse* response);
    // / Returns the image source information string
    virtual ::grpc::Status sourceInfo(::grpc::ServerContext* context, const ::octaneapi::ApiImageBuffer_sourceInfoRequest* request, ::octaneapi::ApiImageBuffer_sourceInfoResponse* response);
    // / TRUE if the image can wrap in horizontal direction
    virtual ::grpc::Status canWrapX(::grpc::ServerContext* context, const ::octaneapi::ApiImageBuffer_canWrapXRequest* request, ::octaneapi::ApiImageBuffer_canWrapXResponse* response);
    // / TRUE if the image can wrap in vertical direction
    virtual ::grpc::Status canWrapY(::grpc::ServerContext* context, const ::octaneapi::ApiImageBuffer_canWrapYRequest* request, ::octaneapi::ApiImageBuffer_canWrapYResponse* response);
    // / TRUE if the image has Y down (currently only for BC compressed images)
    virtual ::grpc::Status needsFlip(::grpc::ServerContext* context, const ::octaneapi::ApiImageBuffer_needsFlipRequest* request, ::octaneapi::ApiImageBuffer_needsFlipResponse* response);
    // / TRUE for a transparent image
    virtual ::grpc::Status hasAlpha(::grpc::ServerContext* context, const ::octaneapi::ApiImageBuffer_hasAlphaRequest* request, ::octaneapi::ApiImageBuffer_hasAlphaResponse* response);
    // / TRUE for a chormatic image
    virtual ::grpc::Status hasColor(::grpc::ServerContext* context, const ::octaneapi::ApiImageBuffer_hasColorRequest* request, ::octaneapi::ApiImageBuffer_hasColorResponse* response);
    // / TRUE for a compressed image
    virtual ::grpc::Status isCompressed(::grpc::ServerContext* context, const ::octaneapi::ApiImageBuffer_isCompressedRequest* request, ::octaneapi::ApiImageBuffer_isCompressedResponse* response);
    // / Checks if this image has data
    virtual ::grpc::Status isEmpty(::grpc::ServerContext* context, const ::octaneapi::ApiImageBuffer_isEmptyRequest* request, ::octaneapi::ApiImageBuffer_isEmptyResponse* response);
    // / TRUE for a 16bits Hdr image
    virtual ::grpc::Status isHalf(::grpc::ServerContext* context, const ::octaneapi::ApiImageBuffer_isHalfRequest* request, ::octaneapi::ApiImageBuffer_isHalfResponse* response);
    // / TRUE for a Hdr image
    virtual ::grpc::Status isHdr(::grpc::ServerContext* context, const ::octaneapi::ApiImageBuffer_isHdrRequest* request, ::octaneapi::ApiImageBuffer_isHdrResponse* response);
    // / TRUE for a single channel image
    virtual ::grpc::Status isMono(::grpc::ServerContext* context, const ::octaneapi::ApiImageBuffer_isMonoRequest* request, ::octaneapi::ApiImageBuffer_isMonoResponse* response);
    // / TRUE is the given pixel location is valid
    virtual ::grpc::Status isPixelValid(::grpc::ServerContext* context, const ::octaneapi::ApiImageBuffer_isPixelValidRequest* request, ::octaneapi::ApiImageBuffer_isPixelValidResponse* response);
    // / Compresses this image buffer
    // / NOTE: Only works for uncompressed images
    // /
    // / 
    virtual ::grpc::Status compress(::grpc::ServerContext* context, const ::octaneapi::ApiImageBuffer_compressRequest* request, ::google::protobuf::Empty* response);
    // / Modifies a pixel in a Ldr image buffer
    // / NOTE: This assumes that the buffer represents a un-compressed Ldr image and
    // /       image that goes bottom-to-top (y points down)
    // /
    // / 
    virtual ::grpc::Status setPixelLdr(::grpc::ServerContext* context, const ::octaneapi::ApiImageBuffer_setPixelLdrRequest* request, ::google::protobuf::Empty* response);
    // / Modifies a pixel in a 16bits Hdr image buffer
    // / NOTE: This assumes that the buffer represents a 16bits un-compressed Hdr image and
    // /       image that goes bottom-to-top (y points down)
    // /
    // / 
    virtual ::grpc::Status setPixelHalf(::grpc::ServerContext* context, const ::octaneapi::ApiImageBuffer_setPixelHalfRequest* request, ::google::protobuf::Empty* response);
    // / Modifies a pixel in a 326bits Hdr image buffer
    // / NOTE: This assumes that the buffer represents a 32bits un-compressed Hdr image and
    // /       image that goes bottom-to-top (y points down)
    // /
    // / 
    virtual ::grpc::Status setPixelHdr(::grpc::ServerContext* context, const ::octaneapi::ApiImageBuffer_setPixelHdrRequest* request, ::google::protobuf::Empty* response);
    // / Copies a region from another ImageBuffer
    virtual ::grpc::Status copyRegion(::grpc::ServerContext* context, const ::octaneapi::ApiImageBuffer_copyRegionRequest* request, ::octaneapi::ApiImageBuffer_copyRegionResponse* response);
    // / eliminates the alpha channel by multiplying the color channels by the alpha channel, and
    // / setting the alpha channel to 1
    virtual ::grpc::Status compositeOnBlack(::grpc::ServerContext* context, const ::octaneapi::ApiImageBuffer_compositeOnBlackRequest* request, ::google::protobuf::Empty* response);
    // / vertical flip (in place)
    virtual ::grpc::Status flipVertical(::grpc::ServerContext* context, const ::octaneapi::ApiImageBuffer_flipVerticalRequest* request, ::google::protobuf::Empty* response);
    // / Convert the current image bufer to another type
    // / NOTE: Only works for uncompressed images
    // /
    // / 
    virtual ::grpc::Status convert(::grpc::ServerContext* context, const ::octaneapi::ApiImageBuffer_convertRequest* request, ::google::protobuf::Empty* response);
    // / Applies gaussian filter to the image
    // / NOTE: Only works for uncompressed images
    // /
    // / 
    virtual ::grpc::Status applyGaussianFilter(::grpc::ServerContext* context, const ::octaneapi::ApiImageBuffer_applyGaussianFilterRequest* request, ::google::protobuf::Empty* response);
    // / Applies Box filter to the image
    virtual ::grpc::Status applyBoxFilter(::grpc::ServerContext* context, const ::octaneapi::ApiImageBuffer_applyBoxFilterRequest* request, ::google::protobuf::Empty* response);
    // / Applies level correction to the image
    // / NOTE: the image must be un-compressed image and have float channels
    // /
    // / 
    virtual ::grpc::Status applyLevels(::grpc::ServerContext* context, const ::octaneapi::ApiImageBuffer_applyLevelsRequest* request, ::google::protobuf::Empty* response);
    // / Compares this image to another image, and puts the difference in this image
    // /
    // / 
    virtual ::grpc::Status compareValues(::grpc::ServerContext* context, const ::octaneapi::ApiImageBuffer_compareValuesRequest* request, ::google::protobuf::Empty* response);
    // / Compares this image to another image, and returns the mean square error for it
    // /
    // / 
    virtual ::grpc::Status calculateMeanSquareError(::grpc::ServerContext* context, const ::octaneapi::ApiImageBuffer_calculateMeanSquareErrorRequest* request, ::octaneapi::ApiImageBuffer_calculateMeanSquareErrorResponse* response);
    // / Saves an image to disk
    virtual ::grpc::Status save(::grpc::ServerContext* context, const ::octaneapi::ApiImageBuffer_saveRequest* request, ::octaneapi::ApiImageBuffer_saveResponse* response);
    // / Starts saving an image to disk on a background thread
    // / Compressed images are saved as DDS, HDR images are saved as EXR and LDR images are saved as PNG
    // / NOTE:  The correct extension is added to the path (if it didn't exist yet)
    // /
    // / 
    virtual ::grpc::Status saveAsync(::grpc::ServerContext* context, const ::octaneapi::ApiImageBuffer_saveAsyncRequest* request, ::octaneapi::ApiImageBuffer_saveAsyncResponse* response);
    // / Gets the constant reference to the memory location of a pixel
    virtual ::grpc::Status pixelAddr(::grpc::ServerContext* context, const ::octaneapi::ApiImageBuffer_pixelAddrRequest* request, ::octaneapi::ApiImageBuffer_pixelAddrResponse* response);
    // / Gets the mutable reference to the memory location of a pixel
    virtual ::grpc::Status pixelAddr1(::grpc::ServerContext* context, const ::octaneapi::ApiImageBuffer_pixelAddr1Request* request, ::octaneapi::ApiImageBuffer_pixelAddr1Response* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_create : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_create() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_create() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status create(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_createRequest* /*request*/, ::octaneapi::ApiImageBuffer_createResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestcreate(::grpc::ServerContext* context, ::octaneapi::ApiImageBuffer_createRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiImageBuffer_createResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_create1 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_create1() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_create1() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status create1(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_create1Request* /*request*/, ::octaneapi::ApiImageBuffer_create1Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestcreate1(::grpc::ServerContext* context, ::octaneapi::ApiImageBuffer_create1Request* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiImageBuffer_create1Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_load : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_load() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_load() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status load(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_loadRequest* /*request*/, ::octaneapi::ApiImageBuffer_loadResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestload(::grpc::ServerContext* context, ::octaneapi::ApiImageBuffer_loadRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiImageBuffer_loadResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_load1 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_load1() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_load1() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status load1(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_load1Request* /*request*/, ::octaneapi::ApiImageBuffer_load1Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestload1(::grpc::ServerContext* context, ::octaneapi::ApiImageBuffer_load1Request* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiImageBuffer_load1Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_convertTo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_convertTo() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_convertTo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status convertTo(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_convertToRequest* /*request*/, ::octaneapi::ApiImageBuffer_convertToResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestconvertTo(::grpc::ServerContext* context, ::octaneapi::ApiImageBuffer_convertToRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiImageBuffer_convertToResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_destroy : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_destroy() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_destroy() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status destroy(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_destroyRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestdestroy(::grpc::ServerContext* context, ::octaneapi::ApiImageBuffer_destroyRequest* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_bytesPerPixel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_bytesPerPixel() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_bytesPerPixel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status bytesPerPixel(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_bytesPerPixelRequest* /*request*/, ::octaneapi::ApiImageBuffer_bytesPerPixelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestbytesPerPixel(::grpc::ServerContext* context, ::octaneapi::ApiImageBuffer_bytesPerPixelRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiImageBuffer_bytesPerPixelResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_bytesPerChannel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_bytesPerChannel() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_bytesPerChannel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status bytesPerChannel(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_bytesPerChannelRequest* /*request*/, ::octaneapi::ApiImageBuffer_bytesPerChannelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestbytesPerChannel(::grpc::ServerContext* context, ::octaneapi::ApiImageBuffer_bytesPerChannelRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiImageBuffer_bytesPerChannelResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_channelCount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_channelCount() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_channelCount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status channelCount(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_channelCountRequest* /*request*/, ::octaneapi::ApiImageBuffer_channelCountResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestchannelCount(::grpc::ServerContext* context, ::octaneapi::ApiImageBuffer_channelCountRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiImageBuffer_channelCountResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_size : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_size() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_size() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status size(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_sizeRequest* /*request*/, ::octaneapi::ApiImageBuffer_sizeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestsize(::grpc::ServerContext* context, ::octaneapi::ApiImageBuffer_sizeRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiImageBuffer_sizeResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_sizeInBytes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_sizeInBytes() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_sizeInBytes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status sizeInBytes(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_sizeInBytesRequest* /*request*/, ::octaneapi::ApiImageBuffer_sizeInBytesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsizeInBytes(::grpc::ServerContext* context, ::octaneapi::ApiImageBuffer_sizeInBytesRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiImageBuffer_sizeInBytesResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_type : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_type() {
      ::grpc::Service::MarkMethodAsync(11);
    }
    ~WithAsyncMethod_type() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status type(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_typeRequest* /*request*/, ::octaneapi::ApiImageBuffer_typeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requesttype(::grpc::ServerContext* context, ::octaneapi::ApiImageBuffer_typeRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiImageBuffer_typeResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_sourceInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_sourceInfo() {
      ::grpc::Service::MarkMethodAsync(12);
    }
    ~WithAsyncMethod_sourceInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status sourceInfo(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_sourceInfoRequest* /*request*/, ::octaneapi::ApiImageBuffer_sourceInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsourceInfo(::grpc::ServerContext* context, ::octaneapi::ApiImageBuffer_sourceInfoRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiImageBuffer_sourceInfoResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_canWrapX : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_canWrapX() {
      ::grpc::Service::MarkMethodAsync(13);
    }
    ~WithAsyncMethod_canWrapX() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status canWrapX(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_canWrapXRequest* /*request*/, ::octaneapi::ApiImageBuffer_canWrapXResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestcanWrapX(::grpc::ServerContext* context, ::octaneapi::ApiImageBuffer_canWrapXRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiImageBuffer_canWrapXResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_canWrapY : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_canWrapY() {
      ::grpc::Service::MarkMethodAsync(14);
    }
    ~WithAsyncMethod_canWrapY() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status canWrapY(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_canWrapYRequest* /*request*/, ::octaneapi::ApiImageBuffer_canWrapYResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestcanWrapY(::grpc::ServerContext* context, ::octaneapi::ApiImageBuffer_canWrapYRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiImageBuffer_canWrapYResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_needsFlip : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_needsFlip() {
      ::grpc::Service::MarkMethodAsync(15);
    }
    ~WithAsyncMethod_needsFlip() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status needsFlip(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_needsFlipRequest* /*request*/, ::octaneapi::ApiImageBuffer_needsFlipResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestneedsFlip(::grpc::ServerContext* context, ::octaneapi::ApiImageBuffer_needsFlipRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiImageBuffer_needsFlipResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_hasAlpha : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_hasAlpha() {
      ::grpc::Service::MarkMethodAsync(16);
    }
    ~WithAsyncMethod_hasAlpha() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status hasAlpha(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_hasAlphaRequest* /*request*/, ::octaneapi::ApiImageBuffer_hasAlphaResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequesthasAlpha(::grpc::ServerContext* context, ::octaneapi::ApiImageBuffer_hasAlphaRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiImageBuffer_hasAlphaResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_hasColor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_hasColor() {
      ::grpc::Service::MarkMethodAsync(17);
    }
    ~WithAsyncMethod_hasColor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status hasColor(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_hasColorRequest* /*request*/, ::octaneapi::ApiImageBuffer_hasColorResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequesthasColor(::grpc::ServerContext* context, ::octaneapi::ApiImageBuffer_hasColorRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiImageBuffer_hasColorResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_isCompressed : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_isCompressed() {
      ::grpc::Service::MarkMethodAsync(18);
    }
    ~WithAsyncMethod_isCompressed() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isCompressed(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_isCompressedRequest* /*request*/, ::octaneapi::ApiImageBuffer_isCompressedResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestisCompressed(::grpc::ServerContext* context, ::octaneapi::ApiImageBuffer_isCompressedRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiImageBuffer_isCompressedResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_isEmpty : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_isEmpty() {
      ::grpc::Service::MarkMethodAsync(19);
    }
    ~WithAsyncMethod_isEmpty() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isEmpty(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_isEmptyRequest* /*request*/, ::octaneapi::ApiImageBuffer_isEmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestisEmpty(::grpc::ServerContext* context, ::octaneapi::ApiImageBuffer_isEmptyRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiImageBuffer_isEmptyResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(19, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_isHalf : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_isHalf() {
      ::grpc::Service::MarkMethodAsync(20);
    }
    ~WithAsyncMethod_isHalf() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isHalf(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_isHalfRequest* /*request*/, ::octaneapi::ApiImageBuffer_isHalfResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestisHalf(::grpc::ServerContext* context, ::octaneapi::ApiImageBuffer_isHalfRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiImageBuffer_isHalfResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(20, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_isHdr : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_isHdr() {
      ::grpc::Service::MarkMethodAsync(21);
    }
    ~WithAsyncMethod_isHdr() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isHdr(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_isHdrRequest* /*request*/, ::octaneapi::ApiImageBuffer_isHdrResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestisHdr(::grpc::ServerContext* context, ::octaneapi::ApiImageBuffer_isHdrRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiImageBuffer_isHdrResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(21, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_isMono : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_isMono() {
      ::grpc::Service::MarkMethodAsync(22);
    }
    ~WithAsyncMethod_isMono() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isMono(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_isMonoRequest* /*request*/, ::octaneapi::ApiImageBuffer_isMonoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestisMono(::grpc::ServerContext* context, ::octaneapi::ApiImageBuffer_isMonoRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiImageBuffer_isMonoResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(22, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_isPixelValid : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_isPixelValid() {
      ::grpc::Service::MarkMethodAsync(23);
    }
    ~WithAsyncMethod_isPixelValid() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isPixelValid(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_isPixelValidRequest* /*request*/, ::octaneapi::ApiImageBuffer_isPixelValidResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestisPixelValid(::grpc::ServerContext* context, ::octaneapi::ApiImageBuffer_isPixelValidRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiImageBuffer_isPixelValidResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(23, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_compress : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_compress() {
      ::grpc::Service::MarkMethodAsync(24);
    }
    ~WithAsyncMethod_compress() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status compress(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_compressRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestcompress(::grpc::ServerContext* context, ::octaneapi::ApiImageBuffer_compressRequest* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(24, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_setPixelLdr : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_setPixelLdr() {
      ::grpc::Service::MarkMethodAsync(25);
    }
    ~WithAsyncMethod_setPixelLdr() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setPixelLdr(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_setPixelLdrRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsetPixelLdr(::grpc::ServerContext* context, ::octaneapi::ApiImageBuffer_setPixelLdrRequest* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(25, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_setPixelHalf : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_setPixelHalf() {
      ::grpc::Service::MarkMethodAsync(26);
    }
    ~WithAsyncMethod_setPixelHalf() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setPixelHalf(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_setPixelHalfRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsetPixelHalf(::grpc::ServerContext* context, ::octaneapi::ApiImageBuffer_setPixelHalfRequest* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(26, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_setPixelHdr : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_setPixelHdr() {
      ::grpc::Service::MarkMethodAsync(27);
    }
    ~WithAsyncMethod_setPixelHdr() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setPixelHdr(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_setPixelHdrRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsetPixelHdr(::grpc::ServerContext* context, ::octaneapi::ApiImageBuffer_setPixelHdrRequest* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(27, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_copyRegion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_copyRegion() {
      ::grpc::Service::MarkMethodAsync(28);
    }
    ~WithAsyncMethod_copyRegion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status copyRegion(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_copyRegionRequest* /*request*/, ::octaneapi::ApiImageBuffer_copyRegionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestcopyRegion(::grpc::ServerContext* context, ::octaneapi::ApiImageBuffer_copyRegionRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiImageBuffer_copyRegionResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(28, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_compositeOnBlack : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_compositeOnBlack() {
      ::grpc::Service::MarkMethodAsync(29);
    }
    ~WithAsyncMethod_compositeOnBlack() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status compositeOnBlack(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_compositeOnBlackRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestcompositeOnBlack(::grpc::ServerContext* context, ::octaneapi::ApiImageBuffer_compositeOnBlackRequest* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(29, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_flipVertical : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_flipVertical() {
      ::grpc::Service::MarkMethodAsync(30);
    }
    ~WithAsyncMethod_flipVertical() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status flipVertical(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_flipVerticalRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestflipVertical(::grpc::ServerContext* context, ::octaneapi::ApiImageBuffer_flipVerticalRequest* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(30, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_convert : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_convert() {
      ::grpc::Service::MarkMethodAsync(31);
    }
    ~WithAsyncMethod_convert() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status convert(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_convertRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestconvert(::grpc::ServerContext* context, ::octaneapi::ApiImageBuffer_convertRequest* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(31, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_applyGaussianFilter : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_applyGaussianFilter() {
      ::grpc::Service::MarkMethodAsync(32);
    }
    ~WithAsyncMethod_applyGaussianFilter() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status applyGaussianFilter(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_applyGaussianFilterRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestapplyGaussianFilter(::grpc::ServerContext* context, ::octaneapi::ApiImageBuffer_applyGaussianFilterRequest* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(32, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_applyBoxFilter : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_applyBoxFilter() {
      ::grpc::Service::MarkMethodAsync(33);
    }
    ~WithAsyncMethod_applyBoxFilter() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status applyBoxFilter(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_applyBoxFilterRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestapplyBoxFilter(::grpc::ServerContext* context, ::octaneapi::ApiImageBuffer_applyBoxFilterRequest* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(33, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_applyLevels : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_applyLevels() {
      ::grpc::Service::MarkMethodAsync(34);
    }
    ~WithAsyncMethod_applyLevels() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status applyLevels(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_applyLevelsRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestapplyLevels(::grpc::ServerContext* context, ::octaneapi::ApiImageBuffer_applyLevelsRequest* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(34, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_compareValues : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_compareValues() {
      ::grpc::Service::MarkMethodAsync(35);
    }
    ~WithAsyncMethod_compareValues() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status compareValues(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_compareValuesRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestcompareValues(::grpc::ServerContext* context, ::octaneapi::ApiImageBuffer_compareValuesRequest* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(35, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_calculateMeanSquareError : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_calculateMeanSquareError() {
      ::grpc::Service::MarkMethodAsync(36);
    }
    ~WithAsyncMethod_calculateMeanSquareError() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status calculateMeanSquareError(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_calculateMeanSquareErrorRequest* /*request*/, ::octaneapi::ApiImageBuffer_calculateMeanSquareErrorResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestcalculateMeanSquareError(::grpc::ServerContext* context, ::octaneapi::ApiImageBuffer_calculateMeanSquareErrorRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiImageBuffer_calculateMeanSquareErrorResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(36, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_save : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_save() {
      ::grpc::Service::MarkMethodAsync(37);
    }
    ~WithAsyncMethod_save() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status save(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_saveRequest* /*request*/, ::octaneapi::ApiImageBuffer_saveResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestsave(::grpc::ServerContext* context, ::octaneapi::ApiImageBuffer_saveRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiImageBuffer_saveResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(37, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_saveAsync : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_saveAsync() {
      ::grpc::Service::MarkMethodAsync(38);
    }
    ~WithAsyncMethod_saveAsync() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status saveAsync(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_saveAsyncRequest* /*request*/, ::octaneapi::ApiImageBuffer_saveAsyncResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsaveAsync(::grpc::ServerContext* context, ::octaneapi::ApiImageBuffer_saveAsyncRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiImageBuffer_saveAsyncResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(38, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_pixelAddr : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_pixelAddr() {
      ::grpc::Service::MarkMethodAsync(39);
    }
    ~WithAsyncMethod_pixelAddr() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status pixelAddr(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_pixelAddrRequest* /*request*/, ::octaneapi::ApiImageBuffer_pixelAddrResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestpixelAddr(::grpc::ServerContext* context, ::octaneapi::ApiImageBuffer_pixelAddrRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiImageBuffer_pixelAddrResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(39, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_pixelAddr1 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_pixelAddr1() {
      ::grpc::Service::MarkMethodAsync(40);
    }
    ~WithAsyncMethod_pixelAddr1() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status pixelAddr1(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_pixelAddr1Request* /*request*/, ::octaneapi::ApiImageBuffer_pixelAddr1Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestpixelAddr1(::grpc::ServerContext* context, ::octaneapi::ApiImageBuffer_pixelAddr1Request* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiImageBuffer_pixelAddr1Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(40, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_create<WithAsyncMethod_create1<WithAsyncMethod_load<WithAsyncMethod_load1<WithAsyncMethod_convertTo<WithAsyncMethod_destroy<WithAsyncMethod_bytesPerPixel<WithAsyncMethod_bytesPerChannel<WithAsyncMethod_channelCount<WithAsyncMethod_size<WithAsyncMethod_sizeInBytes<WithAsyncMethod_type<WithAsyncMethod_sourceInfo<WithAsyncMethod_canWrapX<WithAsyncMethod_canWrapY<WithAsyncMethod_needsFlip<WithAsyncMethod_hasAlpha<WithAsyncMethod_hasColor<WithAsyncMethod_isCompressed<WithAsyncMethod_isEmpty<WithAsyncMethod_isHalf<WithAsyncMethod_isHdr<WithAsyncMethod_isMono<WithAsyncMethod_isPixelValid<WithAsyncMethod_compress<WithAsyncMethod_setPixelLdr<WithAsyncMethod_setPixelHalf<WithAsyncMethod_setPixelHdr<WithAsyncMethod_copyRegion<WithAsyncMethod_compositeOnBlack<WithAsyncMethod_flipVertical<WithAsyncMethod_convert<WithAsyncMethod_applyGaussianFilter<WithAsyncMethod_applyBoxFilter<WithAsyncMethod_applyLevels<WithAsyncMethod_compareValues<WithAsyncMethod_calculateMeanSquareError<WithAsyncMethod_save<WithAsyncMethod_saveAsync<WithAsyncMethod_pixelAddr<WithAsyncMethod_pixelAddr1<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_create : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_create() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiImageBuffer_createRequest, ::octaneapi::ApiImageBuffer_createResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiImageBuffer_createRequest* request, ::octaneapi::ApiImageBuffer_createResponse* response) { return this->create(context, request, response); }));}
    void SetMessageAllocatorFor_create(
        ::grpc::MessageAllocator< ::octaneapi::ApiImageBuffer_createRequest, ::octaneapi::ApiImageBuffer_createResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiImageBuffer_createRequest, ::octaneapi::ApiImageBuffer_createResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_create() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status create(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_createRequest* /*request*/, ::octaneapi::ApiImageBuffer_createResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* create(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_createRequest* /*request*/, ::octaneapi::ApiImageBuffer_createResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_create1 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_create1() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiImageBuffer_create1Request, ::octaneapi::ApiImageBuffer_create1Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiImageBuffer_create1Request* request, ::octaneapi::ApiImageBuffer_create1Response* response) { return this->create1(context, request, response); }));}
    void SetMessageAllocatorFor_create1(
        ::grpc::MessageAllocator< ::octaneapi::ApiImageBuffer_create1Request, ::octaneapi::ApiImageBuffer_create1Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiImageBuffer_create1Request, ::octaneapi::ApiImageBuffer_create1Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_create1() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status create1(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_create1Request* /*request*/, ::octaneapi::ApiImageBuffer_create1Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* create1(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_create1Request* /*request*/, ::octaneapi::ApiImageBuffer_create1Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_load : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_load() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiImageBuffer_loadRequest, ::octaneapi::ApiImageBuffer_loadResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiImageBuffer_loadRequest* request, ::octaneapi::ApiImageBuffer_loadResponse* response) { return this->load(context, request, response); }));}
    void SetMessageAllocatorFor_load(
        ::grpc::MessageAllocator< ::octaneapi::ApiImageBuffer_loadRequest, ::octaneapi::ApiImageBuffer_loadResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiImageBuffer_loadRequest, ::octaneapi::ApiImageBuffer_loadResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_load() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status load(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_loadRequest* /*request*/, ::octaneapi::ApiImageBuffer_loadResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* load(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_loadRequest* /*request*/, ::octaneapi::ApiImageBuffer_loadResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_load1 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_load1() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiImageBuffer_load1Request, ::octaneapi::ApiImageBuffer_load1Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiImageBuffer_load1Request* request, ::octaneapi::ApiImageBuffer_load1Response* response) { return this->load1(context, request, response); }));}
    void SetMessageAllocatorFor_load1(
        ::grpc::MessageAllocator< ::octaneapi::ApiImageBuffer_load1Request, ::octaneapi::ApiImageBuffer_load1Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiImageBuffer_load1Request, ::octaneapi::ApiImageBuffer_load1Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_load1() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status load1(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_load1Request* /*request*/, ::octaneapi::ApiImageBuffer_load1Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* load1(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_load1Request* /*request*/, ::octaneapi::ApiImageBuffer_load1Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_convertTo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_convertTo() {
      ::grpc::Service::MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiImageBuffer_convertToRequest, ::octaneapi::ApiImageBuffer_convertToResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiImageBuffer_convertToRequest* request, ::octaneapi::ApiImageBuffer_convertToResponse* response) { return this->convertTo(context, request, response); }));}
    void SetMessageAllocatorFor_convertTo(
        ::grpc::MessageAllocator< ::octaneapi::ApiImageBuffer_convertToRequest, ::octaneapi::ApiImageBuffer_convertToResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiImageBuffer_convertToRequest, ::octaneapi::ApiImageBuffer_convertToResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_convertTo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status convertTo(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_convertToRequest* /*request*/, ::octaneapi::ApiImageBuffer_convertToResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* convertTo(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_convertToRequest* /*request*/, ::octaneapi::ApiImageBuffer_convertToResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_destroy : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_destroy() {
      ::grpc::Service::MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiImageBuffer_destroyRequest, ::google::protobuf::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiImageBuffer_destroyRequest* request, ::google::protobuf::Empty* response) { return this->destroy(context, request, response); }));}
    void SetMessageAllocatorFor_destroy(
        ::grpc::MessageAllocator< ::octaneapi::ApiImageBuffer_destroyRequest, ::google::protobuf::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiImageBuffer_destroyRequest, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_destroy() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status destroy(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_destroyRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* destroy(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_destroyRequest* /*request*/, ::google::protobuf::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_bytesPerPixel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_bytesPerPixel() {
      ::grpc::Service::MarkMethodCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiImageBuffer_bytesPerPixelRequest, ::octaneapi::ApiImageBuffer_bytesPerPixelResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiImageBuffer_bytesPerPixelRequest* request, ::octaneapi::ApiImageBuffer_bytesPerPixelResponse* response) { return this->bytesPerPixel(context, request, response); }));}
    void SetMessageAllocatorFor_bytesPerPixel(
        ::grpc::MessageAllocator< ::octaneapi::ApiImageBuffer_bytesPerPixelRequest, ::octaneapi::ApiImageBuffer_bytesPerPixelResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiImageBuffer_bytesPerPixelRequest, ::octaneapi::ApiImageBuffer_bytesPerPixelResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_bytesPerPixel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status bytesPerPixel(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_bytesPerPixelRequest* /*request*/, ::octaneapi::ApiImageBuffer_bytesPerPixelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* bytesPerPixel(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_bytesPerPixelRequest* /*request*/, ::octaneapi::ApiImageBuffer_bytesPerPixelResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_bytesPerChannel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_bytesPerChannel() {
      ::grpc::Service::MarkMethodCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiImageBuffer_bytesPerChannelRequest, ::octaneapi::ApiImageBuffer_bytesPerChannelResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiImageBuffer_bytesPerChannelRequest* request, ::octaneapi::ApiImageBuffer_bytesPerChannelResponse* response) { return this->bytesPerChannel(context, request, response); }));}
    void SetMessageAllocatorFor_bytesPerChannel(
        ::grpc::MessageAllocator< ::octaneapi::ApiImageBuffer_bytesPerChannelRequest, ::octaneapi::ApiImageBuffer_bytesPerChannelResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(7);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiImageBuffer_bytesPerChannelRequest, ::octaneapi::ApiImageBuffer_bytesPerChannelResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_bytesPerChannel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status bytesPerChannel(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_bytesPerChannelRequest* /*request*/, ::octaneapi::ApiImageBuffer_bytesPerChannelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* bytesPerChannel(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_bytesPerChannelRequest* /*request*/, ::octaneapi::ApiImageBuffer_bytesPerChannelResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_channelCount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_channelCount() {
      ::grpc::Service::MarkMethodCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiImageBuffer_channelCountRequest, ::octaneapi::ApiImageBuffer_channelCountResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiImageBuffer_channelCountRequest* request, ::octaneapi::ApiImageBuffer_channelCountResponse* response) { return this->channelCount(context, request, response); }));}
    void SetMessageAllocatorFor_channelCount(
        ::grpc::MessageAllocator< ::octaneapi::ApiImageBuffer_channelCountRequest, ::octaneapi::ApiImageBuffer_channelCountResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(8);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiImageBuffer_channelCountRequest, ::octaneapi::ApiImageBuffer_channelCountResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_channelCount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status channelCount(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_channelCountRequest* /*request*/, ::octaneapi::ApiImageBuffer_channelCountResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* channelCount(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_channelCountRequest* /*request*/, ::octaneapi::ApiImageBuffer_channelCountResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_size : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_size() {
      ::grpc::Service::MarkMethodCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiImageBuffer_sizeRequest, ::octaneapi::ApiImageBuffer_sizeResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiImageBuffer_sizeRequest* request, ::octaneapi::ApiImageBuffer_sizeResponse* response) { return this->size(context, request, response); }));}
    void SetMessageAllocatorFor_size(
        ::grpc::MessageAllocator< ::octaneapi::ApiImageBuffer_sizeRequest, ::octaneapi::ApiImageBuffer_sizeResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(9);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiImageBuffer_sizeRequest, ::octaneapi::ApiImageBuffer_sizeResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_size() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status size(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_sizeRequest* /*request*/, ::octaneapi::ApiImageBuffer_sizeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* size(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_sizeRequest* /*request*/, ::octaneapi::ApiImageBuffer_sizeResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_sizeInBytes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_sizeInBytes() {
      ::grpc::Service::MarkMethodCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiImageBuffer_sizeInBytesRequest, ::octaneapi::ApiImageBuffer_sizeInBytesResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiImageBuffer_sizeInBytesRequest* request, ::octaneapi::ApiImageBuffer_sizeInBytesResponse* response) { return this->sizeInBytes(context, request, response); }));}
    void SetMessageAllocatorFor_sizeInBytes(
        ::grpc::MessageAllocator< ::octaneapi::ApiImageBuffer_sizeInBytesRequest, ::octaneapi::ApiImageBuffer_sizeInBytesResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(10);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiImageBuffer_sizeInBytesRequest, ::octaneapi::ApiImageBuffer_sizeInBytesResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_sizeInBytes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status sizeInBytes(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_sizeInBytesRequest* /*request*/, ::octaneapi::ApiImageBuffer_sizeInBytesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* sizeInBytes(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_sizeInBytesRequest* /*request*/, ::octaneapi::ApiImageBuffer_sizeInBytesResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_type : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_type() {
      ::grpc::Service::MarkMethodCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiImageBuffer_typeRequest, ::octaneapi::ApiImageBuffer_typeResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiImageBuffer_typeRequest* request, ::octaneapi::ApiImageBuffer_typeResponse* response) { return this->type(context, request, response); }));}
    void SetMessageAllocatorFor_type(
        ::grpc::MessageAllocator< ::octaneapi::ApiImageBuffer_typeRequest, ::octaneapi::ApiImageBuffer_typeResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(11);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiImageBuffer_typeRequest, ::octaneapi::ApiImageBuffer_typeResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_type() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status type(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_typeRequest* /*request*/, ::octaneapi::ApiImageBuffer_typeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* type(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_typeRequest* /*request*/, ::octaneapi::ApiImageBuffer_typeResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_sourceInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_sourceInfo() {
      ::grpc::Service::MarkMethodCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiImageBuffer_sourceInfoRequest, ::octaneapi::ApiImageBuffer_sourceInfoResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiImageBuffer_sourceInfoRequest* request, ::octaneapi::ApiImageBuffer_sourceInfoResponse* response) { return this->sourceInfo(context, request, response); }));}
    void SetMessageAllocatorFor_sourceInfo(
        ::grpc::MessageAllocator< ::octaneapi::ApiImageBuffer_sourceInfoRequest, ::octaneapi::ApiImageBuffer_sourceInfoResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(12);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiImageBuffer_sourceInfoRequest, ::octaneapi::ApiImageBuffer_sourceInfoResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_sourceInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status sourceInfo(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_sourceInfoRequest* /*request*/, ::octaneapi::ApiImageBuffer_sourceInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* sourceInfo(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_sourceInfoRequest* /*request*/, ::octaneapi::ApiImageBuffer_sourceInfoResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_canWrapX : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_canWrapX() {
      ::grpc::Service::MarkMethodCallback(13,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiImageBuffer_canWrapXRequest, ::octaneapi::ApiImageBuffer_canWrapXResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiImageBuffer_canWrapXRequest* request, ::octaneapi::ApiImageBuffer_canWrapXResponse* response) { return this->canWrapX(context, request, response); }));}
    void SetMessageAllocatorFor_canWrapX(
        ::grpc::MessageAllocator< ::octaneapi::ApiImageBuffer_canWrapXRequest, ::octaneapi::ApiImageBuffer_canWrapXResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(13);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiImageBuffer_canWrapXRequest, ::octaneapi::ApiImageBuffer_canWrapXResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_canWrapX() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status canWrapX(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_canWrapXRequest* /*request*/, ::octaneapi::ApiImageBuffer_canWrapXResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* canWrapX(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_canWrapXRequest* /*request*/, ::octaneapi::ApiImageBuffer_canWrapXResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_canWrapY : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_canWrapY() {
      ::grpc::Service::MarkMethodCallback(14,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiImageBuffer_canWrapYRequest, ::octaneapi::ApiImageBuffer_canWrapYResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiImageBuffer_canWrapYRequest* request, ::octaneapi::ApiImageBuffer_canWrapYResponse* response) { return this->canWrapY(context, request, response); }));}
    void SetMessageAllocatorFor_canWrapY(
        ::grpc::MessageAllocator< ::octaneapi::ApiImageBuffer_canWrapYRequest, ::octaneapi::ApiImageBuffer_canWrapYResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(14);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiImageBuffer_canWrapYRequest, ::octaneapi::ApiImageBuffer_canWrapYResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_canWrapY() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status canWrapY(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_canWrapYRequest* /*request*/, ::octaneapi::ApiImageBuffer_canWrapYResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* canWrapY(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_canWrapYRequest* /*request*/, ::octaneapi::ApiImageBuffer_canWrapYResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_needsFlip : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_needsFlip() {
      ::grpc::Service::MarkMethodCallback(15,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiImageBuffer_needsFlipRequest, ::octaneapi::ApiImageBuffer_needsFlipResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiImageBuffer_needsFlipRequest* request, ::octaneapi::ApiImageBuffer_needsFlipResponse* response) { return this->needsFlip(context, request, response); }));}
    void SetMessageAllocatorFor_needsFlip(
        ::grpc::MessageAllocator< ::octaneapi::ApiImageBuffer_needsFlipRequest, ::octaneapi::ApiImageBuffer_needsFlipResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(15);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiImageBuffer_needsFlipRequest, ::octaneapi::ApiImageBuffer_needsFlipResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_needsFlip() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status needsFlip(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_needsFlipRequest* /*request*/, ::octaneapi::ApiImageBuffer_needsFlipResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* needsFlip(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_needsFlipRequest* /*request*/, ::octaneapi::ApiImageBuffer_needsFlipResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_hasAlpha : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_hasAlpha() {
      ::grpc::Service::MarkMethodCallback(16,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiImageBuffer_hasAlphaRequest, ::octaneapi::ApiImageBuffer_hasAlphaResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiImageBuffer_hasAlphaRequest* request, ::octaneapi::ApiImageBuffer_hasAlphaResponse* response) { return this->hasAlpha(context, request, response); }));}
    void SetMessageAllocatorFor_hasAlpha(
        ::grpc::MessageAllocator< ::octaneapi::ApiImageBuffer_hasAlphaRequest, ::octaneapi::ApiImageBuffer_hasAlphaResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(16);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiImageBuffer_hasAlphaRequest, ::octaneapi::ApiImageBuffer_hasAlphaResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_hasAlpha() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status hasAlpha(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_hasAlphaRequest* /*request*/, ::octaneapi::ApiImageBuffer_hasAlphaResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* hasAlpha(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_hasAlphaRequest* /*request*/, ::octaneapi::ApiImageBuffer_hasAlphaResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_hasColor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_hasColor() {
      ::grpc::Service::MarkMethodCallback(17,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiImageBuffer_hasColorRequest, ::octaneapi::ApiImageBuffer_hasColorResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiImageBuffer_hasColorRequest* request, ::octaneapi::ApiImageBuffer_hasColorResponse* response) { return this->hasColor(context, request, response); }));}
    void SetMessageAllocatorFor_hasColor(
        ::grpc::MessageAllocator< ::octaneapi::ApiImageBuffer_hasColorRequest, ::octaneapi::ApiImageBuffer_hasColorResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(17);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiImageBuffer_hasColorRequest, ::octaneapi::ApiImageBuffer_hasColorResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_hasColor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status hasColor(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_hasColorRequest* /*request*/, ::octaneapi::ApiImageBuffer_hasColorResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* hasColor(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_hasColorRequest* /*request*/, ::octaneapi::ApiImageBuffer_hasColorResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_isCompressed : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_isCompressed() {
      ::grpc::Service::MarkMethodCallback(18,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiImageBuffer_isCompressedRequest, ::octaneapi::ApiImageBuffer_isCompressedResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiImageBuffer_isCompressedRequest* request, ::octaneapi::ApiImageBuffer_isCompressedResponse* response) { return this->isCompressed(context, request, response); }));}
    void SetMessageAllocatorFor_isCompressed(
        ::grpc::MessageAllocator< ::octaneapi::ApiImageBuffer_isCompressedRequest, ::octaneapi::ApiImageBuffer_isCompressedResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(18);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiImageBuffer_isCompressedRequest, ::octaneapi::ApiImageBuffer_isCompressedResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_isCompressed() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isCompressed(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_isCompressedRequest* /*request*/, ::octaneapi::ApiImageBuffer_isCompressedResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* isCompressed(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_isCompressedRequest* /*request*/, ::octaneapi::ApiImageBuffer_isCompressedResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_isEmpty : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_isEmpty() {
      ::grpc::Service::MarkMethodCallback(19,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiImageBuffer_isEmptyRequest, ::octaneapi::ApiImageBuffer_isEmptyResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiImageBuffer_isEmptyRequest* request, ::octaneapi::ApiImageBuffer_isEmptyResponse* response) { return this->isEmpty(context, request, response); }));}
    void SetMessageAllocatorFor_isEmpty(
        ::grpc::MessageAllocator< ::octaneapi::ApiImageBuffer_isEmptyRequest, ::octaneapi::ApiImageBuffer_isEmptyResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(19);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiImageBuffer_isEmptyRequest, ::octaneapi::ApiImageBuffer_isEmptyResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_isEmpty() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isEmpty(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_isEmptyRequest* /*request*/, ::octaneapi::ApiImageBuffer_isEmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* isEmpty(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_isEmptyRequest* /*request*/, ::octaneapi::ApiImageBuffer_isEmptyResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_isHalf : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_isHalf() {
      ::grpc::Service::MarkMethodCallback(20,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiImageBuffer_isHalfRequest, ::octaneapi::ApiImageBuffer_isHalfResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiImageBuffer_isHalfRequest* request, ::octaneapi::ApiImageBuffer_isHalfResponse* response) { return this->isHalf(context, request, response); }));}
    void SetMessageAllocatorFor_isHalf(
        ::grpc::MessageAllocator< ::octaneapi::ApiImageBuffer_isHalfRequest, ::octaneapi::ApiImageBuffer_isHalfResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(20);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiImageBuffer_isHalfRequest, ::octaneapi::ApiImageBuffer_isHalfResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_isHalf() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isHalf(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_isHalfRequest* /*request*/, ::octaneapi::ApiImageBuffer_isHalfResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* isHalf(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_isHalfRequest* /*request*/, ::octaneapi::ApiImageBuffer_isHalfResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_isHdr : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_isHdr() {
      ::grpc::Service::MarkMethodCallback(21,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiImageBuffer_isHdrRequest, ::octaneapi::ApiImageBuffer_isHdrResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiImageBuffer_isHdrRequest* request, ::octaneapi::ApiImageBuffer_isHdrResponse* response) { return this->isHdr(context, request, response); }));}
    void SetMessageAllocatorFor_isHdr(
        ::grpc::MessageAllocator< ::octaneapi::ApiImageBuffer_isHdrRequest, ::octaneapi::ApiImageBuffer_isHdrResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(21);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiImageBuffer_isHdrRequest, ::octaneapi::ApiImageBuffer_isHdrResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_isHdr() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isHdr(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_isHdrRequest* /*request*/, ::octaneapi::ApiImageBuffer_isHdrResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* isHdr(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_isHdrRequest* /*request*/, ::octaneapi::ApiImageBuffer_isHdrResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_isMono : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_isMono() {
      ::grpc::Service::MarkMethodCallback(22,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiImageBuffer_isMonoRequest, ::octaneapi::ApiImageBuffer_isMonoResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiImageBuffer_isMonoRequest* request, ::octaneapi::ApiImageBuffer_isMonoResponse* response) { return this->isMono(context, request, response); }));}
    void SetMessageAllocatorFor_isMono(
        ::grpc::MessageAllocator< ::octaneapi::ApiImageBuffer_isMonoRequest, ::octaneapi::ApiImageBuffer_isMonoResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(22);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiImageBuffer_isMonoRequest, ::octaneapi::ApiImageBuffer_isMonoResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_isMono() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isMono(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_isMonoRequest* /*request*/, ::octaneapi::ApiImageBuffer_isMonoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* isMono(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_isMonoRequest* /*request*/, ::octaneapi::ApiImageBuffer_isMonoResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_isPixelValid : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_isPixelValid() {
      ::grpc::Service::MarkMethodCallback(23,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiImageBuffer_isPixelValidRequest, ::octaneapi::ApiImageBuffer_isPixelValidResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiImageBuffer_isPixelValidRequest* request, ::octaneapi::ApiImageBuffer_isPixelValidResponse* response) { return this->isPixelValid(context, request, response); }));}
    void SetMessageAllocatorFor_isPixelValid(
        ::grpc::MessageAllocator< ::octaneapi::ApiImageBuffer_isPixelValidRequest, ::octaneapi::ApiImageBuffer_isPixelValidResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(23);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiImageBuffer_isPixelValidRequest, ::octaneapi::ApiImageBuffer_isPixelValidResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_isPixelValid() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isPixelValid(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_isPixelValidRequest* /*request*/, ::octaneapi::ApiImageBuffer_isPixelValidResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* isPixelValid(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_isPixelValidRequest* /*request*/, ::octaneapi::ApiImageBuffer_isPixelValidResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_compress : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_compress() {
      ::grpc::Service::MarkMethodCallback(24,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiImageBuffer_compressRequest, ::google::protobuf::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiImageBuffer_compressRequest* request, ::google::protobuf::Empty* response) { return this->compress(context, request, response); }));}
    void SetMessageAllocatorFor_compress(
        ::grpc::MessageAllocator< ::octaneapi::ApiImageBuffer_compressRequest, ::google::protobuf::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(24);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiImageBuffer_compressRequest, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_compress() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status compress(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_compressRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* compress(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_compressRequest* /*request*/, ::google::protobuf::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_setPixelLdr : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_setPixelLdr() {
      ::grpc::Service::MarkMethodCallback(25,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiImageBuffer_setPixelLdrRequest, ::google::protobuf::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiImageBuffer_setPixelLdrRequest* request, ::google::protobuf::Empty* response) { return this->setPixelLdr(context, request, response); }));}
    void SetMessageAllocatorFor_setPixelLdr(
        ::grpc::MessageAllocator< ::octaneapi::ApiImageBuffer_setPixelLdrRequest, ::google::protobuf::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(25);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiImageBuffer_setPixelLdrRequest, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_setPixelLdr() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setPixelLdr(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_setPixelLdrRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* setPixelLdr(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_setPixelLdrRequest* /*request*/, ::google::protobuf::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_setPixelHalf : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_setPixelHalf() {
      ::grpc::Service::MarkMethodCallback(26,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiImageBuffer_setPixelHalfRequest, ::google::protobuf::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiImageBuffer_setPixelHalfRequest* request, ::google::protobuf::Empty* response) { return this->setPixelHalf(context, request, response); }));}
    void SetMessageAllocatorFor_setPixelHalf(
        ::grpc::MessageAllocator< ::octaneapi::ApiImageBuffer_setPixelHalfRequest, ::google::protobuf::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(26);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiImageBuffer_setPixelHalfRequest, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_setPixelHalf() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setPixelHalf(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_setPixelHalfRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* setPixelHalf(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_setPixelHalfRequest* /*request*/, ::google::protobuf::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_setPixelHdr : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_setPixelHdr() {
      ::grpc::Service::MarkMethodCallback(27,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiImageBuffer_setPixelHdrRequest, ::google::protobuf::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiImageBuffer_setPixelHdrRequest* request, ::google::protobuf::Empty* response) { return this->setPixelHdr(context, request, response); }));}
    void SetMessageAllocatorFor_setPixelHdr(
        ::grpc::MessageAllocator< ::octaneapi::ApiImageBuffer_setPixelHdrRequest, ::google::protobuf::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(27);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiImageBuffer_setPixelHdrRequest, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_setPixelHdr() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setPixelHdr(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_setPixelHdrRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* setPixelHdr(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_setPixelHdrRequest* /*request*/, ::google::protobuf::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_copyRegion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_copyRegion() {
      ::grpc::Service::MarkMethodCallback(28,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiImageBuffer_copyRegionRequest, ::octaneapi::ApiImageBuffer_copyRegionResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiImageBuffer_copyRegionRequest* request, ::octaneapi::ApiImageBuffer_copyRegionResponse* response) { return this->copyRegion(context, request, response); }));}
    void SetMessageAllocatorFor_copyRegion(
        ::grpc::MessageAllocator< ::octaneapi::ApiImageBuffer_copyRegionRequest, ::octaneapi::ApiImageBuffer_copyRegionResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(28);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiImageBuffer_copyRegionRequest, ::octaneapi::ApiImageBuffer_copyRegionResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_copyRegion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status copyRegion(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_copyRegionRequest* /*request*/, ::octaneapi::ApiImageBuffer_copyRegionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* copyRegion(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_copyRegionRequest* /*request*/, ::octaneapi::ApiImageBuffer_copyRegionResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_compositeOnBlack : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_compositeOnBlack() {
      ::grpc::Service::MarkMethodCallback(29,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiImageBuffer_compositeOnBlackRequest, ::google::protobuf::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiImageBuffer_compositeOnBlackRequest* request, ::google::protobuf::Empty* response) { return this->compositeOnBlack(context, request, response); }));}
    void SetMessageAllocatorFor_compositeOnBlack(
        ::grpc::MessageAllocator< ::octaneapi::ApiImageBuffer_compositeOnBlackRequest, ::google::protobuf::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(29);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiImageBuffer_compositeOnBlackRequest, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_compositeOnBlack() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status compositeOnBlack(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_compositeOnBlackRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* compositeOnBlack(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_compositeOnBlackRequest* /*request*/, ::google::protobuf::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_flipVertical : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_flipVertical() {
      ::grpc::Service::MarkMethodCallback(30,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiImageBuffer_flipVerticalRequest, ::google::protobuf::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiImageBuffer_flipVerticalRequest* request, ::google::protobuf::Empty* response) { return this->flipVertical(context, request, response); }));}
    void SetMessageAllocatorFor_flipVertical(
        ::grpc::MessageAllocator< ::octaneapi::ApiImageBuffer_flipVerticalRequest, ::google::protobuf::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(30);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiImageBuffer_flipVerticalRequest, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_flipVertical() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status flipVertical(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_flipVerticalRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* flipVertical(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_flipVerticalRequest* /*request*/, ::google::protobuf::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_convert : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_convert() {
      ::grpc::Service::MarkMethodCallback(31,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiImageBuffer_convertRequest, ::google::protobuf::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiImageBuffer_convertRequest* request, ::google::protobuf::Empty* response) { return this->convert(context, request, response); }));}
    void SetMessageAllocatorFor_convert(
        ::grpc::MessageAllocator< ::octaneapi::ApiImageBuffer_convertRequest, ::google::protobuf::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(31);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiImageBuffer_convertRequest, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_convert() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status convert(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_convertRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* convert(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_convertRequest* /*request*/, ::google::protobuf::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_applyGaussianFilter : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_applyGaussianFilter() {
      ::grpc::Service::MarkMethodCallback(32,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiImageBuffer_applyGaussianFilterRequest, ::google::protobuf::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiImageBuffer_applyGaussianFilterRequest* request, ::google::protobuf::Empty* response) { return this->applyGaussianFilter(context, request, response); }));}
    void SetMessageAllocatorFor_applyGaussianFilter(
        ::grpc::MessageAllocator< ::octaneapi::ApiImageBuffer_applyGaussianFilterRequest, ::google::protobuf::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(32);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiImageBuffer_applyGaussianFilterRequest, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_applyGaussianFilter() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status applyGaussianFilter(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_applyGaussianFilterRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* applyGaussianFilter(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_applyGaussianFilterRequest* /*request*/, ::google::protobuf::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_applyBoxFilter : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_applyBoxFilter() {
      ::grpc::Service::MarkMethodCallback(33,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiImageBuffer_applyBoxFilterRequest, ::google::protobuf::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiImageBuffer_applyBoxFilterRequest* request, ::google::protobuf::Empty* response) { return this->applyBoxFilter(context, request, response); }));}
    void SetMessageAllocatorFor_applyBoxFilter(
        ::grpc::MessageAllocator< ::octaneapi::ApiImageBuffer_applyBoxFilterRequest, ::google::protobuf::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(33);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiImageBuffer_applyBoxFilterRequest, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_applyBoxFilter() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status applyBoxFilter(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_applyBoxFilterRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* applyBoxFilter(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_applyBoxFilterRequest* /*request*/, ::google::protobuf::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_applyLevels : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_applyLevels() {
      ::grpc::Service::MarkMethodCallback(34,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiImageBuffer_applyLevelsRequest, ::google::protobuf::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiImageBuffer_applyLevelsRequest* request, ::google::protobuf::Empty* response) { return this->applyLevels(context, request, response); }));}
    void SetMessageAllocatorFor_applyLevels(
        ::grpc::MessageAllocator< ::octaneapi::ApiImageBuffer_applyLevelsRequest, ::google::protobuf::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(34);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiImageBuffer_applyLevelsRequest, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_applyLevels() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status applyLevels(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_applyLevelsRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* applyLevels(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_applyLevelsRequest* /*request*/, ::google::protobuf::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_compareValues : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_compareValues() {
      ::grpc::Service::MarkMethodCallback(35,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiImageBuffer_compareValuesRequest, ::google::protobuf::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiImageBuffer_compareValuesRequest* request, ::google::protobuf::Empty* response) { return this->compareValues(context, request, response); }));}
    void SetMessageAllocatorFor_compareValues(
        ::grpc::MessageAllocator< ::octaneapi::ApiImageBuffer_compareValuesRequest, ::google::protobuf::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(35);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiImageBuffer_compareValuesRequest, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_compareValues() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status compareValues(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_compareValuesRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* compareValues(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_compareValuesRequest* /*request*/, ::google::protobuf::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_calculateMeanSquareError : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_calculateMeanSquareError() {
      ::grpc::Service::MarkMethodCallback(36,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiImageBuffer_calculateMeanSquareErrorRequest, ::octaneapi::ApiImageBuffer_calculateMeanSquareErrorResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiImageBuffer_calculateMeanSquareErrorRequest* request, ::octaneapi::ApiImageBuffer_calculateMeanSquareErrorResponse* response) { return this->calculateMeanSquareError(context, request, response); }));}
    void SetMessageAllocatorFor_calculateMeanSquareError(
        ::grpc::MessageAllocator< ::octaneapi::ApiImageBuffer_calculateMeanSquareErrorRequest, ::octaneapi::ApiImageBuffer_calculateMeanSquareErrorResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(36);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiImageBuffer_calculateMeanSquareErrorRequest, ::octaneapi::ApiImageBuffer_calculateMeanSquareErrorResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_calculateMeanSquareError() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status calculateMeanSquareError(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_calculateMeanSquareErrorRequest* /*request*/, ::octaneapi::ApiImageBuffer_calculateMeanSquareErrorResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* calculateMeanSquareError(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_calculateMeanSquareErrorRequest* /*request*/, ::octaneapi::ApiImageBuffer_calculateMeanSquareErrorResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_save : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_save() {
      ::grpc::Service::MarkMethodCallback(37,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiImageBuffer_saveRequest, ::octaneapi::ApiImageBuffer_saveResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiImageBuffer_saveRequest* request, ::octaneapi::ApiImageBuffer_saveResponse* response) { return this->save(context, request, response); }));}
    void SetMessageAllocatorFor_save(
        ::grpc::MessageAllocator< ::octaneapi::ApiImageBuffer_saveRequest, ::octaneapi::ApiImageBuffer_saveResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(37);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiImageBuffer_saveRequest, ::octaneapi::ApiImageBuffer_saveResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_save() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status save(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_saveRequest* /*request*/, ::octaneapi::ApiImageBuffer_saveResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* save(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_saveRequest* /*request*/, ::octaneapi::ApiImageBuffer_saveResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_saveAsync : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_saveAsync() {
      ::grpc::Service::MarkMethodCallback(38,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiImageBuffer_saveAsyncRequest, ::octaneapi::ApiImageBuffer_saveAsyncResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiImageBuffer_saveAsyncRequest* request, ::octaneapi::ApiImageBuffer_saveAsyncResponse* response) { return this->saveAsync(context, request, response); }));}
    void SetMessageAllocatorFor_saveAsync(
        ::grpc::MessageAllocator< ::octaneapi::ApiImageBuffer_saveAsyncRequest, ::octaneapi::ApiImageBuffer_saveAsyncResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(38);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiImageBuffer_saveAsyncRequest, ::octaneapi::ApiImageBuffer_saveAsyncResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_saveAsync() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status saveAsync(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_saveAsyncRequest* /*request*/, ::octaneapi::ApiImageBuffer_saveAsyncResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* saveAsync(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_saveAsyncRequest* /*request*/, ::octaneapi::ApiImageBuffer_saveAsyncResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_pixelAddr : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_pixelAddr() {
      ::grpc::Service::MarkMethodCallback(39,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiImageBuffer_pixelAddrRequest, ::octaneapi::ApiImageBuffer_pixelAddrResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiImageBuffer_pixelAddrRequest* request, ::octaneapi::ApiImageBuffer_pixelAddrResponse* response) { return this->pixelAddr(context, request, response); }));}
    void SetMessageAllocatorFor_pixelAddr(
        ::grpc::MessageAllocator< ::octaneapi::ApiImageBuffer_pixelAddrRequest, ::octaneapi::ApiImageBuffer_pixelAddrResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(39);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiImageBuffer_pixelAddrRequest, ::octaneapi::ApiImageBuffer_pixelAddrResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_pixelAddr() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status pixelAddr(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_pixelAddrRequest* /*request*/, ::octaneapi::ApiImageBuffer_pixelAddrResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* pixelAddr(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_pixelAddrRequest* /*request*/, ::octaneapi::ApiImageBuffer_pixelAddrResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_pixelAddr1 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_pixelAddr1() {
      ::grpc::Service::MarkMethodCallback(40,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiImageBuffer_pixelAddr1Request, ::octaneapi::ApiImageBuffer_pixelAddr1Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiImageBuffer_pixelAddr1Request* request, ::octaneapi::ApiImageBuffer_pixelAddr1Response* response) { return this->pixelAddr1(context, request, response); }));}
    void SetMessageAllocatorFor_pixelAddr1(
        ::grpc::MessageAllocator< ::octaneapi::ApiImageBuffer_pixelAddr1Request, ::octaneapi::ApiImageBuffer_pixelAddr1Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(40);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiImageBuffer_pixelAddr1Request, ::octaneapi::ApiImageBuffer_pixelAddr1Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_pixelAddr1() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status pixelAddr1(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_pixelAddr1Request* /*request*/, ::octaneapi::ApiImageBuffer_pixelAddr1Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* pixelAddr1(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_pixelAddr1Request* /*request*/, ::octaneapi::ApiImageBuffer_pixelAddr1Response* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_create<WithCallbackMethod_create1<WithCallbackMethod_load<WithCallbackMethod_load1<WithCallbackMethod_convertTo<WithCallbackMethod_destroy<WithCallbackMethod_bytesPerPixel<WithCallbackMethod_bytesPerChannel<WithCallbackMethod_channelCount<WithCallbackMethod_size<WithCallbackMethod_sizeInBytes<WithCallbackMethod_type<WithCallbackMethod_sourceInfo<WithCallbackMethod_canWrapX<WithCallbackMethod_canWrapY<WithCallbackMethod_needsFlip<WithCallbackMethod_hasAlpha<WithCallbackMethod_hasColor<WithCallbackMethod_isCompressed<WithCallbackMethod_isEmpty<WithCallbackMethod_isHalf<WithCallbackMethod_isHdr<WithCallbackMethod_isMono<WithCallbackMethod_isPixelValid<WithCallbackMethod_compress<WithCallbackMethod_setPixelLdr<WithCallbackMethod_setPixelHalf<WithCallbackMethod_setPixelHdr<WithCallbackMethod_copyRegion<WithCallbackMethod_compositeOnBlack<WithCallbackMethod_flipVertical<WithCallbackMethod_convert<WithCallbackMethod_applyGaussianFilter<WithCallbackMethod_applyBoxFilter<WithCallbackMethod_applyLevels<WithCallbackMethod_compareValues<WithCallbackMethod_calculateMeanSquareError<WithCallbackMethod_save<WithCallbackMethod_saveAsync<WithCallbackMethod_pixelAddr<WithCallbackMethod_pixelAddr1<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_create : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_create() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_create() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status create(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_createRequest* /*request*/, ::octaneapi::ApiImageBuffer_createResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_create1 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_create1() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_create1() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status create1(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_create1Request* /*request*/, ::octaneapi::ApiImageBuffer_create1Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_load : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_load() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_load() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status load(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_loadRequest* /*request*/, ::octaneapi::ApiImageBuffer_loadResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_load1 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_load1() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_load1() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status load1(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_load1Request* /*request*/, ::octaneapi::ApiImageBuffer_load1Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_convertTo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_convertTo() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_convertTo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status convertTo(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_convertToRequest* /*request*/, ::octaneapi::ApiImageBuffer_convertToResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_destroy : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_destroy() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_destroy() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status destroy(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_destroyRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_bytesPerPixel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_bytesPerPixel() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_bytesPerPixel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status bytesPerPixel(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_bytesPerPixelRequest* /*request*/, ::octaneapi::ApiImageBuffer_bytesPerPixelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_bytesPerChannel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_bytesPerChannel() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_bytesPerChannel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status bytesPerChannel(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_bytesPerChannelRequest* /*request*/, ::octaneapi::ApiImageBuffer_bytesPerChannelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_channelCount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_channelCount() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_channelCount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status channelCount(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_channelCountRequest* /*request*/, ::octaneapi::ApiImageBuffer_channelCountResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_size : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_size() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_size() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status size(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_sizeRequest* /*request*/, ::octaneapi::ApiImageBuffer_sizeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_sizeInBytes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_sizeInBytes() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_sizeInBytes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status sizeInBytes(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_sizeInBytesRequest* /*request*/, ::octaneapi::ApiImageBuffer_sizeInBytesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_type : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_type() {
      ::grpc::Service::MarkMethodGeneric(11);
    }
    ~WithGenericMethod_type() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status type(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_typeRequest* /*request*/, ::octaneapi::ApiImageBuffer_typeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_sourceInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_sourceInfo() {
      ::grpc::Service::MarkMethodGeneric(12);
    }
    ~WithGenericMethod_sourceInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status sourceInfo(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_sourceInfoRequest* /*request*/, ::octaneapi::ApiImageBuffer_sourceInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_canWrapX : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_canWrapX() {
      ::grpc::Service::MarkMethodGeneric(13);
    }
    ~WithGenericMethod_canWrapX() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status canWrapX(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_canWrapXRequest* /*request*/, ::octaneapi::ApiImageBuffer_canWrapXResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_canWrapY : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_canWrapY() {
      ::grpc::Service::MarkMethodGeneric(14);
    }
    ~WithGenericMethod_canWrapY() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status canWrapY(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_canWrapYRequest* /*request*/, ::octaneapi::ApiImageBuffer_canWrapYResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_needsFlip : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_needsFlip() {
      ::grpc::Service::MarkMethodGeneric(15);
    }
    ~WithGenericMethod_needsFlip() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status needsFlip(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_needsFlipRequest* /*request*/, ::octaneapi::ApiImageBuffer_needsFlipResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_hasAlpha : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_hasAlpha() {
      ::grpc::Service::MarkMethodGeneric(16);
    }
    ~WithGenericMethod_hasAlpha() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status hasAlpha(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_hasAlphaRequest* /*request*/, ::octaneapi::ApiImageBuffer_hasAlphaResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_hasColor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_hasColor() {
      ::grpc::Service::MarkMethodGeneric(17);
    }
    ~WithGenericMethod_hasColor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status hasColor(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_hasColorRequest* /*request*/, ::octaneapi::ApiImageBuffer_hasColorResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_isCompressed : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_isCompressed() {
      ::grpc::Service::MarkMethodGeneric(18);
    }
    ~WithGenericMethod_isCompressed() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isCompressed(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_isCompressedRequest* /*request*/, ::octaneapi::ApiImageBuffer_isCompressedResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_isEmpty : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_isEmpty() {
      ::grpc::Service::MarkMethodGeneric(19);
    }
    ~WithGenericMethod_isEmpty() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isEmpty(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_isEmptyRequest* /*request*/, ::octaneapi::ApiImageBuffer_isEmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_isHalf : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_isHalf() {
      ::grpc::Service::MarkMethodGeneric(20);
    }
    ~WithGenericMethod_isHalf() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isHalf(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_isHalfRequest* /*request*/, ::octaneapi::ApiImageBuffer_isHalfResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_isHdr : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_isHdr() {
      ::grpc::Service::MarkMethodGeneric(21);
    }
    ~WithGenericMethod_isHdr() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isHdr(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_isHdrRequest* /*request*/, ::octaneapi::ApiImageBuffer_isHdrResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_isMono : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_isMono() {
      ::grpc::Service::MarkMethodGeneric(22);
    }
    ~WithGenericMethod_isMono() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isMono(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_isMonoRequest* /*request*/, ::octaneapi::ApiImageBuffer_isMonoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_isPixelValid : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_isPixelValid() {
      ::grpc::Service::MarkMethodGeneric(23);
    }
    ~WithGenericMethod_isPixelValid() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isPixelValid(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_isPixelValidRequest* /*request*/, ::octaneapi::ApiImageBuffer_isPixelValidResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_compress : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_compress() {
      ::grpc::Service::MarkMethodGeneric(24);
    }
    ~WithGenericMethod_compress() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status compress(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_compressRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_setPixelLdr : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_setPixelLdr() {
      ::grpc::Service::MarkMethodGeneric(25);
    }
    ~WithGenericMethod_setPixelLdr() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setPixelLdr(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_setPixelLdrRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_setPixelHalf : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_setPixelHalf() {
      ::grpc::Service::MarkMethodGeneric(26);
    }
    ~WithGenericMethod_setPixelHalf() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setPixelHalf(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_setPixelHalfRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_setPixelHdr : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_setPixelHdr() {
      ::grpc::Service::MarkMethodGeneric(27);
    }
    ~WithGenericMethod_setPixelHdr() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setPixelHdr(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_setPixelHdrRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_copyRegion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_copyRegion() {
      ::grpc::Service::MarkMethodGeneric(28);
    }
    ~WithGenericMethod_copyRegion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status copyRegion(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_copyRegionRequest* /*request*/, ::octaneapi::ApiImageBuffer_copyRegionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_compositeOnBlack : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_compositeOnBlack() {
      ::grpc::Service::MarkMethodGeneric(29);
    }
    ~WithGenericMethod_compositeOnBlack() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status compositeOnBlack(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_compositeOnBlackRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_flipVertical : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_flipVertical() {
      ::grpc::Service::MarkMethodGeneric(30);
    }
    ~WithGenericMethod_flipVertical() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status flipVertical(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_flipVerticalRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_convert : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_convert() {
      ::grpc::Service::MarkMethodGeneric(31);
    }
    ~WithGenericMethod_convert() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status convert(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_convertRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_applyGaussianFilter : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_applyGaussianFilter() {
      ::grpc::Service::MarkMethodGeneric(32);
    }
    ~WithGenericMethod_applyGaussianFilter() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status applyGaussianFilter(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_applyGaussianFilterRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_applyBoxFilter : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_applyBoxFilter() {
      ::grpc::Service::MarkMethodGeneric(33);
    }
    ~WithGenericMethod_applyBoxFilter() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status applyBoxFilter(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_applyBoxFilterRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_applyLevels : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_applyLevels() {
      ::grpc::Service::MarkMethodGeneric(34);
    }
    ~WithGenericMethod_applyLevels() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status applyLevels(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_applyLevelsRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_compareValues : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_compareValues() {
      ::grpc::Service::MarkMethodGeneric(35);
    }
    ~WithGenericMethod_compareValues() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status compareValues(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_compareValuesRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_calculateMeanSquareError : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_calculateMeanSquareError() {
      ::grpc::Service::MarkMethodGeneric(36);
    }
    ~WithGenericMethod_calculateMeanSquareError() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status calculateMeanSquareError(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_calculateMeanSquareErrorRequest* /*request*/, ::octaneapi::ApiImageBuffer_calculateMeanSquareErrorResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_save : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_save() {
      ::grpc::Service::MarkMethodGeneric(37);
    }
    ~WithGenericMethod_save() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status save(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_saveRequest* /*request*/, ::octaneapi::ApiImageBuffer_saveResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_saveAsync : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_saveAsync() {
      ::grpc::Service::MarkMethodGeneric(38);
    }
    ~WithGenericMethod_saveAsync() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status saveAsync(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_saveAsyncRequest* /*request*/, ::octaneapi::ApiImageBuffer_saveAsyncResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_pixelAddr : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_pixelAddr() {
      ::grpc::Service::MarkMethodGeneric(39);
    }
    ~WithGenericMethod_pixelAddr() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status pixelAddr(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_pixelAddrRequest* /*request*/, ::octaneapi::ApiImageBuffer_pixelAddrResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_pixelAddr1 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_pixelAddr1() {
      ::grpc::Service::MarkMethodGeneric(40);
    }
    ~WithGenericMethod_pixelAddr1() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status pixelAddr1(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_pixelAddr1Request* /*request*/, ::octaneapi::ApiImageBuffer_pixelAddr1Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_create : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_create() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_create() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status create(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_createRequest* /*request*/, ::octaneapi::ApiImageBuffer_createResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestcreate(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_create1 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_create1() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_create1() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status create1(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_create1Request* /*request*/, ::octaneapi::ApiImageBuffer_create1Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestcreate1(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_load : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_load() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_load() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status load(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_loadRequest* /*request*/, ::octaneapi::ApiImageBuffer_loadResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestload(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_load1 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_load1() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_load1() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status load1(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_load1Request* /*request*/, ::octaneapi::ApiImageBuffer_load1Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestload1(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_convertTo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_convertTo() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_convertTo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status convertTo(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_convertToRequest* /*request*/, ::octaneapi::ApiImageBuffer_convertToResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestconvertTo(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_destroy : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_destroy() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_destroy() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status destroy(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_destroyRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestdestroy(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_bytesPerPixel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_bytesPerPixel() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_bytesPerPixel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status bytesPerPixel(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_bytesPerPixelRequest* /*request*/, ::octaneapi::ApiImageBuffer_bytesPerPixelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestbytesPerPixel(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_bytesPerChannel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_bytesPerChannel() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_bytesPerChannel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status bytesPerChannel(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_bytesPerChannelRequest* /*request*/, ::octaneapi::ApiImageBuffer_bytesPerChannelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestbytesPerChannel(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_channelCount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_channelCount() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_channelCount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status channelCount(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_channelCountRequest* /*request*/, ::octaneapi::ApiImageBuffer_channelCountResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestchannelCount(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_size : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_size() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_size() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status size(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_sizeRequest* /*request*/, ::octaneapi::ApiImageBuffer_sizeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestsize(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_sizeInBytes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_sizeInBytes() {
      ::grpc::Service::MarkMethodRaw(10);
    }
    ~WithRawMethod_sizeInBytes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status sizeInBytes(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_sizeInBytesRequest* /*request*/, ::octaneapi::ApiImageBuffer_sizeInBytesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsizeInBytes(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_type : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_type() {
      ::grpc::Service::MarkMethodRaw(11);
    }
    ~WithRawMethod_type() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status type(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_typeRequest* /*request*/, ::octaneapi::ApiImageBuffer_typeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requesttype(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_sourceInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_sourceInfo() {
      ::grpc::Service::MarkMethodRaw(12);
    }
    ~WithRawMethod_sourceInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status sourceInfo(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_sourceInfoRequest* /*request*/, ::octaneapi::ApiImageBuffer_sourceInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsourceInfo(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_canWrapX : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_canWrapX() {
      ::grpc::Service::MarkMethodRaw(13);
    }
    ~WithRawMethod_canWrapX() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status canWrapX(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_canWrapXRequest* /*request*/, ::octaneapi::ApiImageBuffer_canWrapXResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestcanWrapX(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_canWrapY : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_canWrapY() {
      ::grpc::Service::MarkMethodRaw(14);
    }
    ~WithRawMethod_canWrapY() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status canWrapY(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_canWrapYRequest* /*request*/, ::octaneapi::ApiImageBuffer_canWrapYResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestcanWrapY(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_needsFlip : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_needsFlip() {
      ::grpc::Service::MarkMethodRaw(15);
    }
    ~WithRawMethod_needsFlip() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status needsFlip(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_needsFlipRequest* /*request*/, ::octaneapi::ApiImageBuffer_needsFlipResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestneedsFlip(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_hasAlpha : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_hasAlpha() {
      ::grpc::Service::MarkMethodRaw(16);
    }
    ~WithRawMethod_hasAlpha() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status hasAlpha(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_hasAlphaRequest* /*request*/, ::octaneapi::ApiImageBuffer_hasAlphaResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequesthasAlpha(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_hasColor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_hasColor() {
      ::grpc::Service::MarkMethodRaw(17);
    }
    ~WithRawMethod_hasColor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status hasColor(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_hasColorRequest* /*request*/, ::octaneapi::ApiImageBuffer_hasColorResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequesthasColor(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_isCompressed : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_isCompressed() {
      ::grpc::Service::MarkMethodRaw(18);
    }
    ~WithRawMethod_isCompressed() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isCompressed(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_isCompressedRequest* /*request*/, ::octaneapi::ApiImageBuffer_isCompressedResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestisCompressed(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_isEmpty : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_isEmpty() {
      ::grpc::Service::MarkMethodRaw(19);
    }
    ~WithRawMethod_isEmpty() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isEmpty(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_isEmptyRequest* /*request*/, ::octaneapi::ApiImageBuffer_isEmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestisEmpty(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(19, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_isHalf : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_isHalf() {
      ::grpc::Service::MarkMethodRaw(20);
    }
    ~WithRawMethod_isHalf() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isHalf(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_isHalfRequest* /*request*/, ::octaneapi::ApiImageBuffer_isHalfResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestisHalf(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(20, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_isHdr : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_isHdr() {
      ::grpc::Service::MarkMethodRaw(21);
    }
    ~WithRawMethod_isHdr() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isHdr(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_isHdrRequest* /*request*/, ::octaneapi::ApiImageBuffer_isHdrResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestisHdr(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(21, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_isMono : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_isMono() {
      ::grpc::Service::MarkMethodRaw(22);
    }
    ~WithRawMethod_isMono() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isMono(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_isMonoRequest* /*request*/, ::octaneapi::ApiImageBuffer_isMonoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestisMono(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(22, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_isPixelValid : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_isPixelValid() {
      ::grpc::Service::MarkMethodRaw(23);
    }
    ~WithRawMethod_isPixelValid() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isPixelValid(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_isPixelValidRequest* /*request*/, ::octaneapi::ApiImageBuffer_isPixelValidResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestisPixelValid(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(23, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_compress : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_compress() {
      ::grpc::Service::MarkMethodRaw(24);
    }
    ~WithRawMethod_compress() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status compress(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_compressRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestcompress(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(24, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_setPixelLdr : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_setPixelLdr() {
      ::grpc::Service::MarkMethodRaw(25);
    }
    ~WithRawMethod_setPixelLdr() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setPixelLdr(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_setPixelLdrRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsetPixelLdr(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(25, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_setPixelHalf : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_setPixelHalf() {
      ::grpc::Service::MarkMethodRaw(26);
    }
    ~WithRawMethod_setPixelHalf() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setPixelHalf(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_setPixelHalfRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsetPixelHalf(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(26, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_setPixelHdr : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_setPixelHdr() {
      ::grpc::Service::MarkMethodRaw(27);
    }
    ~WithRawMethod_setPixelHdr() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setPixelHdr(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_setPixelHdrRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsetPixelHdr(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(27, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_copyRegion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_copyRegion() {
      ::grpc::Service::MarkMethodRaw(28);
    }
    ~WithRawMethod_copyRegion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status copyRegion(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_copyRegionRequest* /*request*/, ::octaneapi::ApiImageBuffer_copyRegionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestcopyRegion(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(28, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_compositeOnBlack : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_compositeOnBlack() {
      ::grpc::Service::MarkMethodRaw(29);
    }
    ~WithRawMethod_compositeOnBlack() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status compositeOnBlack(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_compositeOnBlackRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestcompositeOnBlack(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(29, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_flipVertical : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_flipVertical() {
      ::grpc::Service::MarkMethodRaw(30);
    }
    ~WithRawMethod_flipVertical() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status flipVertical(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_flipVerticalRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestflipVertical(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(30, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_convert : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_convert() {
      ::grpc::Service::MarkMethodRaw(31);
    }
    ~WithRawMethod_convert() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status convert(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_convertRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestconvert(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(31, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_applyGaussianFilter : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_applyGaussianFilter() {
      ::grpc::Service::MarkMethodRaw(32);
    }
    ~WithRawMethod_applyGaussianFilter() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status applyGaussianFilter(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_applyGaussianFilterRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestapplyGaussianFilter(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(32, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_applyBoxFilter : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_applyBoxFilter() {
      ::grpc::Service::MarkMethodRaw(33);
    }
    ~WithRawMethod_applyBoxFilter() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status applyBoxFilter(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_applyBoxFilterRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestapplyBoxFilter(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(33, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_applyLevels : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_applyLevels() {
      ::grpc::Service::MarkMethodRaw(34);
    }
    ~WithRawMethod_applyLevels() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status applyLevels(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_applyLevelsRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestapplyLevels(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(34, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_compareValues : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_compareValues() {
      ::grpc::Service::MarkMethodRaw(35);
    }
    ~WithRawMethod_compareValues() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status compareValues(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_compareValuesRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestcompareValues(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(35, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_calculateMeanSquareError : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_calculateMeanSquareError() {
      ::grpc::Service::MarkMethodRaw(36);
    }
    ~WithRawMethod_calculateMeanSquareError() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status calculateMeanSquareError(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_calculateMeanSquareErrorRequest* /*request*/, ::octaneapi::ApiImageBuffer_calculateMeanSquareErrorResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestcalculateMeanSquareError(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(36, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_save : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_save() {
      ::grpc::Service::MarkMethodRaw(37);
    }
    ~WithRawMethod_save() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status save(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_saveRequest* /*request*/, ::octaneapi::ApiImageBuffer_saveResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestsave(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(37, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_saveAsync : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_saveAsync() {
      ::grpc::Service::MarkMethodRaw(38);
    }
    ~WithRawMethod_saveAsync() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status saveAsync(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_saveAsyncRequest* /*request*/, ::octaneapi::ApiImageBuffer_saveAsyncResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsaveAsync(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(38, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_pixelAddr : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_pixelAddr() {
      ::grpc::Service::MarkMethodRaw(39);
    }
    ~WithRawMethod_pixelAddr() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status pixelAddr(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_pixelAddrRequest* /*request*/, ::octaneapi::ApiImageBuffer_pixelAddrResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestpixelAddr(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(39, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_pixelAddr1 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_pixelAddr1() {
      ::grpc::Service::MarkMethodRaw(40);
    }
    ~WithRawMethod_pixelAddr1() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status pixelAddr1(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_pixelAddr1Request* /*request*/, ::octaneapi::ApiImageBuffer_pixelAddr1Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestpixelAddr1(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(40, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_create : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_create() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->create(context, request, response); }));
    }
    ~WithRawCallbackMethod_create() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status create(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_createRequest* /*request*/, ::octaneapi::ApiImageBuffer_createResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* create(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_create1 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_create1() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->create1(context, request, response); }));
    }
    ~WithRawCallbackMethod_create1() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status create1(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_create1Request* /*request*/, ::octaneapi::ApiImageBuffer_create1Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* create1(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_load : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_load() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->load(context, request, response); }));
    }
    ~WithRawCallbackMethod_load() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status load(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_loadRequest* /*request*/, ::octaneapi::ApiImageBuffer_loadResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* load(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_load1 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_load1() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->load1(context, request, response); }));
    }
    ~WithRawCallbackMethod_load1() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status load1(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_load1Request* /*request*/, ::octaneapi::ApiImageBuffer_load1Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* load1(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_convertTo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_convertTo() {
      ::grpc::Service::MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->convertTo(context, request, response); }));
    }
    ~WithRawCallbackMethod_convertTo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status convertTo(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_convertToRequest* /*request*/, ::octaneapi::ApiImageBuffer_convertToResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* convertTo(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_destroy : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_destroy() {
      ::grpc::Service::MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->destroy(context, request, response); }));
    }
    ~WithRawCallbackMethod_destroy() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status destroy(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_destroyRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* destroy(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_bytesPerPixel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_bytesPerPixel() {
      ::grpc::Service::MarkMethodRawCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->bytesPerPixel(context, request, response); }));
    }
    ~WithRawCallbackMethod_bytesPerPixel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status bytesPerPixel(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_bytesPerPixelRequest* /*request*/, ::octaneapi::ApiImageBuffer_bytesPerPixelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* bytesPerPixel(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_bytesPerChannel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_bytesPerChannel() {
      ::grpc::Service::MarkMethodRawCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->bytesPerChannel(context, request, response); }));
    }
    ~WithRawCallbackMethod_bytesPerChannel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status bytesPerChannel(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_bytesPerChannelRequest* /*request*/, ::octaneapi::ApiImageBuffer_bytesPerChannelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* bytesPerChannel(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_channelCount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_channelCount() {
      ::grpc::Service::MarkMethodRawCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->channelCount(context, request, response); }));
    }
    ~WithRawCallbackMethod_channelCount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status channelCount(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_channelCountRequest* /*request*/, ::octaneapi::ApiImageBuffer_channelCountResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* channelCount(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_size : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_size() {
      ::grpc::Service::MarkMethodRawCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->size(context, request, response); }));
    }
    ~WithRawCallbackMethod_size() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status size(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_sizeRequest* /*request*/, ::octaneapi::ApiImageBuffer_sizeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* size(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_sizeInBytes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_sizeInBytes() {
      ::grpc::Service::MarkMethodRawCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->sizeInBytes(context, request, response); }));
    }
    ~WithRawCallbackMethod_sizeInBytes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status sizeInBytes(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_sizeInBytesRequest* /*request*/, ::octaneapi::ApiImageBuffer_sizeInBytesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* sizeInBytes(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_type : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_type() {
      ::grpc::Service::MarkMethodRawCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->type(context, request, response); }));
    }
    ~WithRawCallbackMethod_type() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status type(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_typeRequest* /*request*/, ::octaneapi::ApiImageBuffer_typeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* type(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_sourceInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_sourceInfo() {
      ::grpc::Service::MarkMethodRawCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->sourceInfo(context, request, response); }));
    }
    ~WithRawCallbackMethod_sourceInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status sourceInfo(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_sourceInfoRequest* /*request*/, ::octaneapi::ApiImageBuffer_sourceInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* sourceInfo(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_canWrapX : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_canWrapX() {
      ::grpc::Service::MarkMethodRawCallback(13,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->canWrapX(context, request, response); }));
    }
    ~WithRawCallbackMethod_canWrapX() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status canWrapX(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_canWrapXRequest* /*request*/, ::octaneapi::ApiImageBuffer_canWrapXResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* canWrapX(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_canWrapY : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_canWrapY() {
      ::grpc::Service::MarkMethodRawCallback(14,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->canWrapY(context, request, response); }));
    }
    ~WithRawCallbackMethod_canWrapY() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status canWrapY(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_canWrapYRequest* /*request*/, ::octaneapi::ApiImageBuffer_canWrapYResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* canWrapY(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_needsFlip : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_needsFlip() {
      ::grpc::Service::MarkMethodRawCallback(15,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->needsFlip(context, request, response); }));
    }
    ~WithRawCallbackMethod_needsFlip() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status needsFlip(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_needsFlipRequest* /*request*/, ::octaneapi::ApiImageBuffer_needsFlipResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* needsFlip(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_hasAlpha : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_hasAlpha() {
      ::grpc::Service::MarkMethodRawCallback(16,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->hasAlpha(context, request, response); }));
    }
    ~WithRawCallbackMethod_hasAlpha() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status hasAlpha(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_hasAlphaRequest* /*request*/, ::octaneapi::ApiImageBuffer_hasAlphaResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* hasAlpha(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_hasColor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_hasColor() {
      ::grpc::Service::MarkMethodRawCallback(17,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->hasColor(context, request, response); }));
    }
    ~WithRawCallbackMethod_hasColor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status hasColor(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_hasColorRequest* /*request*/, ::octaneapi::ApiImageBuffer_hasColorResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* hasColor(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_isCompressed : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_isCompressed() {
      ::grpc::Service::MarkMethodRawCallback(18,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->isCompressed(context, request, response); }));
    }
    ~WithRawCallbackMethod_isCompressed() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isCompressed(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_isCompressedRequest* /*request*/, ::octaneapi::ApiImageBuffer_isCompressedResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* isCompressed(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_isEmpty : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_isEmpty() {
      ::grpc::Service::MarkMethodRawCallback(19,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->isEmpty(context, request, response); }));
    }
    ~WithRawCallbackMethod_isEmpty() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isEmpty(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_isEmptyRequest* /*request*/, ::octaneapi::ApiImageBuffer_isEmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* isEmpty(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_isHalf : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_isHalf() {
      ::grpc::Service::MarkMethodRawCallback(20,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->isHalf(context, request, response); }));
    }
    ~WithRawCallbackMethod_isHalf() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isHalf(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_isHalfRequest* /*request*/, ::octaneapi::ApiImageBuffer_isHalfResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* isHalf(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_isHdr : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_isHdr() {
      ::grpc::Service::MarkMethodRawCallback(21,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->isHdr(context, request, response); }));
    }
    ~WithRawCallbackMethod_isHdr() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isHdr(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_isHdrRequest* /*request*/, ::octaneapi::ApiImageBuffer_isHdrResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* isHdr(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_isMono : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_isMono() {
      ::grpc::Service::MarkMethodRawCallback(22,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->isMono(context, request, response); }));
    }
    ~WithRawCallbackMethod_isMono() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isMono(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_isMonoRequest* /*request*/, ::octaneapi::ApiImageBuffer_isMonoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* isMono(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_isPixelValid : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_isPixelValid() {
      ::grpc::Service::MarkMethodRawCallback(23,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->isPixelValid(context, request, response); }));
    }
    ~WithRawCallbackMethod_isPixelValid() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isPixelValid(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_isPixelValidRequest* /*request*/, ::octaneapi::ApiImageBuffer_isPixelValidResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* isPixelValid(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_compress : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_compress() {
      ::grpc::Service::MarkMethodRawCallback(24,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->compress(context, request, response); }));
    }
    ~WithRawCallbackMethod_compress() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status compress(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_compressRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* compress(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_setPixelLdr : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_setPixelLdr() {
      ::grpc::Service::MarkMethodRawCallback(25,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->setPixelLdr(context, request, response); }));
    }
    ~WithRawCallbackMethod_setPixelLdr() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setPixelLdr(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_setPixelLdrRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* setPixelLdr(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_setPixelHalf : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_setPixelHalf() {
      ::grpc::Service::MarkMethodRawCallback(26,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->setPixelHalf(context, request, response); }));
    }
    ~WithRawCallbackMethod_setPixelHalf() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setPixelHalf(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_setPixelHalfRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* setPixelHalf(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_setPixelHdr : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_setPixelHdr() {
      ::grpc::Service::MarkMethodRawCallback(27,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->setPixelHdr(context, request, response); }));
    }
    ~WithRawCallbackMethod_setPixelHdr() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setPixelHdr(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_setPixelHdrRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* setPixelHdr(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_copyRegion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_copyRegion() {
      ::grpc::Service::MarkMethodRawCallback(28,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->copyRegion(context, request, response); }));
    }
    ~WithRawCallbackMethod_copyRegion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status copyRegion(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_copyRegionRequest* /*request*/, ::octaneapi::ApiImageBuffer_copyRegionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* copyRegion(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_compositeOnBlack : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_compositeOnBlack() {
      ::grpc::Service::MarkMethodRawCallback(29,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->compositeOnBlack(context, request, response); }));
    }
    ~WithRawCallbackMethod_compositeOnBlack() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status compositeOnBlack(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_compositeOnBlackRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* compositeOnBlack(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_flipVertical : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_flipVertical() {
      ::grpc::Service::MarkMethodRawCallback(30,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->flipVertical(context, request, response); }));
    }
    ~WithRawCallbackMethod_flipVertical() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status flipVertical(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_flipVerticalRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* flipVertical(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_convert : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_convert() {
      ::grpc::Service::MarkMethodRawCallback(31,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->convert(context, request, response); }));
    }
    ~WithRawCallbackMethod_convert() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status convert(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_convertRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* convert(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_applyGaussianFilter : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_applyGaussianFilter() {
      ::grpc::Service::MarkMethodRawCallback(32,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->applyGaussianFilter(context, request, response); }));
    }
    ~WithRawCallbackMethod_applyGaussianFilter() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status applyGaussianFilter(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_applyGaussianFilterRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* applyGaussianFilter(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_applyBoxFilter : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_applyBoxFilter() {
      ::grpc::Service::MarkMethodRawCallback(33,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->applyBoxFilter(context, request, response); }));
    }
    ~WithRawCallbackMethod_applyBoxFilter() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status applyBoxFilter(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_applyBoxFilterRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* applyBoxFilter(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_applyLevels : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_applyLevels() {
      ::grpc::Service::MarkMethodRawCallback(34,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->applyLevels(context, request, response); }));
    }
    ~WithRawCallbackMethod_applyLevels() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status applyLevels(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_applyLevelsRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* applyLevels(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_compareValues : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_compareValues() {
      ::grpc::Service::MarkMethodRawCallback(35,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->compareValues(context, request, response); }));
    }
    ~WithRawCallbackMethod_compareValues() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status compareValues(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_compareValuesRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* compareValues(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_calculateMeanSquareError : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_calculateMeanSquareError() {
      ::grpc::Service::MarkMethodRawCallback(36,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->calculateMeanSquareError(context, request, response); }));
    }
    ~WithRawCallbackMethod_calculateMeanSquareError() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status calculateMeanSquareError(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_calculateMeanSquareErrorRequest* /*request*/, ::octaneapi::ApiImageBuffer_calculateMeanSquareErrorResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* calculateMeanSquareError(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_save : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_save() {
      ::grpc::Service::MarkMethodRawCallback(37,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->save(context, request, response); }));
    }
    ~WithRawCallbackMethod_save() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status save(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_saveRequest* /*request*/, ::octaneapi::ApiImageBuffer_saveResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* save(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_saveAsync : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_saveAsync() {
      ::grpc::Service::MarkMethodRawCallback(38,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->saveAsync(context, request, response); }));
    }
    ~WithRawCallbackMethod_saveAsync() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status saveAsync(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_saveAsyncRequest* /*request*/, ::octaneapi::ApiImageBuffer_saveAsyncResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* saveAsync(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_pixelAddr : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_pixelAddr() {
      ::grpc::Service::MarkMethodRawCallback(39,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->pixelAddr(context, request, response); }));
    }
    ~WithRawCallbackMethod_pixelAddr() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status pixelAddr(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_pixelAddrRequest* /*request*/, ::octaneapi::ApiImageBuffer_pixelAddrResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* pixelAddr(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_pixelAddr1 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_pixelAddr1() {
      ::grpc::Service::MarkMethodRawCallback(40,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->pixelAddr1(context, request, response); }));
    }
    ~WithRawCallbackMethod_pixelAddr1() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status pixelAddr1(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_pixelAddr1Request* /*request*/, ::octaneapi::ApiImageBuffer_pixelAddr1Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* pixelAddr1(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_create : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_create() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiImageBuffer_createRequest, ::octaneapi::ApiImageBuffer_createResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiImageBuffer_createRequest, ::octaneapi::ApiImageBuffer_createResponse>* streamer) {
                       return this->Streamedcreate(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_create() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status create(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_createRequest* /*request*/, ::octaneapi::ApiImageBuffer_createResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedcreate(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiImageBuffer_createRequest,::octaneapi::ApiImageBuffer_createResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_create1 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_create1() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiImageBuffer_create1Request, ::octaneapi::ApiImageBuffer_create1Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiImageBuffer_create1Request, ::octaneapi::ApiImageBuffer_create1Response>* streamer) {
                       return this->Streamedcreate1(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_create1() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status create1(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_create1Request* /*request*/, ::octaneapi::ApiImageBuffer_create1Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedcreate1(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiImageBuffer_create1Request,::octaneapi::ApiImageBuffer_create1Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_load : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_load() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiImageBuffer_loadRequest, ::octaneapi::ApiImageBuffer_loadResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiImageBuffer_loadRequest, ::octaneapi::ApiImageBuffer_loadResponse>* streamer) {
                       return this->Streamedload(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_load() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status load(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_loadRequest* /*request*/, ::octaneapi::ApiImageBuffer_loadResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedload(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiImageBuffer_loadRequest,::octaneapi::ApiImageBuffer_loadResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_load1 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_load1() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiImageBuffer_load1Request, ::octaneapi::ApiImageBuffer_load1Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiImageBuffer_load1Request, ::octaneapi::ApiImageBuffer_load1Response>* streamer) {
                       return this->Streamedload1(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_load1() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status load1(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_load1Request* /*request*/, ::octaneapi::ApiImageBuffer_load1Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedload1(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiImageBuffer_load1Request,::octaneapi::ApiImageBuffer_load1Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_convertTo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_convertTo() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiImageBuffer_convertToRequest, ::octaneapi::ApiImageBuffer_convertToResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiImageBuffer_convertToRequest, ::octaneapi::ApiImageBuffer_convertToResponse>* streamer) {
                       return this->StreamedconvertTo(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_convertTo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status convertTo(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_convertToRequest* /*request*/, ::octaneapi::ApiImageBuffer_convertToResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedconvertTo(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiImageBuffer_convertToRequest,::octaneapi::ApiImageBuffer_convertToResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_destroy : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_destroy() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiImageBuffer_destroyRequest, ::google::protobuf::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiImageBuffer_destroyRequest, ::google::protobuf::Empty>* streamer) {
                       return this->Streameddestroy(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_destroy() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status destroy(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_destroyRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streameddestroy(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiImageBuffer_destroyRequest,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_bytesPerPixel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_bytesPerPixel() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiImageBuffer_bytesPerPixelRequest, ::octaneapi::ApiImageBuffer_bytesPerPixelResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiImageBuffer_bytesPerPixelRequest, ::octaneapi::ApiImageBuffer_bytesPerPixelResponse>* streamer) {
                       return this->StreamedbytesPerPixel(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_bytesPerPixel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status bytesPerPixel(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_bytesPerPixelRequest* /*request*/, ::octaneapi::ApiImageBuffer_bytesPerPixelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedbytesPerPixel(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiImageBuffer_bytesPerPixelRequest,::octaneapi::ApiImageBuffer_bytesPerPixelResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_bytesPerChannel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_bytesPerChannel() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiImageBuffer_bytesPerChannelRequest, ::octaneapi::ApiImageBuffer_bytesPerChannelResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiImageBuffer_bytesPerChannelRequest, ::octaneapi::ApiImageBuffer_bytesPerChannelResponse>* streamer) {
                       return this->StreamedbytesPerChannel(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_bytesPerChannel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status bytesPerChannel(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_bytesPerChannelRequest* /*request*/, ::octaneapi::ApiImageBuffer_bytesPerChannelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedbytesPerChannel(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiImageBuffer_bytesPerChannelRequest,::octaneapi::ApiImageBuffer_bytesPerChannelResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_channelCount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_channelCount() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiImageBuffer_channelCountRequest, ::octaneapi::ApiImageBuffer_channelCountResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiImageBuffer_channelCountRequest, ::octaneapi::ApiImageBuffer_channelCountResponse>* streamer) {
                       return this->StreamedchannelCount(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_channelCount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status channelCount(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_channelCountRequest* /*request*/, ::octaneapi::ApiImageBuffer_channelCountResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedchannelCount(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiImageBuffer_channelCountRequest,::octaneapi::ApiImageBuffer_channelCountResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_size : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_size() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiImageBuffer_sizeRequest, ::octaneapi::ApiImageBuffer_sizeResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiImageBuffer_sizeRequest, ::octaneapi::ApiImageBuffer_sizeResponse>* streamer) {
                       return this->Streamedsize(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_size() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status size(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_sizeRequest* /*request*/, ::octaneapi::ApiImageBuffer_sizeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedsize(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiImageBuffer_sizeRequest,::octaneapi::ApiImageBuffer_sizeResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_sizeInBytes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_sizeInBytes() {
      ::grpc::Service::MarkMethodStreamed(10,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiImageBuffer_sizeInBytesRequest, ::octaneapi::ApiImageBuffer_sizeInBytesResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiImageBuffer_sizeInBytesRequest, ::octaneapi::ApiImageBuffer_sizeInBytesResponse>* streamer) {
                       return this->StreamedsizeInBytes(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_sizeInBytes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status sizeInBytes(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_sizeInBytesRequest* /*request*/, ::octaneapi::ApiImageBuffer_sizeInBytesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedsizeInBytes(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiImageBuffer_sizeInBytesRequest,::octaneapi::ApiImageBuffer_sizeInBytesResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_type : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_type() {
      ::grpc::Service::MarkMethodStreamed(11,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiImageBuffer_typeRequest, ::octaneapi::ApiImageBuffer_typeResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiImageBuffer_typeRequest, ::octaneapi::ApiImageBuffer_typeResponse>* streamer) {
                       return this->Streamedtype(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_type() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status type(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_typeRequest* /*request*/, ::octaneapi::ApiImageBuffer_typeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedtype(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiImageBuffer_typeRequest,::octaneapi::ApiImageBuffer_typeResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_sourceInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_sourceInfo() {
      ::grpc::Service::MarkMethodStreamed(12,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiImageBuffer_sourceInfoRequest, ::octaneapi::ApiImageBuffer_sourceInfoResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiImageBuffer_sourceInfoRequest, ::octaneapi::ApiImageBuffer_sourceInfoResponse>* streamer) {
                       return this->StreamedsourceInfo(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_sourceInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status sourceInfo(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_sourceInfoRequest* /*request*/, ::octaneapi::ApiImageBuffer_sourceInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedsourceInfo(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiImageBuffer_sourceInfoRequest,::octaneapi::ApiImageBuffer_sourceInfoResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_canWrapX : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_canWrapX() {
      ::grpc::Service::MarkMethodStreamed(13,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiImageBuffer_canWrapXRequest, ::octaneapi::ApiImageBuffer_canWrapXResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiImageBuffer_canWrapXRequest, ::octaneapi::ApiImageBuffer_canWrapXResponse>* streamer) {
                       return this->StreamedcanWrapX(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_canWrapX() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status canWrapX(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_canWrapXRequest* /*request*/, ::octaneapi::ApiImageBuffer_canWrapXResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedcanWrapX(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiImageBuffer_canWrapXRequest,::octaneapi::ApiImageBuffer_canWrapXResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_canWrapY : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_canWrapY() {
      ::grpc::Service::MarkMethodStreamed(14,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiImageBuffer_canWrapYRequest, ::octaneapi::ApiImageBuffer_canWrapYResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiImageBuffer_canWrapYRequest, ::octaneapi::ApiImageBuffer_canWrapYResponse>* streamer) {
                       return this->StreamedcanWrapY(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_canWrapY() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status canWrapY(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_canWrapYRequest* /*request*/, ::octaneapi::ApiImageBuffer_canWrapYResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedcanWrapY(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiImageBuffer_canWrapYRequest,::octaneapi::ApiImageBuffer_canWrapYResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_needsFlip : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_needsFlip() {
      ::grpc::Service::MarkMethodStreamed(15,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiImageBuffer_needsFlipRequest, ::octaneapi::ApiImageBuffer_needsFlipResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiImageBuffer_needsFlipRequest, ::octaneapi::ApiImageBuffer_needsFlipResponse>* streamer) {
                       return this->StreamedneedsFlip(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_needsFlip() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status needsFlip(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_needsFlipRequest* /*request*/, ::octaneapi::ApiImageBuffer_needsFlipResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedneedsFlip(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiImageBuffer_needsFlipRequest,::octaneapi::ApiImageBuffer_needsFlipResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_hasAlpha : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_hasAlpha() {
      ::grpc::Service::MarkMethodStreamed(16,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiImageBuffer_hasAlphaRequest, ::octaneapi::ApiImageBuffer_hasAlphaResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiImageBuffer_hasAlphaRequest, ::octaneapi::ApiImageBuffer_hasAlphaResponse>* streamer) {
                       return this->StreamedhasAlpha(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_hasAlpha() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status hasAlpha(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_hasAlphaRequest* /*request*/, ::octaneapi::ApiImageBuffer_hasAlphaResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedhasAlpha(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiImageBuffer_hasAlphaRequest,::octaneapi::ApiImageBuffer_hasAlphaResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_hasColor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_hasColor() {
      ::grpc::Service::MarkMethodStreamed(17,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiImageBuffer_hasColorRequest, ::octaneapi::ApiImageBuffer_hasColorResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiImageBuffer_hasColorRequest, ::octaneapi::ApiImageBuffer_hasColorResponse>* streamer) {
                       return this->StreamedhasColor(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_hasColor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status hasColor(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_hasColorRequest* /*request*/, ::octaneapi::ApiImageBuffer_hasColorResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedhasColor(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiImageBuffer_hasColorRequest,::octaneapi::ApiImageBuffer_hasColorResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_isCompressed : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_isCompressed() {
      ::grpc::Service::MarkMethodStreamed(18,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiImageBuffer_isCompressedRequest, ::octaneapi::ApiImageBuffer_isCompressedResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiImageBuffer_isCompressedRequest, ::octaneapi::ApiImageBuffer_isCompressedResponse>* streamer) {
                       return this->StreamedisCompressed(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_isCompressed() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status isCompressed(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_isCompressedRequest* /*request*/, ::octaneapi::ApiImageBuffer_isCompressedResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedisCompressed(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiImageBuffer_isCompressedRequest,::octaneapi::ApiImageBuffer_isCompressedResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_isEmpty : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_isEmpty() {
      ::grpc::Service::MarkMethodStreamed(19,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiImageBuffer_isEmptyRequest, ::octaneapi::ApiImageBuffer_isEmptyResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiImageBuffer_isEmptyRequest, ::octaneapi::ApiImageBuffer_isEmptyResponse>* streamer) {
                       return this->StreamedisEmpty(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_isEmpty() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status isEmpty(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_isEmptyRequest* /*request*/, ::octaneapi::ApiImageBuffer_isEmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedisEmpty(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiImageBuffer_isEmptyRequest,::octaneapi::ApiImageBuffer_isEmptyResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_isHalf : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_isHalf() {
      ::grpc::Service::MarkMethodStreamed(20,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiImageBuffer_isHalfRequest, ::octaneapi::ApiImageBuffer_isHalfResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiImageBuffer_isHalfRequest, ::octaneapi::ApiImageBuffer_isHalfResponse>* streamer) {
                       return this->StreamedisHalf(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_isHalf() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status isHalf(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_isHalfRequest* /*request*/, ::octaneapi::ApiImageBuffer_isHalfResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedisHalf(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiImageBuffer_isHalfRequest,::octaneapi::ApiImageBuffer_isHalfResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_isHdr : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_isHdr() {
      ::grpc::Service::MarkMethodStreamed(21,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiImageBuffer_isHdrRequest, ::octaneapi::ApiImageBuffer_isHdrResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiImageBuffer_isHdrRequest, ::octaneapi::ApiImageBuffer_isHdrResponse>* streamer) {
                       return this->StreamedisHdr(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_isHdr() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status isHdr(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_isHdrRequest* /*request*/, ::octaneapi::ApiImageBuffer_isHdrResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedisHdr(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiImageBuffer_isHdrRequest,::octaneapi::ApiImageBuffer_isHdrResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_isMono : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_isMono() {
      ::grpc::Service::MarkMethodStreamed(22,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiImageBuffer_isMonoRequest, ::octaneapi::ApiImageBuffer_isMonoResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiImageBuffer_isMonoRequest, ::octaneapi::ApiImageBuffer_isMonoResponse>* streamer) {
                       return this->StreamedisMono(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_isMono() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status isMono(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_isMonoRequest* /*request*/, ::octaneapi::ApiImageBuffer_isMonoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedisMono(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiImageBuffer_isMonoRequest,::octaneapi::ApiImageBuffer_isMonoResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_isPixelValid : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_isPixelValid() {
      ::grpc::Service::MarkMethodStreamed(23,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiImageBuffer_isPixelValidRequest, ::octaneapi::ApiImageBuffer_isPixelValidResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiImageBuffer_isPixelValidRequest, ::octaneapi::ApiImageBuffer_isPixelValidResponse>* streamer) {
                       return this->StreamedisPixelValid(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_isPixelValid() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status isPixelValid(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_isPixelValidRequest* /*request*/, ::octaneapi::ApiImageBuffer_isPixelValidResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedisPixelValid(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiImageBuffer_isPixelValidRequest,::octaneapi::ApiImageBuffer_isPixelValidResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_compress : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_compress() {
      ::grpc::Service::MarkMethodStreamed(24,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiImageBuffer_compressRequest, ::google::protobuf::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiImageBuffer_compressRequest, ::google::protobuf::Empty>* streamer) {
                       return this->Streamedcompress(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_compress() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status compress(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_compressRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedcompress(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiImageBuffer_compressRequest,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_setPixelLdr : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_setPixelLdr() {
      ::grpc::Service::MarkMethodStreamed(25,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiImageBuffer_setPixelLdrRequest, ::google::protobuf::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiImageBuffer_setPixelLdrRequest, ::google::protobuf::Empty>* streamer) {
                       return this->StreamedsetPixelLdr(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_setPixelLdr() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status setPixelLdr(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_setPixelLdrRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedsetPixelLdr(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiImageBuffer_setPixelLdrRequest,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_setPixelHalf : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_setPixelHalf() {
      ::grpc::Service::MarkMethodStreamed(26,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiImageBuffer_setPixelHalfRequest, ::google::protobuf::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiImageBuffer_setPixelHalfRequest, ::google::protobuf::Empty>* streamer) {
                       return this->StreamedsetPixelHalf(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_setPixelHalf() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status setPixelHalf(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_setPixelHalfRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedsetPixelHalf(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiImageBuffer_setPixelHalfRequest,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_setPixelHdr : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_setPixelHdr() {
      ::grpc::Service::MarkMethodStreamed(27,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiImageBuffer_setPixelHdrRequest, ::google::protobuf::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiImageBuffer_setPixelHdrRequest, ::google::protobuf::Empty>* streamer) {
                       return this->StreamedsetPixelHdr(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_setPixelHdr() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status setPixelHdr(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_setPixelHdrRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedsetPixelHdr(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiImageBuffer_setPixelHdrRequest,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_copyRegion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_copyRegion() {
      ::grpc::Service::MarkMethodStreamed(28,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiImageBuffer_copyRegionRequest, ::octaneapi::ApiImageBuffer_copyRegionResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiImageBuffer_copyRegionRequest, ::octaneapi::ApiImageBuffer_copyRegionResponse>* streamer) {
                       return this->StreamedcopyRegion(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_copyRegion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status copyRegion(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_copyRegionRequest* /*request*/, ::octaneapi::ApiImageBuffer_copyRegionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedcopyRegion(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiImageBuffer_copyRegionRequest,::octaneapi::ApiImageBuffer_copyRegionResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_compositeOnBlack : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_compositeOnBlack() {
      ::grpc::Service::MarkMethodStreamed(29,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiImageBuffer_compositeOnBlackRequest, ::google::protobuf::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiImageBuffer_compositeOnBlackRequest, ::google::protobuf::Empty>* streamer) {
                       return this->StreamedcompositeOnBlack(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_compositeOnBlack() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status compositeOnBlack(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_compositeOnBlackRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedcompositeOnBlack(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiImageBuffer_compositeOnBlackRequest,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_flipVertical : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_flipVertical() {
      ::grpc::Service::MarkMethodStreamed(30,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiImageBuffer_flipVerticalRequest, ::google::protobuf::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiImageBuffer_flipVerticalRequest, ::google::protobuf::Empty>* streamer) {
                       return this->StreamedflipVertical(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_flipVertical() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status flipVertical(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_flipVerticalRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedflipVertical(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiImageBuffer_flipVerticalRequest,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_convert : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_convert() {
      ::grpc::Service::MarkMethodStreamed(31,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiImageBuffer_convertRequest, ::google::protobuf::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiImageBuffer_convertRequest, ::google::protobuf::Empty>* streamer) {
                       return this->Streamedconvert(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_convert() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status convert(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_convertRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedconvert(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiImageBuffer_convertRequest,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_applyGaussianFilter : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_applyGaussianFilter() {
      ::grpc::Service::MarkMethodStreamed(32,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiImageBuffer_applyGaussianFilterRequest, ::google::protobuf::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiImageBuffer_applyGaussianFilterRequest, ::google::protobuf::Empty>* streamer) {
                       return this->StreamedapplyGaussianFilter(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_applyGaussianFilter() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status applyGaussianFilter(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_applyGaussianFilterRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedapplyGaussianFilter(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiImageBuffer_applyGaussianFilterRequest,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_applyBoxFilter : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_applyBoxFilter() {
      ::grpc::Service::MarkMethodStreamed(33,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiImageBuffer_applyBoxFilterRequest, ::google::protobuf::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiImageBuffer_applyBoxFilterRequest, ::google::protobuf::Empty>* streamer) {
                       return this->StreamedapplyBoxFilter(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_applyBoxFilter() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status applyBoxFilter(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_applyBoxFilterRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedapplyBoxFilter(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiImageBuffer_applyBoxFilterRequest,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_applyLevels : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_applyLevels() {
      ::grpc::Service::MarkMethodStreamed(34,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiImageBuffer_applyLevelsRequest, ::google::protobuf::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiImageBuffer_applyLevelsRequest, ::google::protobuf::Empty>* streamer) {
                       return this->StreamedapplyLevels(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_applyLevels() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status applyLevels(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_applyLevelsRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedapplyLevels(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiImageBuffer_applyLevelsRequest,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_compareValues : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_compareValues() {
      ::grpc::Service::MarkMethodStreamed(35,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiImageBuffer_compareValuesRequest, ::google::protobuf::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiImageBuffer_compareValuesRequest, ::google::protobuf::Empty>* streamer) {
                       return this->StreamedcompareValues(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_compareValues() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status compareValues(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_compareValuesRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedcompareValues(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiImageBuffer_compareValuesRequest,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_calculateMeanSquareError : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_calculateMeanSquareError() {
      ::grpc::Service::MarkMethodStreamed(36,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiImageBuffer_calculateMeanSquareErrorRequest, ::octaneapi::ApiImageBuffer_calculateMeanSquareErrorResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiImageBuffer_calculateMeanSquareErrorRequest, ::octaneapi::ApiImageBuffer_calculateMeanSquareErrorResponse>* streamer) {
                       return this->StreamedcalculateMeanSquareError(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_calculateMeanSquareError() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status calculateMeanSquareError(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_calculateMeanSquareErrorRequest* /*request*/, ::octaneapi::ApiImageBuffer_calculateMeanSquareErrorResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedcalculateMeanSquareError(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiImageBuffer_calculateMeanSquareErrorRequest,::octaneapi::ApiImageBuffer_calculateMeanSquareErrorResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_save : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_save() {
      ::grpc::Service::MarkMethodStreamed(37,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiImageBuffer_saveRequest, ::octaneapi::ApiImageBuffer_saveResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiImageBuffer_saveRequest, ::octaneapi::ApiImageBuffer_saveResponse>* streamer) {
                       return this->Streamedsave(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_save() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status save(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_saveRequest* /*request*/, ::octaneapi::ApiImageBuffer_saveResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedsave(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiImageBuffer_saveRequest,::octaneapi::ApiImageBuffer_saveResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_saveAsync : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_saveAsync() {
      ::grpc::Service::MarkMethodStreamed(38,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiImageBuffer_saveAsyncRequest, ::octaneapi::ApiImageBuffer_saveAsyncResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiImageBuffer_saveAsyncRequest, ::octaneapi::ApiImageBuffer_saveAsyncResponse>* streamer) {
                       return this->StreamedsaveAsync(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_saveAsync() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status saveAsync(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_saveAsyncRequest* /*request*/, ::octaneapi::ApiImageBuffer_saveAsyncResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedsaveAsync(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiImageBuffer_saveAsyncRequest,::octaneapi::ApiImageBuffer_saveAsyncResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_pixelAddr : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_pixelAddr() {
      ::grpc::Service::MarkMethodStreamed(39,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiImageBuffer_pixelAddrRequest, ::octaneapi::ApiImageBuffer_pixelAddrResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiImageBuffer_pixelAddrRequest, ::octaneapi::ApiImageBuffer_pixelAddrResponse>* streamer) {
                       return this->StreamedpixelAddr(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_pixelAddr() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status pixelAddr(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_pixelAddrRequest* /*request*/, ::octaneapi::ApiImageBuffer_pixelAddrResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedpixelAddr(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiImageBuffer_pixelAddrRequest,::octaneapi::ApiImageBuffer_pixelAddrResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_pixelAddr1 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_pixelAddr1() {
      ::grpc::Service::MarkMethodStreamed(40,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiImageBuffer_pixelAddr1Request, ::octaneapi::ApiImageBuffer_pixelAddr1Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiImageBuffer_pixelAddr1Request, ::octaneapi::ApiImageBuffer_pixelAddr1Response>* streamer) {
                       return this->StreamedpixelAddr1(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_pixelAddr1() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status pixelAddr1(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiImageBuffer_pixelAddr1Request* /*request*/, ::octaneapi::ApiImageBuffer_pixelAddr1Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedpixelAddr1(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiImageBuffer_pixelAddr1Request,::octaneapi::ApiImageBuffer_pixelAddr1Response>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_create<WithStreamedUnaryMethod_create1<WithStreamedUnaryMethod_load<WithStreamedUnaryMethod_load1<WithStreamedUnaryMethod_convertTo<WithStreamedUnaryMethod_destroy<WithStreamedUnaryMethod_bytesPerPixel<WithStreamedUnaryMethod_bytesPerChannel<WithStreamedUnaryMethod_channelCount<WithStreamedUnaryMethod_size<WithStreamedUnaryMethod_sizeInBytes<WithStreamedUnaryMethod_type<WithStreamedUnaryMethod_sourceInfo<WithStreamedUnaryMethod_canWrapX<WithStreamedUnaryMethod_canWrapY<WithStreamedUnaryMethod_needsFlip<WithStreamedUnaryMethod_hasAlpha<WithStreamedUnaryMethod_hasColor<WithStreamedUnaryMethod_isCompressed<WithStreamedUnaryMethod_isEmpty<WithStreamedUnaryMethod_isHalf<WithStreamedUnaryMethod_isHdr<WithStreamedUnaryMethod_isMono<WithStreamedUnaryMethod_isPixelValid<WithStreamedUnaryMethod_compress<WithStreamedUnaryMethod_setPixelLdr<WithStreamedUnaryMethod_setPixelHalf<WithStreamedUnaryMethod_setPixelHdr<WithStreamedUnaryMethod_copyRegion<WithStreamedUnaryMethod_compositeOnBlack<WithStreamedUnaryMethod_flipVertical<WithStreamedUnaryMethod_convert<WithStreamedUnaryMethod_applyGaussianFilter<WithStreamedUnaryMethod_applyBoxFilter<WithStreamedUnaryMethod_applyLevels<WithStreamedUnaryMethod_compareValues<WithStreamedUnaryMethod_calculateMeanSquareError<WithStreamedUnaryMethod_save<WithStreamedUnaryMethod_saveAsync<WithStreamedUnaryMethod_pixelAddr<WithStreamedUnaryMethod_pixelAddr1<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_create<WithStreamedUnaryMethod_create1<WithStreamedUnaryMethod_load<WithStreamedUnaryMethod_load1<WithStreamedUnaryMethod_convertTo<WithStreamedUnaryMethod_destroy<WithStreamedUnaryMethod_bytesPerPixel<WithStreamedUnaryMethod_bytesPerChannel<WithStreamedUnaryMethod_channelCount<WithStreamedUnaryMethod_size<WithStreamedUnaryMethod_sizeInBytes<WithStreamedUnaryMethod_type<WithStreamedUnaryMethod_sourceInfo<WithStreamedUnaryMethod_canWrapX<WithStreamedUnaryMethod_canWrapY<WithStreamedUnaryMethod_needsFlip<WithStreamedUnaryMethod_hasAlpha<WithStreamedUnaryMethod_hasColor<WithStreamedUnaryMethod_isCompressed<WithStreamedUnaryMethod_isEmpty<WithStreamedUnaryMethod_isHalf<WithStreamedUnaryMethod_isHdr<WithStreamedUnaryMethod_isMono<WithStreamedUnaryMethod_isPixelValid<WithStreamedUnaryMethod_compress<WithStreamedUnaryMethod_setPixelLdr<WithStreamedUnaryMethod_setPixelHalf<WithStreamedUnaryMethod_setPixelHdr<WithStreamedUnaryMethod_copyRegion<WithStreamedUnaryMethod_compositeOnBlack<WithStreamedUnaryMethod_flipVertical<WithStreamedUnaryMethod_convert<WithStreamedUnaryMethod_applyGaussianFilter<WithStreamedUnaryMethod_applyBoxFilter<WithStreamedUnaryMethod_applyLevels<WithStreamedUnaryMethod_compareValues<WithStreamedUnaryMethod_calculateMeanSquareError<WithStreamedUnaryMethod_save<WithStreamedUnaryMethod_saveAsync<WithStreamedUnaryMethod_pixelAddr<WithStreamedUnaryMethod_pixelAddr1<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > StreamedService;
};

}  // namespace octaneapi


#include <grpcpp/ports_undef.inc>
#endif  // GRPC_apiimagebuffer_2eproto__INCLUDED
