// Copyright (C) 2025 OTOY NZ Ltd.

// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: apianimationtimetransform.proto
// Original file comments:
// ////////////////////////////////////////////////////////////////////////////
// WARNING: This code is machine generated. Manual changes will be overridden.
//
#ifndef GRPC_apianimationtimetransform_2eproto__INCLUDED
#define GRPC_apianimationtimetransform_2eproto__INCLUDED

#include "apianimationtimetransform.pb.h"

#include <functional>
#include <grpcpp/generic/async_generic_service.h>
#include <grpcpp/support/async_stream.h>
#include <grpcpp/support/async_unary_call.h>
#include <grpcpp/support/client_callback.h>
#include <grpcpp/client_context.h>
#include <grpcpp/completion_queue.h>
#include <grpcpp/support/message_allocator.h>
#include <grpcpp/support/method_handler.h>
#include <grpcpp/impl/proto_utils.h>
#include <grpcpp/impl/rpc_method.h>
#include <grpcpp/support/server_callback.h>
#include <grpcpp/impl/server_callback_handlers.h>
#include <grpcpp/server_context.h>
#include <grpcpp/impl/service_type.h>
#include <grpcpp/support/status.h>
#include <grpcpp/support/stub_options.h>
#include <grpcpp/support/sync_stream.h>
#include <grpcpp/ports_def.inc>

namespace octaneapi {

// GRPC interface definition for class 'ApiAnimationTimeTransform' from 'apianimationtimetransform.h'
class ApiAnimationTimeTransformService final {
 public:
  static constexpr char const* service_full_name() {
    return "octaneapi.ApiAnimationTimeTransformService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // / Returns the type of this time transform
    virtual ::grpc::Status type(::grpc::ClientContext* context, const ::octaneapi::ApiAnimationTimeTransform_typeRequest& request, ::octaneapi::ApiAnimationTimeTransform_typeResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiAnimationTimeTransform_typeResponse>> Asynctype(::grpc::ClientContext* context, const ::octaneapi::ApiAnimationTimeTransform_typeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiAnimationTimeTransform_typeResponse>>(AsynctypeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiAnimationTimeTransform_typeResponse>> PrepareAsynctype(::grpc::ClientContext* context, const ::octaneapi::ApiAnimationTimeTransform_typeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiAnimationTimeTransform_typeResponse>>(PrepareAsynctypeRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      // / Returns the type of this time transform
      virtual void type(::grpc::ClientContext* context, const ::octaneapi::ApiAnimationTimeTransform_typeRequest* request, ::octaneapi::ApiAnimationTimeTransform_typeResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void type(::grpc::ClientContext* context, const ::octaneapi::ApiAnimationTimeTransform_typeRequest* request, ::octaneapi::ApiAnimationTimeTransform_typeResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiAnimationTimeTransform_typeResponse>* AsynctypeRaw(::grpc::ClientContext* context, const ::octaneapi::ApiAnimationTimeTransform_typeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiAnimationTimeTransform_typeResponse>* PrepareAsynctypeRaw(::grpc::ClientContext* context, const ::octaneapi::ApiAnimationTimeTransform_typeRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status type(::grpc::ClientContext* context, const ::octaneapi::ApiAnimationTimeTransform_typeRequest& request, ::octaneapi::ApiAnimationTimeTransform_typeResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiAnimationTimeTransform_typeResponse>> Asynctype(::grpc::ClientContext* context, const ::octaneapi::ApiAnimationTimeTransform_typeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiAnimationTimeTransform_typeResponse>>(AsynctypeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiAnimationTimeTransform_typeResponse>> PrepareAsynctype(::grpc::ClientContext* context, const ::octaneapi::ApiAnimationTimeTransform_typeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiAnimationTimeTransform_typeResponse>>(PrepareAsynctypeRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void type(::grpc::ClientContext* context, const ::octaneapi::ApiAnimationTimeTransform_typeRequest* request, ::octaneapi::ApiAnimationTimeTransform_typeResponse* response, std::function<void(::grpc::Status)>) override;
      void type(::grpc::ClientContext* context, const ::octaneapi::ApiAnimationTimeTransform_typeRequest* request, ::octaneapi::ApiAnimationTimeTransform_typeResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiAnimationTimeTransform_typeResponse>* AsynctypeRaw(::grpc::ClientContext* context, const ::octaneapi::ApiAnimationTimeTransform_typeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiAnimationTimeTransform_typeResponse>* PrepareAsynctypeRaw(::grpc::ClientContext* context, const ::octaneapi::ApiAnimationTimeTransform_typeRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_type_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // / Returns the type of this time transform
    virtual ::grpc::Status type(::grpc::ServerContext* context, const ::octaneapi::ApiAnimationTimeTransform_typeRequest* request, ::octaneapi::ApiAnimationTimeTransform_typeResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_type : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_type() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_type() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status type(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiAnimationTimeTransform_typeRequest* /*request*/, ::octaneapi::ApiAnimationTimeTransform_typeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requesttype(::grpc::ServerContext* context, ::octaneapi::ApiAnimationTimeTransform_typeRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiAnimationTimeTransform_typeResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_type<Service > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_type : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_type() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiAnimationTimeTransform_typeRequest, ::octaneapi::ApiAnimationTimeTransform_typeResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiAnimationTimeTransform_typeRequest* request, ::octaneapi::ApiAnimationTimeTransform_typeResponse* response) { return this->type(context, request, response); }));}
    void SetMessageAllocatorFor_type(
        ::grpc::MessageAllocator< ::octaneapi::ApiAnimationTimeTransform_typeRequest, ::octaneapi::ApiAnimationTimeTransform_typeResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiAnimationTimeTransform_typeRequest, ::octaneapi::ApiAnimationTimeTransform_typeResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_type() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status type(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiAnimationTimeTransform_typeRequest* /*request*/, ::octaneapi::ApiAnimationTimeTransform_typeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* type(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiAnimationTimeTransform_typeRequest* /*request*/, ::octaneapi::ApiAnimationTimeTransform_typeResponse* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_type<Service > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_type : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_type() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_type() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status type(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiAnimationTimeTransform_typeRequest* /*request*/, ::octaneapi::ApiAnimationTimeTransform_typeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_type : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_type() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_type() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status type(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiAnimationTimeTransform_typeRequest* /*request*/, ::octaneapi::ApiAnimationTimeTransform_typeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requesttype(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_type : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_type() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->type(context, request, response); }));
    }
    ~WithRawCallbackMethod_type() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status type(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiAnimationTimeTransform_typeRequest* /*request*/, ::octaneapi::ApiAnimationTimeTransform_typeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* type(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_type : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_type() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiAnimationTimeTransform_typeRequest, ::octaneapi::ApiAnimationTimeTransform_typeResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiAnimationTimeTransform_typeRequest, ::octaneapi::ApiAnimationTimeTransform_typeResponse>* streamer) {
                       return this->Streamedtype(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_type() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status type(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiAnimationTimeTransform_typeRequest* /*request*/, ::octaneapi::ApiAnimationTimeTransform_typeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedtype(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiAnimationTimeTransform_typeRequest,::octaneapi::ApiAnimationTimeTransform_typeResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_type<Service > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_type<Service > StreamedService;
};

// GRPC interface definition for class 'ApiLinearTimeTransform' from 'apianimationtimetransform.h'
class ApiLinearTimeTransformService final {
 public:
  static constexpr char const* service_full_name() {
    return "octaneapi.ApiLinearTimeTransformService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // / The delay of the animation start time in seconds
    virtual ::grpc::Status delay(::grpc::ClientContext* context, const ::octaneapi::ApiLinearTimeTransform_delayRequest& request, ::octaneapi::ApiLinearTimeTransform_delayResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiLinearTimeTransform_delayResponse>> Asyncdelay(::grpc::ClientContext* context, const ::octaneapi::ApiLinearTimeTransform_delayRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiLinearTimeTransform_delayResponse>>(AsyncdelayRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiLinearTimeTransform_delayResponse>> PrepareAsyncdelay(::grpc::ClientContext* context, const ::octaneapi::ApiLinearTimeTransform_delayRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiLinearTimeTransform_delayResponse>>(PrepareAsyncdelayRaw(context, request, cq));
    }
    // / The scale of the animation playback speed (default is 1)
    virtual ::grpc::Status speedUp(::grpc::ClientContext* context, const ::octaneapi::ApiLinearTimeTransform_speedUpRequest& request, ::octaneapi::ApiLinearTimeTransform_speedUpResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiLinearTimeTransform_speedUpResponse>> AsyncspeedUp(::grpc::ClientContext* context, const ::octaneapi::ApiLinearTimeTransform_speedUpRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiLinearTimeTransform_speedUpResponse>>(AsyncspeedUpRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiLinearTimeTransform_speedUpResponse>> PrepareAsyncspeedUp(::grpc::ClientContext* context, const ::octaneapi::ApiLinearTimeTransform_speedUpRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiLinearTimeTransform_speedUpResponse>>(PrepareAsyncspeedUpRaw(context, request, cq));
    }
    // / Returns TRUE when custom interval is enabled
    virtual ::grpc::Status customIntervalEnabled(::grpc::ClientContext* context, const ::octaneapi::ApiLinearTimeTransform_customIntervalEnabledRequest& request, ::octaneapi::ApiLinearTimeTransform_customIntervalEnabledResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiLinearTimeTransform_customIntervalEnabledResponse>> AsynccustomIntervalEnabled(::grpc::ClientContext* context, const ::octaneapi::ApiLinearTimeTransform_customIntervalEnabledRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiLinearTimeTransform_customIntervalEnabledResponse>>(AsynccustomIntervalEnabledRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiLinearTimeTransform_customIntervalEnabledResponse>> PrepareAsynccustomIntervalEnabled(::grpc::ClientContext* context, const ::octaneapi::ApiLinearTimeTransform_customIntervalEnabledRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiLinearTimeTransform_customIntervalEnabledResponse>>(PrepareAsynccustomIntervalEnabledRaw(context, request, cq));
    }
    // / Returns interval of the animation that should be played
    virtual ::grpc::Status customInterval(::grpc::ClientContext* context, const ::octaneapi::ApiLinearTimeTransform_customIntervalRequest& request, ::octaneapi::ApiLinearTimeTransform_customIntervalResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiLinearTimeTransform_customIntervalResponse>> AsynccustomInterval(::grpc::ClientContext* context, const ::octaneapi::ApiLinearTimeTransform_customIntervalRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiLinearTimeTransform_customIntervalResponse>>(AsynccustomIntervalRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiLinearTimeTransform_customIntervalResponse>> PrepareAsynccustomInterval(::grpc::ClientContext* context, const ::octaneapi::ApiLinearTimeTransform_customIntervalRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiLinearTimeTransform_customIntervalResponse>>(PrepareAsynccustomIntervalRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      // / The delay of the animation start time in seconds
      virtual void delay(::grpc::ClientContext* context, const ::octaneapi::ApiLinearTimeTransform_delayRequest* request, ::octaneapi::ApiLinearTimeTransform_delayResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void delay(::grpc::ClientContext* context, const ::octaneapi::ApiLinearTimeTransform_delayRequest* request, ::octaneapi::ApiLinearTimeTransform_delayResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / The scale of the animation playback speed (default is 1)
      virtual void speedUp(::grpc::ClientContext* context, const ::octaneapi::ApiLinearTimeTransform_speedUpRequest* request, ::octaneapi::ApiLinearTimeTransform_speedUpResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void speedUp(::grpc::ClientContext* context, const ::octaneapi::ApiLinearTimeTransform_speedUpRequest* request, ::octaneapi::ApiLinearTimeTransform_speedUpResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Returns TRUE when custom interval is enabled
      virtual void customIntervalEnabled(::grpc::ClientContext* context, const ::octaneapi::ApiLinearTimeTransform_customIntervalEnabledRequest* request, ::octaneapi::ApiLinearTimeTransform_customIntervalEnabledResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void customIntervalEnabled(::grpc::ClientContext* context, const ::octaneapi::ApiLinearTimeTransform_customIntervalEnabledRequest* request, ::octaneapi::ApiLinearTimeTransform_customIntervalEnabledResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Returns interval of the animation that should be played
      virtual void customInterval(::grpc::ClientContext* context, const ::octaneapi::ApiLinearTimeTransform_customIntervalRequest* request, ::octaneapi::ApiLinearTimeTransform_customIntervalResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void customInterval(::grpc::ClientContext* context, const ::octaneapi::ApiLinearTimeTransform_customIntervalRequest* request, ::octaneapi::ApiLinearTimeTransform_customIntervalResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiLinearTimeTransform_delayResponse>* AsyncdelayRaw(::grpc::ClientContext* context, const ::octaneapi::ApiLinearTimeTransform_delayRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiLinearTimeTransform_delayResponse>* PrepareAsyncdelayRaw(::grpc::ClientContext* context, const ::octaneapi::ApiLinearTimeTransform_delayRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiLinearTimeTransform_speedUpResponse>* AsyncspeedUpRaw(::grpc::ClientContext* context, const ::octaneapi::ApiLinearTimeTransform_speedUpRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiLinearTimeTransform_speedUpResponse>* PrepareAsyncspeedUpRaw(::grpc::ClientContext* context, const ::octaneapi::ApiLinearTimeTransform_speedUpRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiLinearTimeTransform_customIntervalEnabledResponse>* AsynccustomIntervalEnabledRaw(::grpc::ClientContext* context, const ::octaneapi::ApiLinearTimeTransform_customIntervalEnabledRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiLinearTimeTransform_customIntervalEnabledResponse>* PrepareAsynccustomIntervalEnabledRaw(::grpc::ClientContext* context, const ::octaneapi::ApiLinearTimeTransform_customIntervalEnabledRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiLinearTimeTransform_customIntervalResponse>* AsynccustomIntervalRaw(::grpc::ClientContext* context, const ::octaneapi::ApiLinearTimeTransform_customIntervalRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiLinearTimeTransform_customIntervalResponse>* PrepareAsynccustomIntervalRaw(::grpc::ClientContext* context, const ::octaneapi::ApiLinearTimeTransform_customIntervalRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status delay(::grpc::ClientContext* context, const ::octaneapi::ApiLinearTimeTransform_delayRequest& request, ::octaneapi::ApiLinearTimeTransform_delayResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiLinearTimeTransform_delayResponse>> Asyncdelay(::grpc::ClientContext* context, const ::octaneapi::ApiLinearTimeTransform_delayRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiLinearTimeTransform_delayResponse>>(AsyncdelayRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiLinearTimeTransform_delayResponse>> PrepareAsyncdelay(::grpc::ClientContext* context, const ::octaneapi::ApiLinearTimeTransform_delayRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiLinearTimeTransform_delayResponse>>(PrepareAsyncdelayRaw(context, request, cq));
    }
    ::grpc::Status speedUp(::grpc::ClientContext* context, const ::octaneapi::ApiLinearTimeTransform_speedUpRequest& request, ::octaneapi::ApiLinearTimeTransform_speedUpResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiLinearTimeTransform_speedUpResponse>> AsyncspeedUp(::grpc::ClientContext* context, const ::octaneapi::ApiLinearTimeTransform_speedUpRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiLinearTimeTransform_speedUpResponse>>(AsyncspeedUpRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiLinearTimeTransform_speedUpResponse>> PrepareAsyncspeedUp(::grpc::ClientContext* context, const ::octaneapi::ApiLinearTimeTransform_speedUpRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiLinearTimeTransform_speedUpResponse>>(PrepareAsyncspeedUpRaw(context, request, cq));
    }
    ::grpc::Status customIntervalEnabled(::grpc::ClientContext* context, const ::octaneapi::ApiLinearTimeTransform_customIntervalEnabledRequest& request, ::octaneapi::ApiLinearTimeTransform_customIntervalEnabledResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiLinearTimeTransform_customIntervalEnabledResponse>> AsynccustomIntervalEnabled(::grpc::ClientContext* context, const ::octaneapi::ApiLinearTimeTransform_customIntervalEnabledRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiLinearTimeTransform_customIntervalEnabledResponse>>(AsynccustomIntervalEnabledRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiLinearTimeTransform_customIntervalEnabledResponse>> PrepareAsynccustomIntervalEnabled(::grpc::ClientContext* context, const ::octaneapi::ApiLinearTimeTransform_customIntervalEnabledRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiLinearTimeTransform_customIntervalEnabledResponse>>(PrepareAsynccustomIntervalEnabledRaw(context, request, cq));
    }
    ::grpc::Status customInterval(::grpc::ClientContext* context, const ::octaneapi::ApiLinearTimeTransform_customIntervalRequest& request, ::octaneapi::ApiLinearTimeTransform_customIntervalResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiLinearTimeTransform_customIntervalResponse>> AsynccustomInterval(::grpc::ClientContext* context, const ::octaneapi::ApiLinearTimeTransform_customIntervalRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiLinearTimeTransform_customIntervalResponse>>(AsynccustomIntervalRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiLinearTimeTransform_customIntervalResponse>> PrepareAsynccustomInterval(::grpc::ClientContext* context, const ::octaneapi::ApiLinearTimeTransform_customIntervalRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiLinearTimeTransform_customIntervalResponse>>(PrepareAsynccustomIntervalRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void delay(::grpc::ClientContext* context, const ::octaneapi::ApiLinearTimeTransform_delayRequest* request, ::octaneapi::ApiLinearTimeTransform_delayResponse* response, std::function<void(::grpc::Status)>) override;
      void delay(::grpc::ClientContext* context, const ::octaneapi::ApiLinearTimeTransform_delayRequest* request, ::octaneapi::ApiLinearTimeTransform_delayResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void speedUp(::grpc::ClientContext* context, const ::octaneapi::ApiLinearTimeTransform_speedUpRequest* request, ::octaneapi::ApiLinearTimeTransform_speedUpResponse* response, std::function<void(::grpc::Status)>) override;
      void speedUp(::grpc::ClientContext* context, const ::octaneapi::ApiLinearTimeTransform_speedUpRequest* request, ::octaneapi::ApiLinearTimeTransform_speedUpResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void customIntervalEnabled(::grpc::ClientContext* context, const ::octaneapi::ApiLinearTimeTransform_customIntervalEnabledRequest* request, ::octaneapi::ApiLinearTimeTransform_customIntervalEnabledResponse* response, std::function<void(::grpc::Status)>) override;
      void customIntervalEnabled(::grpc::ClientContext* context, const ::octaneapi::ApiLinearTimeTransform_customIntervalEnabledRequest* request, ::octaneapi::ApiLinearTimeTransform_customIntervalEnabledResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void customInterval(::grpc::ClientContext* context, const ::octaneapi::ApiLinearTimeTransform_customIntervalRequest* request, ::octaneapi::ApiLinearTimeTransform_customIntervalResponse* response, std::function<void(::grpc::Status)>) override;
      void customInterval(::grpc::ClientContext* context, const ::octaneapi::ApiLinearTimeTransform_customIntervalRequest* request, ::octaneapi::ApiLinearTimeTransform_customIntervalResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiLinearTimeTransform_delayResponse>* AsyncdelayRaw(::grpc::ClientContext* context, const ::octaneapi::ApiLinearTimeTransform_delayRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiLinearTimeTransform_delayResponse>* PrepareAsyncdelayRaw(::grpc::ClientContext* context, const ::octaneapi::ApiLinearTimeTransform_delayRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiLinearTimeTransform_speedUpResponse>* AsyncspeedUpRaw(::grpc::ClientContext* context, const ::octaneapi::ApiLinearTimeTransform_speedUpRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiLinearTimeTransform_speedUpResponse>* PrepareAsyncspeedUpRaw(::grpc::ClientContext* context, const ::octaneapi::ApiLinearTimeTransform_speedUpRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiLinearTimeTransform_customIntervalEnabledResponse>* AsynccustomIntervalEnabledRaw(::grpc::ClientContext* context, const ::octaneapi::ApiLinearTimeTransform_customIntervalEnabledRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiLinearTimeTransform_customIntervalEnabledResponse>* PrepareAsynccustomIntervalEnabledRaw(::grpc::ClientContext* context, const ::octaneapi::ApiLinearTimeTransform_customIntervalEnabledRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiLinearTimeTransform_customIntervalResponse>* AsynccustomIntervalRaw(::grpc::ClientContext* context, const ::octaneapi::ApiLinearTimeTransform_customIntervalRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiLinearTimeTransform_customIntervalResponse>* PrepareAsynccustomIntervalRaw(::grpc::ClientContext* context, const ::octaneapi::ApiLinearTimeTransform_customIntervalRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_delay_;
    const ::grpc::internal::RpcMethod rpcmethod_speedUp_;
    const ::grpc::internal::RpcMethod rpcmethod_customIntervalEnabled_;
    const ::grpc::internal::RpcMethod rpcmethod_customInterval_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // / The delay of the animation start time in seconds
    virtual ::grpc::Status delay(::grpc::ServerContext* context, const ::octaneapi::ApiLinearTimeTransform_delayRequest* request, ::octaneapi::ApiLinearTimeTransform_delayResponse* response);
    // / The scale of the animation playback speed (default is 1)
    virtual ::grpc::Status speedUp(::grpc::ServerContext* context, const ::octaneapi::ApiLinearTimeTransform_speedUpRequest* request, ::octaneapi::ApiLinearTimeTransform_speedUpResponse* response);
    // / Returns TRUE when custom interval is enabled
    virtual ::grpc::Status customIntervalEnabled(::grpc::ServerContext* context, const ::octaneapi::ApiLinearTimeTransform_customIntervalEnabledRequest* request, ::octaneapi::ApiLinearTimeTransform_customIntervalEnabledResponse* response);
    // / Returns interval of the animation that should be played
    virtual ::grpc::Status customInterval(::grpc::ServerContext* context, const ::octaneapi::ApiLinearTimeTransform_customIntervalRequest* request, ::octaneapi::ApiLinearTimeTransform_customIntervalResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_delay : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_delay() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_delay() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status delay(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiLinearTimeTransform_delayRequest* /*request*/, ::octaneapi::ApiLinearTimeTransform_delayResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestdelay(::grpc::ServerContext* context, ::octaneapi::ApiLinearTimeTransform_delayRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiLinearTimeTransform_delayResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_speedUp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_speedUp() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_speedUp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status speedUp(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiLinearTimeTransform_speedUpRequest* /*request*/, ::octaneapi::ApiLinearTimeTransform_speedUpResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestspeedUp(::grpc::ServerContext* context, ::octaneapi::ApiLinearTimeTransform_speedUpRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiLinearTimeTransform_speedUpResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_customIntervalEnabled : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_customIntervalEnabled() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_customIntervalEnabled() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status customIntervalEnabled(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiLinearTimeTransform_customIntervalEnabledRequest* /*request*/, ::octaneapi::ApiLinearTimeTransform_customIntervalEnabledResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestcustomIntervalEnabled(::grpc::ServerContext* context, ::octaneapi::ApiLinearTimeTransform_customIntervalEnabledRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiLinearTimeTransform_customIntervalEnabledResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_customInterval : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_customInterval() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_customInterval() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status customInterval(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiLinearTimeTransform_customIntervalRequest* /*request*/, ::octaneapi::ApiLinearTimeTransform_customIntervalResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestcustomInterval(::grpc::ServerContext* context, ::octaneapi::ApiLinearTimeTransform_customIntervalRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiLinearTimeTransform_customIntervalResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_delay<WithAsyncMethod_speedUp<WithAsyncMethod_customIntervalEnabled<WithAsyncMethod_customInterval<Service > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_delay : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_delay() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiLinearTimeTransform_delayRequest, ::octaneapi::ApiLinearTimeTransform_delayResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiLinearTimeTransform_delayRequest* request, ::octaneapi::ApiLinearTimeTransform_delayResponse* response) { return this->delay(context, request, response); }));}
    void SetMessageAllocatorFor_delay(
        ::grpc::MessageAllocator< ::octaneapi::ApiLinearTimeTransform_delayRequest, ::octaneapi::ApiLinearTimeTransform_delayResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiLinearTimeTransform_delayRequest, ::octaneapi::ApiLinearTimeTransform_delayResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_delay() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status delay(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiLinearTimeTransform_delayRequest* /*request*/, ::octaneapi::ApiLinearTimeTransform_delayResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* delay(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiLinearTimeTransform_delayRequest* /*request*/, ::octaneapi::ApiLinearTimeTransform_delayResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_speedUp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_speedUp() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiLinearTimeTransform_speedUpRequest, ::octaneapi::ApiLinearTimeTransform_speedUpResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiLinearTimeTransform_speedUpRequest* request, ::octaneapi::ApiLinearTimeTransform_speedUpResponse* response) { return this->speedUp(context, request, response); }));}
    void SetMessageAllocatorFor_speedUp(
        ::grpc::MessageAllocator< ::octaneapi::ApiLinearTimeTransform_speedUpRequest, ::octaneapi::ApiLinearTimeTransform_speedUpResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiLinearTimeTransform_speedUpRequest, ::octaneapi::ApiLinearTimeTransform_speedUpResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_speedUp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status speedUp(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiLinearTimeTransform_speedUpRequest* /*request*/, ::octaneapi::ApiLinearTimeTransform_speedUpResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* speedUp(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiLinearTimeTransform_speedUpRequest* /*request*/, ::octaneapi::ApiLinearTimeTransform_speedUpResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_customIntervalEnabled : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_customIntervalEnabled() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiLinearTimeTransform_customIntervalEnabledRequest, ::octaneapi::ApiLinearTimeTransform_customIntervalEnabledResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiLinearTimeTransform_customIntervalEnabledRequest* request, ::octaneapi::ApiLinearTimeTransform_customIntervalEnabledResponse* response) { return this->customIntervalEnabled(context, request, response); }));}
    void SetMessageAllocatorFor_customIntervalEnabled(
        ::grpc::MessageAllocator< ::octaneapi::ApiLinearTimeTransform_customIntervalEnabledRequest, ::octaneapi::ApiLinearTimeTransform_customIntervalEnabledResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiLinearTimeTransform_customIntervalEnabledRequest, ::octaneapi::ApiLinearTimeTransform_customIntervalEnabledResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_customIntervalEnabled() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status customIntervalEnabled(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiLinearTimeTransform_customIntervalEnabledRequest* /*request*/, ::octaneapi::ApiLinearTimeTransform_customIntervalEnabledResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* customIntervalEnabled(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiLinearTimeTransform_customIntervalEnabledRequest* /*request*/, ::octaneapi::ApiLinearTimeTransform_customIntervalEnabledResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_customInterval : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_customInterval() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiLinearTimeTransform_customIntervalRequest, ::octaneapi::ApiLinearTimeTransform_customIntervalResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiLinearTimeTransform_customIntervalRequest* request, ::octaneapi::ApiLinearTimeTransform_customIntervalResponse* response) { return this->customInterval(context, request, response); }));}
    void SetMessageAllocatorFor_customInterval(
        ::grpc::MessageAllocator< ::octaneapi::ApiLinearTimeTransform_customIntervalRequest, ::octaneapi::ApiLinearTimeTransform_customIntervalResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiLinearTimeTransform_customIntervalRequest, ::octaneapi::ApiLinearTimeTransform_customIntervalResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_customInterval() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status customInterval(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiLinearTimeTransform_customIntervalRequest* /*request*/, ::octaneapi::ApiLinearTimeTransform_customIntervalResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* customInterval(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiLinearTimeTransform_customIntervalRequest* /*request*/, ::octaneapi::ApiLinearTimeTransform_customIntervalResponse* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_delay<WithCallbackMethod_speedUp<WithCallbackMethod_customIntervalEnabled<WithCallbackMethod_customInterval<Service > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_delay : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_delay() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_delay() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status delay(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiLinearTimeTransform_delayRequest* /*request*/, ::octaneapi::ApiLinearTimeTransform_delayResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_speedUp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_speedUp() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_speedUp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status speedUp(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiLinearTimeTransform_speedUpRequest* /*request*/, ::octaneapi::ApiLinearTimeTransform_speedUpResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_customIntervalEnabled : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_customIntervalEnabled() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_customIntervalEnabled() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status customIntervalEnabled(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiLinearTimeTransform_customIntervalEnabledRequest* /*request*/, ::octaneapi::ApiLinearTimeTransform_customIntervalEnabledResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_customInterval : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_customInterval() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_customInterval() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status customInterval(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiLinearTimeTransform_customIntervalRequest* /*request*/, ::octaneapi::ApiLinearTimeTransform_customIntervalResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_delay : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_delay() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_delay() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status delay(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiLinearTimeTransform_delayRequest* /*request*/, ::octaneapi::ApiLinearTimeTransform_delayResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestdelay(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_speedUp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_speedUp() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_speedUp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status speedUp(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiLinearTimeTransform_speedUpRequest* /*request*/, ::octaneapi::ApiLinearTimeTransform_speedUpResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestspeedUp(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_customIntervalEnabled : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_customIntervalEnabled() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_customIntervalEnabled() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status customIntervalEnabled(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiLinearTimeTransform_customIntervalEnabledRequest* /*request*/, ::octaneapi::ApiLinearTimeTransform_customIntervalEnabledResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestcustomIntervalEnabled(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_customInterval : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_customInterval() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_customInterval() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status customInterval(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiLinearTimeTransform_customIntervalRequest* /*request*/, ::octaneapi::ApiLinearTimeTransform_customIntervalResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestcustomInterval(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_delay : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_delay() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->delay(context, request, response); }));
    }
    ~WithRawCallbackMethod_delay() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status delay(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiLinearTimeTransform_delayRequest* /*request*/, ::octaneapi::ApiLinearTimeTransform_delayResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* delay(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_speedUp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_speedUp() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->speedUp(context, request, response); }));
    }
    ~WithRawCallbackMethod_speedUp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status speedUp(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiLinearTimeTransform_speedUpRequest* /*request*/, ::octaneapi::ApiLinearTimeTransform_speedUpResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* speedUp(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_customIntervalEnabled : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_customIntervalEnabled() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->customIntervalEnabled(context, request, response); }));
    }
    ~WithRawCallbackMethod_customIntervalEnabled() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status customIntervalEnabled(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiLinearTimeTransform_customIntervalEnabledRequest* /*request*/, ::octaneapi::ApiLinearTimeTransform_customIntervalEnabledResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* customIntervalEnabled(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_customInterval : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_customInterval() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->customInterval(context, request, response); }));
    }
    ~WithRawCallbackMethod_customInterval() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status customInterval(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiLinearTimeTransform_customIntervalRequest* /*request*/, ::octaneapi::ApiLinearTimeTransform_customIntervalResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* customInterval(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_delay : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_delay() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiLinearTimeTransform_delayRequest, ::octaneapi::ApiLinearTimeTransform_delayResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiLinearTimeTransform_delayRequest, ::octaneapi::ApiLinearTimeTransform_delayResponse>* streamer) {
                       return this->Streameddelay(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_delay() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status delay(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiLinearTimeTransform_delayRequest* /*request*/, ::octaneapi::ApiLinearTimeTransform_delayResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streameddelay(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiLinearTimeTransform_delayRequest,::octaneapi::ApiLinearTimeTransform_delayResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_speedUp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_speedUp() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiLinearTimeTransform_speedUpRequest, ::octaneapi::ApiLinearTimeTransform_speedUpResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiLinearTimeTransform_speedUpRequest, ::octaneapi::ApiLinearTimeTransform_speedUpResponse>* streamer) {
                       return this->StreamedspeedUp(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_speedUp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status speedUp(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiLinearTimeTransform_speedUpRequest* /*request*/, ::octaneapi::ApiLinearTimeTransform_speedUpResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedspeedUp(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiLinearTimeTransform_speedUpRequest,::octaneapi::ApiLinearTimeTransform_speedUpResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_customIntervalEnabled : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_customIntervalEnabled() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiLinearTimeTransform_customIntervalEnabledRequest, ::octaneapi::ApiLinearTimeTransform_customIntervalEnabledResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiLinearTimeTransform_customIntervalEnabledRequest, ::octaneapi::ApiLinearTimeTransform_customIntervalEnabledResponse>* streamer) {
                       return this->StreamedcustomIntervalEnabled(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_customIntervalEnabled() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status customIntervalEnabled(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiLinearTimeTransform_customIntervalEnabledRequest* /*request*/, ::octaneapi::ApiLinearTimeTransform_customIntervalEnabledResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedcustomIntervalEnabled(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiLinearTimeTransform_customIntervalEnabledRequest,::octaneapi::ApiLinearTimeTransform_customIntervalEnabledResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_customInterval : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_customInterval() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiLinearTimeTransform_customIntervalRequest, ::octaneapi::ApiLinearTimeTransform_customIntervalResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiLinearTimeTransform_customIntervalRequest, ::octaneapi::ApiLinearTimeTransform_customIntervalResponse>* streamer) {
                       return this->StreamedcustomInterval(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_customInterval() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status customInterval(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiLinearTimeTransform_customIntervalRequest* /*request*/, ::octaneapi::ApiLinearTimeTransform_customIntervalResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedcustomInterval(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiLinearTimeTransform_customIntervalRequest,::octaneapi::ApiLinearTimeTransform_customIntervalResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_delay<WithStreamedUnaryMethod_speedUp<WithStreamedUnaryMethod_customIntervalEnabled<WithStreamedUnaryMethod_customInterval<Service > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_delay<WithStreamedUnaryMethod_speedUp<WithStreamedUnaryMethod_customIntervalEnabled<WithStreamedUnaryMethod_customInterval<Service > > > > StreamedService;
};

}  // namespace octaneapi


#include <grpcpp/ports_undef.inc>
#endif  // GRPC_apianimationtimetransform_2eproto__INCLUDED
