// Copyright (C) 2026 OTOY NZ Ltd.

// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: octaneinfos.proto
// Original file comments:
// ////////////////////////////////////////////////////////////////////////////
// WARNING: This code is machine generated. Manual changes will be overridden.
//
#ifndef GRPC_octaneinfos_2eproto__INCLUDED
#define GRPC_octaneinfos_2eproto__INCLUDED

#include "octaneinfos.pb.h"

#include <functional>
#include <grpcpp/generic/async_generic_service.h>
#include <grpcpp/support/async_stream.h>
#include <grpcpp/support/async_unary_call.h>
#include <grpcpp/support/client_callback.h>
#include <grpcpp/client_context.h>
#include <grpcpp/completion_queue.h>
#include <grpcpp/support/message_allocator.h>
#include <grpcpp/support/method_handler.h>
#include <grpcpp/impl/proto_utils.h>
#include <grpcpp/impl/rpc_method.h>
#include <grpcpp/support/server_callback.h>
#include <grpcpp/impl/server_callback_handlers.h>
#include <grpcpp/server_context.h>
#include <grpcpp/impl/service_type.h>
#include <grpcpp/support/status.h>
#include <grpcpp/support/stub_options.h>
#include <grpcpp/support/sync_stream.h>
#include <grpcpp/ports_def.inc>

namespace octaneapi {

// GRPC interface definition for class 'ApiAttributeInfo' from 'octaneinfos.h'
class ApiAttributeInfoService final {
 public:
  static constexpr char const* service_full_name() {
    return "octaneapi.ApiAttributeInfoService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // / fast version validity check
    virtual ::grpc::Status isValidFor(::grpc::ClientContext* context, const ::octaneapi::ApiAttributeInfo_isValidForRequest& request, ::octaneapi::ApiAttributeInfo_isValidForResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiAttributeInfo_isValidForResponse>> AsyncisValidFor(::grpc::ClientContext* context, const ::octaneapi::ApiAttributeInfo_isValidForRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiAttributeInfo_isValidForResponse>>(AsyncisValidForRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiAttributeInfo_isValidForResponse>> PrepareAsyncisValidFor(::grpc::ClientContext* context, const ::octaneapi::ApiAttributeInfo_isValidForRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiAttributeInfo_isValidForResponse>>(PrepareAsyncisValidForRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      // / fast version validity check
      virtual void isValidFor(::grpc::ClientContext* context, const ::octaneapi::ApiAttributeInfo_isValidForRequest* request, ::octaneapi::ApiAttributeInfo_isValidForResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void isValidFor(::grpc::ClientContext* context, const ::octaneapi::ApiAttributeInfo_isValidForRequest* request, ::octaneapi::ApiAttributeInfo_isValidForResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiAttributeInfo_isValidForResponse>* AsyncisValidForRaw(::grpc::ClientContext* context, const ::octaneapi::ApiAttributeInfo_isValidForRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiAttributeInfo_isValidForResponse>* PrepareAsyncisValidForRaw(::grpc::ClientContext* context, const ::octaneapi::ApiAttributeInfo_isValidForRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status isValidFor(::grpc::ClientContext* context, const ::octaneapi::ApiAttributeInfo_isValidForRequest& request, ::octaneapi::ApiAttributeInfo_isValidForResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiAttributeInfo_isValidForResponse>> AsyncisValidFor(::grpc::ClientContext* context, const ::octaneapi::ApiAttributeInfo_isValidForRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiAttributeInfo_isValidForResponse>>(AsyncisValidForRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiAttributeInfo_isValidForResponse>> PrepareAsyncisValidFor(::grpc::ClientContext* context, const ::octaneapi::ApiAttributeInfo_isValidForRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiAttributeInfo_isValidForResponse>>(PrepareAsyncisValidForRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void isValidFor(::grpc::ClientContext* context, const ::octaneapi::ApiAttributeInfo_isValidForRequest* request, ::octaneapi::ApiAttributeInfo_isValidForResponse* response, std::function<void(::grpc::Status)>) override;
      void isValidFor(::grpc::ClientContext* context, const ::octaneapi::ApiAttributeInfo_isValidForRequest* request, ::octaneapi::ApiAttributeInfo_isValidForResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiAttributeInfo_isValidForResponse>* AsyncisValidForRaw(::grpc::ClientContext* context, const ::octaneapi::ApiAttributeInfo_isValidForRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiAttributeInfo_isValidForResponse>* PrepareAsyncisValidForRaw(::grpc::ClientContext* context, const ::octaneapi::ApiAttributeInfo_isValidForRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_isValidFor_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // / fast version validity check
    virtual ::grpc::Status isValidFor(::grpc::ServerContext* context, const ::octaneapi::ApiAttributeInfo_isValidForRequest* request, ::octaneapi::ApiAttributeInfo_isValidForResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_isValidFor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_isValidFor() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_isValidFor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isValidFor(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiAttributeInfo_isValidForRequest* /*request*/, ::octaneapi::ApiAttributeInfo_isValidForResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestisValidFor(::grpc::ServerContext* context, ::octaneapi::ApiAttributeInfo_isValidForRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiAttributeInfo_isValidForResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_isValidFor<Service > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_isValidFor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_isValidFor() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiAttributeInfo_isValidForRequest, ::octaneapi::ApiAttributeInfo_isValidForResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiAttributeInfo_isValidForRequest* request, ::octaneapi::ApiAttributeInfo_isValidForResponse* response) { return this->isValidFor(context, request, response); }));}
    void SetMessageAllocatorFor_isValidFor(
        ::grpc::MessageAllocator< ::octaneapi::ApiAttributeInfo_isValidForRequest, ::octaneapi::ApiAttributeInfo_isValidForResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiAttributeInfo_isValidForRequest, ::octaneapi::ApiAttributeInfo_isValidForResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_isValidFor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isValidFor(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiAttributeInfo_isValidForRequest* /*request*/, ::octaneapi::ApiAttributeInfo_isValidForResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* isValidFor(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiAttributeInfo_isValidForRequest* /*request*/, ::octaneapi::ApiAttributeInfo_isValidForResponse* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_isValidFor<Service > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_isValidFor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_isValidFor() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_isValidFor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isValidFor(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiAttributeInfo_isValidForRequest* /*request*/, ::octaneapi::ApiAttributeInfo_isValidForResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_isValidFor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_isValidFor() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_isValidFor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isValidFor(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiAttributeInfo_isValidForRequest* /*request*/, ::octaneapi::ApiAttributeInfo_isValidForResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestisValidFor(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_isValidFor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_isValidFor() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->isValidFor(context, request, response); }));
    }
    ~WithRawCallbackMethod_isValidFor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isValidFor(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiAttributeInfo_isValidForRequest* /*request*/, ::octaneapi::ApiAttributeInfo_isValidForResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* isValidFor(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_isValidFor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_isValidFor() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiAttributeInfo_isValidForRequest, ::octaneapi::ApiAttributeInfo_isValidForResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiAttributeInfo_isValidForRequest, ::octaneapi::ApiAttributeInfo_isValidForResponse>* streamer) {
                       return this->StreamedisValidFor(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_isValidFor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status isValidFor(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiAttributeInfo_isValidForRequest* /*request*/, ::octaneapi::ApiAttributeInfo_isValidForResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedisValidFor(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiAttributeInfo_isValidForRequest,::octaneapi::ApiAttributeInfo_isValidForResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_isValidFor<Service > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_isValidFor<Service > StreamedService;
};

// GRPC interface definition for class 'ApiBitMaskPinInfo' from 'octaneinfos.h'
//
// GRPC interface definition for class 'ApiBitMaskPinInfo_Label' from 'octaneinfos.h'
//
// GRPC interface definition for class 'ApiBoolPinInfo' from 'octaneinfos.h'
//
// GRPC interface definition for class 'ApiCompatibilityModeInfo' from 'octaneinfos.h'
class ApiCompatibilityModeInfoService final {
 public:
  static constexpr char const* service_full_name() {
    return "octaneapi.ApiCompatibilityModeInfoService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // / Gets the first version of Octane that has this behavior, i
    virtual ::grpc::Status startVersion(::grpc::ClientContext* context, const ::octaneapi::ApiCompatibilityModeInfo_startVersionRequest& request, ::octaneapi::ApiCompatibilityModeInfo_startVersionResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiCompatibilityModeInfo_startVersionResponse>> AsyncstartVersion(::grpc::ClientContext* context, const ::octaneapi::ApiCompatibilityModeInfo_startVersionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiCompatibilityModeInfo_startVersionResponse>>(AsyncstartVersionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiCompatibilityModeInfo_startVersionResponse>> PrepareAsyncstartVersion(::grpc::ClientContext* context, const ::octaneapi::ApiCompatibilityModeInfo_startVersionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiCompatibilityModeInfo_startVersionResponse>>(PrepareAsyncstartVersionRaw(context, request, cq));
    }
    // / Gets the name of the compatibility mode
    virtual ::grpc::Status name(::grpc::ClientContext* context, const ::octaneapi::ApiCompatibilityModeInfo_nameRequest& request, ::octaneapi::ApiCompatibilityModeInfo_nameResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiCompatibilityModeInfo_nameResponse>> Asyncname(::grpc::ClientContext* context, const ::octaneapi::ApiCompatibilityModeInfo_nameRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiCompatibilityModeInfo_nameResponse>>(AsyncnameRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiCompatibilityModeInfo_nameResponse>> PrepareAsyncname(::grpc::ClientContext* context, const ::octaneapi::ApiCompatibilityModeInfo_nameRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiCompatibilityModeInfo_nameResponse>>(PrepareAsyncnameRaw(context, request, cq));
    }
    // / Gets a brief description of how this behavior differs from the behavior of the current
    // / version of Octane
    virtual ::grpc::Status description(::grpc::ClientContext* context, const ::octaneapi::ApiCompatibilityModeInfo_descriptionRequest& request, ::octaneapi::ApiCompatibilityModeInfo_descriptionResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiCompatibilityModeInfo_descriptionResponse>> Asyncdescription(::grpc::ClientContext* context, const ::octaneapi::ApiCompatibilityModeInfo_descriptionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiCompatibilityModeInfo_descriptionResponse>>(AsyncdescriptionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiCompatibilityModeInfo_descriptionResponse>> PrepareAsyncdescription(::grpc::ClientContext* context, const ::octaneapi::ApiCompatibilityModeInfo_descriptionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiCompatibilityModeInfo_descriptionResponse>>(PrepareAsyncdescriptionRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      // / Gets the first version of Octane that has this behavior, i
      virtual void startVersion(::grpc::ClientContext* context, const ::octaneapi::ApiCompatibilityModeInfo_startVersionRequest* request, ::octaneapi::ApiCompatibilityModeInfo_startVersionResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void startVersion(::grpc::ClientContext* context, const ::octaneapi::ApiCompatibilityModeInfo_startVersionRequest* request, ::octaneapi::ApiCompatibilityModeInfo_startVersionResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Gets the name of the compatibility mode
      virtual void name(::grpc::ClientContext* context, const ::octaneapi::ApiCompatibilityModeInfo_nameRequest* request, ::octaneapi::ApiCompatibilityModeInfo_nameResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void name(::grpc::ClientContext* context, const ::octaneapi::ApiCompatibilityModeInfo_nameRequest* request, ::octaneapi::ApiCompatibilityModeInfo_nameResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Gets a brief description of how this behavior differs from the behavior of the current
      // / version of Octane
      virtual void description(::grpc::ClientContext* context, const ::octaneapi::ApiCompatibilityModeInfo_descriptionRequest* request, ::octaneapi::ApiCompatibilityModeInfo_descriptionResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void description(::grpc::ClientContext* context, const ::octaneapi::ApiCompatibilityModeInfo_descriptionRequest* request, ::octaneapi::ApiCompatibilityModeInfo_descriptionResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiCompatibilityModeInfo_startVersionResponse>* AsyncstartVersionRaw(::grpc::ClientContext* context, const ::octaneapi::ApiCompatibilityModeInfo_startVersionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiCompatibilityModeInfo_startVersionResponse>* PrepareAsyncstartVersionRaw(::grpc::ClientContext* context, const ::octaneapi::ApiCompatibilityModeInfo_startVersionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiCompatibilityModeInfo_nameResponse>* AsyncnameRaw(::grpc::ClientContext* context, const ::octaneapi::ApiCompatibilityModeInfo_nameRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiCompatibilityModeInfo_nameResponse>* PrepareAsyncnameRaw(::grpc::ClientContext* context, const ::octaneapi::ApiCompatibilityModeInfo_nameRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiCompatibilityModeInfo_descriptionResponse>* AsyncdescriptionRaw(::grpc::ClientContext* context, const ::octaneapi::ApiCompatibilityModeInfo_descriptionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiCompatibilityModeInfo_descriptionResponse>* PrepareAsyncdescriptionRaw(::grpc::ClientContext* context, const ::octaneapi::ApiCompatibilityModeInfo_descriptionRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status startVersion(::grpc::ClientContext* context, const ::octaneapi::ApiCompatibilityModeInfo_startVersionRequest& request, ::octaneapi::ApiCompatibilityModeInfo_startVersionResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiCompatibilityModeInfo_startVersionResponse>> AsyncstartVersion(::grpc::ClientContext* context, const ::octaneapi::ApiCompatibilityModeInfo_startVersionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiCompatibilityModeInfo_startVersionResponse>>(AsyncstartVersionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiCompatibilityModeInfo_startVersionResponse>> PrepareAsyncstartVersion(::grpc::ClientContext* context, const ::octaneapi::ApiCompatibilityModeInfo_startVersionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiCompatibilityModeInfo_startVersionResponse>>(PrepareAsyncstartVersionRaw(context, request, cq));
    }
    ::grpc::Status name(::grpc::ClientContext* context, const ::octaneapi::ApiCompatibilityModeInfo_nameRequest& request, ::octaneapi::ApiCompatibilityModeInfo_nameResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiCompatibilityModeInfo_nameResponse>> Asyncname(::grpc::ClientContext* context, const ::octaneapi::ApiCompatibilityModeInfo_nameRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiCompatibilityModeInfo_nameResponse>>(AsyncnameRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiCompatibilityModeInfo_nameResponse>> PrepareAsyncname(::grpc::ClientContext* context, const ::octaneapi::ApiCompatibilityModeInfo_nameRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiCompatibilityModeInfo_nameResponse>>(PrepareAsyncnameRaw(context, request, cq));
    }
    ::grpc::Status description(::grpc::ClientContext* context, const ::octaneapi::ApiCompatibilityModeInfo_descriptionRequest& request, ::octaneapi::ApiCompatibilityModeInfo_descriptionResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiCompatibilityModeInfo_descriptionResponse>> Asyncdescription(::grpc::ClientContext* context, const ::octaneapi::ApiCompatibilityModeInfo_descriptionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiCompatibilityModeInfo_descriptionResponse>>(AsyncdescriptionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiCompatibilityModeInfo_descriptionResponse>> PrepareAsyncdescription(::grpc::ClientContext* context, const ::octaneapi::ApiCompatibilityModeInfo_descriptionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiCompatibilityModeInfo_descriptionResponse>>(PrepareAsyncdescriptionRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void startVersion(::grpc::ClientContext* context, const ::octaneapi::ApiCompatibilityModeInfo_startVersionRequest* request, ::octaneapi::ApiCompatibilityModeInfo_startVersionResponse* response, std::function<void(::grpc::Status)>) override;
      void startVersion(::grpc::ClientContext* context, const ::octaneapi::ApiCompatibilityModeInfo_startVersionRequest* request, ::octaneapi::ApiCompatibilityModeInfo_startVersionResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void name(::grpc::ClientContext* context, const ::octaneapi::ApiCompatibilityModeInfo_nameRequest* request, ::octaneapi::ApiCompatibilityModeInfo_nameResponse* response, std::function<void(::grpc::Status)>) override;
      void name(::grpc::ClientContext* context, const ::octaneapi::ApiCompatibilityModeInfo_nameRequest* request, ::octaneapi::ApiCompatibilityModeInfo_nameResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void description(::grpc::ClientContext* context, const ::octaneapi::ApiCompatibilityModeInfo_descriptionRequest* request, ::octaneapi::ApiCompatibilityModeInfo_descriptionResponse* response, std::function<void(::grpc::Status)>) override;
      void description(::grpc::ClientContext* context, const ::octaneapi::ApiCompatibilityModeInfo_descriptionRequest* request, ::octaneapi::ApiCompatibilityModeInfo_descriptionResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiCompatibilityModeInfo_startVersionResponse>* AsyncstartVersionRaw(::grpc::ClientContext* context, const ::octaneapi::ApiCompatibilityModeInfo_startVersionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiCompatibilityModeInfo_startVersionResponse>* PrepareAsyncstartVersionRaw(::grpc::ClientContext* context, const ::octaneapi::ApiCompatibilityModeInfo_startVersionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiCompatibilityModeInfo_nameResponse>* AsyncnameRaw(::grpc::ClientContext* context, const ::octaneapi::ApiCompatibilityModeInfo_nameRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiCompatibilityModeInfo_nameResponse>* PrepareAsyncnameRaw(::grpc::ClientContext* context, const ::octaneapi::ApiCompatibilityModeInfo_nameRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiCompatibilityModeInfo_descriptionResponse>* AsyncdescriptionRaw(::grpc::ClientContext* context, const ::octaneapi::ApiCompatibilityModeInfo_descriptionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiCompatibilityModeInfo_descriptionResponse>* PrepareAsyncdescriptionRaw(::grpc::ClientContext* context, const ::octaneapi::ApiCompatibilityModeInfo_descriptionRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_startVersion_;
    const ::grpc::internal::RpcMethod rpcmethod_name_;
    const ::grpc::internal::RpcMethod rpcmethod_description_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // / Gets the first version of Octane that has this behavior, i
    virtual ::grpc::Status startVersion(::grpc::ServerContext* context, const ::octaneapi::ApiCompatibilityModeInfo_startVersionRequest* request, ::octaneapi::ApiCompatibilityModeInfo_startVersionResponse* response);
    // / Gets the name of the compatibility mode
    virtual ::grpc::Status name(::grpc::ServerContext* context, const ::octaneapi::ApiCompatibilityModeInfo_nameRequest* request, ::octaneapi::ApiCompatibilityModeInfo_nameResponse* response);
    // / Gets a brief description of how this behavior differs from the behavior of the current
    // / version of Octane
    virtual ::grpc::Status description(::grpc::ServerContext* context, const ::octaneapi::ApiCompatibilityModeInfo_descriptionRequest* request, ::octaneapi::ApiCompatibilityModeInfo_descriptionResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_startVersion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_startVersion() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_startVersion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status startVersion(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiCompatibilityModeInfo_startVersionRequest* /*request*/, ::octaneapi::ApiCompatibilityModeInfo_startVersionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequeststartVersion(::grpc::ServerContext* context, ::octaneapi::ApiCompatibilityModeInfo_startVersionRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiCompatibilityModeInfo_startVersionResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_name : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_name() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_name() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status name(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiCompatibilityModeInfo_nameRequest* /*request*/, ::octaneapi::ApiCompatibilityModeInfo_nameResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestname(::grpc::ServerContext* context, ::octaneapi::ApiCompatibilityModeInfo_nameRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiCompatibilityModeInfo_nameResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_description : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_description() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_description() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status description(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiCompatibilityModeInfo_descriptionRequest* /*request*/, ::octaneapi::ApiCompatibilityModeInfo_descriptionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestdescription(::grpc::ServerContext* context, ::octaneapi::ApiCompatibilityModeInfo_descriptionRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiCompatibilityModeInfo_descriptionResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_startVersion<WithAsyncMethod_name<WithAsyncMethod_description<Service > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_startVersion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_startVersion() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiCompatibilityModeInfo_startVersionRequest, ::octaneapi::ApiCompatibilityModeInfo_startVersionResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiCompatibilityModeInfo_startVersionRequest* request, ::octaneapi::ApiCompatibilityModeInfo_startVersionResponse* response) { return this->startVersion(context, request, response); }));}
    void SetMessageAllocatorFor_startVersion(
        ::grpc::MessageAllocator< ::octaneapi::ApiCompatibilityModeInfo_startVersionRequest, ::octaneapi::ApiCompatibilityModeInfo_startVersionResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiCompatibilityModeInfo_startVersionRequest, ::octaneapi::ApiCompatibilityModeInfo_startVersionResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_startVersion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status startVersion(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiCompatibilityModeInfo_startVersionRequest* /*request*/, ::octaneapi::ApiCompatibilityModeInfo_startVersionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* startVersion(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiCompatibilityModeInfo_startVersionRequest* /*request*/, ::octaneapi::ApiCompatibilityModeInfo_startVersionResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_name : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_name() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiCompatibilityModeInfo_nameRequest, ::octaneapi::ApiCompatibilityModeInfo_nameResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiCompatibilityModeInfo_nameRequest* request, ::octaneapi::ApiCompatibilityModeInfo_nameResponse* response) { return this->name(context, request, response); }));}
    void SetMessageAllocatorFor_name(
        ::grpc::MessageAllocator< ::octaneapi::ApiCompatibilityModeInfo_nameRequest, ::octaneapi::ApiCompatibilityModeInfo_nameResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiCompatibilityModeInfo_nameRequest, ::octaneapi::ApiCompatibilityModeInfo_nameResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_name() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status name(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiCompatibilityModeInfo_nameRequest* /*request*/, ::octaneapi::ApiCompatibilityModeInfo_nameResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* name(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiCompatibilityModeInfo_nameRequest* /*request*/, ::octaneapi::ApiCompatibilityModeInfo_nameResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_description : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_description() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiCompatibilityModeInfo_descriptionRequest, ::octaneapi::ApiCompatibilityModeInfo_descriptionResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiCompatibilityModeInfo_descriptionRequest* request, ::octaneapi::ApiCompatibilityModeInfo_descriptionResponse* response) { return this->description(context, request, response); }));}
    void SetMessageAllocatorFor_description(
        ::grpc::MessageAllocator< ::octaneapi::ApiCompatibilityModeInfo_descriptionRequest, ::octaneapi::ApiCompatibilityModeInfo_descriptionResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiCompatibilityModeInfo_descriptionRequest, ::octaneapi::ApiCompatibilityModeInfo_descriptionResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_description() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status description(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiCompatibilityModeInfo_descriptionRequest* /*request*/, ::octaneapi::ApiCompatibilityModeInfo_descriptionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* description(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiCompatibilityModeInfo_descriptionRequest* /*request*/, ::octaneapi::ApiCompatibilityModeInfo_descriptionResponse* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_startVersion<WithCallbackMethod_name<WithCallbackMethod_description<Service > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_startVersion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_startVersion() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_startVersion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status startVersion(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiCompatibilityModeInfo_startVersionRequest* /*request*/, ::octaneapi::ApiCompatibilityModeInfo_startVersionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_name : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_name() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_name() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status name(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiCompatibilityModeInfo_nameRequest* /*request*/, ::octaneapi::ApiCompatibilityModeInfo_nameResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_description : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_description() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_description() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status description(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiCompatibilityModeInfo_descriptionRequest* /*request*/, ::octaneapi::ApiCompatibilityModeInfo_descriptionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_startVersion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_startVersion() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_startVersion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status startVersion(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiCompatibilityModeInfo_startVersionRequest* /*request*/, ::octaneapi::ApiCompatibilityModeInfo_startVersionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequeststartVersion(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_name : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_name() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_name() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status name(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiCompatibilityModeInfo_nameRequest* /*request*/, ::octaneapi::ApiCompatibilityModeInfo_nameResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestname(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_description : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_description() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_description() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status description(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiCompatibilityModeInfo_descriptionRequest* /*request*/, ::octaneapi::ApiCompatibilityModeInfo_descriptionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestdescription(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_startVersion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_startVersion() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->startVersion(context, request, response); }));
    }
    ~WithRawCallbackMethod_startVersion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status startVersion(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiCompatibilityModeInfo_startVersionRequest* /*request*/, ::octaneapi::ApiCompatibilityModeInfo_startVersionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* startVersion(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_name : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_name() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->name(context, request, response); }));
    }
    ~WithRawCallbackMethod_name() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status name(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiCompatibilityModeInfo_nameRequest* /*request*/, ::octaneapi::ApiCompatibilityModeInfo_nameResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* name(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_description : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_description() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->description(context, request, response); }));
    }
    ~WithRawCallbackMethod_description() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status description(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiCompatibilityModeInfo_descriptionRequest* /*request*/, ::octaneapi::ApiCompatibilityModeInfo_descriptionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* description(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_startVersion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_startVersion() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiCompatibilityModeInfo_startVersionRequest, ::octaneapi::ApiCompatibilityModeInfo_startVersionResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiCompatibilityModeInfo_startVersionRequest, ::octaneapi::ApiCompatibilityModeInfo_startVersionResponse>* streamer) {
                       return this->StreamedstartVersion(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_startVersion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status startVersion(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiCompatibilityModeInfo_startVersionRequest* /*request*/, ::octaneapi::ApiCompatibilityModeInfo_startVersionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedstartVersion(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiCompatibilityModeInfo_startVersionRequest,::octaneapi::ApiCompatibilityModeInfo_startVersionResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_name : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_name() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiCompatibilityModeInfo_nameRequest, ::octaneapi::ApiCompatibilityModeInfo_nameResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiCompatibilityModeInfo_nameRequest, ::octaneapi::ApiCompatibilityModeInfo_nameResponse>* streamer) {
                       return this->Streamedname(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_name() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status name(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiCompatibilityModeInfo_nameRequest* /*request*/, ::octaneapi::ApiCompatibilityModeInfo_nameResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedname(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiCompatibilityModeInfo_nameRequest,::octaneapi::ApiCompatibilityModeInfo_nameResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_description : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_description() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiCompatibilityModeInfo_descriptionRequest, ::octaneapi::ApiCompatibilityModeInfo_descriptionResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiCompatibilityModeInfo_descriptionRequest, ::octaneapi::ApiCompatibilityModeInfo_descriptionResponse>* streamer) {
                       return this->Streameddescription(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_description() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status description(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiCompatibilityModeInfo_descriptionRequest* /*request*/, ::octaneapi::ApiCompatibilityModeInfo_descriptionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streameddescription(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiCompatibilityModeInfo_descriptionRequest,::octaneapi::ApiCompatibilityModeInfo_descriptionResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_startVersion<WithStreamedUnaryMethod_name<WithStreamedUnaryMethod_description<Service > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_startVersion<WithStreamedUnaryMethod_name<WithStreamedUnaryMethod_description<Service > > > StreamedService;
};

// GRPC interface definition for class 'ApiCompatibilityModeInfoSet' from 'octaneinfos.h'
class ApiCompatibilityModeInfoSetService final {
 public:
  static constexpr char const* service_full_name() {
    return "octaneapi.ApiCompatibilityModeInfoSetService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // / Gets the number of compatibility modes
    virtual ::grpc::Status size(::grpc::ClientContext* context, const ::octaneapi::ApiCompatibilityModeInfoSet_sizeRequest& request, ::octaneapi::ApiCompatibilityModeInfoSet_sizeResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiCompatibilityModeInfoSet_sizeResponse>> Asyncsize(::grpc::ClientContext* context, const ::octaneapi::ApiCompatibilityModeInfoSet_sizeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiCompatibilityModeInfoSet_sizeResponse>>(AsyncsizeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiCompatibilityModeInfoSet_sizeResponse>> PrepareAsyncsize(::grpc::ClientContext* context, const ::octaneapi::ApiCompatibilityModeInfoSet_sizeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiCompatibilityModeInfoSet_sizeResponse>>(PrepareAsyncsizeRaw(context, request, cq));
    }
    // / Gets the info for one of the compatibility modes
    virtual ::grpc::Status info(::grpc::ClientContext* context, const ::octaneapi::ApiCompatibilityModeInfoSet_infoRequest& request, ::octaneapi::ApiCompatibilityModeInfoSet_infoResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiCompatibilityModeInfoSet_infoResponse>> Asyncinfo(::grpc::ClientContext* context, const ::octaneapi::ApiCompatibilityModeInfoSet_infoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiCompatibilityModeInfoSet_infoResponse>>(AsyncinfoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiCompatibilityModeInfoSet_infoResponse>> PrepareAsyncinfo(::grpc::ClientContext* context, const ::octaneapi::ApiCompatibilityModeInfoSet_infoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiCompatibilityModeInfoSet_infoResponse>>(PrepareAsyncinfoRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      // / Gets the number of compatibility modes
      virtual void size(::grpc::ClientContext* context, const ::octaneapi::ApiCompatibilityModeInfoSet_sizeRequest* request, ::octaneapi::ApiCompatibilityModeInfoSet_sizeResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void size(::grpc::ClientContext* context, const ::octaneapi::ApiCompatibilityModeInfoSet_sizeRequest* request, ::octaneapi::ApiCompatibilityModeInfoSet_sizeResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Gets the info for one of the compatibility modes
      virtual void info(::grpc::ClientContext* context, const ::octaneapi::ApiCompatibilityModeInfoSet_infoRequest* request, ::octaneapi::ApiCompatibilityModeInfoSet_infoResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void info(::grpc::ClientContext* context, const ::octaneapi::ApiCompatibilityModeInfoSet_infoRequest* request, ::octaneapi::ApiCompatibilityModeInfoSet_infoResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiCompatibilityModeInfoSet_sizeResponse>* AsyncsizeRaw(::grpc::ClientContext* context, const ::octaneapi::ApiCompatibilityModeInfoSet_sizeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiCompatibilityModeInfoSet_sizeResponse>* PrepareAsyncsizeRaw(::grpc::ClientContext* context, const ::octaneapi::ApiCompatibilityModeInfoSet_sizeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiCompatibilityModeInfoSet_infoResponse>* AsyncinfoRaw(::grpc::ClientContext* context, const ::octaneapi::ApiCompatibilityModeInfoSet_infoRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiCompatibilityModeInfoSet_infoResponse>* PrepareAsyncinfoRaw(::grpc::ClientContext* context, const ::octaneapi::ApiCompatibilityModeInfoSet_infoRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status size(::grpc::ClientContext* context, const ::octaneapi::ApiCompatibilityModeInfoSet_sizeRequest& request, ::octaneapi::ApiCompatibilityModeInfoSet_sizeResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiCompatibilityModeInfoSet_sizeResponse>> Asyncsize(::grpc::ClientContext* context, const ::octaneapi::ApiCompatibilityModeInfoSet_sizeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiCompatibilityModeInfoSet_sizeResponse>>(AsyncsizeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiCompatibilityModeInfoSet_sizeResponse>> PrepareAsyncsize(::grpc::ClientContext* context, const ::octaneapi::ApiCompatibilityModeInfoSet_sizeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiCompatibilityModeInfoSet_sizeResponse>>(PrepareAsyncsizeRaw(context, request, cq));
    }
    ::grpc::Status info(::grpc::ClientContext* context, const ::octaneapi::ApiCompatibilityModeInfoSet_infoRequest& request, ::octaneapi::ApiCompatibilityModeInfoSet_infoResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiCompatibilityModeInfoSet_infoResponse>> Asyncinfo(::grpc::ClientContext* context, const ::octaneapi::ApiCompatibilityModeInfoSet_infoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiCompatibilityModeInfoSet_infoResponse>>(AsyncinfoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiCompatibilityModeInfoSet_infoResponse>> PrepareAsyncinfo(::grpc::ClientContext* context, const ::octaneapi::ApiCompatibilityModeInfoSet_infoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiCompatibilityModeInfoSet_infoResponse>>(PrepareAsyncinfoRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void size(::grpc::ClientContext* context, const ::octaneapi::ApiCompatibilityModeInfoSet_sizeRequest* request, ::octaneapi::ApiCompatibilityModeInfoSet_sizeResponse* response, std::function<void(::grpc::Status)>) override;
      void size(::grpc::ClientContext* context, const ::octaneapi::ApiCompatibilityModeInfoSet_sizeRequest* request, ::octaneapi::ApiCompatibilityModeInfoSet_sizeResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void info(::grpc::ClientContext* context, const ::octaneapi::ApiCompatibilityModeInfoSet_infoRequest* request, ::octaneapi::ApiCompatibilityModeInfoSet_infoResponse* response, std::function<void(::grpc::Status)>) override;
      void info(::grpc::ClientContext* context, const ::octaneapi::ApiCompatibilityModeInfoSet_infoRequest* request, ::octaneapi::ApiCompatibilityModeInfoSet_infoResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiCompatibilityModeInfoSet_sizeResponse>* AsyncsizeRaw(::grpc::ClientContext* context, const ::octaneapi::ApiCompatibilityModeInfoSet_sizeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiCompatibilityModeInfoSet_sizeResponse>* PrepareAsyncsizeRaw(::grpc::ClientContext* context, const ::octaneapi::ApiCompatibilityModeInfoSet_sizeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiCompatibilityModeInfoSet_infoResponse>* AsyncinfoRaw(::grpc::ClientContext* context, const ::octaneapi::ApiCompatibilityModeInfoSet_infoRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiCompatibilityModeInfoSet_infoResponse>* PrepareAsyncinfoRaw(::grpc::ClientContext* context, const ::octaneapi::ApiCompatibilityModeInfoSet_infoRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_size_;
    const ::grpc::internal::RpcMethod rpcmethod_info_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // / Gets the number of compatibility modes
    virtual ::grpc::Status size(::grpc::ServerContext* context, const ::octaneapi::ApiCompatibilityModeInfoSet_sizeRequest* request, ::octaneapi::ApiCompatibilityModeInfoSet_sizeResponse* response);
    // / Gets the info for one of the compatibility modes
    virtual ::grpc::Status info(::grpc::ServerContext* context, const ::octaneapi::ApiCompatibilityModeInfoSet_infoRequest* request, ::octaneapi::ApiCompatibilityModeInfoSet_infoResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_size : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_size() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_size() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status size(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiCompatibilityModeInfoSet_sizeRequest* /*request*/, ::octaneapi::ApiCompatibilityModeInfoSet_sizeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestsize(::grpc::ServerContext* context, ::octaneapi::ApiCompatibilityModeInfoSet_sizeRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiCompatibilityModeInfoSet_sizeResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_info() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status info(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiCompatibilityModeInfoSet_infoRequest* /*request*/, ::octaneapi::ApiCompatibilityModeInfoSet_infoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestinfo(::grpc::ServerContext* context, ::octaneapi::ApiCompatibilityModeInfoSet_infoRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiCompatibilityModeInfoSet_infoResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_size<WithAsyncMethod_info<Service > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_size : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_size() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiCompatibilityModeInfoSet_sizeRequest, ::octaneapi::ApiCompatibilityModeInfoSet_sizeResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiCompatibilityModeInfoSet_sizeRequest* request, ::octaneapi::ApiCompatibilityModeInfoSet_sizeResponse* response) { return this->size(context, request, response); }));}
    void SetMessageAllocatorFor_size(
        ::grpc::MessageAllocator< ::octaneapi::ApiCompatibilityModeInfoSet_sizeRequest, ::octaneapi::ApiCompatibilityModeInfoSet_sizeResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiCompatibilityModeInfoSet_sizeRequest, ::octaneapi::ApiCompatibilityModeInfoSet_sizeResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_size() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status size(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiCompatibilityModeInfoSet_sizeRequest* /*request*/, ::octaneapi::ApiCompatibilityModeInfoSet_sizeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* size(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiCompatibilityModeInfoSet_sizeRequest* /*request*/, ::octaneapi::ApiCompatibilityModeInfoSet_sizeResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_info() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiCompatibilityModeInfoSet_infoRequest, ::octaneapi::ApiCompatibilityModeInfoSet_infoResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiCompatibilityModeInfoSet_infoRequest* request, ::octaneapi::ApiCompatibilityModeInfoSet_infoResponse* response) { return this->info(context, request, response); }));}
    void SetMessageAllocatorFor_info(
        ::grpc::MessageAllocator< ::octaneapi::ApiCompatibilityModeInfoSet_infoRequest, ::octaneapi::ApiCompatibilityModeInfoSet_infoResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiCompatibilityModeInfoSet_infoRequest, ::octaneapi::ApiCompatibilityModeInfoSet_infoResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status info(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiCompatibilityModeInfoSet_infoRequest* /*request*/, ::octaneapi::ApiCompatibilityModeInfoSet_infoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* info(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiCompatibilityModeInfoSet_infoRequest* /*request*/, ::octaneapi::ApiCompatibilityModeInfoSet_infoResponse* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_size<WithCallbackMethod_info<Service > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_size : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_size() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_size() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status size(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiCompatibilityModeInfoSet_sizeRequest* /*request*/, ::octaneapi::ApiCompatibilityModeInfoSet_sizeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_info() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status info(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiCompatibilityModeInfoSet_infoRequest* /*request*/, ::octaneapi::ApiCompatibilityModeInfoSet_infoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_size : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_size() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_size() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status size(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiCompatibilityModeInfoSet_sizeRequest* /*request*/, ::octaneapi::ApiCompatibilityModeInfoSet_sizeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestsize(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_info() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status info(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiCompatibilityModeInfoSet_infoRequest* /*request*/, ::octaneapi::ApiCompatibilityModeInfoSet_infoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestinfo(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_size : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_size() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->size(context, request, response); }));
    }
    ~WithRawCallbackMethod_size() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status size(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiCompatibilityModeInfoSet_sizeRequest* /*request*/, ::octaneapi::ApiCompatibilityModeInfoSet_sizeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* size(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_info() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->info(context, request, response); }));
    }
    ~WithRawCallbackMethod_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status info(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiCompatibilityModeInfoSet_infoRequest* /*request*/, ::octaneapi::ApiCompatibilityModeInfoSet_infoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* info(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_size : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_size() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiCompatibilityModeInfoSet_sizeRequest, ::octaneapi::ApiCompatibilityModeInfoSet_sizeResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiCompatibilityModeInfoSet_sizeRequest, ::octaneapi::ApiCompatibilityModeInfoSet_sizeResponse>* streamer) {
                       return this->Streamedsize(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_size() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status size(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiCompatibilityModeInfoSet_sizeRequest* /*request*/, ::octaneapi::ApiCompatibilityModeInfoSet_sizeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedsize(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiCompatibilityModeInfoSet_sizeRequest,::octaneapi::ApiCompatibilityModeInfoSet_sizeResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_info() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiCompatibilityModeInfoSet_infoRequest, ::octaneapi::ApiCompatibilityModeInfoSet_infoResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiCompatibilityModeInfoSet_infoRequest, ::octaneapi::ApiCompatibilityModeInfoSet_infoResponse>* streamer) {
                       return this->Streamedinfo(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status info(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiCompatibilityModeInfoSet_infoRequest* /*request*/, ::octaneapi::ApiCompatibilityModeInfoSet_infoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedinfo(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiCompatibilityModeInfoSet_infoRequest,::octaneapi::ApiCompatibilityModeInfoSet_infoResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_size<WithStreamedUnaryMethod_info<Service > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_size<WithStreamedUnaryMethod_info<Service > > StreamedService;
};

// GRPC interface definition for class 'ApiEnumPinInfo' from 'octaneinfos.h'
//
// GRPC interface definition for class 'ApiEnumPinInfo_Value' from 'octaneinfos.h'
//
// GRPC interface definition for class 'ApiFloatPinInfo' from 'octaneinfos.h'
//
// GRPC interface definition for class 'ApiFloatPinInfo_DimInfo' from 'octaneinfos.h'
//
// GRPC interface definition for class 'ApiIntPinInfo' from 'octaneinfos.h'
//
// GRPC interface definition for class 'ApiIntPinInfo_DimInfo' from 'octaneinfos.h'
//
// GRPC interface definition for class 'ApiNodeGraphInfo' from 'octaneinfos.h'
//
// GRPC interface definition for class 'ApiNodeInfo' from 'octaneinfos.h'
//
// GRPC interface definition for class 'ApiNodePinInfo' from 'octaneinfos.h'
class ApiNodePinInfoService final {
 public:
  static constexpr char const* service_full_name() {
    return "octaneapi.ApiNodePinInfoService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // / fast version validity check
    virtual ::grpc::Status isValidFor1(::grpc::ClientContext* context, const ::octaneapi::ApiNodePinInfo_isValidForRequest& request, ::octaneapi::ApiNodePinInfo_isValidForResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiNodePinInfo_isValidForResponse>> AsyncisValidFor1(::grpc::ClientContext* context, const ::octaneapi::ApiNodePinInfo_isValidForRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiNodePinInfo_isValidForResponse>>(AsyncisValidFor1Raw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiNodePinInfo_isValidForResponse>> PrepareAsyncisValidFor1(::grpc::ClientContext* context, const ::octaneapi::ApiNodePinInfo_isValidForRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiNodePinInfo_isValidForResponse>>(PrepareAsyncisValidFor1Raw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      // / fast version validity check
      virtual void isValidFor1(::grpc::ClientContext* context, const ::octaneapi::ApiNodePinInfo_isValidForRequest* request, ::octaneapi::ApiNodePinInfo_isValidForResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void isValidFor1(::grpc::ClientContext* context, const ::octaneapi::ApiNodePinInfo_isValidForRequest* request, ::octaneapi::ApiNodePinInfo_isValidForResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiNodePinInfo_isValidForResponse>* AsyncisValidFor1Raw(::grpc::ClientContext* context, const ::octaneapi::ApiNodePinInfo_isValidForRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiNodePinInfo_isValidForResponse>* PrepareAsyncisValidFor1Raw(::grpc::ClientContext* context, const ::octaneapi::ApiNodePinInfo_isValidForRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status isValidFor1(::grpc::ClientContext* context, const ::octaneapi::ApiNodePinInfo_isValidForRequest& request, ::octaneapi::ApiNodePinInfo_isValidForResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiNodePinInfo_isValidForResponse>> AsyncisValidFor1(::grpc::ClientContext* context, const ::octaneapi::ApiNodePinInfo_isValidForRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiNodePinInfo_isValidForResponse>>(AsyncisValidFor1Raw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiNodePinInfo_isValidForResponse>> PrepareAsyncisValidFor1(::grpc::ClientContext* context, const ::octaneapi::ApiNodePinInfo_isValidForRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiNodePinInfo_isValidForResponse>>(PrepareAsyncisValidFor1Raw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void isValidFor1(::grpc::ClientContext* context, const ::octaneapi::ApiNodePinInfo_isValidForRequest* request, ::octaneapi::ApiNodePinInfo_isValidForResponse* response, std::function<void(::grpc::Status)>) override;
      void isValidFor1(::grpc::ClientContext* context, const ::octaneapi::ApiNodePinInfo_isValidForRequest* request, ::octaneapi::ApiNodePinInfo_isValidForResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiNodePinInfo_isValidForResponse>* AsyncisValidFor1Raw(::grpc::ClientContext* context, const ::octaneapi::ApiNodePinInfo_isValidForRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiNodePinInfo_isValidForResponse>* PrepareAsyncisValidFor1Raw(::grpc::ClientContext* context, const ::octaneapi::ApiNodePinInfo_isValidForRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_isValidFor1_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // / fast version validity check
    virtual ::grpc::Status isValidFor1(::grpc::ServerContext* context, const ::octaneapi::ApiNodePinInfo_isValidForRequest* request, ::octaneapi::ApiNodePinInfo_isValidForResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_isValidFor1 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_isValidFor1() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_isValidFor1() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isValidFor1(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiNodePinInfo_isValidForRequest* /*request*/, ::octaneapi::ApiNodePinInfo_isValidForResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestisValidFor1(::grpc::ServerContext* context, ::octaneapi::ApiNodePinInfo_isValidForRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiNodePinInfo_isValidForResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_isValidFor1<Service > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_isValidFor1 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_isValidFor1() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiNodePinInfo_isValidForRequest, ::octaneapi::ApiNodePinInfo_isValidForResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiNodePinInfo_isValidForRequest* request, ::octaneapi::ApiNodePinInfo_isValidForResponse* response) { return this->isValidFor1(context, request, response); }));}
    void SetMessageAllocatorFor_isValidFor1(
        ::grpc::MessageAllocator< ::octaneapi::ApiNodePinInfo_isValidForRequest, ::octaneapi::ApiNodePinInfo_isValidForResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiNodePinInfo_isValidForRequest, ::octaneapi::ApiNodePinInfo_isValidForResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_isValidFor1() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isValidFor1(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiNodePinInfo_isValidForRequest* /*request*/, ::octaneapi::ApiNodePinInfo_isValidForResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* isValidFor1(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiNodePinInfo_isValidForRequest* /*request*/, ::octaneapi::ApiNodePinInfo_isValidForResponse* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_isValidFor1<Service > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_isValidFor1 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_isValidFor1() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_isValidFor1() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isValidFor1(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiNodePinInfo_isValidForRequest* /*request*/, ::octaneapi::ApiNodePinInfo_isValidForResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_isValidFor1 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_isValidFor1() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_isValidFor1() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isValidFor1(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiNodePinInfo_isValidForRequest* /*request*/, ::octaneapi::ApiNodePinInfo_isValidForResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestisValidFor1(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_isValidFor1 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_isValidFor1() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->isValidFor1(context, request, response); }));
    }
    ~WithRawCallbackMethod_isValidFor1() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isValidFor1(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiNodePinInfo_isValidForRequest* /*request*/, ::octaneapi::ApiNodePinInfo_isValidForResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* isValidFor1(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_isValidFor1 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_isValidFor1() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiNodePinInfo_isValidForRequest, ::octaneapi::ApiNodePinInfo_isValidForResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiNodePinInfo_isValidForRequest, ::octaneapi::ApiNodePinInfo_isValidForResponse>* streamer) {
                       return this->StreamedisValidFor1(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_isValidFor1() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status isValidFor1(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiNodePinInfo_isValidForRequest* /*request*/, ::octaneapi::ApiNodePinInfo_isValidForResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedisValidFor1(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiNodePinInfo_isValidForRequest,::octaneapi::ApiNodePinInfo_isValidForResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_isValidFor1<Service > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_isValidFor1<Service > StreamedService;
};

// GRPC interface definition for class 'ApiOcioColorSpacePinInfo' from 'octaneinfos.h'
//
// GRPC interface definition for class 'ApiOcioLookPinInfo' from 'octaneinfos.h'
//
// GRPC interface definition for class 'ApiOcioViewPinInfo' from 'octaneinfos.h'
//
// GRPC interface definition for class 'ApiProjectionPinInfo' from 'octaneinfos.h'
//
// GRPC interface definition for class 'ApiStringPinInfo' from 'octaneinfos.h'
//
// GRPC interface definition for class 'ApiTextureNodeTypeInfo' from 'octaneinfos.h'
class ApiTextureNodeTypeInfoService final {
 public:
  static constexpr char const* service_full_name() {
    return "octaneapi.ApiTextureNodeTypeInfoService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // / Find the configuration that has the given node interface of texture value types of output and inputs
    // /
    // / 
    virtual ::grpc::Status findConfiguration1(::grpc::ClientContext* context, const ::octaneapi::ApiTextureNodeTypeInfo_findConfiguration1Request& request, ::octaneapi::ApiTextureNodeTypeInfo_findConfiguration1Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiTextureNodeTypeInfo_findConfiguration1Response>> AsyncfindConfiguration1(::grpc::ClientContext* context, const ::octaneapi::ApiTextureNodeTypeInfo_findConfiguration1Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiTextureNodeTypeInfo_findConfiguration1Response>>(AsyncfindConfiguration1Raw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiTextureNodeTypeInfo_findConfiguration1Response>> PrepareAsyncfindConfiguration1(::grpc::ClientContext* context, const ::octaneapi::ApiTextureNodeTypeInfo_findConfiguration1Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiTextureNodeTypeInfo_findConfiguration1Response>>(PrepareAsyncfindConfiguration1Raw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      // / Find the configuration that has the given node interface of texture value types of output and inputs
      // /
      // / 
      virtual void findConfiguration1(::grpc::ClientContext* context, const ::octaneapi::ApiTextureNodeTypeInfo_findConfiguration1Request* request, ::octaneapi::ApiTextureNodeTypeInfo_findConfiguration1Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void findConfiguration1(::grpc::ClientContext* context, const ::octaneapi::ApiTextureNodeTypeInfo_findConfiguration1Request* request, ::octaneapi::ApiTextureNodeTypeInfo_findConfiguration1Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiTextureNodeTypeInfo_findConfiguration1Response>* AsyncfindConfiguration1Raw(::grpc::ClientContext* context, const ::octaneapi::ApiTextureNodeTypeInfo_findConfiguration1Request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiTextureNodeTypeInfo_findConfiguration1Response>* PrepareAsyncfindConfiguration1Raw(::grpc::ClientContext* context, const ::octaneapi::ApiTextureNodeTypeInfo_findConfiguration1Request& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status findConfiguration1(::grpc::ClientContext* context, const ::octaneapi::ApiTextureNodeTypeInfo_findConfiguration1Request& request, ::octaneapi::ApiTextureNodeTypeInfo_findConfiguration1Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiTextureNodeTypeInfo_findConfiguration1Response>> AsyncfindConfiguration1(::grpc::ClientContext* context, const ::octaneapi::ApiTextureNodeTypeInfo_findConfiguration1Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiTextureNodeTypeInfo_findConfiguration1Response>>(AsyncfindConfiguration1Raw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiTextureNodeTypeInfo_findConfiguration1Response>> PrepareAsyncfindConfiguration1(::grpc::ClientContext* context, const ::octaneapi::ApiTextureNodeTypeInfo_findConfiguration1Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiTextureNodeTypeInfo_findConfiguration1Response>>(PrepareAsyncfindConfiguration1Raw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void findConfiguration1(::grpc::ClientContext* context, const ::octaneapi::ApiTextureNodeTypeInfo_findConfiguration1Request* request, ::octaneapi::ApiTextureNodeTypeInfo_findConfiguration1Response* response, std::function<void(::grpc::Status)>) override;
      void findConfiguration1(::grpc::ClientContext* context, const ::octaneapi::ApiTextureNodeTypeInfo_findConfiguration1Request* request, ::octaneapi::ApiTextureNodeTypeInfo_findConfiguration1Response* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiTextureNodeTypeInfo_findConfiguration1Response>* AsyncfindConfiguration1Raw(::grpc::ClientContext* context, const ::octaneapi::ApiTextureNodeTypeInfo_findConfiguration1Request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiTextureNodeTypeInfo_findConfiguration1Response>* PrepareAsyncfindConfiguration1Raw(::grpc::ClientContext* context, const ::octaneapi::ApiTextureNodeTypeInfo_findConfiguration1Request& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_findConfiguration1_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // / Find the configuration that has the given node interface of texture value types of output and inputs
    // /
    // / 
    virtual ::grpc::Status findConfiguration1(::grpc::ServerContext* context, const ::octaneapi::ApiTextureNodeTypeInfo_findConfiguration1Request* request, ::octaneapi::ApiTextureNodeTypeInfo_findConfiguration1Response* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_findConfiguration1 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_findConfiguration1() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_findConfiguration1() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status findConfiguration1(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiTextureNodeTypeInfo_findConfiguration1Request* /*request*/, ::octaneapi::ApiTextureNodeTypeInfo_findConfiguration1Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestfindConfiguration1(::grpc::ServerContext* context, ::octaneapi::ApiTextureNodeTypeInfo_findConfiguration1Request* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiTextureNodeTypeInfo_findConfiguration1Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_findConfiguration1<Service > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_findConfiguration1 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_findConfiguration1() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiTextureNodeTypeInfo_findConfiguration1Request, ::octaneapi::ApiTextureNodeTypeInfo_findConfiguration1Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiTextureNodeTypeInfo_findConfiguration1Request* request, ::octaneapi::ApiTextureNodeTypeInfo_findConfiguration1Response* response) { return this->findConfiguration1(context, request, response); }));}
    void SetMessageAllocatorFor_findConfiguration1(
        ::grpc::MessageAllocator< ::octaneapi::ApiTextureNodeTypeInfo_findConfiguration1Request, ::octaneapi::ApiTextureNodeTypeInfo_findConfiguration1Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiTextureNodeTypeInfo_findConfiguration1Request, ::octaneapi::ApiTextureNodeTypeInfo_findConfiguration1Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_findConfiguration1() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status findConfiguration1(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiTextureNodeTypeInfo_findConfiguration1Request* /*request*/, ::octaneapi::ApiTextureNodeTypeInfo_findConfiguration1Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* findConfiguration1(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiTextureNodeTypeInfo_findConfiguration1Request* /*request*/, ::octaneapi::ApiTextureNodeTypeInfo_findConfiguration1Response* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_findConfiguration1<Service > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_findConfiguration1 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_findConfiguration1() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_findConfiguration1() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status findConfiguration1(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiTextureNodeTypeInfo_findConfiguration1Request* /*request*/, ::octaneapi::ApiTextureNodeTypeInfo_findConfiguration1Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_findConfiguration1 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_findConfiguration1() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_findConfiguration1() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status findConfiguration1(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiTextureNodeTypeInfo_findConfiguration1Request* /*request*/, ::octaneapi::ApiTextureNodeTypeInfo_findConfiguration1Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestfindConfiguration1(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_findConfiguration1 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_findConfiguration1() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->findConfiguration1(context, request, response); }));
    }
    ~WithRawCallbackMethod_findConfiguration1() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status findConfiguration1(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiTextureNodeTypeInfo_findConfiguration1Request* /*request*/, ::octaneapi::ApiTextureNodeTypeInfo_findConfiguration1Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* findConfiguration1(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_findConfiguration1 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_findConfiguration1() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiTextureNodeTypeInfo_findConfiguration1Request, ::octaneapi::ApiTextureNodeTypeInfo_findConfiguration1Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiTextureNodeTypeInfo_findConfiguration1Request, ::octaneapi::ApiTextureNodeTypeInfo_findConfiguration1Response>* streamer) {
                       return this->StreamedfindConfiguration1(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_findConfiguration1() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status findConfiguration1(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiTextureNodeTypeInfo_findConfiguration1Request* /*request*/, ::octaneapi::ApiTextureNodeTypeInfo_findConfiguration1Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedfindConfiguration1(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiTextureNodeTypeInfo_findConfiguration1Request,::octaneapi::ApiTextureNodeTypeInfo_findConfiguration1Response>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_findConfiguration1<Service > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_findConfiguration1<Service > StreamedService;
};

// GRPC interface definition for class 'ApiTextureNodeTypeInfo_Configuration' from 'octaneinfos.h'
//
// GRPC interface definition for class 'ApiTextureNodeTypeInfo_Configuration_Interface' from 'octaneinfos.h'
//
// GRPC interface definition for class 'ApiTextureNodeTypeInfo_Configuration_Parameters' from 'octaneinfos.h'
//
// GRPC interface definition for class 'ApiTexturePinInfo' from 'octaneinfos.h'
//
// GRPC interface definition for class 'ApiTexturePinTypeInfo' from 'octaneinfos.h'
class ApiTexturePinTypeInfoService final {
 public:
  static constexpr char const* service_full_name() {
    return "octaneapi.ApiTexturePinTypeInfoService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // / Get the texture value type of a pin for given configuration parameters
    // /
    // / 
    virtual ::grpc::Status getTextureValueType(::grpc::ClientContext* context, const ::octaneapi::ApiTexturePinTypeInfo_getTextureValueTypeRequest& request, ::octaneapi::ApiTexturePinTypeInfo_getTextureValueTypeResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiTexturePinTypeInfo_getTextureValueTypeResponse>> AsyncgetTextureValueType(::grpc::ClientContext* context, const ::octaneapi::ApiTexturePinTypeInfo_getTextureValueTypeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiTexturePinTypeInfo_getTextureValueTypeResponse>>(AsyncgetTextureValueTypeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiTexturePinTypeInfo_getTextureValueTypeResponse>> PrepareAsyncgetTextureValueType(::grpc::ClientContext* context, const ::octaneapi::ApiTexturePinTypeInfo_getTextureValueTypeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiTexturePinTypeInfo_getTextureValueTypeResponse>>(PrepareAsyncgetTextureValueTypeRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      // / Get the texture value type of a pin for given configuration parameters
      // /
      // / 
      virtual void getTextureValueType(::grpc::ClientContext* context, const ::octaneapi::ApiTexturePinTypeInfo_getTextureValueTypeRequest* request, ::octaneapi::ApiTexturePinTypeInfo_getTextureValueTypeResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void getTextureValueType(::grpc::ClientContext* context, const ::octaneapi::ApiTexturePinTypeInfo_getTextureValueTypeRequest* request, ::octaneapi::ApiTexturePinTypeInfo_getTextureValueTypeResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiTexturePinTypeInfo_getTextureValueTypeResponse>* AsyncgetTextureValueTypeRaw(::grpc::ClientContext* context, const ::octaneapi::ApiTexturePinTypeInfo_getTextureValueTypeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiTexturePinTypeInfo_getTextureValueTypeResponse>* PrepareAsyncgetTextureValueTypeRaw(::grpc::ClientContext* context, const ::octaneapi::ApiTexturePinTypeInfo_getTextureValueTypeRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status getTextureValueType(::grpc::ClientContext* context, const ::octaneapi::ApiTexturePinTypeInfo_getTextureValueTypeRequest& request, ::octaneapi::ApiTexturePinTypeInfo_getTextureValueTypeResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiTexturePinTypeInfo_getTextureValueTypeResponse>> AsyncgetTextureValueType(::grpc::ClientContext* context, const ::octaneapi::ApiTexturePinTypeInfo_getTextureValueTypeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiTexturePinTypeInfo_getTextureValueTypeResponse>>(AsyncgetTextureValueTypeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiTexturePinTypeInfo_getTextureValueTypeResponse>> PrepareAsyncgetTextureValueType(::grpc::ClientContext* context, const ::octaneapi::ApiTexturePinTypeInfo_getTextureValueTypeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiTexturePinTypeInfo_getTextureValueTypeResponse>>(PrepareAsyncgetTextureValueTypeRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void getTextureValueType(::grpc::ClientContext* context, const ::octaneapi::ApiTexturePinTypeInfo_getTextureValueTypeRequest* request, ::octaneapi::ApiTexturePinTypeInfo_getTextureValueTypeResponse* response, std::function<void(::grpc::Status)>) override;
      void getTextureValueType(::grpc::ClientContext* context, const ::octaneapi::ApiTexturePinTypeInfo_getTextureValueTypeRequest* request, ::octaneapi::ApiTexturePinTypeInfo_getTextureValueTypeResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiTexturePinTypeInfo_getTextureValueTypeResponse>* AsyncgetTextureValueTypeRaw(::grpc::ClientContext* context, const ::octaneapi::ApiTexturePinTypeInfo_getTextureValueTypeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiTexturePinTypeInfo_getTextureValueTypeResponse>* PrepareAsyncgetTextureValueTypeRaw(::grpc::ClientContext* context, const ::octaneapi::ApiTexturePinTypeInfo_getTextureValueTypeRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_getTextureValueType_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // / Get the texture value type of a pin for given configuration parameters
    // /
    // / 
    virtual ::grpc::Status getTextureValueType(::grpc::ServerContext* context, const ::octaneapi::ApiTexturePinTypeInfo_getTextureValueTypeRequest* request, ::octaneapi::ApiTexturePinTypeInfo_getTextureValueTypeResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_getTextureValueType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_getTextureValueType() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_getTextureValueType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getTextureValueType(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiTexturePinTypeInfo_getTextureValueTypeRequest* /*request*/, ::octaneapi::ApiTexturePinTypeInfo_getTextureValueTypeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetTextureValueType(::grpc::ServerContext* context, ::octaneapi::ApiTexturePinTypeInfo_getTextureValueTypeRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiTexturePinTypeInfo_getTextureValueTypeResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_getTextureValueType<Service > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_getTextureValueType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_getTextureValueType() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiTexturePinTypeInfo_getTextureValueTypeRequest, ::octaneapi::ApiTexturePinTypeInfo_getTextureValueTypeResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiTexturePinTypeInfo_getTextureValueTypeRequest* request, ::octaneapi::ApiTexturePinTypeInfo_getTextureValueTypeResponse* response) { return this->getTextureValueType(context, request, response); }));}
    void SetMessageAllocatorFor_getTextureValueType(
        ::grpc::MessageAllocator< ::octaneapi::ApiTexturePinTypeInfo_getTextureValueTypeRequest, ::octaneapi::ApiTexturePinTypeInfo_getTextureValueTypeResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiTexturePinTypeInfo_getTextureValueTypeRequest, ::octaneapi::ApiTexturePinTypeInfo_getTextureValueTypeResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_getTextureValueType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getTextureValueType(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiTexturePinTypeInfo_getTextureValueTypeRequest* /*request*/, ::octaneapi::ApiTexturePinTypeInfo_getTextureValueTypeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getTextureValueType(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiTexturePinTypeInfo_getTextureValueTypeRequest* /*request*/, ::octaneapi::ApiTexturePinTypeInfo_getTextureValueTypeResponse* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_getTextureValueType<Service > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_getTextureValueType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_getTextureValueType() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_getTextureValueType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getTextureValueType(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiTexturePinTypeInfo_getTextureValueTypeRequest* /*request*/, ::octaneapi::ApiTexturePinTypeInfo_getTextureValueTypeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_getTextureValueType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_getTextureValueType() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_getTextureValueType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getTextureValueType(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiTexturePinTypeInfo_getTextureValueTypeRequest* /*request*/, ::octaneapi::ApiTexturePinTypeInfo_getTextureValueTypeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetTextureValueType(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_getTextureValueType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_getTextureValueType() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->getTextureValueType(context, request, response); }));
    }
    ~WithRawCallbackMethod_getTextureValueType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getTextureValueType(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiTexturePinTypeInfo_getTextureValueTypeRequest* /*request*/, ::octaneapi::ApiTexturePinTypeInfo_getTextureValueTypeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getTextureValueType(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_getTextureValueType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_getTextureValueType() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiTexturePinTypeInfo_getTextureValueTypeRequest, ::octaneapi::ApiTexturePinTypeInfo_getTextureValueTypeResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiTexturePinTypeInfo_getTextureValueTypeRequest, ::octaneapi::ApiTexturePinTypeInfo_getTextureValueTypeResponse>* streamer) {
                       return this->StreamedgetTextureValueType(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_getTextureValueType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status getTextureValueType(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiTexturePinTypeInfo_getTextureValueTypeRequest* /*request*/, ::octaneapi::ApiTexturePinTypeInfo_getTextureValueTypeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedgetTextureValueType(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiTexturePinTypeInfo_getTextureValueTypeRequest,::octaneapi::ApiTexturePinTypeInfo_getTextureValueTypeResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_getTextureValueType<Service > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_getTextureValueType<Service > StreamedService;
};

// GRPC interface definition for class 'ApiTextureValueTypeSet' from 'octaneinfos.h'
class ApiTextureValueTypeSetService final {
 public:
  static constexpr char const* service_full_name() {
    return "octaneapi.ApiTextureValueTypeSetService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // / Gets the number of texture value types
    virtual ::grpc::Status size1(::grpc::ClientContext* context, const ::octaneapi::ApiTextureValueTypeSet_sizeRequest& request, ::octaneapi::ApiTextureValueTypeSet_sizeResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiTextureValueTypeSet_sizeResponse>> Asyncsize1(::grpc::ClientContext* context, const ::octaneapi::ApiTextureValueTypeSet_sizeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiTextureValueTypeSet_sizeResponse>>(Asyncsize1Raw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiTextureValueTypeSet_sizeResponse>> PrepareAsyncsize1(::grpc::ClientContext* context, const ::octaneapi::ApiTextureValueTypeSet_sizeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiTextureValueTypeSet_sizeResponse>>(PrepareAsyncsize1Raw(context, request, cq));
    }
    // / Gets the TextureValueType at a given index (TEXTURE_VALUE_TYPE_UNKNOWN if out of bounds)
    virtual ::grpc::Status at(::grpc::ClientContext* context, const ::octaneapi::ApiTextureValueTypeSet_atRequest& request, ::octaneapi::ApiTextureValueTypeSet_atResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiTextureValueTypeSet_atResponse>> Asyncat(::grpc::ClientContext* context, const ::octaneapi::ApiTextureValueTypeSet_atRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiTextureValueTypeSet_atResponse>>(AsyncatRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiTextureValueTypeSet_atResponse>> PrepareAsyncat(::grpc::ClientContext* context, const ::octaneapi::ApiTextureValueTypeSet_atRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiTextureValueTypeSet_atResponse>>(PrepareAsyncatRaw(context, request, cq));
    }
    // / Checks if a given TextureValueType is included in the set
    virtual ::grpc::Status contains(::grpc::ClientContext* context, const ::octaneapi::ApiTextureValueTypeSet_containsRequest& request, ::octaneapi::ApiTextureValueTypeSet_containsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiTextureValueTypeSet_containsResponse>> Asynccontains(::grpc::ClientContext* context, const ::octaneapi::ApiTextureValueTypeSet_containsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiTextureValueTypeSet_containsResponse>>(AsynccontainsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiTextureValueTypeSet_containsResponse>> PrepareAsynccontains(::grpc::ClientContext* context, const ::octaneapi::ApiTextureValueTypeSet_containsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiTextureValueTypeSet_containsResponse>>(PrepareAsynccontainsRaw(context, request, cq));
    }
    // / Return the bitfield encoding all the texture value types in the set
    virtual ::grpc::Status bitField(::grpc::ClientContext* context, const ::octaneapi::ApiTextureValueTypeSet_bitFieldRequest& request, ::octaneapi::ApiTextureValueTypeSet_bitFieldResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiTextureValueTypeSet_bitFieldResponse>> AsyncbitField(::grpc::ClientContext* context, const ::octaneapi::ApiTextureValueTypeSet_bitFieldRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiTextureValueTypeSet_bitFieldResponse>>(AsyncbitFieldRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiTextureValueTypeSet_bitFieldResponse>> PrepareAsyncbitField(::grpc::ClientContext* context, const ::octaneapi::ApiTextureValueTypeSet_bitFieldRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiTextureValueTypeSet_bitFieldResponse>>(PrepareAsyncbitFieldRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      // / Gets the number of texture value types
      virtual void size1(::grpc::ClientContext* context, const ::octaneapi::ApiTextureValueTypeSet_sizeRequest* request, ::octaneapi::ApiTextureValueTypeSet_sizeResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void size1(::grpc::ClientContext* context, const ::octaneapi::ApiTextureValueTypeSet_sizeRequest* request, ::octaneapi::ApiTextureValueTypeSet_sizeResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Gets the TextureValueType at a given index (TEXTURE_VALUE_TYPE_UNKNOWN if out of bounds)
      virtual void at(::grpc::ClientContext* context, const ::octaneapi::ApiTextureValueTypeSet_atRequest* request, ::octaneapi::ApiTextureValueTypeSet_atResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void at(::grpc::ClientContext* context, const ::octaneapi::ApiTextureValueTypeSet_atRequest* request, ::octaneapi::ApiTextureValueTypeSet_atResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Checks if a given TextureValueType is included in the set
      virtual void contains(::grpc::ClientContext* context, const ::octaneapi::ApiTextureValueTypeSet_containsRequest* request, ::octaneapi::ApiTextureValueTypeSet_containsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void contains(::grpc::ClientContext* context, const ::octaneapi::ApiTextureValueTypeSet_containsRequest* request, ::octaneapi::ApiTextureValueTypeSet_containsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Return the bitfield encoding all the texture value types in the set
      virtual void bitField(::grpc::ClientContext* context, const ::octaneapi::ApiTextureValueTypeSet_bitFieldRequest* request, ::octaneapi::ApiTextureValueTypeSet_bitFieldResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void bitField(::grpc::ClientContext* context, const ::octaneapi::ApiTextureValueTypeSet_bitFieldRequest* request, ::octaneapi::ApiTextureValueTypeSet_bitFieldResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiTextureValueTypeSet_sizeResponse>* Asyncsize1Raw(::grpc::ClientContext* context, const ::octaneapi::ApiTextureValueTypeSet_sizeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiTextureValueTypeSet_sizeResponse>* PrepareAsyncsize1Raw(::grpc::ClientContext* context, const ::octaneapi::ApiTextureValueTypeSet_sizeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiTextureValueTypeSet_atResponse>* AsyncatRaw(::grpc::ClientContext* context, const ::octaneapi::ApiTextureValueTypeSet_atRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiTextureValueTypeSet_atResponse>* PrepareAsyncatRaw(::grpc::ClientContext* context, const ::octaneapi::ApiTextureValueTypeSet_atRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiTextureValueTypeSet_containsResponse>* AsynccontainsRaw(::grpc::ClientContext* context, const ::octaneapi::ApiTextureValueTypeSet_containsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiTextureValueTypeSet_containsResponse>* PrepareAsynccontainsRaw(::grpc::ClientContext* context, const ::octaneapi::ApiTextureValueTypeSet_containsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiTextureValueTypeSet_bitFieldResponse>* AsyncbitFieldRaw(::grpc::ClientContext* context, const ::octaneapi::ApiTextureValueTypeSet_bitFieldRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiTextureValueTypeSet_bitFieldResponse>* PrepareAsyncbitFieldRaw(::grpc::ClientContext* context, const ::octaneapi::ApiTextureValueTypeSet_bitFieldRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status size1(::grpc::ClientContext* context, const ::octaneapi::ApiTextureValueTypeSet_sizeRequest& request, ::octaneapi::ApiTextureValueTypeSet_sizeResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiTextureValueTypeSet_sizeResponse>> Asyncsize1(::grpc::ClientContext* context, const ::octaneapi::ApiTextureValueTypeSet_sizeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiTextureValueTypeSet_sizeResponse>>(Asyncsize1Raw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiTextureValueTypeSet_sizeResponse>> PrepareAsyncsize1(::grpc::ClientContext* context, const ::octaneapi::ApiTextureValueTypeSet_sizeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiTextureValueTypeSet_sizeResponse>>(PrepareAsyncsize1Raw(context, request, cq));
    }
    ::grpc::Status at(::grpc::ClientContext* context, const ::octaneapi::ApiTextureValueTypeSet_atRequest& request, ::octaneapi::ApiTextureValueTypeSet_atResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiTextureValueTypeSet_atResponse>> Asyncat(::grpc::ClientContext* context, const ::octaneapi::ApiTextureValueTypeSet_atRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiTextureValueTypeSet_atResponse>>(AsyncatRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiTextureValueTypeSet_atResponse>> PrepareAsyncat(::grpc::ClientContext* context, const ::octaneapi::ApiTextureValueTypeSet_atRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiTextureValueTypeSet_atResponse>>(PrepareAsyncatRaw(context, request, cq));
    }
    ::grpc::Status contains(::grpc::ClientContext* context, const ::octaneapi::ApiTextureValueTypeSet_containsRequest& request, ::octaneapi::ApiTextureValueTypeSet_containsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiTextureValueTypeSet_containsResponse>> Asynccontains(::grpc::ClientContext* context, const ::octaneapi::ApiTextureValueTypeSet_containsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiTextureValueTypeSet_containsResponse>>(AsynccontainsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiTextureValueTypeSet_containsResponse>> PrepareAsynccontains(::grpc::ClientContext* context, const ::octaneapi::ApiTextureValueTypeSet_containsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiTextureValueTypeSet_containsResponse>>(PrepareAsynccontainsRaw(context, request, cq));
    }
    ::grpc::Status bitField(::grpc::ClientContext* context, const ::octaneapi::ApiTextureValueTypeSet_bitFieldRequest& request, ::octaneapi::ApiTextureValueTypeSet_bitFieldResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiTextureValueTypeSet_bitFieldResponse>> AsyncbitField(::grpc::ClientContext* context, const ::octaneapi::ApiTextureValueTypeSet_bitFieldRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiTextureValueTypeSet_bitFieldResponse>>(AsyncbitFieldRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiTextureValueTypeSet_bitFieldResponse>> PrepareAsyncbitField(::grpc::ClientContext* context, const ::octaneapi::ApiTextureValueTypeSet_bitFieldRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiTextureValueTypeSet_bitFieldResponse>>(PrepareAsyncbitFieldRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void size1(::grpc::ClientContext* context, const ::octaneapi::ApiTextureValueTypeSet_sizeRequest* request, ::octaneapi::ApiTextureValueTypeSet_sizeResponse* response, std::function<void(::grpc::Status)>) override;
      void size1(::grpc::ClientContext* context, const ::octaneapi::ApiTextureValueTypeSet_sizeRequest* request, ::octaneapi::ApiTextureValueTypeSet_sizeResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void at(::grpc::ClientContext* context, const ::octaneapi::ApiTextureValueTypeSet_atRequest* request, ::octaneapi::ApiTextureValueTypeSet_atResponse* response, std::function<void(::grpc::Status)>) override;
      void at(::grpc::ClientContext* context, const ::octaneapi::ApiTextureValueTypeSet_atRequest* request, ::octaneapi::ApiTextureValueTypeSet_atResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void contains(::grpc::ClientContext* context, const ::octaneapi::ApiTextureValueTypeSet_containsRequest* request, ::octaneapi::ApiTextureValueTypeSet_containsResponse* response, std::function<void(::grpc::Status)>) override;
      void contains(::grpc::ClientContext* context, const ::octaneapi::ApiTextureValueTypeSet_containsRequest* request, ::octaneapi::ApiTextureValueTypeSet_containsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void bitField(::grpc::ClientContext* context, const ::octaneapi::ApiTextureValueTypeSet_bitFieldRequest* request, ::octaneapi::ApiTextureValueTypeSet_bitFieldResponse* response, std::function<void(::grpc::Status)>) override;
      void bitField(::grpc::ClientContext* context, const ::octaneapi::ApiTextureValueTypeSet_bitFieldRequest* request, ::octaneapi::ApiTextureValueTypeSet_bitFieldResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiTextureValueTypeSet_sizeResponse>* Asyncsize1Raw(::grpc::ClientContext* context, const ::octaneapi::ApiTextureValueTypeSet_sizeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiTextureValueTypeSet_sizeResponse>* PrepareAsyncsize1Raw(::grpc::ClientContext* context, const ::octaneapi::ApiTextureValueTypeSet_sizeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiTextureValueTypeSet_atResponse>* AsyncatRaw(::grpc::ClientContext* context, const ::octaneapi::ApiTextureValueTypeSet_atRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiTextureValueTypeSet_atResponse>* PrepareAsyncatRaw(::grpc::ClientContext* context, const ::octaneapi::ApiTextureValueTypeSet_atRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiTextureValueTypeSet_containsResponse>* AsynccontainsRaw(::grpc::ClientContext* context, const ::octaneapi::ApiTextureValueTypeSet_containsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiTextureValueTypeSet_containsResponse>* PrepareAsynccontainsRaw(::grpc::ClientContext* context, const ::octaneapi::ApiTextureValueTypeSet_containsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiTextureValueTypeSet_bitFieldResponse>* AsyncbitFieldRaw(::grpc::ClientContext* context, const ::octaneapi::ApiTextureValueTypeSet_bitFieldRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiTextureValueTypeSet_bitFieldResponse>* PrepareAsyncbitFieldRaw(::grpc::ClientContext* context, const ::octaneapi::ApiTextureValueTypeSet_bitFieldRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_size1_;
    const ::grpc::internal::RpcMethod rpcmethod_at_;
    const ::grpc::internal::RpcMethod rpcmethod_contains_;
    const ::grpc::internal::RpcMethod rpcmethod_bitField_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // / Gets the number of texture value types
    virtual ::grpc::Status size1(::grpc::ServerContext* context, const ::octaneapi::ApiTextureValueTypeSet_sizeRequest* request, ::octaneapi::ApiTextureValueTypeSet_sizeResponse* response);
    // / Gets the TextureValueType at a given index (TEXTURE_VALUE_TYPE_UNKNOWN if out of bounds)
    virtual ::grpc::Status at(::grpc::ServerContext* context, const ::octaneapi::ApiTextureValueTypeSet_atRequest* request, ::octaneapi::ApiTextureValueTypeSet_atResponse* response);
    // / Checks if a given TextureValueType is included in the set
    virtual ::grpc::Status contains(::grpc::ServerContext* context, const ::octaneapi::ApiTextureValueTypeSet_containsRequest* request, ::octaneapi::ApiTextureValueTypeSet_containsResponse* response);
    // / Return the bitfield encoding all the texture value types in the set
    virtual ::grpc::Status bitField(::grpc::ServerContext* context, const ::octaneapi::ApiTextureValueTypeSet_bitFieldRequest* request, ::octaneapi::ApiTextureValueTypeSet_bitFieldResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_size1 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_size1() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_size1() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status size1(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiTextureValueTypeSet_sizeRequest* /*request*/, ::octaneapi::ApiTextureValueTypeSet_sizeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestsize1(::grpc::ServerContext* context, ::octaneapi::ApiTextureValueTypeSet_sizeRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiTextureValueTypeSet_sizeResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_at : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_at() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_at() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status at(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiTextureValueTypeSet_atRequest* /*request*/, ::octaneapi::ApiTextureValueTypeSet_atResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestat(::grpc::ServerContext* context, ::octaneapi::ApiTextureValueTypeSet_atRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiTextureValueTypeSet_atResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_contains : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_contains() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_contains() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status contains(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiTextureValueTypeSet_containsRequest* /*request*/, ::octaneapi::ApiTextureValueTypeSet_containsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestcontains(::grpc::ServerContext* context, ::octaneapi::ApiTextureValueTypeSet_containsRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiTextureValueTypeSet_containsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_bitField : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_bitField() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_bitField() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status bitField(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiTextureValueTypeSet_bitFieldRequest* /*request*/, ::octaneapi::ApiTextureValueTypeSet_bitFieldResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestbitField(::grpc::ServerContext* context, ::octaneapi::ApiTextureValueTypeSet_bitFieldRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiTextureValueTypeSet_bitFieldResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_size1<WithAsyncMethod_at<WithAsyncMethod_contains<WithAsyncMethod_bitField<Service > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_size1 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_size1() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiTextureValueTypeSet_sizeRequest, ::octaneapi::ApiTextureValueTypeSet_sizeResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiTextureValueTypeSet_sizeRequest* request, ::octaneapi::ApiTextureValueTypeSet_sizeResponse* response) { return this->size1(context, request, response); }));}
    void SetMessageAllocatorFor_size1(
        ::grpc::MessageAllocator< ::octaneapi::ApiTextureValueTypeSet_sizeRequest, ::octaneapi::ApiTextureValueTypeSet_sizeResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiTextureValueTypeSet_sizeRequest, ::octaneapi::ApiTextureValueTypeSet_sizeResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_size1() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status size1(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiTextureValueTypeSet_sizeRequest* /*request*/, ::octaneapi::ApiTextureValueTypeSet_sizeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* size1(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiTextureValueTypeSet_sizeRequest* /*request*/, ::octaneapi::ApiTextureValueTypeSet_sizeResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_at : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_at() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiTextureValueTypeSet_atRequest, ::octaneapi::ApiTextureValueTypeSet_atResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiTextureValueTypeSet_atRequest* request, ::octaneapi::ApiTextureValueTypeSet_atResponse* response) { return this->at(context, request, response); }));}
    void SetMessageAllocatorFor_at(
        ::grpc::MessageAllocator< ::octaneapi::ApiTextureValueTypeSet_atRequest, ::octaneapi::ApiTextureValueTypeSet_atResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiTextureValueTypeSet_atRequest, ::octaneapi::ApiTextureValueTypeSet_atResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_at() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status at(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiTextureValueTypeSet_atRequest* /*request*/, ::octaneapi::ApiTextureValueTypeSet_atResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* at(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiTextureValueTypeSet_atRequest* /*request*/, ::octaneapi::ApiTextureValueTypeSet_atResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_contains : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_contains() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiTextureValueTypeSet_containsRequest, ::octaneapi::ApiTextureValueTypeSet_containsResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiTextureValueTypeSet_containsRequest* request, ::octaneapi::ApiTextureValueTypeSet_containsResponse* response) { return this->contains(context, request, response); }));}
    void SetMessageAllocatorFor_contains(
        ::grpc::MessageAllocator< ::octaneapi::ApiTextureValueTypeSet_containsRequest, ::octaneapi::ApiTextureValueTypeSet_containsResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiTextureValueTypeSet_containsRequest, ::octaneapi::ApiTextureValueTypeSet_containsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_contains() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status contains(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiTextureValueTypeSet_containsRequest* /*request*/, ::octaneapi::ApiTextureValueTypeSet_containsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* contains(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiTextureValueTypeSet_containsRequest* /*request*/, ::octaneapi::ApiTextureValueTypeSet_containsResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_bitField : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_bitField() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiTextureValueTypeSet_bitFieldRequest, ::octaneapi::ApiTextureValueTypeSet_bitFieldResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiTextureValueTypeSet_bitFieldRequest* request, ::octaneapi::ApiTextureValueTypeSet_bitFieldResponse* response) { return this->bitField(context, request, response); }));}
    void SetMessageAllocatorFor_bitField(
        ::grpc::MessageAllocator< ::octaneapi::ApiTextureValueTypeSet_bitFieldRequest, ::octaneapi::ApiTextureValueTypeSet_bitFieldResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiTextureValueTypeSet_bitFieldRequest, ::octaneapi::ApiTextureValueTypeSet_bitFieldResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_bitField() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status bitField(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiTextureValueTypeSet_bitFieldRequest* /*request*/, ::octaneapi::ApiTextureValueTypeSet_bitFieldResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* bitField(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiTextureValueTypeSet_bitFieldRequest* /*request*/, ::octaneapi::ApiTextureValueTypeSet_bitFieldResponse* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_size1<WithCallbackMethod_at<WithCallbackMethod_contains<WithCallbackMethod_bitField<Service > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_size1 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_size1() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_size1() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status size1(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiTextureValueTypeSet_sizeRequest* /*request*/, ::octaneapi::ApiTextureValueTypeSet_sizeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_at : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_at() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_at() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status at(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiTextureValueTypeSet_atRequest* /*request*/, ::octaneapi::ApiTextureValueTypeSet_atResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_contains : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_contains() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_contains() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status contains(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiTextureValueTypeSet_containsRequest* /*request*/, ::octaneapi::ApiTextureValueTypeSet_containsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_bitField : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_bitField() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_bitField() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status bitField(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiTextureValueTypeSet_bitFieldRequest* /*request*/, ::octaneapi::ApiTextureValueTypeSet_bitFieldResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_size1 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_size1() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_size1() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status size1(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiTextureValueTypeSet_sizeRequest* /*request*/, ::octaneapi::ApiTextureValueTypeSet_sizeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestsize1(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_at : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_at() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_at() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status at(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiTextureValueTypeSet_atRequest* /*request*/, ::octaneapi::ApiTextureValueTypeSet_atResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestat(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_contains : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_contains() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_contains() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status contains(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiTextureValueTypeSet_containsRequest* /*request*/, ::octaneapi::ApiTextureValueTypeSet_containsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestcontains(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_bitField : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_bitField() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_bitField() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status bitField(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiTextureValueTypeSet_bitFieldRequest* /*request*/, ::octaneapi::ApiTextureValueTypeSet_bitFieldResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestbitField(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_size1 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_size1() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->size1(context, request, response); }));
    }
    ~WithRawCallbackMethod_size1() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status size1(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiTextureValueTypeSet_sizeRequest* /*request*/, ::octaneapi::ApiTextureValueTypeSet_sizeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* size1(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_at : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_at() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->at(context, request, response); }));
    }
    ~WithRawCallbackMethod_at() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status at(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiTextureValueTypeSet_atRequest* /*request*/, ::octaneapi::ApiTextureValueTypeSet_atResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* at(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_contains : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_contains() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->contains(context, request, response); }));
    }
    ~WithRawCallbackMethod_contains() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status contains(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiTextureValueTypeSet_containsRequest* /*request*/, ::octaneapi::ApiTextureValueTypeSet_containsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* contains(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_bitField : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_bitField() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->bitField(context, request, response); }));
    }
    ~WithRawCallbackMethod_bitField() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status bitField(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiTextureValueTypeSet_bitFieldRequest* /*request*/, ::octaneapi::ApiTextureValueTypeSet_bitFieldResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* bitField(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_size1 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_size1() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiTextureValueTypeSet_sizeRequest, ::octaneapi::ApiTextureValueTypeSet_sizeResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiTextureValueTypeSet_sizeRequest, ::octaneapi::ApiTextureValueTypeSet_sizeResponse>* streamer) {
                       return this->Streamedsize1(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_size1() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status size1(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiTextureValueTypeSet_sizeRequest* /*request*/, ::octaneapi::ApiTextureValueTypeSet_sizeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedsize1(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiTextureValueTypeSet_sizeRequest,::octaneapi::ApiTextureValueTypeSet_sizeResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_at : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_at() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiTextureValueTypeSet_atRequest, ::octaneapi::ApiTextureValueTypeSet_atResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiTextureValueTypeSet_atRequest, ::octaneapi::ApiTextureValueTypeSet_atResponse>* streamer) {
                       return this->Streamedat(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_at() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status at(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiTextureValueTypeSet_atRequest* /*request*/, ::octaneapi::ApiTextureValueTypeSet_atResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedat(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiTextureValueTypeSet_atRequest,::octaneapi::ApiTextureValueTypeSet_atResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_contains : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_contains() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiTextureValueTypeSet_containsRequest, ::octaneapi::ApiTextureValueTypeSet_containsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiTextureValueTypeSet_containsRequest, ::octaneapi::ApiTextureValueTypeSet_containsResponse>* streamer) {
                       return this->Streamedcontains(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_contains() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status contains(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiTextureValueTypeSet_containsRequest* /*request*/, ::octaneapi::ApiTextureValueTypeSet_containsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedcontains(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiTextureValueTypeSet_containsRequest,::octaneapi::ApiTextureValueTypeSet_containsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_bitField : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_bitField() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiTextureValueTypeSet_bitFieldRequest, ::octaneapi::ApiTextureValueTypeSet_bitFieldResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiTextureValueTypeSet_bitFieldRequest, ::octaneapi::ApiTextureValueTypeSet_bitFieldResponse>* streamer) {
                       return this->StreamedbitField(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_bitField() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status bitField(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiTextureValueTypeSet_bitFieldRequest* /*request*/, ::octaneapi::ApiTextureValueTypeSet_bitFieldResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedbitField(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiTextureValueTypeSet_bitFieldRequest,::octaneapi::ApiTextureValueTypeSet_bitFieldResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_size1<WithStreamedUnaryMethod_at<WithStreamedUnaryMethod_contains<WithStreamedUnaryMethod_bitField<Service > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_size1<WithStreamedUnaryMethod_at<WithStreamedUnaryMethod_contains<WithStreamedUnaryMethod_bitField<Service > > > > StreamedService;
};

}  // namespace octaneapi


#include <grpcpp/ports_undef.inc>
#endif  // GRPC_octaneinfos_2eproto__INCLUDED
