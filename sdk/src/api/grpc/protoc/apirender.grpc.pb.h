// Copyright (C) 2025 OTOY NZ Ltd.

// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: apirender.proto
// Original file comments:
// ////////////////////////////////////////////////////////////////////////////
// WARNING: This code is machine generated. Manual changes will be overridden.
//
#ifndef GRPC_apirender_2eproto__INCLUDED
#define GRPC_apirender_2eproto__INCLUDED

#include "apirender.pb.h"

#include <functional>
#include <grpcpp/generic/async_generic_service.h>
#include <grpcpp/support/async_stream.h>
#include <grpcpp/support/async_unary_call.h>
#include <grpcpp/support/client_callback.h>
#include <grpcpp/client_context.h>
#include <grpcpp/completion_queue.h>
#include <grpcpp/support/message_allocator.h>
#include <grpcpp/support/method_handler.h>
#include <grpcpp/impl/proto_utils.h>
#include <grpcpp/impl/rpc_method.h>
#include <grpcpp/support/server_callback.h>
#include <grpcpp/impl/server_callback_handlers.h>
#include <grpcpp/server_context.h>
#include <grpcpp/impl/service_type.h>
#include <grpcpp/support/status.h>
#include <grpcpp/support/stub_options.h>
#include <grpcpp/support/sync_stream.h>
#include <grpcpp/ports_def.inc>

namespace octaneapi {

// GRPC interface definition for class 'ApiDeviceMemoryUsage' from 'apirender.h'
//
// GRPC interface definition for class 'ApiDeviceResourceStatistics' from 'apirender.h'
//
// GRPC interface definition for class 'ApiGeometryStatistics' from 'apirender.h'
//
// GRPC interface definition for class 'ApiRenderEngine' from 'apirender.h'
class ApiRenderEngineService final {
 public:
  static constexpr char const* service_full_name() {
    return "octaneapi.ApiRenderEngineService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // / Sets the render target node that should be rendered
    virtual ::grpc::Status setRenderTargetNode(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setRenderTargetNodeRequest& request, ::octaneapi::ApiRenderEngine_setRenderTargetNodeResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_setRenderTargetNodeResponse>> AsyncsetRenderTargetNode(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setRenderTargetNodeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_setRenderTargetNodeResponse>>(AsyncsetRenderTargetNodeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_setRenderTargetNodeResponse>> PrepareAsyncsetRenderTargetNode(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setRenderTargetNodeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_setRenderTargetNodeResponse>>(PrepareAsyncsetRenderTargetNodeRaw(context, request, cq));
    }
    // / Returns render target node that's currently being rendered (can be NULL)
    virtual ::grpc::Status getRenderTargetNode(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRenderTargetNodeRequest& request, ::octaneapi::ApiRenderEngine_getRenderTargetNodeResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getRenderTargetNodeResponse>> AsyncgetRenderTargetNode(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRenderTargetNodeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getRenderTargetNodeResponse>>(AsyncgetRenderTargetNodeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getRenderTargetNodeResponse>> PrepareAsyncgetRenderTargetNode(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRenderTargetNodeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getRenderTargetNodeResponse>>(PrepareAsyncgetRenderTargetNodeRaw(context, request, cq));
    }
    // / Returns the geometry root node that's currently being rendered (can be NULL)
    virtual ::grpc::Status getRenderGeometryNode(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRenderGeometryNodeRequest& request, ::octaneapi::ApiRenderEngine_getRenderGeometryNodeResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getRenderGeometryNodeResponse>> AsyncgetRenderGeometryNode(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRenderGeometryNodeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getRenderGeometryNodeResponse>>(AsyncgetRenderGeometryNodeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getRenderGeometryNodeResponse>> PrepareAsyncgetRenderGeometryNode(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRenderGeometryNodeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getRenderGeometryNodeResponse>>(PrepareAsyncgetRenderGeometryNodeRaw(context, request, cq));
    }
    // / Returns the camera node that's currently being rendered (can be NULL)
    virtual ::grpc::Status getRenderCameraNode(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRenderCameraNodeRequest& request, ::octaneapi::ApiRenderEngine_getRenderCameraNodeResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getRenderCameraNodeResponse>> AsyncgetRenderCameraNode(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRenderCameraNodeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getRenderCameraNodeResponse>>(AsyncgetRenderCameraNodeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getRenderCameraNodeResponse>> PrepareAsyncgetRenderCameraNode(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRenderCameraNodeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getRenderCameraNodeResponse>>(PrepareAsyncgetRenderCameraNodeRaw(context, request, cq));
    }
    // / Sets the render region
    virtual ::grpc::Status setRenderRegion(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setRenderRegionRequest& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncsetRenderRegion(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setRenderRegionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncsetRenderRegionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncsetRenderRegion(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setRenderRegionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncsetRenderRegionRaw(context, request, cq));
    }
    // / Fetches the current render region settings
    virtual ::grpc::Status getRenderRegion(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRenderRegionRequest& request, ::octaneapi::ApiRenderEngine_getRenderRegionResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getRenderRegionResponse>> AsyncgetRenderRegion(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRenderRegionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getRenderRegionResponse>>(AsyncgetRenderRegionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getRenderRegionResponse>> PrepareAsyncgetRenderRegion(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRenderRegionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getRenderRegionResponse>>(PrepareAsyncgetRenderRegionRaw(context, request, cq));
    }
    // / Sets parameters for asynchronous tonemapping
    virtual ::grpc::Status setAsyncTonemapParams(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setAsyncTonemapParamsRequest& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncsetAsyncTonemapParams(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setAsyncTonemapParamsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncsetAsyncTonemapParamsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncsetAsyncTonemapParams(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setAsyncTonemapParamsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncsetAsyncTonemapParamsRaw(context, request, cq));
    }
    // / Convenience overload that does the same thing as:
    // /
    // /     auto info = ApiOutputColorSpaceInfo::createKnownColorSpace(colorSpace, false);
    // /     setAsyncTonemapParams(
    virtual ::grpc::Status setAsyncTonemapParams1(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setAsyncTonemapParams1Request& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncsetAsyncTonemapParams1(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setAsyncTonemapParams1Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncsetAsyncTonemapParams1Raw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncsetAsyncTonemapParams1(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setAsyncTonemapParams1Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncsetAsyncTonemapParams1Raw(context, request, cq));
    }
    // / Returns the current asynchronous tonemap buffer type
    virtual ::grpc::Status asyncTonemapBufferType(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_asyncTonemapBufferTypeRequest& request, ::octaneapi::ApiRenderEngine_asyncTonemapBufferTypeResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_asyncTonemapBufferTypeResponse>> AsyncasyncTonemapBufferType(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_asyncTonemapBufferTypeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_asyncTonemapBufferTypeResponse>>(AsyncasyncTonemapBufferTypeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_asyncTonemapBufferTypeResponse>> PrepareAsyncasyncTonemapBufferType(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_asyncTonemapBufferTypeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_asyncTonemapBufferTypeResponse>>(PrepareAsyncasyncTonemapBufferTypeRaw(context, request, cq));
    }
    // / Returns the current value of whether to apply false color to cryptomatte passes for
    // / asynchronous tonemapping
    virtual ::grpc::Status asyncTonemapCryptomatteFalseColor(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_asyncTonemapCryptomatteFalseColorRequest& request, ::octaneapi::ApiRenderEngine_asyncTonemapCryptomatteFalseColorResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_asyncTonemapCryptomatteFalseColorResponse>> AsyncasyncTonemapCryptomatteFalseColor(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_asyncTonemapCryptomatteFalseColorRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_asyncTonemapCryptomatteFalseColorResponse>>(AsyncasyncTonemapCryptomatteFalseColorRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_asyncTonemapCryptomatteFalseColorResponse>> PrepareAsyncasyncTonemapCryptomatteFalseColor(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_asyncTonemapCryptomatteFalseColorRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_asyncTonemapCryptomatteFalseColorResponse>>(PrepareAsyncasyncTonemapCryptomatteFalseColorRaw(context, request, cq));
    }
    // / Returns the current asynchronous tonemap output color space info
    virtual ::grpc::Status asyncTonemapOutputColorSpaceInfo(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_asyncTonemapOutputColorSpaceInfoRequest& request, ::octaneapi::ApiRenderEngine_asyncTonemapOutputColorSpaceInfoResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_asyncTonemapOutputColorSpaceInfoResponse>> AsyncasyncTonemapOutputColorSpaceInfo(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_asyncTonemapOutputColorSpaceInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_asyncTonemapOutputColorSpaceInfoResponse>>(AsyncasyncTonemapOutputColorSpaceInfoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_asyncTonemapOutputColorSpaceInfoResponse>> PrepareAsyncasyncTonemapOutputColorSpaceInfo(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_asyncTonemapOutputColorSpaceInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_asyncTonemapOutputColorSpaceInfoResponse>>(PrepareAsyncasyncTonemapOutputColorSpaceInfoRaw(context, request, cq));
    }
    // / Returns the current asynchronous tonemap output color space
    virtual ::grpc::Status asyncTonemapColorSpace(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_asyncTonemapColorSpaceRequest& request, ::octaneapi::ApiRenderEngine_asyncTonemapColorSpaceResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_asyncTonemapColorSpaceResponse>> AsyncasyncTonemapColorSpace(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_asyncTonemapColorSpaceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_asyncTonemapColorSpaceResponse>>(AsyncasyncTonemapColorSpaceRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_asyncTonemapColorSpaceResponse>> PrepareAsyncasyncTonemapColorSpace(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_asyncTonemapColorSpaceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_asyncTonemapColorSpaceResponse>>(PrepareAsyncasyncTonemapColorSpaceRaw(context, request, cq));
    }
    // / Returns the current asynchronous tonemap premultiplied alpha type
    virtual ::grpc::Status asyncTonemapPremultipliedAlphaType(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_asyncTonemapPremultipliedAlphaTypeRequest& request, ::octaneapi::ApiRenderEngine_asyncTonemapPremultipliedAlphaTypeResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_asyncTonemapPremultipliedAlphaTypeResponse>> AsyncasyncTonemapPremultipliedAlphaType(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_asyncTonemapPremultipliedAlphaTypeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_asyncTonemapPremultipliedAlphaTypeResponse>>(AsyncasyncTonemapPremultipliedAlphaTypeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_asyncTonemapPremultipliedAlphaTypeResponse>> PrepareAsyncasyncTonemapPremultipliedAlphaType(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_asyncTonemapPremultipliedAlphaTypeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_asyncTonemapPremultipliedAlphaTypeResponse>>(PrepareAsyncasyncTonemapPremultipliedAlphaTypeRaw(context, request, cq));
    }
    // / Sets the render passes that are tonemapped all the time
    virtual ::grpc::Status setAsyncTonemapRenderPasses(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setAsyncTonemapRenderPassesRequest& request, ::octaneapi::ApiRenderEngine_setAsyncTonemapRenderPassesResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_setAsyncTonemapRenderPassesResponse>> AsyncsetAsyncTonemapRenderPasses(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setAsyncTonemapRenderPassesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_setAsyncTonemapRenderPassesResponse>>(AsyncsetAsyncTonemapRenderPassesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_setAsyncTonemapRenderPassesResponse>> PrepareAsyncsetAsyncTonemapRenderPasses(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setAsyncTonemapRenderPassesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_setAsyncTonemapRenderPassesResponse>>(PrepareAsyncsetAsyncTonemapRenderPassesRaw(context, request, cq));
    }
    // / Returns the set of tonemap render passes
    virtual ::grpc::Status asyncTonemapRenderPasses(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_asyncTonemapRenderPassesRequest& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncasyncTonemapRenderPasses(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_asyncTonemapRenderPassesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncasyncTonemapRenderPassesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncasyncTonemapRenderPasses(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_asyncTonemapRenderPassesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncasyncTonemapRenderPassesRaw(context, request, cq));
    }
    // / Returns the render AOVs and output AOVs that are enabled in the specified render target
    // / node as a set of render pass IDs
    virtual ::grpc::Status getEnabledAovs(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getEnabledAovsRequest& request, ::octaneapi::ApiRenderEngine_getEnabledAovsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getEnabledAovsResponse>> AsyncgetEnabledAovs(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getEnabledAovsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getEnabledAovsResponse>>(AsyncgetEnabledAovsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getEnabledAovsResponse>> PrepareAsyncgetEnabledAovs(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getEnabledAovsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getEnabledAovsResponse>>(PrepareAsyncgetEnabledAovsRaw(context, request, cq));
    }
    // / Frees the set of tonemap passes returned by 
    virtual ::grpc::Status freeTonemapPasses(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_freeTonemapPassesRequest& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncfreeTonemapPasses(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_freeTonemapPassesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncfreeTonemapPassesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncfreeTonemapPasses(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_freeTonemapPassesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncfreeTonemapPassesRaw(context, request, cq));
    }
    // / Returns the display pass in the current render
    virtual ::grpc::Status displayRenderPassId(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_displayRenderPassIdRequest& request, ::octaneapi::ApiRenderEngine_displayRenderPassIdResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_displayRenderPassIdResponse>> AsyncdisplayRenderPassId(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_displayRenderPassIdRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_displayRenderPassIdResponse>>(AsyncdisplayRenderPassIdRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_displayRenderPassIdResponse>> PrepareAsyncdisplayRenderPassId(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_displayRenderPassIdRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_displayRenderPassIdResponse>>(PrepareAsyncdisplayRenderPassIdRaw(context, request, cq));
    }
    // / Sets the sub-sampling mode
    virtual ::grpc::Status setSubSampleMode(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setSubSampleModeRequest& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncsetSubSampleMode(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setSubSampleModeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncsetSubSampleModeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncsetSubSampleMode(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setSubSampleModeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncsetSubSampleModeRaw(context, request, cq));
    }
    // / Returns the current sub-sampling mode
    virtual ::grpc::Status getSubSampleMode(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getSubSampleModeRequest& request, ::octaneapi::ApiRenderEngine_getSubSampleModeResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getSubSampleModeResponse>> AsyncgetSubSampleMode(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getSubSampleModeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getSubSampleModeResponse>>(AsyncgetSubSampleModeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getSubSampleModeResponse>> PrepareAsyncgetSubSampleMode(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getSubSampleModeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getSubSampleModeResponse>>(PrepareAsyncgetSubSampleModeRaw(context, request, cq));
    }
    // / Sets the current clay render mode
    virtual ::grpc::Status setClayMode(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setClayModeRequest& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncsetClayMode(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setClayModeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncsetClayModeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncsetClayMode(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setClayModeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncsetClayModeRaw(context, request, cq));
    }
    // / Returns the current clay mode
    virtual ::grpc::Status clayMode(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_clayModeRequest& request, ::octaneapi::ApiRenderEngine_clayModeResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_clayModeResponse>> AsyncclayMode(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_clayModeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_clayModeResponse>>(AsyncclayModeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_clayModeResponse>> PrepareAsyncclayMode(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_clayModeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_clayModeResponse>>(PrepareAsyncclayModeRaw(context, request, cq));
    }
    // / Returns the current fps
    virtual ::grpc::Status fps(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_fpsRequest& request, ::octaneapi::ApiRenderEngine_fpsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_fpsResponse>> Asyncfps(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_fpsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_fpsResponse>>(AsyncfpsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_fpsResponse>> PrepareAsyncfps(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_fpsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_fpsResponse>>(PrepareAsyncfpsRaw(context, request, cq));
    }
    // / Sets the current fps
    virtual ::grpc::Status setFps(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setFpsRequest& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncsetFps(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setFpsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncsetFpsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncsetFps(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setFpsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncsetFpsRaw(context, request, cq));
    }
    // / Returns TRUE if the render engine is currently running a compilation job
    virtual ::grpc::Status isCompiling(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isCompilingRequest& request, ::octaneapi::ApiRenderEngine_isCompilingResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_isCompilingResponse>> AsyncisCompiling(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isCompilingRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_isCompilingResponse>>(AsyncisCompilingRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_isCompilingResponse>> PrepareAsyncisCompiling(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isCompilingRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_isCompilingResponse>>(PrepareAsyncisCompilingRaw(context, request, cq));
    }
    // / Deprecated, this returns the same value as hasPendingRenderData()
    virtual ::grpc::Status isCompressingTextures(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isCompressingTexturesRequest& request, ::octaneapi::ApiRenderEngine_isCompressingTexturesResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_isCompressingTexturesResponse>> AsyncisCompressingTextures(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isCompressingTexturesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_isCompressingTexturesResponse>>(AsyncisCompressingTexturesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_isCompressingTexturesResponse>> PrepareAsyncisCompressingTextures(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isCompressingTexturesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_isCompressingTexturesResponse>>(PrepareAsyncisCompressingTexturesRaw(context, request, cq));
    }
    // / Returns TRUE if there is render data that has not finished compiling
    virtual ::grpc::Status hasPendingRenderData(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_hasPendingRenderDataRequest& request, ::octaneapi::ApiRenderEngine_hasPendingRenderDataResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_hasPendingRenderDataResponse>> AsynchasPendingRenderData(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_hasPendingRenderDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_hasPendingRenderDataResponse>>(AsynchasPendingRenderDataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_hasPendingRenderDataResponse>> PrepareAsynchasPendingRenderData(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_hasPendingRenderDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_hasPendingRenderDataResponse>>(PrepareAsynchasPendingRenderDataRaw(context, request, cq));
    }
    // / Returns the change level after the last update
    virtual ::grpc::Status getCurrentChangeLevel(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getCurrentChangeLevelRequest& request, ::octaneapi::ApiRenderEngine_getCurrentChangeLevelResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getCurrentChangeLevelResponse>> AsyncgetCurrentChangeLevel(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getCurrentChangeLevelRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getCurrentChangeLevelResponse>>(AsyncgetCurrentChangeLevelRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getCurrentChangeLevelResponse>> PrepareAsyncgetCurrentChangeLevel(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getCurrentChangeLevelRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getCurrentChangeLevelResponse>>(PrepareAsyncgetCurrentChangeLevelRaw(context, request, cq));
    }
    // / Returns the change level of the last rendered image, which can be lower than
    // / getCurrentChangeLevel()
    virtual ::grpc::Status getRenderImageChangeLevel(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRenderImageChangeLevelRequest& request, ::octaneapi::ApiRenderEngine_getRenderImageChangeLevelResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getRenderImageChangeLevelResponse>> AsyncgetRenderImageChangeLevel(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRenderImageChangeLevelRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getRenderImageChangeLevelResponse>>(AsyncgetRenderImageChangeLevelRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getRenderImageChangeLevelResponse>> PrepareAsyncgetRenderImageChangeLevel(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRenderImageChangeLevelRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getRenderImageChangeLevelResponse>>(PrepareAsyncgetRenderImageChangeLevelRaw(context, request, cq));
    }
    // / Returns the change level of the last time the rendering was restarted
    virtual ::grpc::Status getRenderRestartedChangeLevel(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRenderRestartedChangeLevelRequest& request, ::octaneapi::ApiRenderEngine_getRenderRestartedChangeLevelResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getRenderRestartedChangeLevelResponse>> AsyncgetRenderRestartedChangeLevel(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRenderRestartedChangeLevelRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getRenderRestartedChangeLevelResponse>>(AsyncgetRenderRestartedChangeLevelRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getRenderRestartedChangeLevelResponse>> PrepareAsyncgetRenderRestartedChangeLevel(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRenderRestartedChangeLevelRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getRenderRestartedChangeLevelResponse>>(PrepareAsyncgetRenderRestartedChangeLevelRaw(context, request, cq));
    }
    // / Registers an asynchronous update callback
    virtual ::grpc::Status setAsyncUpdateCallback(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setAsyncUpdateCallbackRequest& request, ::octaneapi::ApiRenderEngine_setAsyncUpdateCallbackResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_setAsyncUpdateCallbackResponse>> AsyncsetAsyncUpdateCallback(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setAsyncUpdateCallbackRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_setAsyncUpdateCallbackResponse>>(AsyncsetAsyncUpdateCallbackRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_setAsyncUpdateCallbackResponse>> PrepareAsyncsetAsyncUpdateCallback(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setAsyncUpdateCallbackRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_setAsyncUpdateCallbackResponse>>(PrepareAsyncsetAsyncUpdateCallbackRaw(context, request, cq));
    }
    // / Checks if updates are done asynchronously
    virtual ::grpc::Status updatesAreAsync(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_updatesAreAsyncRequest& request, ::octaneapi::ApiRenderEngine_updatesAreAsyncResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_updatesAreAsyncResponse>> AsyncupdatesAreAsync(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_updatesAreAsyncRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_updatesAreAsyncResponse>>(AsyncupdatesAreAsyncRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_updatesAreAsyncResponse>> PrepareAsyncupdatesAreAsync(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_updatesAreAsyncRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_updatesAreAsyncResponse>>(PrepareAsyncupdatesAreAsyncRaw(context, request, cq));
    }
    // / 
    virtual ::grpc::Status isImageReady(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isImageReadyRequest& request, ::octaneapi::ApiRenderEngine_isImageReadyResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_isImageReadyResponse>> AsyncisImageReady(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isImageReadyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_isImageReadyResponse>>(AsyncisImageReadyRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_isImageReadyResponse>> PrepareAsyncisImageReady(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isImageReadyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_isImageReadyResponse>>(PrepareAsyncisImageReadyRaw(context, request, cq));
    }
    virtual ::grpc::Status resetImageReady(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_resetImageReadyRequest& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncresetImageReady(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_resetImageReadyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncresetImageReadyRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncresetImageReady(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_resetImageReadyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncresetImageReadyRaw(context, request, cq));
    }
    virtual ::grpc::Status isRenderFailure(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isRenderFailureRequest& request, ::octaneapi::ApiRenderEngine_isRenderFailureResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_isRenderFailureResponse>> AsyncisRenderFailure(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isRenderFailureRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_isRenderFailureResponse>>(AsyncisRenderFailureRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_isRenderFailureResponse>> PrepareAsyncisRenderFailure(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isRenderFailureRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_isRenderFailureResponse>>(PrepareAsyncisRenderFailureRaw(context, request, cq));
    }
    virtual ::grpc::Status resetRenderFailure(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_resetRenderFailureRequest& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncresetRenderFailure(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_resetRenderFailureRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncresetRenderFailureRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncresetRenderFailure(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_resetRenderFailureRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncresetRenderFailureRaw(context, request, cq));
    }
    // / Registers a callback with the render target that is called when a tile was blended in one
    // / of the two render films and the render statistics did not change
    virtual ::grpc::Status setOnTileBlendedCallback(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setOnTileBlendedCallbackRequest& request, ::octaneapi::ApiRenderEngine_setOnTileBlendedCallbackResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_setOnTileBlendedCallbackResponse>> AsyncsetOnTileBlendedCallback(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setOnTileBlendedCallbackRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_setOnTileBlendedCallbackResponse>>(AsyncsetOnTileBlendedCallbackRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_setOnTileBlendedCallbackResponse>> PrepareAsyncsetOnTileBlendedCallback(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setOnTileBlendedCallbackRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_setOnTileBlendedCallbackResponse>>(PrepareAsyncsetOnTileBlendedCallbackRaw(context, request, cq));
    }
    // / Registers a callback with the render target that is called when the statistics in the
    // / render target changed
    virtual ::grpc::Status setOnNewStatisticsCallback(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setOnNewStatisticsCallbackRequest& request, ::octaneapi::ApiRenderEngine_setOnNewStatisticsCallbackResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_setOnNewStatisticsCallbackResponse>> AsyncsetOnNewStatisticsCallback(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setOnNewStatisticsCallbackRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_setOnNewStatisticsCallbackResponse>>(AsyncsetOnNewStatisticsCallbackRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_setOnNewStatisticsCallbackResponse>> PrepareAsyncsetOnNewStatisticsCallback(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setOnNewStatisticsCallbackRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_setOnNewStatisticsCallbackResponse>>(PrepareAsyncsetOnNewStatisticsCallbackRaw(context, request, cq));
    }
    // / Registers a callback with the render target that is called when a new tonemapped result
    // / is available
    virtual ::grpc::Status setOnNewImageCallback(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setOnNewImageCallbackRequest& request, ::octaneapi::ApiRenderEngine_setOnNewImageCallbackResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_setOnNewImageCallbackResponse>> AsyncsetOnNewImageCallback(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setOnNewImageCallbackRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_setOnNewImageCallbackResponse>>(AsyncsetOnNewImageCallbackRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_setOnNewImageCallbackResponse>> PrepareAsyncsetOnNewImageCallback(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setOnNewImageCallbackRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_setOnNewImageCallbackResponse>>(PrepareAsyncsetOnNewImageCallbackRaw(context, request, cq));
    }
    // / Registers a callback with the render target that is called when OCIO errors are encountered
    // / when updating render data
    virtual ::grpc::Status setOnOcioErrorCallback(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setOnOcioErrorCallbackRequest& request, ::octaneapi::ApiRenderEngine_setOnOcioErrorCallbackResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_setOnOcioErrorCallbackResponse>> AsyncsetOnOcioErrorCallback(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setOnOcioErrorCallbackRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_setOnOcioErrorCallbackResponse>>(AsyncsetOnOcioErrorCallbackRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_setOnOcioErrorCallbackResponse>> PrepareAsyncsetOnOcioErrorCallback(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setOnOcioErrorCallbackRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_setOnOcioErrorCallbackResponse>>(PrepareAsyncsetOnOcioErrorCallbackRaw(context, request, cq));
    }
    // / Registers a callback with the render target that is called when rendering fails
    virtual ::grpc::Status setOnRenderFailureCallback(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setOnRenderFailureCallbackRequest& request, ::octaneapi::ApiRenderEngine_setOnRenderFailureCallbackResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_setOnRenderFailureCallbackResponse>> AsyncsetOnRenderFailureCallback(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setOnRenderFailureCallbackRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_setOnRenderFailureCallbackResponse>>(AsyncsetOnRenderFailureCallbackRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_setOnRenderFailureCallbackResponse>> PrepareAsyncsetOnRenderFailureCallback(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setOnRenderFailureCallbackRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_setOnRenderFailureCallbackResponse>>(PrepareAsyncsetOnRenderFailureCallbackRaw(context, request, cq));
    }
    // / Forces render engine callbacks to be made in render threads instead of the main message
    // / thread
    virtual ::grpc::Status setForceCallbacksInRenderThreads(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setForceCallbacksInRenderThreadsRequest& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncsetForceCallbacksInRenderThreads(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setForceCallbacksInRenderThreadsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncsetForceCallbacksInRenderThreadsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncsetForceCallbacksInRenderThreads(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setForceCallbacksInRenderThreadsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncsetForceCallbacksInRenderThreadsRaw(context, request, cq));
    }
    // / Grabs the latest render result in the passed in array
    virtual ::grpc::Status grabRenderResult(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_grabRenderResultRequest& request, ::octaneapi::ApiRenderEngine_grabRenderResultResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_grabRenderResultResponse>> AsyncgrabRenderResult(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_grabRenderResultRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_grabRenderResultResponse>>(AsyncgrabRenderResultRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_grabRenderResultResponse>> PrepareAsyncgrabRenderResult(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_grabRenderResultRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_grabRenderResultResponse>>(PrepareAsyncgrabRenderResultRaw(context, request, cq));
    }
    // / Releases the results again so that the engine can reuse it
    virtual ::grpc::Status releaseRenderResult(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_releaseRenderResultRequest& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncreleaseRenderResult(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_releaseRenderResultRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncreleaseRenderResultRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncreleaseRenderResult(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_releaseRenderResultRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncreleaseRenderResultRaw(context, request, cq));
    }
    // / Runs a synchronous tonemap and returns the result
    virtual ::grpc::Status synchronousTonemap(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_synchronousTonemapRequest& request, ::octaneapi::ApiRenderEngine_synchronousTonemapResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_synchronousTonemapResponse>> AsyncsynchronousTonemap(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_synchronousTonemapRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_synchronousTonemapResponse>>(AsyncsynchronousTonemapRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_synchronousTonemapResponse>> PrepareAsyncsynchronousTonemap(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_synchronousTonemapRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_synchronousTonemapResponse>>(PrepareAsyncsynchronousTonemapRaw(context, request, cq));
    }
    // / Convenience overload that does the same thing as:
    // /
    // /     auto info = ApiOutputColorSpaceInfo::createKnownColorSpace(colorSpace, false);
    // /     auto result = synchronousTonemap(
    virtual ::grpc::Status synchronousTonemap1(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_synchronousTonemap1Request& request, ::octaneapi::ApiRenderEngine_synchronousTonemap1Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_synchronousTonemap1Response>> AsyncsynchronousTonemap1(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_synchronousTonemap1Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_synchronousTonemap1Response>>(AsyncsynchronousTonemap1Raw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_synchronousTonemap1Response>> PrepareAsyncsynchronousTonemap1(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_synchronousTonemap1Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_synchronousTonemap1Response>>(PrepareAsyncsynchronousTonemap1Raw(context, request, cq));
    }
    // / Runs a synchronous tonemap for all render passes that are already started by the render 
    // / engine and returns the results
    virtual ::grpc::Status synchronousTonemapAllRenderPasses(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPassesRequest& request, ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPassesResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPassesResponse>> AsyncsynchronousTonemapAllRenderPasses(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPassesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPassesResponse>>(AsyncsynchronousTonemapAllRenderPassesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPassesResponse>> PrepareAsyncsynchronousTonemapAllRenderPasses(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPassesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPassesResponse>>(PrepareAsyncsynchronousTonemapAllRenderPassesRaw(context, request, cq));
    }
    // / Convenience overload that does the same thing as:
    // /
    // /     auto info = ApiOutputColorSpaceInfo::createKnownColorSpace(colorSpace, false);
    // /     auto result = synchronousTonemapAllRenderPasses(
    virtual ::grpc::Status synchronousTonemapAllRenderPasses1(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPasses1Request& request, ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPasses1Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPasses1Response>> AsyncsynchronousTonemapAllRenderPasses1(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPasses1Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPasses1Response>>(AsyncsynchronousTonemapAllRenderPasses1Raw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPasses1Response>> PrepareAsyncsynchronousTonemapAllRenderPasses1(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPasses1Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPasses1Response>>(PrepareAsyncsynchronousTonemapAllRenderPasses1Raw(context, request, cq));
    }
    // / Returns the statistics for the current render progress
    virtual ::grpc::Status getRenderStatistics(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRenderStatisticsRequest& request, ::octaneapi::ApiRenderEngine_getRenderStatisticsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getRenderStatisticsResponse>> AsyncgetRenderStatistics(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRenderStatisticsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getRenderStatisticsResponse>>(AsyncgetRenderStatisticsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getRenderStatisticsResponse>> PrepareAsyncgetRenderStatistics(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRenderStatisticsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getRenderStatisticsResponse>>(PrepareAsyncgetRenderStatisticsRaw(context, request, cq));
    }
    // / Returns the statistics for the render results
    virtual ::grpc::Status getRenderResultStatistics(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRenderResultStatisticsRequest& request, ::octaneapi::ApiRenderEngine_getRenderResultStatisticsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getRenderResultStatisticsResponse>> AsyncgetRenderResultStatistics(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRenderResultStatisticsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getRenderResultStatisticsResponse>>(AsyncgetRenderResultStatisticsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getRenderResultStatisticsResponse>> PrepareAsyncgetRenderResultStatistics(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRenderResultStatisticsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getRenderResultStatisticsResponse>>(PrepareAsyncgetRenderResultStatisticsRaw(context, request, cq));
    }
    // / Saves the current result of the render target to the specified file
    virtual ::grpc::Status saveImage(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveImageRequest& request, ::octaneapi::ApiRenderEngine_saveImageResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_saveImageResponse>> AsyncsaveImage(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveImageRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_saveImageResponse>>(AsyncsaveImageRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_saveImageResponse>> PrepareAsyncsaveImage(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveImageRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_saveImageResponse>>(PrepareAsyncsaveImageRaw(context, request, cq));
    }
    // / Convenience overload that does the same thing as:
    // /
    // /     auto info = ApiOutputColorSpaceInfo::createKnownColorSpace(colorSpace, false);
    // /     auto result = saveImage(
    virtual ::grpc::Status saveImage1(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveImage1Request& request, ::octaneapi::ApiRenderEngine_saveImage1Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_saveImage1Response>> AsyncsaveImage1(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveImage1Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_saveImage1Response>>(AsyncsaveImage1Raw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_saveImage1Response>> PrepareAsyncsaveImage1(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveImage1Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_saveImage1Response>>(PrepareAsyncsaveImage1Raw(context, request, cq));
    }
    // / Saves the current result of the render target to the specified file using provided export settings
    // /
    // / 
    virtual ::grpc::Status saveImage2(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveImage2Request& request, ::octaneapi::ApiRenderEngine_saveImage2Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_saveImage2Response>> AsyncsaveImage2(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveImage2Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_saveImage2Response>>(AsyncsaveImage2Raw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_saveImage2Response>> PrepareAsyncsaveImage2(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveImage2Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_saveImage2Response>>(PrepareAsyncsaveImage2Raw(context, request, cq));
    }
    // / Saves the render passes as discrete files in the provided output directory
    virtual ::grpc::Status saveRenderPasses(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveRenderPassesRequest& request, ::octaneapi::ApiRenderEngine_saveRenderPassesResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_saveRenderPassesResponse>> AsyncsaveRenderPasses(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveRenderPassesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_saveRenderPassesResponse>>(AsyncsaveRenderPassesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_saveRenderPassesResponse>> PrepareAsyncsaveRenderPasses(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveRenderPassesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_saveRenderPassesResponse>>(PrepareAsyncsaveRenderPassesRaw(context, request, cq));
    }
    // / Convenience overload that does the same thing as:
    // /
    // /     auto info = ApiOutputColorSpaceInfo::createKnownColorSpace(colorSpace, false);
    // /     auto result = saveRenderPasses(
    virtual ::grpc::Status saveRenderPasses1(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveRenderPasses1Request& request, ::octaneapi::ApiRenderEngine_saveRenderPasses1Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_saveRenderPasses1Response>> AsyncsaveRenderPasses1(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveRenderPasses1Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_saveRenderPasses1Response>>(AsyncsaveRenderPasses1Raw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_saveRenderPasses1Response>> PrepareAsyncsaveRenderPasses1(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveRenderPasses1Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_saveRenderPasses1Response>>(PrepareAsyncsaveRenderPasses1Raw(context, request, cq));
    }
    // / Saves the render passes as discrete files in the provided output directory
    virtual ::grpc::Status saveRenderPasses2(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveRenderPasses2Request& request, ::octaneapi::ApiRenderEngine_saveRenderPasses2Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_saveRenderPasses2Response>> AsyncsaveRenderPasses2(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveRenderPasses2Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_saveRenderPasses2Response>>(AsyncsaveRenderPasses2Raw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_saveRenderPasses2Response>> PrepareAsyncsaveRenderPasses2(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveRenderPasses2Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_saveRenderPasses2Response>>(PrepareAsyncsaveRenderPasses2Raw(context, request, cq));
    }
    // / Saves the render passes in a multi layer EXR file
    virtual ::grpc::Status saveRenderPassesMultiExr(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExrRequest& request, ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExrResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExrResponse>> AsyncsaveRenderPassesMultiExr(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExrRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExrResponse>>(AsyncsaveRenderPassesMultiExrRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExrResponse>> PrepareAsyncsaveRenderPassesMultiExr(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExrRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExrResponse>>(PrepareAsyncsaveRenderPassesMultiExrRaw(context, request, cq));
    }
    // / Convenience overload that does the same thing as:
    // /
    // /     auto info = ApiOutputColorSpaceInfo::createKnownColorSpace(colorSpace, false);
    // /     auto result = saveRenderPassesMultiExr(
    virtual ::grpc::Status saveRenderPassesMultiExr1(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExr1Request& request, ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExr1Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExr1Response>> AsyncsaveRenderPassesMultiExr1(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExr1Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExr1Response>>(AsyncsaveRenderPassesMultiExr1Raw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExr1Response>> PrepareAsyncsaveRenderPassesMultiExr1(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExr1Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExr1Response>>(PrepareAsyncsaveRenderPassesMultiExr1Raw(context, request, cq));
    }
    // / Saves the render passes in a deep image EXR file
    virtual ::grpc::Status saveRenderPassesDeepExr(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveRenderPassesDeepExrRequest& request, ::octaneapi::ApiRenderEngine_saveRenderPassesDeepExrResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_saveRenderPassesDeepExrResponse>> AsyncsaveRenderPassesDeepExr(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveRenderPassesDeepExrRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_saveRenderPassesDeepExrResponse>>(AsyncsaveRenderPassesDeepExrRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_saveRenderPassesDeepExrResponse>> PrepareAsyncsaveRenderPassesDeepExr(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveRenderPassesDeepExrRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_saveRenderPassesDeepExrResponse>>(PrepareAsyncsaveRenderPassesDeepExrRaw(context, request, cq));
    }
    // / Checks whether the provided render target both supports and has enabled deep pixel rendering
    virtual ::grpc::Status deepImageEnabled(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deepImageEnabledRequest& request, ::octaneapi::ApiRenderEngine_deepImageEnabledResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_deepImageEnabledResponse>> AsyncdeepImageEnabled(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deepImageEnabledRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_deepImageEnabledResponse>>(AsyncdeepImageEnabledRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_deepImageEnabledResponse>> PrepareAsyncdeepImageEnabled(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deepImageEnabledRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_deepImageEnabledResponse>>(PrepareAsyncdeepImageEnabledRaw(context, request, cq));
    }
    // / Checks if deep image rendering is enabled for the current render task
    virtual ::grpc::Status deepImageEnabled1(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deepImageEnabled1Request& request, ::octaneapi::ApiRenderEngine_deepImageEnabled1Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_deepImageEnabled1Response>> AsyncdeepImageEnabled1(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deepImageEnabled1Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_deepImageEnabled1Response>>(AsyncdeepImageEnabled1Raw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_deepImageEnabled1Response>> PrepareAsyncdeepImageEnabled1(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deepImageEnabled1Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_deepImageEnabled1Response>>(PrepareAsyncdeepImageEnabled1Raw(context, request, cq));
    }
    // / Checks if deep image rendering and deep render AOVs are enabled for the current render task
    virtual ::grpc::Status deepPassesEnabled(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deepPassesEnabledRequest& request, ::octaneapi::ApiRenderEngine_deepPassesEnabledResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_deepPassesEnabledResponse>> AsyncdeepPassesEnabled(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deepPassesEnabledRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_deepPassesEnabledResponse>>(AsyncdeepPassesEnabledRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_deepPassesEnabledResponse>> PrepareAsyncdeepPassesEnabled(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deepPassesEnabledRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_deepPassesEnabledResponse>>(PrepareAsyncdeepPassesEnabledRaw(context, request, cq));
    }
    // / Checks if we can save a deep image
    virtual ::grpc::Status canSaveDeepImage(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_canSaveDeepImageRequest& request, ::octaneapi::ApiRenderEngine_canSaveDeepImageResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_canSaveDeepImageResponse>> AsynccanSaveDeepImage(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_canSaveDeepImageRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_canSaveDeepImageResponse>>(AsynccanSaveDeepImageRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_canSaveDeepImageResponse>> PrepareAsynccanSaveDeepImage(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_canSaveDeepImageRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_canSaveDeepImageResponse>>(PrepareAsynccanSaveDeepImageRaw(context, request, cq));
    }
    // / Saves the current render as a deep image
    virtual ::grpc::Status saveDeepImage(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveDeepImageRequest& request, ::octaneapi::ApiRenderEngine_saveDeepImageResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_saveDeepImageResponse>> AsyncsaveDeepImage(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveDeepImageRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_saveDeepImageResponse>>(AsyncsaveDeepImageRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_saveDeepImageResponse>> PrepareAsyncsaveDeepImage(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveDeepImageRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_saveDeepImageResponse>>(PrepareAsyncsaveDeepImageRaw(context, request, cq));
    }
    // / Saves the current render state plus a reference to the project file
    virtual ::grpc::Status saveRenderState(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveRenderStateRequest& request, ::octaneapi::ApiRenderEngine_saveRenderStateResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_saveRenderStateResponse>> AsyncsaveRenderState(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveRenderStateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_saveRenderStateResponse>>(AsyncsaveRenderStateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_saveRenderStateResponse>> PrepareAsyncsaveRenderState(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveRenderStateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_saveRenderStateResponse>>(PrepareAsyncsaveRenderStateRaw(context, request, cq));
    }
    // / Loads an Octane render state file
    virtual ::grpc::Status loadRenderState(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_loadRenderStateRequest& request, ::octaneapi::ApiRenderEngine_loadRenderStateResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_loadRenderStateResponse>> AsyncloadRenderState(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_loadRenderStateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_loadRenderStateResponse>>(AsyncloadRenderStateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_loadRenderStateResponse>> PrepareAsyncloadRenderState(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_loadRenderStateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_loadRenderStateResponse>>(PrepareAsyncloadRenderStateRaw(context, request, cq));
    }
    // / Renders a preview image of a texture / material node
    virtual ::grpc::Status previewMaterial(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_previewMaterialRequest& request, ::octaneapi::ApiRenderEngine_previewMaterialResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_previewMaterialResponse>> AsyncpreviewMaterial(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_previewMaterialRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_previewMaterialResponse>>(AsyncpreviewMaterialRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_previewMaterialResponse>> PrepareAsyncpreviewMaterial(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_previewMaterialRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_previewMaterialResponse>>(PrepareAsyncpreviewMaterialRaw(context, request, cq));
    }
    // / Same as above but return HDR buffer
    // /
    // / 
    virtual ::grpc::Status previewMaterialHdr(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_previewMaterialHdrRequest& request, ::octaneapi::ApiRenderEngine_previewMaterialHdrResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_previewMaterialHdrResponse>> AsyncpreviewMaterialHdr(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_previewMaterialHdrRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_previewMaterialHdrResponse>>(AsyncpreviewMaterialHdrRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_previewMaterialHdrResponse>> PrepareAsyncpreviewMaterialHdr(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_previewMaterialHdrRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_previewMaterialHdrResponse>>(PrepareAsyncpreviewMaterialHdrRaw(context, request, cq));
    }
    // / Preview a material or texture node
    // /
    // / 
    virtual ::grpc::Status previewMaterial1(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_previewMaterial1Request& request, ::octaneapi::ApiRenderEngine_previewMaterial1Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_previewMaterial1Response>> AsyncpreviewMaterial1(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_previewMaterial1Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_previewMaterial1Response>>(AsyncpreviewMaterial1Raw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_previewMaterial1Response>> PrepareAsyncpreviewMaterial1(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_previewMaterial1Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_previewMaterial1Response>>(PrepareAsyncpreviewMaterial1Raw(context, request, cq));
    }
    // / Returns the overall memory usage of a device
    virtual ::grpc::Status getMemoryUsage(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getMemoryUsageRequest& request, ::octaneapi::ApiRenderEngine_getMemoryUsageResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getMemoryUsageResponse>> AsyncgetMemoryUsage(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getMemoryUsageRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getMemoryUsageResponse>>(AsyncgetMemoryUsageRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getMemoryUsageResponse>> PrepareAsyncgetMemoryUsage(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getMemoryUsageRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getMemoryUsageResponse>>(PrepareAsyncgetMemoryUsageRaw(context, request, cq));
    }
    // / Returns memory usage statistics for a device
    // /
    // / 
    virtual ::grpc::Status getResourceStatistics(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getResourceStatisticsRequest& request, ::octaneapi::ApiRenderEngine_getResourceStatisticsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getResourceStatisticsResponse>> AsyncgetResourceStatistics(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getResourceStatisticsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getResourceStatisticsResponse>>(AsyncgetResourceStatisticsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getResourceStatisticsResponse>> PrepareAsyncgetResourceStatistics(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getResourceStatisticsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getResourceStatisticsResponse>>(PrepareAsyncgetResourceStatisticsRaw(context, request, cq));
    }
    // / Returns the geometry statistics of the current scene
    virtual ::grpc::Status getGeometryStatistics(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getGeometryStatisticsRequest& request, ::octaneapi::ApiRenderEngine_getGeometryStatisticsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getGeometryStatisticsResponse>> AsyncgetGeometryStatistics(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getGeometryStatisticsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getGeometryStatisticsResponse>>(AsyncgetGeometryStatisticsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getGeometryStatisticsResponse>> PrepareAsyncgetGeometryStatistics(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getGeometryStatisticsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getGeometryStatisticsResponse>>(PrepareAsyncgetGeometryStatisticsRaw(context, request, cq));
    }
    // / Returns the texture usage
    virtual ::grpc::Status getTexturesStatistics(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getTexturesStatisticsRequest& request, ::octaneapi::ApiRenderEngine_getTexturesStatisticsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getTexturesStatisticsResponse>> AsyncgetTexturesStatistics(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getTexturesStatisticsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getTexturesStatisticsResponse>>(AsyncgetTexturesStatisticsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getTexturesStatisticsResponse>> PrepareAsyncgetTexturesStatistics(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getTexturesStatisticsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getTexturesStatisticsResponse>>(PrepareAsyncgetTexturesStatisticsRaw(context, request, cq));
    }
    // / If the currently rendered scene contains geometry, its bounding box is stored in the
    // / provided vectors and TRUE is returned
    virtual ::grpc::Status getSceneBounds(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getSceneBoundsRequest& request, ::octaneapi::ApiRenderEngine_getSceneBoundsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getSceneBoundsResponse>> AsyncgetSceneBounds(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getSceneBoundsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getSceneBoundsResponse>>(AsyncgetSceneBoundsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getSceneBoundsResponse>> PrepareAsyncgetSceneBounds(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getSceneBoundsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getSceneBoundsResponse>>(PrepareAsyncgetSceneBoundsRaw(context, request, cq));
    }
    // / Returns the number of render devices (GPUs) in this machine
    virtual ::grpc::Status getDeviceCount(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getDeviceCountRequest& request, ::octaneapi::ApiRenderEngine_getDeviceCountResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getDeviceCountResponse>> AsyncgetDeviceCount(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getDeviceCountRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getDeviceCountResponse>>(AsyncgetDeviceCountRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getDeviceCountResponse>> PrepareAsyncgetDeviceCount(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getDeviceCountRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getDeviceCountResponse>>(PrepareAsyncgetDeviceCountRaw(context, request, cq));
    }
    // / Returns the compute model of the device
    virtual ::grpc::Status getDeviceComputeModel(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getDeviceComputeModelRequest& request, ::octaneapi::ApiRenderEngine_getDeviceComputeModelResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getDeviceComputeModelResponse>> AsyncgetDeviceComputeModel(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getDeviceComputeModelRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getDeviceComputeModelResponse>>(AsyncgetDeviceComputeModelRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getDeviceComputeModelResponse>> PrepareAsyncgetDeviceComputeModel(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getDeviceComputeModelRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getDeviceComputeModelResponse>>(PrepareAsyncgetDeviceComputeModelRaw(context, request, cq));
    }
    // / Returns the name of the device
    virtual ::grpc::Status getDeviceName(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getDeviceNameRequest& request, ::octaneapi::ApiRenderEngine_getDeviceNameResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getDeviceNameResponse>> AsyncgetDeviceName(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getDeviceNameRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getDeviceNameResponse>>(AsyncgetDeviceNameRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getDeviceNameResponse>> PrepareAsyncgetDeviceName(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getDeviceNameRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getDeviceNameResponse>>(PrepareAsyncgetDeviceNameRaw(context, request, cq));
    }
    // / Returns TRUE if the device with the provided index is supported by Octane, i
    virtual ::grpc::Status isSupportedDevice(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isSupportedDeviceRequest& request, ::octaneapi::ApiRenderEngine_isSupportedDeviceResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_isSupportedDeviceResponse>> AsyncisSupportedDevice(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isSupportedDeviceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_isSupportedDeviceResponse>>(AsyncisSupportedDeviceRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_isSupportedDeviceResponse>> PrepareAsyncisSupportedDevice(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isSupportedDeviceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_isSupportedDeviceResponse>>(PrepareAsyncisSupportedDeviceRaw(context, request, cq));
    }
    // / Returns TRUE if the device with the provided index can be used for rendering
    virtual ::grpc::Status deviceCanRender(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deviceCanRenderRequest& request, ::octaneapi::ApiRenderEngine_deviceCanRenderResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_deviceCanRenderResponse>> AsyncdeviceCanRender(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deviceCanRenderRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_deviceCanRenderResponse>>(AsyncdeviceCanRenderRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_deviceCanRenderResponse>> PrepareAsyncdeviceCanRender(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deviceCanRenderRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_deviceCanRenderResponse>>(PrepareAsyncdeviceCanRenderRaw(context, request, cq));
    }
    // / Returns TRUE if the device with the provided index can be used for denoising
    virtual ::grpc::Status deviceCanDenoise(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deviceCanDenoiseRequest& request, ::octaneapi::ApiRenderEngine_deviceCanDenoiseResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_deviceCanDenoiseResponse>> AsyncdeviceCanDenoise(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deviceCanDenoiseRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_deviceCanDenoiseResponse>>(AsyncdeviceCanDenoiseRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_deviceCanDenoiseResponse>> PrepareAsyncdeviceCanDenoise(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deviceCanDenoiseRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_deviceCanDenoiseResponse>>(PrepareAsyncdeviceCanDenoiseRaw(context, request, cq));
    }
    // / Returns TRUE if the device with the provided index supports hardware ray-tracing
    virtual ::grpc::Status deviceSupportsHardwareRayTracing(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deviceSupportsHardwareRayTracingRequest& request, ::octaneapi::ApiRenderEngine_deviceSupportsHardwareRayTracingResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_deviceSupportsHardwareRayTracingResponse>> AsyncdeviceSupportsHardwareRayTracing(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deviceSupportsHardwareRayTracingRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_deviceSupportsHardwareRayTracingResponse>>(AsyncdeviceSupportsHardwareRayTracingRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_deviceSupportsHardwareRayTracingResponse>> PrepareAsyncdeviceSupportsHardwareRayTracing(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deviceSupportsHardwareRayTracingRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_deviceSupportsHardwareRayTracingResponse>>(PrepareAsyncdeviceSupportsHardwareRayTracingRaw(context, request, cq));
    }
    // / Returns details of the shared surface capabilities of the device with the provided index
    virtual ::grpc::Status deviceSharedSurfaceInfo(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deviceSharedSurfaceInfoRequest& request, ::octaneapi::ApiRenderEngine_deviceSharedSurfaceInfoResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_deviceSharedSurfaceInfoResponse>> AsyncdeviceSharedSurfaceInfo(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deviceSharedSurfaceInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_deviceSharedSurfaceInfoResponse>>(AsyncdeviceSharedSurfaceInfoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_deviceSharedSurfaceInfoResponse>> PrepareAsyncdeviceSharedSurfaceInfo(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deviceSharedSurfaceInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_deviceSharedSurfaceInfoResponse>>(PrepareAsyncdeviceSharedSurfaceInfoRaw(context, request, cq));
    }
    // / Returns an array of available peer-to-peer (NVlink) pairs
    virtual ::grpc::Status getAvailablePeerToPeerPairs(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getAvailablePeerToPeerPairsRequest& request, ::octaneapi::ApiRenderEngine_getAvailablePeerToPeerPairsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getAvailablePeerToPeerPairsResponse>> AsyncgetAvailablePeerToPeerPairs(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getAvailablePeerToPeerPairsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getAvailablePeerToPeerPairsResponse>>(AsyncgetAvailablePeerToPeerPairsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getAvailablePeerToPeerPairsResponse>> PrepareAsyncgetAvailablePeerToPeerPairs(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getAvailablePeerToPeerPairsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getAvailablePeerToPeerPairsResponse>>(PrepareAsyncgetAvailablePeerToPeerPairsRaw(context, request, cq));
    }
    // / List of devices to enable for rendering and denoising
    virtual ::grpc::Status setDevicesActivity(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setDevicesActivityRequest& request, ::octaneapi::ApiRenderEngine_setDevicesActivityResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_setDevicesActivityResponse>> AsyncsetDevicesActivity(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setDevicesActivityRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_setDevicesActivityResponse>>(AsyncsetDevicesActivityRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_setDevicesActivityResponse>> PrepareAsyncsetDevicesActivity(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setDevicesActivityRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_setDevicesActivityResponse>>(PrepareAsyncsetDevicesActivityRaw(context, request, cq));
    }
    // / Returns TRUE if the device is used for rendering
    virtual ::grpc::Status isDeviceUsedForRendering(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isDeviceUsedForRenderingRequest& request, ::octaneapi::ApiRenderEngine_isDeviceUsedForRenderingResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_isDeviceUsedForRenderingResponse>> AsyncisDeviceUsedForRendering(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isDeviceUsedForRenderingRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_isDeviceUsedForRenderingResponse>>(AsyncisDeviceUsedForRenderingRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_isDeviceUsedForRenderingResponse>> PrepareAsyncisDeviceUsedForRendering(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isDeviceUsedForRenderingRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_isDeviceUsedForRenderingResponse>>(PrepareAsyncisDeviceUsedForRenderingRaw(context, request, cq));
    }
    // / Returns TRUE if the device with index uses render priority
    virtual ::grpc::Status deviceUsesPriority(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deviceUsesPriorityRequest& request, ::octaneapi::ApiRenderEngine_deviceUsesPriorityResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_deviceUsesPriorityResponse>> AsyncdeviceUsesPriority(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deviceUsesPriorityRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_deviceUsesPriorityResponse>>(AsyncdeviceUsesPriorityRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_deviceUsesPriorityResponse>> PrepareAsyncdeviceUsesPriority(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deviceUsesPriorityRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_deviceUsesPriorityResponse>>(PrepareAsyncdeviceUsesPriorityRaw(context, request, cq));
    }
    // / Returns TRUE if the device at the provided index is using hardware ray-tracing
    virtual ::grpc::Status deviceUsesHardwareRayTracing(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deviceUsesHardwareRayTracingRequest& request, ::octaneapi::ApiRenderEngine_deviceUsesHardwareRayTracingResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_deviceUsesHardwareRayTracingResponse>> AsyncdeviceUsesHardwareRayTracing(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deviceUsesHardwareRayTracingRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_deviceUsesHardwareRayTracingResponse>>(AsyncdeviceUsesHardwareRayTracingRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_deviceUsesHardwareRayTracingResponse>> PrepareAsyncdeviceUsesHardwareRayTracing(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deviceUsesHardwareRayTracingRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_deviceUsesHardwareRayTracingResponse>>(PrepareAsyncdeviceUsesHardwareRayTracingRaw(context, request, cq));
    }
    // / Returns the index of the device used for imaging, or -1 if no device is capable
    virtual ::grpc::Status imageDeviceIndex(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_imageDeviceIndexRequest& request, ::octaneapi::ApiRenderEngine_imageDeviceIndexResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_imageDeviceIndexResponse>> AsyncimageDeviceIndex(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_imageDeviceIndexRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_imageDeviceIndexResponse>>(AsyncimageDeviceIndexRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_imageDeviceIndexResponse>> PrepareAsyncimageDeviceIndex(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_imageDeviceIndexRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_imageDeviceIndexResponse>>(PrepareAsyncimageDeviceIndexRaw(context, request, cq));
    }
    // / Returns TRUE if the device is used for denoising
    virtual ::grpc::Status isDeviceUsedForDenoising(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isDeviceUsedForDenoisingRequest& request, ::octaneapi::ApiRenderEngine_isDeviceUsedForDenoisingResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_isDeviceUsedForDenoisingResponse>> AsyncisDeviceUsedForDenoising(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isDeviceUsedForDenoisingRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_isDeviceUsedForDenoisingResponse>>(AsyncisDeviceUsedForDenoisingRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_isDeviceUsedForDenoisingResponse>> PrepareAsyncisDeviceUsedForDenoising(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isDeviceUsedForDenoisingRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_isDeviceUsedForDenoisingResponse>>(PrepareAsyncisDeviceUsedForDenoisingRaw(context, request, cq));
    }
    // / Returns the current render priority
    virtual ::grpc::Status renderPriority(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_renderPriorityRequest& request, ::octaneapi::ApiRenderEngine_renderPriorityResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_renderPriorityResponse>> AsyncrenderPriority(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_renderPriorityRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_renderPriorityResponse>>(AsyncrenderPriorityRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_renderPriorityResponse>> PrepareAsyncrenderPriority(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_renderPriorityRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_renderPriorityResponse>>(PrepareAsyncrenderPriorityRaw(context, request, cq));
    }
    // / Sets the current render priority
    virtual ::grpc::Status setRenderPriority(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setRenderPriorityRequest& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncsetRenderPriority(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setRenderPriorityRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncsetRenderPriorityRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncsetRenderPriority(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setRenderPriorityRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncsetRenderPriorityRaw(context, request, cq));
    }
    // / Returns the current peer-to-peer configuration
    virtual ::grpc::Status currentPeerToPeerGroups(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_currentPeerToPeerGroupsRequest& request, ::octaneapi::ApiRenderEngine_currentPeerToPeerGroupsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_currentPeerToPeerGroupsResponse>> AsynccurrentPeerToPeerGroups(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_currentPeerToPeerGroupsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_currentPeerToPeerGroupsResponse>>(AsynccurrentPeerToPeerGroupsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_currentPeerToPeerGroupsResponse>> PrepareAsynccurrentPeerToPeerGroups(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_currentPeerToPeerGroupsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_currentPeerToPeerGroupsResponse>>(PrepareAsynccurrentPeerToPeerGroupsRaw(context, request, cq));
    }
    // / Returns TRUE if hardware raytracing is currently enabled for all devices with support for it
    virtual ::grpc::Status hardwareRayTracingEnabled(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_hardwareRayTracingEnabledRequest& request, ::octaneapi::ApiRenderEngine_hardwareRayTracingEnabledResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_hardwareRayTracingEnabledResponse>> AsynchardwareRayTracingEnabled(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_hardwareRayTracingEnabledRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_hardwareRayTracingEnabledResponse>>(AsynchardwareRayTracingEnabledRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_hardwareRayTracingEnabledResponse>> PrepareAsynchardwareRayTracingEnabled(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_hardwareRayTracingEnabledRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_hardwareRayTracingEnabledResponse>>(PrepareAsynchardwareRayTracingEnabledRaw(context, request, cq));
    }
    // / Opens a modal dialog to allow the user to set devices configuration
    virtual ::grpc::Status openDeviceSettings(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_openDeviceSettingsRequest& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncopenDeviceSettings(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_openDeviceSettingsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncopenDeviceSettingsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncopenDeviceSettings(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_openDeviceSettingsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncopenDeviceSettingsRaw(context, request, cq));
    }
    // / Returns the state of the device
    virtual ::grpc::Status renderDeviceState(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_renderDeviceStateRequest& request, ::octaneapi::ApiRenderEngine_renderDeviceStateResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_renderDeviceStateResponse>> AsyncrenderDeviceState(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_renderDeviceStateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_renderDeviceStateResponse>>(AsyncrenderDeviceStateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_renderDeviceStateResponse>> PrepareAsyncrenderDeviceState(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_renderDeviceStateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_renderDeviceStateResponse>>(PrepareAsyncrenderDeviceStateRaw(context, request, cq));
    }
    // / Returns the error state of a device or RENDER_ERROR_NONE if the device has not failed or
    // / is not active
    virtual ::grpc::Status renderDeviceErrorCode(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_renderDeviceErrorCodeRequest& request, ::octaneapi::ApiRenderEngine_renderDeviceErrorCodeResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_renderDeviceErrorCodeResponse>> AsyncrenderDeviceErrorCode(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_renderDeviceErrorCodeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_renderDeviceErrorCodeResponse>>(AsyncrenderDeviceErrorCodeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_renderDeviceErrorCodeResponse>> PrepareAsyncrenderDeviceErrorCode(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_renderDeviceErrorCodeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_renderDeviceErrorCodeResponse>>(PrepareAsyncrenderDeviceErrorCodeRaw(context, request, cq));
    }
    // / Returns the error state of a device as string or an empty string if the device is not in an
    // / error state or is not active
    virtual ::grpc::Status errorcodeToString(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_errorcodeToStringRequest& request, ::octaneapi::ApiRenderEngine_errorcodeToStringResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_errorcodeToStringResponse>> AsyncerrorcodeToString(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_errorcodeToStringRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_errorcodeToStringResponse>>(AsyncerrorcodeToStringRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_errorcodeToStringResponse>> PrepareAsyncerrorcodeToString(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_errorcodeToStringRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_errorcodeToStringResponse>>(PrepareAsyncerrorcodeToStringRaw(context, request, cq));
    }
    // / Returns the (low-level) error message that triggered the device to fail or an empty string
    // / if it hasn't failed or isn't active
    virtual ::grpc::Status renderDeviceErrorMessage(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_renderDeviceErrorMessageRequest& request, ::octaneapi::ApiRenderEngine_renderDeviceErrorMessageResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_renderDeviceErrorMessageResponse>> AsyncrenderDeviceErrorMessage(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_renderDeviceErrorMessageRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_renderDeviceErrorMessageResponse>>(AsyncrenderDeviceErrorMessageRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_renderDeviceErrorMessageResponse>> PrepareAsyncrenderDeviceErrorMessage(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_renderDeviceErrorMessageRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_renderDeviceErrorMessageResponse>>(PrepareAsyncrenderDeviceErrorMessageRaw(context, request, cq));
    }
    // / Saves the current render device configuration (device activity and priority usage in the
    // / Octane preferences, which are shared between Octane Standalone and all plugins)
    virtual ::grpc::Status saveRenderDeviceConfig(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveRenderDeviceConfigRequest& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncsaveRenderDeviceConfig(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveRenderDeviceConfigRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncsaveRenderDeviceConfigRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncsaveRenderDeviceConfig(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveRenderDeviceConfigRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncsaveRenderDeviceConfigRaw(context, request, cq));
    }
    // / Returns true if out-of-core textures are enabled
    virtual ::grpc::Status outOfCoreEnabled(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_outOfCoreEnabledRequest& request, ::octaneapi::ApiRenderEngine_outOfCoreEnabledResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_outOfCoreEnabledResponse>> AsyncoutOfCoreEnabled(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_outOfCoreEnabledRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_outOfCoreEnabledResponse>>(AsyncoutOfCoreEnabledRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_outOfCoreEnabledResponse>> PrepareAsyncoutOfCoreEnabled(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_outOfCoreEnabledRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_outOfCoreEnabledResponse>>(PrepareAsyncoutOfCoreEnabledRaw(context, request, cq));
    }
    // / Enable out-of-core textures and geometry, or update the maximum amount of system memory
    // / to allow for use
    virtual ::grpc::Status enableOutOfCore(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_enableOutOfCoreRequest& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncenableOutOfCore(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_enableOutOfCoreRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncenableOutOfCoreRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncenableOutOfCore(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_enableOutOfCoreRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncenableOutOfCoreRaw(context, request, cq));
    }
    // / Disables out-of-core
    virtual ::grpc::Status disableOutOfCore(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_disableOutOfCoreRequest& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncdisableOutOfCore(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_disableOutOfCoreRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncdisableOutOfCoreRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncdisableOutOfCore(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_disableOutOfCoreRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncdisableOutOfCoreRaw(context, request, cq));
    }
    // / Returns RAM usage by out-of-core textures
    virtual ::grpc::Status getOutOfCoreMemoryUsage(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getOutOfCoreMemoryUsageRequest& request, ::octaneapi::ApiRenderEngine_getOutOfCoreMemoryUsageResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getOutOfCoreMemoryUsageResponse>> AsyncgetOutOfCoreMemoryUsage(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getOutOfCoreMemoryUsageRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getOutOfCoreMemoryUsageResponse>>(AsyncgetOutOfCoreMemoryUsageRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getOutOfCoreMemoryUsageResponse>> PrepareAsyncgetOutOfCoreMemoryUsage(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getOutOfCoreMemoryUsageRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getOutOfCoreMemoryUsageResponse>>(PrepareAsyncgetOutOfCoreMemoryUsageRaw(context, request, cq));
    }
    // / To run the render kernels successfully, there needs to be some amount of free GPU memory
    virtual ::grpc::Status setGpuHeadroom(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setGpuHeadroomRequest& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncsetGpuHeadroom(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setGpuHeadroomRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncsetGpuHeadroomRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncsetGpuHeadroom(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setGpuHeadroomRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncsetGpuHeadroomRaw(context, request, cq));
    }
    // / Gets the GPU headroom value
    virtual ::grpc::Status getGpuHeadroom(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getGpuHeadroomRequest& request, ::octaneapi::ApiRenderEngine_getGpuHeadroomResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getGpuHeadroomResponse>> AsyncgetGpuHeadroom(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getGpuHeadroomRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getGpuHeadroomResponse>>(AsyncgetGpuHeadroomRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getGpuHeadroomResponse>> PrepareAsyncgetGpuHeadroom(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getGpuHeadroomRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getGpuHeadroomResponse>>(PrepareAsyncgetGpuHeadroomRaw(context, request, cq));
    }
    // / Sets the maximum number of system cores to use for the following subsystems:
    // / 1
    virtual ::grpc::Status setCoreLimit(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setCoreLimitRequest& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncsetCoreLimit(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setCoreLimitRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncsetCoreLimitRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncsetCoreLimit(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setCoreLimitRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncsetCoreLimitRaw(context, request, cq));
    }
    // / Disables the core limit, meaning Octane will use all cores available for the subsystems
    // / listed in the comments above on setCoreLimit()
    virtual ::grpc::Status disableCoreLimit(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_disableCoreLimitRequest& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncdisableCoreLimit(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_disableCoreLimitRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncdisableCoreLimitRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncdisableCoreLimit(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_disableCoreLimitRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncdisableCoreLimitRaw(context, request, cq));
    }
    // / Registers a shared surface to be used for compositor input
    virtual ::grpc::Status registerInputSharedSurface(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_registerInputSharedSurfaceRequest& request, ::octaneapi::ApiRenderEngine_registerInputSharedSurfaceResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_registerInputSharedSurfaceResponse>> AsyncregisterInputSharedSurface(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_registerInputSharedSurfaceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_registerInputSharedSurfaceResponse>>(AsyncregisterInputSharedSurfaceRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_registerInputSharedSurfaceResponse>> PrepareAsyncregisterInputSharedSurface(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_registerInputSharedSurfaceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_registerInputSharedSurfaceResponse>>(PrepareAsyncregisterInputSharedSurfaceRaw(context, request, cq));
    }
    // / Unregisters an input shared surface that was registered with registerInputSharedSurface
    virtual ::grpc::Status unregisterInputSharedSurface(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_unregisterInputSharedSurfaceRequest& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncunregisterInputSharedSurface(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_unregisterInputSharedSurfaceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncunregisterInputSharedSurfaceRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncunregisterInputSharedSurface(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_unregisterInputSharedSurfaceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncunregisterInputSharedSurfaceRaw(context, request, cq));
    }
    // / Causes an asynchronous tonemap operation to run even if one wouldn't otherwise have been
    // / run
    virtual ::grpc::Status triggerAsyncTonemap(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_triggerAsyncTonemapRequest& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsynctriggerAsyncTonemap(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_triggerAsyncTonemapRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsynctriggerAsyncTonemapRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsynctriggerAsyncTonemap(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_triggerAsyncTonemapRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsynctriggerAsyncTonemapRaw(context, request, cq));
    }
    // / Sets the shared surface output type and whether to use real time mode
    virtual ::grpc::Status setSharedSurfaceOutputType(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setSharedSurfaceOutputTypeRequest& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncsetSharedSurfaceOutputType(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setSharedSurfaceOutputTypeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncsetSharedSurfaceOutputTypeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncsetSharedSurfaceOutputType(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setSharedSurfaceOutputTypeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncsetSharedSurfaceOutputTypeRaw(context, request, cq));
    }
    // / Gets the current shared surface output type
    virtual ::grpc::Status getSharedSurfaceOutputType(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getSharedSurfaceOutputTypeRequest& request, ::octaneapi::ApiRenderEngine_getSharedSurfaceOutputTypeResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getSharedSurfaceOutputTypeResponse>> AsyncgetSharedSurfaceOutputType(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getSharedSurfaceOutputTypeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getSharedSurfaceOutputTypeResponse>>(AsyncgetSharedSurfaceOutputTypeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getSharedSurfaceOutputTypeResponse>> PrepareAsyncgetSharedSurfaceOutputType(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getSharedSurfaceOutputTypeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getSharedSurfaceOutputTypeResponse>>(PrepareAsyncgetSharedSurfaceOutputTypeRaw(context, request, cq));
    }
    // / Gets whether the renderer is in real time mode
    virtual ::grpc::Status getRealTime(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRealTimeRequest& request, ::octaneapi::ApiRenderEngine_getRealTimeResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getRealTimeResponse>> AsyncgetRealTime(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRealTimeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getRealTimeResponse>>(AsyncgetRealTimeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getRealTimeResponse>> PrepareAsyncgetRealTime(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRealTimeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getRealTimeResponse>>(PrepareAsyncgetRealTimeRaw(context, request, cq));
    }
    // / Pauses rendering
    virtual ::grpc::Status pauseRendering(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_pauseRenderingRequest& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncpauseRendering(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_pauseRenderingRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncpauseRenderingRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncpauseRendering(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_pauseRenderingRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncpauseRenderingRaw(context, request, cq));
    }
    // / Continues rendering
    virtual ::grpc::Status continueRendering(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_continueRenderingRequest& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsynccontinueRendering(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_continueRenderingRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsynccontinueRenderingRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsynccontinueRendering(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_continueRenderingRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsynccontinueRenderingRaw(context, request, cq));
    }
    // / Returns TRUE if rendering is currently paused
    virtual ::grpc::Status isRenderingPaused(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isRenderingPausedRequest& request, ::octaneapi::ApiRenderEngine_isRenderingPausedResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_isRenderingPausedResponse>> AsyncisRenderingPaused(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isRenderingPausedRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_isRenderingPausedResponse>>(AsyncisRenderingPausedRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_isRenderingPausedResponse>> PrepareAsyncisRenderingPaused(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isRenderingPausedRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_isRenderingPausedResponse>>(PrepareAsyncisRenderingPausedRaw(context, request, cq));
    }
    // / Restarts the rendering, i
    virtual ::grpc::Status restartRendering(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_restartRenderingRequest& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncrestartRendering(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_restartRenderingRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncrestartRenderingRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncrestartRendering(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_restartRenderingRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncrestartRenderingRaw(context, request, cq));
    }
    // / Stops the rendering completely, i
    virtual ::grpc::Status stopRendering(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_stopRenderingRequest& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncstopRendering(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_stopRenderingRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncstopRenderingRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncstopRendering(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_stopRenderingRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncstopRenderingRaw(context, request, cq));
    }
    // / Shoots a viewing ray from the camera through the specified pixel and records all
    // / intersections with the scene ordered by distance from camera
    virtual ::grpc::Status pick(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_pickRequest& request, ::octaneapi::ApiRenderEngine_pickResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_pickResponse>> Asyncpick(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_pickRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_pickResponse>>(AsyncpickRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_pickResponse>> PrepareAsyncpick(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_pickRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_pickResponse>>(PrepareAsyncpickRaw(context, request, cq));
    }
    // / 
    virtual ::grpc::Status pickWhitePoint(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_pickWhitePointRequest& request, ::octaneapi::ApiRenderEngine_pickWhitePointResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_pickWhitePointResponse>> AsyncpickWhitePoint(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_pickWhitePointRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_pickWhitePointResponse>>(AsyncpickWhitePointRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_pickWhitePointResponse>> PrepareAsyncpickWhitePoint(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_pickWhitePointRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_pickWhitePointResponse>>(PrepareAsyncpickWhitePointRaw(context, request, cq));
    }
    // / Determines the average color around a specified location in the main beauty pass and
    // / calculates the required color to white balance those pixels, i
    virtual ::grpc::Status pickImagerWhitePoint(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_pickImagerWhitePointRequest& request, ::octaneapi::ApiRenderEngine_pickImagerWhitePointResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_pickImagerWhitePointResponse>> AsyncpickImagerWhitePoint(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_pickImagerWhitePointRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_pickImagerWhitePointResponse>>(AsyncpickImagerWhitePointRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_pickImagerWhitePointResponse>> PrepareAsyncpickImagerWhitePoint(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_pickImagerWhitePointRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_pickImagerWhitePointResponse>>(PrepareAsyncpickImagerWhitePointRaw(context, request, cq));
    }
    // / Checks whether a white point is pickable for a given output AOV and "Adjust white balance"
    // / output AOV layer node
    virtual ::grpc::Status isOutputAovWhitePointPickable(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isOutputAovWhitePointPickableRequest& request, ::octaneapi::ApiRenderEngine_isOutputAovWhitePointPickableResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_isOutputAovWhitePointPickableResponse>> AsyncisOutputAovWhitePointPickable(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isOutputAovWhitePointPickableRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_isOutputAovWhitePointPickableResponse>>(AsyncisOutputAovWhitePointPickableRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_isOutputAovWhitePointPickableResponse>> PrepareAsyncisOutputAovWhitePointPickable(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isOutputAovWhitePointPickableRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_isOutputAovWhitePointPickableResponse>>(PrepareAsyncisOutputAovWhitePointPickableRaw(context, request, cq));
    }
    // / Determines the average color around a specified location before applying an "Adjust white
    // / balance" output AOV layer while compositing an output AOV, and calculates the required white
    // / point to use for the layer so that it will make that location neutral
    virtual ::grpc::Status pickOutputAovWhitePoint(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_pickOutputAovWhitePointRequest& request, ::octaneapi::ApiRenderEngine_pickOutputAovWhitePointResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_pickOutputAovWhitePointResponse>> AsyncpickOutputAovWhitePoint(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_pickOutputAovWhitePointRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_pickOutputAovWhitePointResponse>>(AsyncpickOutputAovWhitePointRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_pickOutputAovWhitePointResponse>> PrepareAsyncpickOutputAovWhitePoint(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_pickOutputAovWhitePointRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_pickOutputAovWhitePointResponse>>(PrepareAsyncpickOutputAovWhitePointRaw(context, request, cq));
    }
    // / Gets the name of the cryptomatte matte with the most coverage at a given position
    virtual ::grpc::Status pickCryptomatteMatte(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_pickCryptomatteMatteRequest& request, ::octaneapi::ApiRenderEngine_pickCryptomatteMatteResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_pickCryptomatteMatteResponse>> AsyncpickCryptomatteMatte(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_pickCryptomatteMatteRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_pickCryptomatteMatteResponse>>(AsyncpickCryptomatteMatteRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_pickCryptomatteMatteResponse>> PrepareAsyncpickCryptomatteMatte(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_pickCryptomatteMatteRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_pickCryptomatteMatteResponse>>(PrepareAsyncpickCryptomatteMatteRaw(context, request, cq));
    }
    // / Modifies a cryptomatte matte selection string (e
    virtual ::grpc::Status modifyCryptomatteMatteSelection(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_modifyCryptomatteMatteSelectionRequest& request, ::octaneapi::ApiRenderEngine_modifyCryptomatteMatteSelectionResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_modifyCryptomatteMatteSelectionResponse>> AsyncmodifyCryptomatteMatteSelection(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_modifyCryptomatteMatteSelectionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_modifyCryptomatteMatteSelectionResponse>>(AsyncmodifyCryptomatteMatteSelectionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_modifyCryptomatteMatteSelectionResponse>> PrepareAsyncmodifyCryptomatteMatteSelection(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_modifyCryptomatteMatteSelectionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_modifyCryptomatteMatteSelectionResponse>>(PrepareAsyncmodifyCryptomatteMatteSelectionRaw(context, request, cq));
    }
    // / Returns a human readable string for a render priority
    virtual ::grpc::Status toString(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_toStringRequest& request, ::octaneapi::ApiRenderEngine_toStringResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_toStringResponse>> AsynctoString(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_toStringRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_toStringResponse>>(AsynctoStringRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_toStringResponse>> PrepareAsynctoString(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_toStringRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_toStringResponse>>(PrepareAsynctoStringRaw(context, request, cq));
    }
    // / Returns PCI bus and device ids of the device
    // /
    // / 
    virtual ::grpc::Status getDevicePciIds(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getDevicePciIdsRequest& request, ::octaneapi::ApiRenderEngine_getDevicePciIdsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getDevicePciIdsResponse>> AsyncgetDevicePciIds(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getDevicePciIdsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getDevicePciIdsResponse>>(AsyncgetDevicePciIdsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getDevicePciIdsResponse>> PrepareAsyncgetDevicePciIds(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getDevicePciIdsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getDevicePciIdsResponse>>(PrepareAsyncgetDevicePciIdsRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      // / Sets the render target node that should be rendered
      virtual void setRenderTargetNode(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setRenderTargetNodeRequest* request, ::octaneapi::ApiRenderEngine_setRenderTargetNodeResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void setRenderTargetNode(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setRenderTargetNodeRequest* request, ::octaneapi::ApiRenderEngine_setRenderTargetNodeResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Returns render target node that's currently being rendered (can be NULL)
      virtual void getRenderTargetNode(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRenderTargetNodeRequest* request, ::octaneapi::ApiRenderEngine_getRenderTargetNodeResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void getRenderTargetNode(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRenderTargetNodeRequest* request, ::octaneapi::ApiRenderEngine_getRenderTargetNodeResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Returns the geometry root node that's currently being rendered (can be NULL)
      virtual void getRenderGeometryNode(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRenderGeometryNodeRequest* request, ::octaneapi::ApiRenderEngine_getRenderGeometryNodeResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void getRenderGeometryNode(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRenderGeometryNodeRequest* request, ::octaneapi::ApiRenderEngine_getRenderGeometryNodeResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Returns the camera node that's currently being rendered (can be NULL)
      virtual void getRenderCameraNode(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRenderCameraNodeRequest* request, ::octaneapi::ApiRenderEngine_getRenderCameraNodeResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void getRenderCameraNode(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRenderCameraNodeRequest* request, ::octaneapi::ApiRenderEngine_getRenderCameraNodeResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Sets the render region
      virtual void setRenderRegion(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setRenderRegionRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void setRenderRegion(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setRenderRegionRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Fetches the current render region settings
      virtual void getRenderRegion(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRenderRegionRequest* request, ::octaneapi::ApiRenderEngine_getRenderRegionResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void getRenderRegion(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRenderRegionRequest* request, ::octaneapi::ApiRenderEngine_getRenderRegionResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Sets parameters for asynchronous tonemapping
      virtual void setAsyncTonemapParams(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setAsyncTonemapParamsRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void setAsyncTonemapParams(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setAsyncTonemapParamsRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Convenience overload that does the same thing as:
      // /
      // /     auto info = ApiOutputColorSpaceInfo::createKnownColorSpace(colorSpace, false);
      // /     setAsyncTonemapParams(
      virtual void setAsyncTonemapParams1(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setAsyncTonemapParams1Request* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void setAsyncTonemapParams1(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setAsyncTonemapParams1Request* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Returns the current asynchronous tonemap buffer type
      virtual void asyncTonemapBufferType(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_asyncTonemapBufferTypeRequest* request, ::octaneapi::ApiRenderEngine_asyncTonemapBufferTypeResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void asyncTonemapBufferType(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_asyncTonemapBufferTypeRequest* request, ::octaneapi::ApiRenderEngine_asyncTonemapBufferTypeResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Returns the current value of whether to apply false color to cryptomatte passes for
      // / asynchronous tonemapping
      virtual void asyncTonemapCryptomatteFalseColor(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_asyncTonemapCryptomatteFalseColorRequest* request, ::octaneapi::ApiRenderEngine_asyncTonemapCryptomatteFalseColorResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void asyncTonemapCryptomatteFalseColor(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_asyncTonemapCryptomatteFalseColorRequest* request, ::octaneapi::ApiRenderEngine_asyncTonemapCryptomatteFalseColorResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Returns the current asynchronous tonemap output color space info
      virtual void asyncTonemapOutputColorSpaceInfo(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_asyncTonemapOutputColorSpaceInfoRequest* request, ::octaneapi::ApiRenderEngine_asyncTonemapOutputColorSpaceInfoResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void asyncTonemapOutputColorSpaceInfo(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_asyncTonemapOutputColorSpaceInfoRequest* request, ::octaneapi::ApiRenderEngine_asyncTonemapOutputColorSpaceInfoResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Returns the current asynchronous tonemap output color space
      virtual void asyncTonemapColorSpace(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_asyncTonemapColorSpaceRequest* request, ::octaneapi::ApiRenderEngine_asyncTonemapColorSpaceResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void asyncTonemapColorSpace(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_asyncTonemapColorSpaceRequest* request, ::octaneapi::ApiRenderEngine_asyncTonemapColorSpaceResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Returns the current asynchronous tonemap premultiplied alpha type
      virtual void asyncTonemapPremultipliedAlphaType(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_asyncTonemapPremultipliedAlphaTypeRequest* request, ::octaneapi::ApiRenderEngine_asyncTonemapPremultipliedAlphaTypeResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void asyncTonemapPremultipliedAlphaType(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_asyncTonemapPremultipliedAlphaTypeRequest* request, ::octaneapi::ApiRenderEngine_asyncTonemapPremultipliedAlphaTypeResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Sets the render passes that are tonemapped all the time
      virtual void setAsyncTonemapRenderPasses(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setAsyncTonemapRenderPassesRequest* request, ::octaneapi::ApiRenderEngine_setAsyncTonemapRenderPassesResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void setAsyncTonemapRenderPasses(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setAsyncTonemapRenderPassesRequest* request, ::octaneapi::ApiRenderEngine_setAsyncTonemapRenderPassesResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Returns the set of tonemap render passes
      virtual void asyncTonemapRenderPasses(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_asyncTonemapRenderPassesRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void asyncTonemapRenderPasses(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_asyncTonemapRenderPassesRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Returns the render AOVs and output AOVs that are enabled in the specified render target
      // / node as a set of render pass IDs
      virtual void getEnabledAovs(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getEnabledAovsRequest* request, ::octaneapi::ApiRenderEngine_getEnabledAovsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void getEnabledAovs(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getEnabledAovsRequest* request, ::octaneapi::ApiRenderEngine_getEnabledAovsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Frees the set of tonemap passes returned by 
      virtual void freeTonemapPasses(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_freeTonemapPassesRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void freeTonemapPasses(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_freeTonemapPassesRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Returns the display pass in the current render
      virtual void displayRenderPassId(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_displayRenderPassIdRequest* request, ::octaneapi::ApiRenderEngine_displayRenderPassIdResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void displayRenderPassId(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_displayRenderPassIdRequest* request, ::octaneapi::ApiRenderEngine_displayRenderPassIdResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Sets the sub-sampling mode
      virtual void setSubSampleMode(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setSubSampleModeRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void setSubSampleMode(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setSubSampleModeRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Returns the current sub-sampling mode
      virtual void getSubSampleMode(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getSubSampleModeRequest* request, ::octaneapi::ApiRenderEngine_getSubSampleModeResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void getSubSampleMode(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getSubSampleModeRequest* request, ::octaneapi::ApiRenderEngine_getSubSampleModeResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Sets the current clay render mode
      virtual void setClayMode(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setClayModeRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void setClayMode(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setClayModeRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Returns the current clay mode
      virtual void clayMode(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_clayModeRequest* request, ::octaneapi::ApiRenderEngine_clayModeResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void clayMode(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_clayModeRequest* request, ::octaneapi::ApiRenderEngine_clayModeResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Returns the current fps
      virtual void fps(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_fpsRequest* request, ::octaneapi::ApiRenderEngine_fpsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void fps(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_fpsRequest* request, ::octaneapi::ApiRenderEngine_fpsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Sets the current fps
      virtual void setFps(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setFpsRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void setFps(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setFpsRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Returns TRUE if the render engine is currently running a compilation job
      virtual void isCompiling(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isCompilingRequest* request, ::octaneapi::ApiRenderEngine_isCompilingResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void isCompiling(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isCompilingRequest* request, ::octaneapi::ApiRenderEngine_isCompilingResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Deprecated, this returns the same value as hasPendingRenderData()
      virtual void isCompressingTextures(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isCompressingTexturesRequest* request, ::octaneapi::ApiRenderEngine_isCompressingTexturesResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void isCompressingTextures(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isCompressingTexturesRequest* request, ::octaneapi::ApiRenderEngine_isCompressingTexturesResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Returns TRUE if there is render data that has not finished compiling
      virtual void hasPendingRenderData(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_hasPendingRenderDataRequest* request, ::octaneapi::ApiRenderEngine_hasPendingRenderDataResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void hasPendingRenderData(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_hasPendingRenderDataRequest* request, ::octaneapi::ApiRenderEngine_hasPendingRenderDataResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Returns the change level after the last update
      virtual void getCurrentChangeLevel(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getCurrentChangeLevelRequest* request, ::octaneapi::ApiRenderEngine_getCurrentChangeLevelResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void getCurrentChangeLevel(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getCurrentChangeLevelRequest* request, ::octaneapi::ApiRenderEngine_getCurrentChangeLevelResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Returns the change level of the last rendered image, which can be lower than
      // / getCurrentChangeLevel()
      virtual void getRenderImageChangeLevel(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRenderImageChangeLevelRequest* request, ::octaneapi::ApiRenderEngine_getRenderImageChangeLevelResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void getRenderImageChangeLevel(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRenderImageChangeLevelRequest* request, ::octaneapi::ApiRenderEngine_getRenderImageChangeLevelResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Returns the change level of the last time the rendering was restarted
      virtual void getRenderRestartedChangeLevel(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRenderRestartedChangeLevelRequest* request, ::octaneapi::ApiRenderEngine_getRenderRestartedChangeLevelResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void getRenderRestartedChangeLevel(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRenderRestartedChangeLevelRequest* request, ::octaneapi::ApiRenderEngine_getRenderRestartedChangeLevelResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Registers an asynchronous update callback
      virtual void setAsyncUpdateCallback(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setAsyncUpdateCallbackRequest* request, ::octaneapi::ApiRenderEngine_setAsyncUpdateCallbackResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void setAsyncUpdateCallback(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setAsyncUpdateCallbackRequest* request, ::octaneapi::ApiRenderEngine_setAsyncUpdateCallbackResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Checks if updates are done asynchronously
      virtual void updatesAreAsync(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_updatesAreAsyncRequest* request, ::octaneapi::ApiRenderEngine_updatesAreAsyncResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void updatesAreAsync(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_updatesAreAsyncRequest* request, ::octaneapi::ApiRenderEngine_updatesAreAsyncResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / 
      virtual void isImageReady(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isImageReadyRequest* request, ::octaneapi::ApiRenderEngine_isImageReadyResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void isImageReady(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isImageReadyRequest* request, ::octaneapi::ApiRenderEngine_isImageReadyResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void resetImageReady(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_resetImageReadyRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void resetImageReady(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_resetImageReadyRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void isRenderFailure(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isRenderFailureRequest* request, ::octaneapi::ApiRenderEngine_isRenderFailureResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void isRenderFailure(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isRenderFailureRequest* request, ::octaneapi::ApiRenderEngine_isRenderFailureResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void resetRenderFailure(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_resetRenderFailureRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void resetRenderFailure(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_resetRenderFailureRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Registers a callback with the render target that is called when a tile was blended in one
      // / of the two render films and the render statistics did not change
      virtual void setOnTileBlendedCallback(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setOnTileBlendedCallbackRequest* request, ::octaneapi::ApiRenderEngine_setOnTileBlendedCallbackResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void setOnTileBlendedCallback(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setOnTileBlendedCallbackRequest* request, ::octaneapi::ApiRenderEngine_setOnTileBlendedCallbackResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Registers a callback with the render target that is called when the statistics in the
      // / render target changed
      virtual void setOnNewStatisticsCallback(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setOnNewStatisticsCallbackRequest* request, ::octaneapi::ApiRenderEngine_setOnNewStatisticsCallbackResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void setOnNewStatisticsCallback(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setOnNewStatisticsCallbackRequest* request, ::octaneapi::ApiRenderEngine_setOnNewStatisticsCallbackResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Registers a callback with the render target that is called when a new tonemapped result
      // / is available
      virtual void setOnNewImageCallback(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setOnNewImageCallbackRequest* request, ::octaneapi::ApiRenderEngine_setOnNewImageCallbackResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void setOnNewImageCallback(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setOnNewImageCallbackRequest* request, ::octaneapi::ApiRenderEngine_setOnNewImageCallbackResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Registers a callback with the render target that is called when OCIO errors are encountered
      // / when updating render data
      virtual void setOnOcioErrorCallback(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setOnOcioErrorCallbackRequest* request, ::octaneapi::ApiRenderEngine_setOnOcioErrorCallbackResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void setOnOcioErrorCallback(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setOnOcioErrorCallbackRequest* request, ::octaneapi::ApiRenderEngine_setOnOcioErrorCallbackResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Registers a callback with the render target that is called when rendering fails
      virtual void setOnRenderFailureCallback(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setOnRenderFailureCallbackRequest* request, ::octaneapi::ApiRenderEngine_setOnRenderFailureCallbackResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void setOnRenderFailureCallback(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setOnRenderFailureCallbackRequest* request, ::octaneapi::ApiRenderEngine_setOnRenderFailureCallbackResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Forces render engine callbacks to be made in render threads instead of the main message
      // / thread
      virtual void setForceCallbacksInRenderThreads(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setForceCallbacksInRenderThreadsRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void setForceCallbacksInRenderThreads(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setForceCallbacksInRenderThreadsRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Grabs the latest render result in the passed in array
      virtual void grabRenderResult(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_grabRenderResultRequest* request, ::octaneapi::ApiRenderEngine_grabRenderResultResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void grabRenderResult(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_grabRenderResultRequest* request, ::octaneapi::ApiRenderEngine_grabRenderResultResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Releases the results again so that the engine can reuse it
      virtual void releaseRenderResult(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_releaseRenderResultRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void releaseRenderResult(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_releaseRenderResultRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Runs a synchronous tonemap and returns the result
      virtual void synchronousTonemap(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_synchronousTonemapRequest* request, ::octaneapi::ApiRenderEngine_synchronousTonemapResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void synchronousTonemap(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_synchronousTonemapRequest* request, ::octaneapi::ApiRenderEngine_synchronousTonemapResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Convenience overload that does the same thing as:
      // /
      // /     auto info = ApiOutputColorSpaceInfo::createKnownColorSpace(colorSpace, false);
      // /     auto result = synchronousTonemap(
      virtual void synchronousTonemap1(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_synchronousTonemap1Request* request, ::octaneapi::ApiRenderEngine_synchronousTonemap1Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void synchronousTonemap1(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_synchronousTonemap1Request* request, ::octaneapi::ApiRenderEngine_synchronousTonemap1Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Runs a synchronous tonemap for all render passes that are already started by the render 
      // / engine and returns the results
      virtual void synchronousTonemapAllRenderPasses(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPassesRequest* request, ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPassesResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void synchronousTonemapAllRenderPasses(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPassesRequest* request, ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPassesResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Convenience overload that does the same thing as:
      // /
      // /     auto info = ApiOutputColorSpaceInfo::createKnownColorSpace(colorSpace, false);
      // /     auto result = synchronousTonemapAllRenderPasses(
      virtual void synchronousTonemapAllRenderPasses1(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPasses1Request* request, ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPasses1Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void synchronousTonemapAllRenderPasses1(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPasses1Request* request, ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPasses1Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Returns the statistics for the current render progress
      virtual void getRenderStatistics(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRenderStatisticsRequest* request, ::octaneapi::ApiRenderEngine_getRenderStatisticsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void getRenderStatistics(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRenderStatisticsRequest* request, ::octaneapi::ApiRenderEngine_getRenderStatisticsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Returns the statistics for the render results
      virtual void getRenderResultStatistics(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRenderResultStatisticsRequest* request, ::octaneapi::ApiRenderEngine_getRenderResultStatisticsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void getRenderResultStatistics(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRenderResultStatisticsRequest* request, ::octaneapi::ApiRenderEngine_getRenderResultStatisticsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Saves the current result of the render target to the specified file
      virtual void saveImage(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveImageRequest* request, ::octaneapi::ApiRenderEngine_saveImageResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void saveImage(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveImageRequest* request, ::octaneapi::ApiRenderEngine_saveImageResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Convenience overload that does the same thing as:
      // /
      // /     auto info = ApiOutputColorSpaceInfo::createKnownColorSpace(colorSpace, false);
      // /     auto result = saveImage(
      virtual void saveImage1(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveImage1Request* request, ::octaneapi::ApiRenderEngine_saveImage1Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void saveImage1(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveImage1Request* request, ::octaneapi::ApiRenderEngine_saveImage1Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Saves the current result of the render target to the specified file using provided export settings
      // /
      // / 
      virtual void saveImage2(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveImage2Request* request, ::octaneapi::ApiRenderEngine_saveImage2Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void saveImage2(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveImage2Request* request, ::octaneapi::ApiRenderEngine_saveImage2Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Saves the render passes as discrete files in the provided output directory
      virtual void saveRenderPasses(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveRenderPassesRequest* request, ::octaneapi::ApiRenderEngine_saveRenderPassesResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void saveRenderPasses(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveRenderPassesRequest* request, ::octaneapi::ApiRenderEngine_saveRenderPassesResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Convenience overload that does the same thing as:
      // /
      // /     auto info = ApiOutputColorSpaceInfo::createKnownColorSpace(colorSpace, false);
      // /     auto result = saveRenderPasses(
      virtual void saveRenderPasses1(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveRenderPasses1Request* request, ::octaneapi::ApiRenderEngine_saveRenderPasses1Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void saveRenderPasses1(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveRenderPasses1Request* request, ::octaneapi::ApiRenderEngine_saveRenderPasses1Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Saves the render passes as discrete files in the provided output directory
      virtual void saveRenderPasses2(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveRenderPasses2Request* request, ::octaneapi::ApiRenderEngine_saveRenderPasses2Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void saveRenderPasses2(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveRenderPasses2Request* request, ::octaneapi::ApiRenderEngine_saveRenderPasses2Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Saves the render passes in a multi layer EXR file
      virtual void saveRenderPassesMultiExr(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExrRequest* request, ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExrResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void saveRenderPassesMultiExr(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExrRequest* request, ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExrResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Convenience overload that does the same thing as:
      // /
      // /     auto info = ApiOutputColorSpaceInfo::createKnownColorSpace(colorSpace, false);
      // /     auto result = saveRenderPassesMultiExr(
      virtual void saveRenderPassesMultiExr1(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExr1Request* request, ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExr1Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void saveRenderPassesMultiExr1(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExr1Request* request, ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExr1Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Saves the render passes in a deep image EXR file
      virtual void saveRenderPassesDeepExr(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveRenderPassesDeepExrRequest* request, ::octaneapi::ApiRenderEngine_saveRenderPassesDeepExrResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void saveRenderPassesDeepExr(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveRenderPassesDeepExrRequest* request, ::octaneapi::ApiRenderEngine_saveRenderPassesDeepExrResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Checks whether the provided render target both supports and has enabled deep pixel rendering
      virtual void deepImageEnabled(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deepImageEnabledRequest* request, ::octaneapi::ApiRenderEngine_deepImageEnabledResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void deepImageEnabled(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deepImageEnabledRequest* request, ::octaneapi::ApiRenderEngine_deepImageEnabledResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Checks if deep image rendering is enabled for the current render task
      virtual void deepImageEnabled1(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deepImageEnabled1Request* request, ::octaneapi::ApiRenderEngine_deepImageEnabled1Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void deepImageEnabled1(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deepImageEnabled1Request* request, ::octaneapi::ApiRenderEngine_deepImageEnabled1Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Checks if deep image rendering and deep render AOVs are enabled for the current render task
      virtual void deepPassesEnabled(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deepPassesEnabledRequest* request, ::octaneapi::ApiRenderEngine_deepPassesEnabledResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void deepPassesEnabled(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deepPassesEnabledRequest* request, ::octaneapi::ApiRenderEngine_deepPassesEnabledResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Checks if we can save a deep image
      virtual void canSaveDeepImage(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_canSaveDeepImageRequest* request, ::octaneapi::ApiRenderEngine_canSaveDeepImageResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void canSaveDeepImage(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_canSaveDeepImageRequest* request, ::octaneapi::ApiRenderEngine_canSaveDeepImageResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Saves the current render as a deep image
      virtual void saveDeepImage(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveDeepImageRequest* request, ::octaneapi::ApiRenderEngine_saveDeepImageResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void saveDeepImage(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveDeepImageRequest* request, ::octaneapi::ApiRenderEngine_saveDeepImageResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Saves the current render state plus a reference to the project file
      virtual void saveRenderState(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveRenderStateRequest* request, ::octaneapi::ApiRenderEngine_saveRenderStateResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void saveRenderState(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveRenderStateRequest* request, ::octaneapi::ApiRenderEngine_saveRenderStateResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Loads an Octane render state file
      virtual void loadRenderState(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_loadRenderStateRequest* request, ::octaneapi::ApiRenderEngine_loadRenderStateResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void loadRenderState(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_loadRenderStateRequest* request, ::octaneapi::ApiRenderEngine_loadRenderStateResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Renders a preview image of a texture / material node
      virtual void previewMaterial(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_previewMaterialRequest* request, ::octaneapi::ApiRenderEngine_previewMaterialResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void previewMaterial(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_previewMaterialRequest* request, ::octaneapi::ApiRenderEngine_previewMaterialResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Same as above but return HDR buffer
      // /
      // / 
      virtual void previewMaterialHdr(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_previewMaterialHdrRequest* request, ::octaneapi::ApiRenderEngine_previewMaterialHdrResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void previewMaterialHdr(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_previewMaterialHdrRequest* request, ::octaneapi::ApiRenderEngine_previewMaterialHdrResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Preview a material or texture node
      // /
      // / 
      virtual void previewMaterial1(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_previewMaterial1Request* request, ::octaneapi::ApiRenderEngine_previewMaterial1Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void previewMaterial1(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_previewMaterial1Request* request, ::octaneapi::ApiRenderEngine_previewMaterial1Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Returns the overall memory usage of a device
      virtual void getMemoryUsage(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getMemoryUsageRequest* request, ::octaneapi::ApiRenderEngine_getMemoryUsageResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void getMemoryUsage(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getMemoryUsageRequest* request, ::octaneapi::ApiRenderEngine_getMemoryUsageResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Returns memory usage statistics for a device
      // /
      // / 
      virtual void getResourceStatistics(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getResourceStatisticsRequest* request, ::octaneapi::ApiRenderEngine_getResourceStatisticsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void getResourceStatistics(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getResourceStatisticsRequest* request, ::octaneapi::ApiRenderEngine_getResourceStatisticsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Returns the geometry statistics of the current scene
      virtual void getGeometryStatistics(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getGeometryStatisticsRequest* request, ::octaneapi::ApiRenderEngine_getGeometryStatisticsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void getGeometryStatistics(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getGeometryStatisticsRequest* request, ::octaneapi::ApiRenderEngine_getGeometryStatisticsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Returns the texture usage
      virtual void getTexturesStatistics(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getTexturesStatisticsRequest* request, ::octaneapi::ApiRenderEngine_getTexturesStatisticsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void getTexturesStatistics(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getTexturesStatisticsRequest* request, ::octaneapi::ApiRenderEngine_getTexturesStatisticsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / If the currently rendered scene contains geometry, its bounding box is stored in the
      // / provided vectors and TRUE is returned
      virtual void getSceneBounds(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getSceneBoundsRequest* request, ::octaneapi::ApiRenderEngine_getSceneBoundsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void getSceneBounds(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getSceneBoundsRequest* request, ::octaneapi::ApiRenderEngine_getSceneBoundsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Returns the number of render devices (GPUs) in this machine
      virtual void getDeviceCount(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getDeviceCountRequest* request, ::octaneapi::ApiRenderEngine_getDeviceCountResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void getDeviceCount(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getDeviceCountRequest* request, ::octaneapi::ApiRenderEngine_getDeviceCountResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Returns the compute model of the device
      virtual void getDeviceComputeModel(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getDeviceComputeModelRequest* request, ::octaneapi::ApiRenderEngine_getDeviceComputeModelResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void getDeviceComputeModel(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getDeviceComputeModelRequest* request, ::octaneapi::ApiRenderEngine_getDeviceComputeModelResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Returns the name of the device
      virtual void getDeviceName(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getDeviceNameRequest* request, ::octaneapi::ApiRenderEngine_getDeviceNameResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void getDeviceName(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getDeviceNameRequest* request, ::octaneapi::ApiRenderEngine_getDeviceNameResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Returns TRUE if the device with the provided index is supported by Octane, i
      virtual void isSupportedDevice(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isSupportedDeviceRequest* request, ::octaneapi::ApiRenderEngine_isSupportedDeviceResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void isSupportedDevice(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isSupportedDeviceRequest* request, ::octaneapi::ApiRenderEngine_isSupportedDeviceResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Returns TRUE if the device with the provided index can be used for rendering
      virtual void deviceCanRender(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deviceCanRenderRequest* request, ::octaneapi::ApiRenderEngine_deviceCanRenderResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void deviceCanRender(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deviceCanRenderRequest* request, ::octaneapi::ApiRenderEngine_deviceCanRenderResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Returns TRUE if the device with the provided index can be used for denoising
      virtual void deviceCanDenoise(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deviceCanDenoiseRequest* request, ::octaneapi::ApiRenderEngine_deviceCanDenoiseResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void deviceCanDenoise(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deviceCanDenoiseRequest* request, ::octaneapi::ApiRenderEngine_deviceCanDenoiseResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Returns TRUE if the device with the provided index supports hardware ray-tracing
      virtual void deviceSupportsHardwareRayTracing(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deviceSupportsHardwareRayTracingRequest* request, ::octaneapi::ApiRenderEngine_deviceSupportsHardwareRayTracingResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void deviceSupportsHardwareRayTracing(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deviceSupportsHardwareRayTracingRequest* request, ::octaneapi::ApiRenderEngine_deviceSupportsHardwareRayTracingResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Returns details of the shared surface capabilities of the device with the provided index
      virtual void deviceSharedSurfaceInfo(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deviceSharedSurfaceInfoRequest* request, ::octaneapi::ApiRenderEngine_deviceSharedSurfaceInfoResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void deviceSharedSurfaceInfo(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deviceSharedSurfaceInfoRequest* request, ::octaneapi::ApiRenderEngine_deviceSharedSurfaceInfoResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Returns an array of available peer-to-peer (NVlink) pairs
      virtual void getAvailablePeerToPeerPairs(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getAvailablePeerToPeerPairsRequest* request, ::octaneapi::ApiRenderEngine_getAvailablePeerToPeerPairsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void getAvailablePeerToPeerPairs(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getAvailablePeerToPeerPairsRequest* request, ::octaneapi::ApiRenderEngine_getAvailablePeerToPeerPairsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / List of devices to enable for rendering and denoising
      virtual void setDevicesActivity(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setDevicesActivityRequest* request, ::octaneapi::ApiRenderEngine_setDevicesActivityResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void setDevicesActivity(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setDevicesActivityRequest* request, ::octaneapi::ApiRenderEngine_setDevicesActivityResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Returns TRUE if the device is used for rendering
      virtual void isDeviceUsedForRendering(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isDeviceUsedForRenderingRequest* request, ::octaneapi::ApiRenderEngine_isDeviceUsedForRenderingResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void isDeviceUsedForRendering(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isDeviceUsedForRenderingRequest* request, ::octaneapi::ApiRenderEngine_isDeviceUsedForRenderingResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Returns TRUE if the device with index uses render priority
      virtual void deviceUsesPriority(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deviceUsesPriorityRequest* request, ::octaneapi::ApiRenderEngine_deviceUsesPriorityResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void deviceUsesPriority(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deviceUsesPriorityRequest* request, ::octaneapi::ApiRenderEngine_deviceUsesPriorityResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Returns TRUE if the device at the provided index is using hardware ray-tracing
      virtual void deviceUsesHardwareRayTracing(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deviceUsesHardwareRayTracingRequest* request, ::octaneapi::ApiRenderEngine_deviceUsesHardwareRayTracingResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void deviceUsesHardwareRayTracing(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deviceUsesHardwareRayTracingRequest* request, ::octaneapi::ApiRenderEngine_deviceUsesHardwareRayTracingResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Returns the index of the device used for imaging, or -1 if no device is capable
      virtual void imageDeviceIndex(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_imageDeviceIndexRequest* request, ::octaneapi::ApiRenderEngine_imageDeviceIndexResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void imageDeviceIndex(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_imageDeviceIndexRequest* request, ::octaneapi::ApiRenderEngine_imageDeviceIndexResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Returns TRUE if the device is used for denoising
      virtual void isDeviceUsedForDenoising(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isDeviceUsedForDenoisingRequest* request, ::octaneapi::ApiRenderEngine_isDeviceUsedForDenoisingResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void isDeviceUsedForDenoising(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isDeviceUsedForDenoisingRequest* request, ::octaneapi::ApiRenderEngine_isDeviceUsedForDenoisingResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Returns the current render priority
      virtual void renderPriority(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_renderPriorityRequest* request, ::octaneapi::ApiRenderEngine_renderPriorityResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void renderPriority(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_renderPriorityRequest* request, ::octaneapi::ApiRenderEngine_renderPriorityResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Sets the current render priority
      virtual void setRenderPriority(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setRenderPriorityRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void setRenderPriority(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setRenderPriorityRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Returns the current peer-to-peer configuration
      virtual void currentPeerToPeerGroups(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_currentPeerToPeerGroupsRequest* request, ::octaneapi::ApiRenderEngine_currentPeerToPeerGroupsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void currentPeerToPeerGroups(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_currentPeerToPeerGroupsRequest* request, ::octaneapi::ApiRenderEngine_currentPeerToPeerGroupsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Returns TRUE if hardware raytracing is currently enabled for all devices with support for it
      virtual void hardwareRayTracingEnabled(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_hardwareRayTracingEnabledRequest* request, ::octaneapi::ApiRenderEngine_hardwareRayTracingEnabledResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void hardwareRayTracingEnabled(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_hardwareRayTracingEnabledRequest* request, ::octaneapi::ApiRenderEngine_hardwareRayTracingEnabledResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Opens a modal dialog to allow the user to set devices configuration
      virtual void openDeviceSettings(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_openDeviceSettingsRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void openDeviceSettings(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_openDeviceSettingsRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Returns the state of the device
      virtual void renderDeviceState(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_renderDeviceStateRequest* request, ::octaneapi::ApiRenderEngine_renderDeviceStateResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void renderDeviceState(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_renderDeviceStateRequest* request, ::octaneapi::ApiRenderEngine_renderDeviceStateResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Returns the error state of a device or RENDER_ERROR_NONE if the device has not failed or
      // / is not active
      virtual void renderDeviceErrorCode(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_renderDeviceErrorCodeRequest* request, ::octaneapi::ApiRenderEngine_renderDeviceErrorCodeResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void renderDeviceErrorCode(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_renderDeviceErrorCodeRequest* request, ::octaneapi::ApiRenderEngine_renderDeviceErrorCodeResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Returns the error state of a device as string or an empty string if the device is not in an
      // / error state or is not active
      virtual void errorcodeToString(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_errorcodeToStringRequest* request, ::octaneapi::ApiRenderEngine_errorcodeToStringResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void errorcodeToString(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_errorcodeToStringRequest* request, ::octaneapi::ApiRenderEngine_errorcodeToStringResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Returns the (low-level) error message that triggered the device to fail or an empty string
      // / if it hasn't failed or isn't active
      virtual void renderDeviceErrorMessage(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_renderDeviceErrorMessageRequest* request, ::octaneapi::ApiRenderEngine_renderDeviceErrorMessageResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void renderDeviceErrorMessage(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_renderDeviceErrorMessageRequest* request, ::octaneapi::ApiRenderEngine_renderDeviceErrorMessageResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Saves the current render device configuration (device activity and priority usage in the
      // / Octane preferences, which are shared between Octane Standalone and all plugins)
      virtual void saveRenderDeviceConfig(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveRenderDeviceConfigRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void saveRenderDeviceConfig(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveRenderDeviceConfigRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Returns true if out-of-core textures are enabled
      virtual void outOfCoreEnabled(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_outOfCoreEnabledRequest* request, ::octaneapi::ApiRenderEngine_outOfCoreEnabledResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void outOfCoreEnabled(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_outOfCoreEnabledRequest* request, ::octaneapi::ApiRenderEngine_outOfCoreEnabledResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Enable out-of-core textures and geometry, or update the maximum amount of system memory
      // / to allow for use
      virtual void enableOutOfCore(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_enableOutOfCoreRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void enableOutOfCore(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_enableOutOfCoreRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Disables out-of-core
      virtual void disableOutOfCore(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_disableOutOfCoreRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void disableOutOfCore(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_disableOutOfCoreRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Returns RAM usage by out-of-core textures
      virtual void getOutOfCoreMemoryUsage(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getOutOfCoreMemoryUsageRequest* request, ::octaneapi::ApiRenderEngine_getOutOfCoreMemoryUsageResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void getOutOfCoreMemoryUsage(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getOutOfCoreMemoryUsageRequest* request, ::octaneapi::ApiRenderEngine_getOutOfCoreMemoryUsageResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / To run the render kernels successfully, there needs to be some amount of free GPU memory
      virtual void setGpuHeadroom(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setGpuHeadroomRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void setGpuHeadroom(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setGpuHeadroomRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Gets the GPU headroom value
      virtual void getGpuHeadroom(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getGpuHeadroomRequest* request, ::octaneapi::ApiRenderEngine_getGpuHeadroomResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void getGpuHeadroom(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getGpuHeadroomRequest* request, ::octaneapi::ApiRenderEngine_getGpuHeadroomResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Sets the maximum number of system cores to use for the following subsystems:
      // / 1
      virtual void setCoreLimit(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setCoreLimitRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void setCoreLimit(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setCoreLimitRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Disables the core limit, meaning Octane will use all cores available for the subsystems
      // / listed in the comments above on setCoreLimit()
      virtual void disableCoreLimit(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_disableCoreLimitRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void disableCoreLimit(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_disableCoreLimitRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Registers a shared surface to be used for compositor input
      virtual void registerInputSharedSurface(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_registerInputSharedSurfaceRequest* request, ::octaneapi::ApiRenderEngine_registerInputSharedSurfaceResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void registerInputSharedSurface(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_registerInputSharedSurfaceRequest* request, ::octaneapi::ApiRenderEngine_registerInputSharedSurfaceResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Unregisters an input shared surface that was registered with registerInputSharedSurface
      virtual void unregisterInputSharedSurface(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_unregisterInputSharedSurfaceRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void unregisterInputSharedSurface(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_unregisterInputSharedSurfaceRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Causes an asynchronous tonemap operation to run even if one wouldn't otherwise have been
      // / run
      virtual void triggerAsyncTonemap(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_triggerAsyncTonemapRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void triggerAsyncTonemap(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_triggerAsyncTonemapRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Sets the shared surface output type and whether to use real time mode
      virtual void setSharedSurfaceOutputType(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setSharedSurfaceOutputTypeRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void setSharedSurfaceOutputType(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setSharedSurfaceOutputTypeRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Gets the current shared surface output type
      virtual void getSharedSurfaceOutputType(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getSharedSurfaceOutputTypeRequest* request, ::octaneapi::ApiRenderEngine_getSharedSurfaceOutputTypeResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void getSharedSurfaceOutputType(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getSharedSurfaceOutputTypeRequest* request, ::octaneapi::ApiRenderEngine_getSharedSurfaceOutputTypeResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Gets whether the renderer is in real time mode
      virtual void getRealTime(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRealTimeRequest* request, ::octaneapi::ApiRenderEngine_getRealTimeResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void getRealTime(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRealTimeRequest* request, ::octaneapi::ApiRenderEngine_getRealTimeResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Pauses rendering
      virtual void pauseRendering(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_pauseRenderingRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void pauseRendering(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_pauseRenderingRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Continues rendering
      virtual void continueRendering(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_continueRenderingRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void continueRendering(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_continueRenderingRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Returns TRUE if rendering is currently paused
      virtual void isRenderingPaused(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isRenderingPausedRequest* request, ::octaneapi::ApiRenderEngine_isRenderingPausedResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void isRenderingPaused(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isRenderingPausedRequest* request, ::octaneapi::ApiRenderEngine_isRenderingPausedResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Restarts the rendering, i
      virtual void restartRendering(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_restartRenderingRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void restartRendering(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_restartRenderingRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Stops the rendering completely, i
      virtual void stopRendering(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_stopRenderingRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void stopRendering(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_stopRenderingRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Shoots a viewing ray from the camera through the specified pixel and records all
      // / intersections with the scene ordered by distance from camera
      virtual void pick(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_pickRequest* request, ::octaneapi::ApiRenderEngine_pickResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void pick(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_pickRequest* request, ::octaneapi::ApiRenderEngine_pickResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / 
      virtual void pickWhitePoint(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_pickWhitePointRequest* request, ::octaneapi::ApiRenderEngine_pickWhitePointResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void pickWhitePoint(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_pickWhitePointRequest* request, ::octaneapi::ApiRenderEngine_pickWhitePointResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Determines the average color around a specified location in the main beauty pass and
      // / calculates the required color to white balance those pixels, i
      virtual void pickImagerWhitePoint(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_pickImagerWhitePointRequest* request, ::octaneapi::ApiRenderEngine_pickImagerWhitePointResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void pickImagerWhitePoint(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_pickImagerWhitePointRequest* request, ::octaneapi::ApiRenderEngine_pickImagerWhitePointResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Checks whether a white point is pickable for a given output AOV and "Adjust white balance"
      // / output AOV layer node
      virtual void isOutputAovWhitePointPickable(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isOutputAovWhitePointPickableRequest* request, ::octaneapi::ApiRenderEngine_isOutputAovWhitePointPickableResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void isOutputAovWhitePointPickable(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isOutputAovWhitePointPickableRequest* request, ::octaneapi::ApiRenderEngine_isOutputAovWhitePointPickableResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Determines the average color around a specified location before applying an "Adjust white
      // / balance" output AOV layer while compositing an output AOV, and calculates the required white
      // / point to use for the layer so that it will make that location neutral
      virtual void pickOutputAovWhitePoint(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_pickOutputAovWhitePointRequest* request, ::octaneapi::ApiRenderEngine_pickOutputAovWhitePointResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void pickOutputAovWhitePoint(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_pickOutputAovWhitePointRequest* request, ::octaneapi::ApiRenderEngine_pickOutputAovWhitePointResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Gets the name of the cryptomatte matte with the most coverage at a given position
      virtual void pickCryptomatteMatte(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_pickCryptomatteMatteRequest* request, ::octaneapi::ApiRenderEngine_pickCryptomatteMatteResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void pickCryptomatteMatte(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_pickCryptomatteMatteRequest* request, ::octaneapi::ApiRenderEngine_pickCryptomatteMatteResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Modifies a cryptomatte matte selection string (e
      virtual void modifyCryptomatteMatteSelection(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_modifyCryptomatteMatteSelectionRequest* request, ::octaneapi::ApiRenderEngine_modifyCryptomatteMatteSelectionResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void modifyCryptomatteMatteSelection(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_modifyCryptomatteMatteSelectionRequest* request, ::octaneapi::ApiRenderEngine_modifyCryptomatteMatteSelectionResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Returns a human readable string for a render priority
      virtual void toString(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_toStringRequest* request, ::octaneapi::ApiRenderEngine_toStringResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void toString(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_toStringRequest* request, ::octaneapi::ApiRenderEngine_toStringResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Returns PCI bus and device ids of the device
      // /
      // / 
      virtual void getDevicePciIds(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getDevicePciIdsRequest* request, ::octaneapi::ApiRenderEngine_getDevicePciIdsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void getDevicePciIds(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getDevicePciIdsRequest* request, ::octaneapi::ApiRenderEngine_getDevicePciIdsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_setRenderTargetNodeResponse>* AsyncsetRenderTargetNodeRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setRenderTargetNodeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_setRenderTargetNodeResponse>* PrepareAsyncsetRenderTargetNodeRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setRenderTargetNodeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getRenderTargetNodeResponse>* AsyncgetRenderTargetNodeRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRenderTargetNodeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getRenderTargetNodeResponse>* PrepareAsyncgetRenderTargetNodeRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRenderTargetNodeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getRenderGeometryNodeResponse>* AsyncgetRenderGeometryNodeRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRenderGeometryNodeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getRenderGeometryNodeResponse>* PrepareAsyncgetRenderGeometryNodeRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRenderGeometryNodeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getRenderCameraNodeResponse>* AsyncgetRenderCameraNodeRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRenderCameraNodeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getRenderCameraNodeResponse>* PrepareAsyncgetRenderCameraNodeRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRenderCameraNodeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncsetRenderRegionRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setRenderRegionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncsetRenderRegionRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setRenderRegionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getRenderRegionResponse>* AsyncgetRenderRegionRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRenderRegionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getRenderRegionResponse>* PrepareAsyncgetRenderRegionRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRenderRegionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncsetAsyncTonemapParamsRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setAsyncTonemapParamsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncsetAsyncTonemapParamsRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setAsyncTonemapParamsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncsetAsyncTonemapParams1Raw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setAsyncTonemapParams1Request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncsetAsyncTonemapParams1Raw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setAsyncTonemapParams1Request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_asyncTonemapBufferTypeResponse>* AsyncasyncTonemapBufferTypeRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_asyncTonemapBufferTypeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_asyncTonemapBufferTypeResponse>* PrepareAsyncasyncTonemapBufferTypeRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_asyncTonemapBufferTypeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_asyncTonemapCryptomatteFalseColorResponse>* AsyncasyncTonemapCryptomatteFalseColorRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_asyncTonemapCryptomatteFalseColorRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_asyncTonemapCryptomatteFalseColorResponse>* PrepareAsyncasyncTonemapCryptomatteFalseColorRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_asyncTonemapCryptomatteFalseColorRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_asyncTonemapOutputColorSpaceInfoResponse>* AsyncasyncTonemapOutputColorSpaceInfoRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_asyncTonemapOutputColorSpaceInfoRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_asyncTonemapOutputColorSpaceInfoResponse>* PrepareAsyncasyncTonemapOutputColorSpaceInfoRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_asyncTonemapOutputColorSpaceInfoRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_asyncTonemapColorSpaceResponse>* AsyncasyncTonemapColorSpaceRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_asyncTonemapColorSpaceRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_asyncTonemapColorSpaceResponse>* PrepareAsyncasyncTonemapColorSpaceRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_asyncTonemapColorSpaceRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_asyncTonemapPremultipliedAlphaTypeResponse>* AsyncasyncTonemapPremultipliedAlphaTypeRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_asyncTonemapPremultipliedAlphaTypeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_asyncTonemapPremultipliedAlphaTypeResponse>* PrepareAsyncasyncTonemapPremultipliedAlphaTypeRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_asyncTonemapPremultipliedAlphaTypeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_setAsyncTonemapRenderPassesResponse>* AsyncsetAsyncTonemapRenderPassesRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setAsyncTonemapRenderPassesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_setAsyncTonemapRenderPassesResponse>* PrepareAsyncsetAsyncTonemapRenderPassesRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setAsyncTonemapRenderPassesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncasyncTonemapRenderPassesRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_asyncTonemapRenderPassesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncasyncTonemapRenderPassesRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_asyncTonemapRenderPassesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getEnabledAovsResponse>* AsyncgetEnabledAovsRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getEnabledAovsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getEnabledAovsResponse>* PrepareAsyncgetEnabledAovsRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getEnabledAovsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncfreeTonemapPassesRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_freeTonemapPassesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncfreeTonemapPassesRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_freeTonemapPassesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_displayRenderPassIdResponse>* AsyncdisplayRenderPassIdRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_displayRenderPassIdRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_displayRenderPassIdResponse>* PrepareAsyncdisplayRenderPassIdRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_displayRenderPassIdRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncsetSubSampleModeRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setSubSampleModeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncsetSubSampleModeRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setSubSampleModeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getSubSampleModeResponse>* AsyncgetSubSampleModeRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getSubSampleModeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getSubSampleModeResponse>* PrepareAsyncgetSubSampleModeRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getSubSampleModeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncsetClayModeRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setClayModeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncsetClayModeRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setClayModeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_clayModeResponse>* AsyncclayModeRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_clayModeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_clayModeResponse>* PrepareAsyncclayModeRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_clayModeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_fpsResponse>* AsyncfpsRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_fpsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_fpsResponse>* PrepareAsyncfpsRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_fpsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncsetFpsRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setFpsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncsetFpsRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setFpsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_isCompilingResponse>* AsyncisCompilingRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isCompilingRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_isCompilingResponse>* PrepareAsyncisCompilingRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isCompilingRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_isCompressingTexturesResponse>* AsyncisCompressingTexturesRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isCompressingTexturesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_isCompressingTexturesResponse>* PrepareAsyncisCompressingTexturesRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isCompressingTexturesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_hasPendingRenderDataResponse>* AsynchasPendingRenderDataRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_hasPendingRenderDataRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_hasPendingRenderDataResponse>* PrepareAsynchasPendingRenderDataRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_hasPendingRenderDataRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getCurrentChangeLevelResponse>* AsyncgetCurrentChangeLevelRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getCurrentChangeLevelRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getCurrentChangeLevelResponse>* PrepareAsyncgetCurrentChangeLevelRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getCurrentChangeLevelRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getRenderImageChangeLevelResponse>* AsyncgetRenderImageChangeLevelRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRenderImageChangeLevelRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getRenderImageChangeLevelResponse>* PrepareAsyncgetRenderImageChangeLevelRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRenderImageChangeLevelRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getRenderRestartedChangeLevelResponse>* AsyncgetRenderRestartedChangeLevelRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRenderRestartedChangeLevelRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getRenderRestartedChangeLevelResponse>* PrepareAsyncgetRenderRestartedChangeLevelRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRenderRestartedChangeLevelRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_setAsyncUpdateCallbackResponse>* AsyncsetAsyncUpdateCallbackRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setAsyncUpdateCallbackRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_setAsyncUpdateCallbackResponse>* PrepareAsyncsetAsyncUpdateCallbackRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setAsyncUpdateCallbackRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_updatesAreAsyncResponse>* AsyncupdatesAreAsyncRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_updatesAreAsyncRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_updatesAreAsyncResponse>* PrepareAsyncupdatesAreAsyncRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_updatesAreAsyncRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_isImageReadyResponse>* AsyncisImageReadyRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isImageReadyRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_isImageReadyResponse>* PrepareAsyncisImageReadyRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isImageReadyRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncresetImageReadyRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_resetImageReadyRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncresetImageReadyRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_resetImageReadyRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_isRenderFailureResponse>* AsyncisRenderFailureRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isRenderFailureRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_isRenderFailureResponse>* PrepareAsyncisRenderFailureRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isRenderFailureRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncresetRenderFailureRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_resetRenderFailureRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncresetRenderFailureRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_resetRenderFailureRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_setOnTileBlendedCallbackResponse>* AsyncsetOnTileBlendedCallbackRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setOnTileBlendedCallbackRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_setOnTileBlendedCallbackResponse>* PrepareAsyncsetOnTileBlendedCallbackRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setOnTileBlendedCallbackRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_setOnNewStatisticsCallbackResponse>* AsyncsetOnNewStatisticsCallbackRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setOnNewStatisticsCallbackRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_setOnNewStatisticsCallbackResponse>* PrepareAsyncsetOnNewStatisticsCallbackRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setOnNewStatisticsCallbackRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_setOnNewImageCallbackResponse>* AsyncsetOnNewImageCallbackRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setOnNewImageCallbackRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_setOnNewImageCallbackResponse>* PrepareAsyncsetOnNewImageCallbackRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setOnNewImageCallbackRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_setOnOcioErrorCallbackResponse>* AsyncsetOnOcioErrorCallbackRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setOnOcioErrorCallbackRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_setOnOcioErrorCallbackResponse>* PrepareAsyncsetOnOcioErrorCallbackRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setOnOcioErrorCallbackRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_setOnRenderFailureCallbackResponse>* AsyncsetOnRenderFailureCallbackRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setOnRenderFailureCallbackRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_setOnRenderFailureCallbackResponse>* PrepareAsyncsetOnRenderFailureCallbackRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setOnRenderFailureCallbackRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncsetForceCallbacksInRenderThreadsRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setForceCallbacksInRenderThreadsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncsetForceCallbacksInRenderThreadsRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setForceCallbacksInRenderThreadsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_grabRenderResultResponse>* AsyncgrabRenderResultRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_grabRenderResultRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_grabRenderResultResponse>* PrepareAsyncgrabRenderResultRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_grabRenderResultRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncreleaseRenderResultRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_releaseRenderResultRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncreleaseRenderResultRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_releaseRenderResultRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_synchronousTonemapResponse>* AsyncsynchronousTonemapRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_synchronousTonemapRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_synchronousTonemapResponse>* PrepareAsyncsynchronousTonemapRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_synchronousTonemapRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_synchronousTonemap1Response>* AsyncsynchronousTonemap1Raw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_synchronousTonemap1Request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_synchronousTonemap1Response>* PrepareAsyncsynchronousTonemap1Raw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_synchronousTonemap1Request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPassesResponse>* AsyncsynchronousTonemapAllRenderPassesRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPassesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPassesResponse>* PrepareAsyncsynchronousTonemapAllRenderPassesRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPassesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPasses1Response>* AsyncsynchronousTonemapAllRenderPasses1Raw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPasses1Request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPasses1Response>* PrepareAsyncsynchronousTonemapAllRenderPasses1Raw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPasses1Request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getRenderStatisticsResponse>* AsyncgetRenderStatisticsRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRenderStatisticsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getRenderStatisticsResponse>* PrepareAsyncgetRenderStatisticsRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRenderStatisticsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getRenderResultStatisticsResponse>* AsyncgetRenderResultStatisticsRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRenderResultStatisticsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getRenderResultStatisticsResponse>* PrepareAsyncgetRenderResultStatisticsRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRenderResultStatisticsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_saveImageResponse>* AsyncsaveImageRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveImageRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_saveImageResponse>* PrepareAsyncsaveImageRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveImageRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_saveImage1Response>* AsyncsaveImage1Raw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveImage1Request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_saveImage1Response>* PrepareAsyncsaveImage1Raw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveImage1Request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_saveImage2Response>* AsyncsaveImage2Raw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveImage2Request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_saveImage2Response>* PrepareAsyncsaveImage2Raw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveImage2Request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_saveRenderPassesResponse>* AsyncsaveRenderPassesRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveRenderPassesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_saveRenderPassesResponse>* PrepareAsyncsaveRenderPassesRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveRenderPassesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_saveRenderPasses1Response>* AsyncsaveRenderPasses1Raw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveRenderPasses1Request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_saveRenderPasses1Response>* PrepareAsyncsaveRenderPasses1Raw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveRenderPasses1Request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_saveRenderPasses2Response>* AsyncsaveRenderPasses2Raw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveRenderPasses2Request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_saveRenderPasses2Response>* PrepareAsyncsaveRenderPasses2Raw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveRenderPasses2Request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExrResponse>* AsyncsaveRenderPassesMultiExrRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExrRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExrResponse>* PrepareAsyncsaveRenderPassesMultiExrRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExrRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExr1Response>* AsyncsaveRenderPassesMultiExr1Raw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExr1Request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExr1Response>* PrepareAsyncsaveRenderPassesMultiExr1Raw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExr1Request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_saveRenderPassesDeepExrResponse>* AsyncsaveRenderPassesDeepExrRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveRenderPassesDeepExrRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_saveRenderPassesDeepExrResponse>* PrepareAsyncsaveRenderPassesDeepExrRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveRenderPassesDeepExrRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_deepImageEnabledResponse>* AsyncdeepImageEnabledRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deepImageEnabledRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_deepImageEnabledResponse>* PrepareAsyncdeepImageEnabledRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deepImageEnabledRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_deepImageEnabled1Response>* AsyncdeepImageEnabled1Raw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deepImageEnabled1Request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_deepImageEnabled1Response>* PrepareAsyncdeepImageEnabled1Raw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deepImageEnabled1Request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_deepPassesEnabledResponse>* AsyncdeepPassesEnabledRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deepPassesEnabledRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_deepPassesEnabledResponse>* PrepareAsyncdeepPassesEnabledRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deepPassesEnabledRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_canSaveDeepImageResponse>* AsynccanSaveDeepImageRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_canSaveDeepImageRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_canSaveDeepImageResponse>* PrepareAsynccanSaveDeepImageRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_canSaveDeepImageRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_saveDeepImageResponse>* AsyncsaveDeepImageRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveDeepImageRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_saveDeepImageResponse>* PrepareAsyncsaveDeepImageRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveDeepImageRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_saveRenderStateResponse>* AsyncsaveRenderStateRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveRenderStateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_saveRenderStateResponse>* PrepareAsyncsaveRenderStateRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveRenderStateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_loadRenderStateResponse>* AsyncloadRenderStateRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_loadRenderStateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_loadRenderStateResponse>* PrepareAsyncloadRenderStateRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_loadRenderStateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_previewMaterialResponse>* AsyncpreviewMaterialRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_previewMaterialRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_previewMaterialResponse>* PrepareAsyncpreviewMaterialRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_previewMaterialRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_previewMaterialHdrResponse>* AsyncpreviewMaterialHdrRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_previewMaterialHdrRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_previewMaterialHdrResponse>* PrepareAsyncpreviewMaterialHdrRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_previewMaterialHdrRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_previewMaterial1Response>* AsyncpreviewMaterial1Raw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_previewMaterial1Request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_previewMaterial1Response>* PrepareAsyncpreviewMaterial1Raw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_previewMaterial1Request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getMemoryUsageResponse>* AsyncgetMemoryUsageRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getMemoryUsageRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getMemoryUsageResponse>* PrepareAsyncgetMemoryUsageRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getMemoryUsageRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getResourceStatisticsResponse>* AsyncgetResourceStatisticsRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getResourceStatisticsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getResourceStatisticsResponse>* PrepareAsyncgetResourceStatisticsRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getResourceStatisticsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getGeometryStatisticsResponse>* AsyncgetGeometryStatisticsRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getGeometryStatisticsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getGeometryStatisticsResponse>* PrepareAsyncgetGeometryStatisticsRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getGeometryStatisticsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getTexturesStatisticsResponse>* AsyncgetTexturesStatisticsRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getTexturesStatisticsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getTexturesStatisticsResponse>* PrepareAsyncgetTexturesStatisticsRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getTexturesStatisticsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getSceneBoundsResponse>* AsyncgetSceneBoundsRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getSceneBoundsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getSceneBoundsResponse>* PrepareAsyncgetSceneBoundsRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getSceneBoundsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getDeviceCountResponse>* AsyncgetDeviceCountRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getDeviceCountRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getDeviceCountResponse>* PrepareAsyncgetDeviceCountRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getDeviceCountRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getDeviceComputeModelResponse>* AsyncgetDeviceComputeModelRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getDeviceComputeModelRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getDeviceComputeModelResponse>* PrepareAsyncgetDeviceComputeModelRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getDeviceComputeModelRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getDeviceNameResponse>* AsyncgetDeviceNameRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getDeviceNameRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getDeviceNameResponse>* PrepareAsyncgetDeviceNameRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getDeviceNameRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_isSupportedDeviceResponse>* AsyncisSupportedDeviceRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isSupportedDeviceRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_isSupportedDeviceResponse>* PrepareAsyncisSupportedDeviceRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isSupportedDeviceRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_deviceCanRenderResponse>* AsyncdeviceCanRenderRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deviceCanRenderRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_deviceCanRenderResponse>* PrepareAsyncdeviceCanRenderRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deviceCanRenderRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_deviceCanDenoiseResponse>* AsyncdeviceCanDenoiseRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deviceCanDenoiseRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_deviceCanDenoiseResponse>* PrepareAsyncdeviceCanDenoiseRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deviceCanDenoiseRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_deviceSupportsHardwareRayTracingResponse>* AsyncdeviceSupportsHardwareRayTracingRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deviceSupportsHardwareRayTracingRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_deviceSupportsHardwareRayTracingResponse>* PrepareAsyncdeviceSupportsHardwareRayTracingRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deviceSupportsHardwareRayTracingRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_deviceSharedSurfaceInfoResponse>* AsyncdeviceSharedSurfaceInfoRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deviceSharedSurfaceInfoRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_deviceSharedSurfaceInfoResponse>* PrepareAsyncdeviceSharedSurfaceInfoRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deviceSharedSurfaceInfoRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getAvailablePeerToPeerPairsResponse>* AsyncgetAvailablePeerToPeerPairsRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getAvailablePeerToPeerPairsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getAvailablePeerToPeerPairsResponse>* PrepareAsyncgetAvailablePeerToPeerPairsRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getAvailablePeerToPeerPairsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_setDevicesActivityResponse>* AsyncsetDevicesActivityRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setDevicesActivityRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_setDevicesActivityResponse>* PrepareAsyncsetDevicesActivityRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setDevicesActivityRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_isDeviceUsedForRenderingResponse>* AsyncisDeviceUsedForRenderingRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isDeviceUsedForRenderingRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_isDeviceUsedForRenderingResponse>* PrepareAsyncisDeviceUsedForRenderingRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isDeviceUsedForRenderingRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_deviceUsesPriorityResponse>* AsyncdeviceUsesPriorityRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deviceUsesPriorityRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_deviceUsesPriorityResponse>* PrepareAsyncdeviceUsesPriorityRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deviceUsesPriorityRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_deviceUsesHardwareRayTracingResponse>* AsyncdeviceUsesHardwareRayTracingRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deviceUsesHardwareRayTracingRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_deviceUsesHardwareRayTracingResponse>* PrepareAsyncdeviceUsesHardwareRayTracingRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deviceUsesHardwareRayTracingRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_imageDeviceIndexResponse>* AsyncimageDeviceIndexRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_imageDeviceIndexRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_imageDeviceIndexResponse>* PrepareAsyncimageDeviceIndexRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_imageDeviceIndexRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_isDeviceUsedForDenoisingResponse>* AsyncisDeviceUsedForDenoisingRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isDeviceUsedForDenoisingRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_isDeviceUsedForDenoisingResponse>* PrepareAsyncisDeviceUsedForDenoisingRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isDeviceUsedForDenoisingRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_renderPriorityResponse>* AsyncrenderPriorityRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_renderPriorityRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_renderPriorityResponse>* PrepareAsyncrenderPriorityRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_renderPriorityRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncsetRenderPriorityRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setRenderPriorityRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncsetRenderPriorityRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setRenderPriorityRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_currentPeerToPeerGroupsResponse>* AsynccurrentPeerToPeerGroupsRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_currentPeerToPeerGroupsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_currentPeerToPeerGroupsResponse>* PrepareAsynccurrentPeerToPeerGroupsRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_currentPeerToPeerGroupsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_hardwareRayTracingEnabledResponse>* AsynchardwareRayTracingEnabledRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_hardwareRayTracingEnabledRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_hardwareRayTracingEnabledResponse>* PrepareAsynchardwareRayTracingEnabledRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_hardwareRayTracingEnabledRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncopenDeviceSettingsRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_openDeviceSettingsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncopenDeviceSettingsRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_openDeviceSettingsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_renderDeviceStateResponse>* AsyncrenderDeviceStateRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_renderDeviceStateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_renderDeviceStateResponse>* PrepareAsyncrenderDeviceStateRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_renderDeviceStateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_renderDeviceErrorCodeResponse>* AsyncrenderDeviceErrorCodeRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_renderDeviceErrorCodeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_renderDeviceErrorCodeResponse>* PrepareAsyncrenderDeviceErrorCodeRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_renderDeviceErrorCodeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_errorcodeToStringResponse>* AsyncerrorcodeToStringRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_errorcodeToStringRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_errorcodeToStringResponse>* PrepareAsyncerrorcodeToStringRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_errorcodeToStringRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_renderDeviceErrorMessageResponse>* AsyncrenderDeviceErrorMessageRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_renderDeviceErrorMessageRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_renderDeviceErrorMessageResponse>* PrepareAsyncrenderDeviceErrorMessageRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_renderDeviceErrorMessageRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncsaveRenderDeviceConfigRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveRenderDeviceConfigRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncsaveRenderDeviceConfigRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveRenderDeviceConfigRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_outOfCoreEnabledResponse>* AsyncoutOfCoreEnabledRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_outOfCoreEnabledRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_outOfCoreEnabledResponse>* PrepareAsyncoutOfCoreEnabledRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_outOfCoreEnabledRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncenableOutOfCoreRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_enableOutOfCoreRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncenableOutOfCoreRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_enableOutOfCoreRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncdisableOutOfCoreRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_disableOutOfCoreRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncdisableOutOfCoreRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_disableOutOfCoreRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getOutOfCoreMemoryUsageResponse>* AsyncgetOutOfCoreMemoryUsageRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getOutOfCoreMemoryUsageRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getOutOfCoreMemoryUsageResponse>* PrepareAsyncgetOutOfCoreMemoryUsageRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getOutOfCoreMemoryUsageRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncsetGpuHeadroomRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setGpuHeadroomRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncsetGpuHeadroomRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setGpuHeadroomRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getGpuHeadroomResponse>* AsyncgetGpuHeadroomRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getGpuHeadroomRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getGpuHeadroomResponse>* PrepareAsyncgetGpuHeadroomRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getGpuHeadroomRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncsetCoreLimitRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setCoreLimitRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncsetCoreLimitRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setCoreLimitRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncdisableCoreLimitRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_disableCoreLimitRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncdisableCoreLimitRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_disableCoreLimitRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_registerInputSharedSurfaceResponse>* AsyncregisterInputSharedSurfaceRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_registerInputSharedSurfaceRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_registerInputSharedSurfaceResponse>* PrepareAsyncregisterInputSharedSurfaceRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_registerInputSharedSurfaceRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncunregisterInputSharedSurfaceRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_unregisterInputSharedSurfaceRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncunregisterInputSharedSurfaceRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_unregisterInputSharedSurfaceRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsynctriggerAsyncTonemapRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_triggerAsyncTonemapRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsynctriggerAsyncTonemapRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_triggerAsyncTonemapRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncsetSharedSurfaceOutputTypeRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setSharedSurfaceOutputTypeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncsetSharedSurfaceOutputTypeRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setSharedSurfaceOutputTypeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getSharedSurfaceOutputTypeResponse>* AsyncgetSharedSurfaceOutputTypeRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getSharedSurfaceOutputTypeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getSharedSurfaceOutputTypeResponse>* PrepareAsyncgetSharedSurfaceOutputTypeRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getSharedSurfaceOutputTypeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getRealTimeResponse>* AsyncgetRealTimeRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRealTimeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getRealTimeResponse>* PrepareAsyncgetRealTimeRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRealTimeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncpauseRenderingRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_pauseRenderingRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncpauseRenderingRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_pauseRenderingRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsynccontinueRenderingRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_continueRenderingRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsynccontinueRenderingRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_continueRenderingRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_isRenderingPausedResponse>* AsyncisRenderingPausedRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isRenderingPausedRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_isRenderingPausedResponse>* PrepareAsyncisRenderingPausedRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isRenderingPausedRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncrestartRenderingRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_restartRenderingRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncrestartRenderingRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_restartRenderingRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncstopRenderingRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_stopRenderingRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncstopRenderingRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_stopRenderingRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_pickResponse>* AsyncpickRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_pickRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_pickResponse>* PrepareAsyncpickRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_pickRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_pickWhitePointResponse>* AsyncpickWhitePointRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_pickWhitePointRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_pickWhitePointResponse>* PrepareAsyncpickWhitePointRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_pickWhitePointRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_pickImagerWhitePointResponse>* AsyncpickImagerWhitePointRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_pickImagerWhitePointRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_pickImagerWhitePointResponse>* PrepareAsyncpickImagerWhitePointRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_pickImagerWhitePointRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_isOutputAovWhitePointPickableResponse>* AsyncisOutputAovWhitePointPickableRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isOutputAovWhitePointPickableRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_isOutputAovWhitePointPickableResponse>* PrepareAsyncisOutputAovWhitePointPickableRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isOutputAovWhitePointPickableRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_pickOutputAovWhitePointResponse>* AsyncpickOutputAovWhitePointRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_pickOutputAovWhitePointRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_pickOutputAovWhitePointResponse>* PrepareAsyncpickOutputAovWhitePointRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_pickOutputAovWhitePointRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_pickCryptomatteMatteResponse>* AsyncpickCryptomatteMatteRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_pickCryptomatteMatteRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_pickCryptomatteMatteResponse>* PrepareAsyncpickCryptomatteMatteRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_pickCryptomatteMatteRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_modifyCryptomatteMatteSelectionResponse>* AsyncmodifyCryptomatteMatteSelectionRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_modifyCryptomatteMatteSelectionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_modifyCryptomatteMatteSelectionResponse>* PrepareAsyncmodifyCryptomatteMatteSelectionRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_modifyCryptomatteMatteSelectionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_toStringResponse>* AsynctoStringRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_toStringRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_toStringResponse>* PrepareAsynctoStringRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_toStringRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getDevicePciIdsResponse>* AsyncgetDevicePciIdsRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getDevicePciIdsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderEngine_getDevicePciIdsResponse>* PrepareAsyncgetDevicePciIdsRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getDevicePciIdsRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status setRenderTargetNode(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setRenderTargetNodeRequest& request, ::octaneapi::ApiRenderEngine_setRenderTargetNodeResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_setRenderTargetNodeResponse>> AsyncsetRenderTargetNode(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setRenderTargetNodeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_setRenderTargetNodeResponse>>(AsyncsetRenderTargetNodeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_setRenderTargetNodeResponse>> PrepareAsyncsetRenderTargetNode(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setRenderTargetNodeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_setRenderTargetNodeResponse>>(PrepareAsyncsetRenderTargetNodeRaw(context, request, cq));
    }
    ::grpc::Status getRenderTargetNode(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRenderTargetNodeRequest& request, ::octaneapi::ApiRenderEngine_getRenderTargetNodeResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getRenderTargetNodeResponse>> AsyncgetRenderTargetNode(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRenderTargetNodeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getRenderTargetNodeResponse>>(AsyncgetRenderTargetNodeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getRenderTargetNodeResponse>> PrepareAsyncgetRenderTargetNode(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRenderTargetNodeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getRenderTargetNodeResponse>>(PrepareAsyncgetRenderTargetNodeRaw(context, request, cq));
    }
    ::grpc::Status getRenderGeometryNode(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRenderGeometryNodeRequest& request, ::octaneapi::ApiRenderEngine_getRenderGeometryNodeResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getRenderGeometryNodeResponse>> AsyncgetRenderGeometryNode(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRenderGeometryNodeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getRenderGeometryNodeResponse>>(AsyncgetRenderGeometryNodeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getRenderGeometryNodeResponse>> PrepareAsyncgetRenderGeometryNode(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRenderGeometryNodeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getRenderGeometryNodeResponse>>(PrepareAsyncgetRenderGeometryNodeRaw(context, request, cq));
    }
    ::grpc::Status getRenderCameraNode(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRenderCameraNodeRequest& request, ::octaneapi::ApiRenderEngine_getRenderCameraNodeResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getRenderCameraNodeResponse>> AsyncgetRenderCameraNode(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRenderCameraNodeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getRenderCameraNodeResponse>>(AsyncgetRenderCameraNodeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getRenderCameraNodeResponse>> PrepareAsyncgetRenderCameraNode(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRenderCameraNodeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getRenderCameraNodeResponse>>(PrepareAsyncgetRenderCameraNodeRaw(context, request, cq));
    }
    ::grpc::Status setRenderRegion(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setRenderRegionRequest& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncsetRenderRegion(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setRenderRegionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncsetRenderRegionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncsetRenderRegion(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setRenderRegionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncsetRenderRegionRaw(context, request, cq));
    }
    ::grpc::Status getRenderRegion(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRenderRegionRequest& request, ::octaneapi::ApiRenderEngine_getRenderRegionResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getRenderRegionResponse>> AsyncgetRenderRegion(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRenderRegionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getRenderRegionResponse>>(AsyncgetRenderRegionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getRenderRegionResponse>> PrepareAsyncgetRenderRegion(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRenderRegionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getRenderRegionResponse>>(PrepareAsyncgetRenderRegionRaw(context, request, cq));
    }
    ::grpc::Status setAsyncTonemapParams(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setAsyncTonemapParamsRequest& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncsetAsyncTonemapParams(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setAsyncTonemapParamsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncsetAsyncTonemapParamsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncsetAsyncTonemapParams(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setAsyncTonemapParamsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncsetAsyncTonemapParamsRaw(context, request, cq));
    }
    ::grpc::Status setAsyncTonemapParams1(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setAsyncTonemapParams1Request& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncsetAsyncTonemapParams1(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setAsyncTonemapParams1Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncsetAsyncTonemapParams1Raw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncsetAsyncTonemapParams1(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setAsyncTonemapParams1Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncsetAsyncTonemapParams1Raw(context, request, cq));
    }
    ::grpc::Status asyncTonemapBufferType(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_asyncTonemapBufferTypeRequest& request, ::octaneapi::ApiRenderEngine_asyncTonemapBufferTypeResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_asyncTonemapBufferTypeResponse>> AsyncasyncTonemapBufferType(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_asyncTonemapBufferTypeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_asyncTonemapBufferTypeResponse>>(AsyncasyncTonemapBufferTypeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_asyncTonemapBufferTypeResponse>> PrepareAsyncasyncTonemapBufferType(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_asyncTonemapBufferTypeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_asyncTonemapBufferTypeResponse>>(PrepareAsyncasyncTonemapBufferTypeRaw(context, request, cq));
    }
    ::grpc::Status asyncTonemapCryptomatteFalseColor(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_asyncTonemapCryptomatteFalseColorRequest& request, ::octaneapi::ApiRenderEngine_asyncTonemapCryptomatteFalseColorResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_asyncTonemapCryptomatteFalseColorResponse>> AsyncasyncTonemapCryptomatteFalseColor(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_asyncTonemapCryptomatteFalseColorRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_asyncTonemapCryptomatteFalseColorResponse>>(AsyncasyncTonemapCryptomatteFalseColorRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_asyncTonemapCryptomatteFalseColorResponse>> PrepareAsyncasyncTonemapCryptomatteFalseColor(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_asyncTonemapCryptomatteFalseColorRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_asyncTonemapCryptomatteFalseColorResponse>>(PrepareAsyncasyncTonemapCryptomatteFalseColorRaw(context, request, cq));
    }
    ::grpc::Status asyncTonemapOutputColorSpaceInfo(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_asyncTonemapOutputColorSpaceInfoRequest& request, ::octaneapi::ApiRenderEngine_asyncTonemapOutputColorSpaceInfoResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_asyncTonemapOutputColorSpaceInfoResponse>> AsyncasyncTonemapOutputColorSpaceInfo(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_asyncTonemapOutputColorSpaceInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_asyncTonemapOutputColorSpaceInfoResponse>>(AsyncasyncTonemapOutputColorSpaceInfoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_asyncTonemapOutputColorSpaceInfoResponse>> PrepareAsyncasyncTonemapOutputColorSpaceInfo(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_asyncTonemapOutputColorSpaceInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_asyncTonemapOutputColorSpaceInfoResponse>>(PrepareAsyncasyncTonemapOutputColorSpaceInfoRaw(context, request, cq));
    }
    ::grpc::Status asyncTonemapColorSpace(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_asyncTonemapColorSpaceRequest& request, ::octaneapi::ApiRenderEngine_asyncTonemapColorSpaceResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_asyncTonemapColorSpaceResponse>> AsyncasyncTonemapColorSpace(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_asyncTonemapColorSpaceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_asyncTonemapColorSpaceResponse>>(AsyncasyncTonemapColorSpaceRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_asyncTonemapColorSpaceResponse>> PrepareAsyncasyncTonemapColorSpace(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_asyncTonemapColorSpaceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_asyncTonemapColorSpaceResponse>>(PrepareAsyncasyncTonemapColorSpaceRaw(context, request, cq));
    }
    ::grpc::Status asyncTonemapPremultipliedAlphaType(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_asyncTonemapPremultipliedAlphaTypeRequest& request, ::octaneapi::ApiRenderEngine_asyncTonemapPremultipliedAlphaTypeResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_asyncTonemapPremultipliedAlphaTypeResponse>> AsyncasyncTonemapPremultipliedAlphaType(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_asyncTonemapPremultipliedAlphaTypeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_asyncTonemapPremultipliedAlphaTypeResponse>>(AsyncasyncTonemapPremultipliedAlphaTypeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_asyncTonemapPremultipliedAlphaTypeResponse>> PrepareAsyncasyncTonemapPremultipliedAlphaType(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_asyncTonemapPremultipliedAlphaTypeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_asyncTonemapPremultipliedAlphaTypeResponse>>(PrepareAsyncasyncTonemapPremultipliedAlphaTypeRaw(context, request, cq));
    }
    ::grpc::Status setAsyncTonemapRenderPasses(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setAsyncTonemapRenderPassesRequest& request, ::octaneapi::ApiRenderEngine_setAsyncTonemapRenderPassesResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_setAsyncTonemapRenderPassesResponse>> AsyncsetAsyncTonemapRenderPasses(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setAsyncTonemapRenderPassesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_setAsyncTonemapRenderPassesResponse>>(AsyncsetAsyncTonemapRenderPassesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_setAsyncTonemapRenderPassesResponse>> PrepareAsyncsetAsyncTonemapRenderPasses(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setAsyncTonemapRenderPassesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_setAsyncTonemapRenderPassesResponse>>(PrepareAsyncsetAsyncTonemapRenderPassesRaw(context, request, cq));
    }
    ::grpc::Status asyncTonemapRenderPasses(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_asyncTonemapRenderPassesRequest& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncasyncTonemapRenderPasses(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_asyncTonemapRenderPassesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncasyncTonemapRenderPassesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncasyncTonemapRenderPasses(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_asyncTonemapRenderPassesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncasyncTonemapRenderPassesRaw(context, request, cq));
    }
    ::grpc::Status getEnabledAovs(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getEnabledAovsRequest& request, ::octaneapi::ApiRenderEngine_getEnabledAovsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getEnabledAovsResponse>> AsyncgetEnabledAovs(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getEnabledAovsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getEnabledAovsResponse>>(AsyncgetEnabledAovsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getEnabledAovsResponse>> PrepareAsyncgetEnabledAovs(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getEnabledAovsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getEnabledAovsResponse>>(PrepareAsyncgetEnabledAovsRaw(context, request, cq));
    }
    ::grpc::Status freeTonemapPasses(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_freeTonemapPassesRequest& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncfreeTonemapPasses(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_freeTonemapPassesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncfreeTonemapPassesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncfreeTonemapPasses(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_freeTonemapPassesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncfreeTonemapPassesRaw(context, request, cq));
    }
    ::grpc::Status displayRenderPassId(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_displayRenderPassIdRequest& request, ::octaneapi::ApiRenderEngine_displayRenderPassIdResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_displayRenderPassIdResponse>> AsyncdisplayRenderPassId(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_displayRenderPassIdRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_displayRenderPassIdResponse>>(AsyncdisplayRenderPassIdRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_displayRenderPassIdResponse>> PrepareAsyncdisplayRenderPassId(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_displayRenderPassIdRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_displayRenderPassIdResponse>>(PrepareAsyncdisplayRenderPassIdRaw(context, request, cq));
    }
    ::grpc::Status setSubSampleMode(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setSubSampleModeRequest& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncsetSubSampleMode(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setSubSampleModeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncsetSubSampleModeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncsetSubSampleMode(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setSubSampleModeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncsetSubSampleModeRaw(context, request, cq));
    }
    ::grpc::Status getSubSampleMode(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getSubSampleModeRequest& request, ::octaneapi::ApiRenderEngine_getSubSampleModeResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getSubSampleModeResponse>> AsyncgetSubSampleMode(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getSubSampleModeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getSubSampleModeResponse>>(AsyncgetSubSampleModeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getSubSampleModeResponse>> PrepareAsyncgetSubSampleMode(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getSubSampleModeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getSubSampleModeResponse>>(PrepareAsyncgetSubSampleModeRaw(context, request, cq));
    }
    ::grpc::Status setClayMode(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setClayModeRequest& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncsetClayMode(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setClayModeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncsetClayModeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncsetClayMode(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setClayModeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncsetClayModeRaw(context, request, cq));
    }
    ::grpc::Status clayMode(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_clayModeRequest& request, ::octaneapi::ApiRenderEngine_clayModeResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_clayModeResponse>> AsyncclayMode(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_clayModeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_clayModeResponse>>(AsyncclayModeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_clayModeResponse>> PrepareAsyncclayMode(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_clayModeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_clayModeResponse>>(PrepareAsyncclayModeRaw(context, request, cq));
    }
    ::grpc::Status fps(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_fpsRequest& request, ::octaneapi::ApiRenderEngine_fpsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_fpsResponse>> Asyncfps(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_fpsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_fpsResponse>>(AsyncfpsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_fpsResponse>> PrepareAsyncfps(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_fpsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_fpsResponse>>(PrepareAsyncfpsRaw(context, request, cq));
    }
    ::grpc::Status setFps(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setFpsRequest& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncsetFps(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setFpsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncsetFpsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncsetFps(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setFpsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncsetFpsRaw(context, request, cq));
    }
    ::grpc::Status isCompiling(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isCompilingRequest& request, ::octaneapi::ApiRenderEngine_isCompilingResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_isCompilingResponse>> AsyncisCompiling(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isCompilingRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_isCompilingResponse>>(AsyncisCompilingRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_isCompilingResponse>> PrepareAsyncisCompiling(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isCompilingRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_isCompilingResponse>>(PrepareAsyncisCompilingRaw(context, request, cq));
    }
    ::grpc::Status isCompressingTextures(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isCompressingTexturesRequest& request, ::octaneapi::ApiRenderEngine_isCompressingTexturesResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_isCompressingTexturesResponse>> AsyncisCompressingTextures(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isCompressingTexturesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_isCompressingTexturesResponse>>(AsyncisCompressingTexturesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_isCompressingTexturesResponse>> PrepareAsyncisCompressingTextures(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isCompressingTexturesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_isCompressingTexturesResponse>>(PrepareAsyncisCompressingTexturesRaw(context, request, cq));
    }
    ::grpc::Status hasPendingRenderData(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_hasPendingRenderDataRequest& request, ::octaneapi::ApiRenderEngine_hasPendingRenderDataResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_hasPendingRenderDataResponse>> AsynchasPendingRenderData(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_hasPendingRenderDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_hasPendingRenderDataResponse>>(AsynchasPendingRenderDataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_hasPendingRenderDataResponse>> PrepareAsynchasPendingRenderData(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_hasPendingRenderDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_hasPendingRenderDataResponse>>(PrepareAsynchasPendingRenderDataRaw(context, request, cq));
    }
    ::grpc::Status getCurrentChangeLevel(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getCurrentChangeLevelRequest& request, ::octaneapi::ApiRenderEngine_getCurrentChangeLevelResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getCurrentChangeLevelResponse>> AsyncgetCurrentChangeLevel(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getCurrentChangeLevelRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getCurrentChangeLevelResponse>>(AsyncgetCurrentChangeLevelRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getCurrentChangeLevelResponse>> PrepareAsyncgetCurrentChangeLevel(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getCurrentChangeLevelRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getCurrentChangeLevelResponse>>(PrepareAsyncgetCurrentChangeLevelRaw(context, request, cq));
    }
    ::grpc::Status getRenderImageChangeLevel(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRenderImageChangeLevelRequest& request, ::octaneapi::ApiRenderEngine_getRenderImageChangeLevelResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getRenderImageChangeLevelResponse>> AsyncgetRenderImageChangeLevel(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRenderImageChangeLevelRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getRenderImageChangeLevelResponse>>(AsyncgetRenderImageChangeLevelRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getRenderImageChangeLevelResponse>> PrepareAsyncgetRenderImageChangeLevel(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRenderImageChangeLevelRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getRenderImageChangeLevelResponse>>(PrepareAsyncgetRenderImageChangeLevelRaw(context, request, cq));
    }
    ::grpc::Status getRenderRestartedChangeLevel(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRenderRestartedChangeLevelRequest& request, ::octaneapi::ApiRenderEngine_getRenderRestartedChangeLevelResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getRenderRestartedChangeLevelResponse>> AsyncgetRenderRestartedChangeLevel(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRenderRestartedChangeLevelRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getRenderRestartedChangeLevelResponse>>(AsyncgetRenderRestartedChangeLevelRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getRenderRestartedChangeLevelResponse>> PrepareAsyncgetRenderRestartedChangeLevel(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRenderRestartedChangeLevelRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getRenderRestartedChangeLevelResponse>>(PrepareAsyncgetRenderRestartedChangeLevelRaw(context, request, cq));
    }
    ::grpc::Status setAsyncUpdateCallback(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setAsyncUpdateCallbackRequest& request, ::octaneapi::ApiRenderEngine_setAsyncUpdateCallbackResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_setAsyncUpdateCallbackResponse>> AsyncsetAsyncUpdateCallback(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setAsyncUpdateCallbackRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_setAsyncUpdateCallbackResponse>>(AsyncsetAsyncUpdateCallbackRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_setAsyncUpdateCallbackResponse>> PrepareAsyncsetAsyncUpdateCallback(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setAsyncUpdateCallbackRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_setAsyncUpdateCallbackResponse>>(PrepareAsyncsetAsyncUpdateCallbackRaw(context, request, cq));
    }
    ::grpc::Status updatesAreAsync(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_updatesAreAsyncRequest& request, ::octaneapi::ApiRenderEngine_updatesAreAsyncResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_updatesAreAsyncResponse>> AsyncupdatesAreAsync(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_updatesAreAsyncRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_updatesAreAsyncResponse>>(AsyncupdatesAreAsyncRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_updatesAreAsyncResponse>> PrepareAsyncupdatesAreAsync(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_updatesAreAsyncRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_updatesAreAsyncResponse>>(PrepareAsyncupdatesAreAsyncRaw(context, request, cq));
    }
    ::grpc::Status isImageReady(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isImageReadyRequest& request, ::octaneapi::ApiRenderEngine_isImageReadyResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_isImageReadyResponse>> AsyncisImageReady(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isImageReadyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_isImageReadyResponse>>(AsyncisImageReadyRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_isImageReadyResponse>> PrepareAsyncisImageReady(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isImageReadyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_isImageReadyResponse>>(PrepareAsyncisImageReadyRaw(context, request, cq));
    }
    ::grpc::Status resetImageReady(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_resetImageReadyRequest& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncresetImageReady(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_resetImageReadyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncresetImageReadyRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncresetImageReady(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_resetImageReadyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncresetImageReadyRaw(context, request, cq));
    }
    ::grpc::Status isRenderFailure(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isRenderFailureRequest& request, ::octaneapi::ApiRenderEngine_isRenderFailureResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_isRenderFailureResponse>> AsyncisRenderFailure(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isRenderFailureRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_isRenderFailureResponse>>(AsyncisRenderFailureRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_isRenderFailureResponse>> PrepareAsyncisRenderFailure(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isRenderFailureRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_isRenderFailureResponse>>(PrepareAsyncisRenderFailureRaw(context, request, cq));
    }
    ::grpc::Status resetRenderFailure(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_resetRenderFailureRequest& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncresetRenderFailure(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_resetRenderFailureRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncresetRenderFailureRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncresetRenderFailure(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_resetRenderFailureRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncresetRenderFailureRaw(context, request, cq));
    }
    ::grpc::Status setOnTileBlendedCallback(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setOnTileBlendedCallbackRequest& request, ::octaneapi::ApiRenderEngine_setOnTileBlendedCallbackResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_setOnTileBlendedCallbackResponse>> AsyncsetOnTileBlendedCallback(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setOnTileBlendedCallbackRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_setOnTileBlendedCallbackResponse>>(AsyncsetOnTileBlendedCallbackRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_setOnTileBlendedCallbackResponse>> PrepareAsyncsetOnTileBlendedCallback(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setOnTileBlendedCallbackRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_setOnTileBlendedCallbackResponse>>(PrepareAsyncsetOnTileBlendedCallbackRaw(context, request, cq));
    }
    ::grpc::Status setOnNewStatisticsCallback(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setOnNewStatisticsCallbackRequest& request, ::octaneapi::ApiRenderEngine_setOnNewStatisticsCallbackResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_setOnNewStatisticsCallbackResponse>> AsyncsetOnNewStatisticsCallback(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setOnNewStatisticsCallbackRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_setOnNewStatisticsCallbackResponse>>(AsyncsetOnNewStatisticsCallbackRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_setOnNewStatisticsCallbackResponse>> PrepareAsyncsetOnNewStatisticsCallback(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setOnNewStatisticsCallbackRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_setOnNewStatisticsCallbackResponse>>(PrepareAsyncsetOnNewStatisticsCallbackRaw(context, request, cq));
    }
    ::grpc::Status setOnNewImageCallback(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setOnNewImageCallbackRequest& request, ::octaneapi::ApiRenderEngine_setOnNewImageCallbackResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_setOnNewImageCallbackResponse>> AsyncsetOnNewImageCallback(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setOnNewImageCallbackRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_setOnNewImageCallbackResponse>>(AsyncsetOnNewImageCallbackRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_setOnNewImageCallbackResponse>> PrepareAsyncsetOnNewImageCallback(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setOnNewImageCallbackRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_setOnNewImageCallbackResponse>>(PrepareAsyncsetOnNewImageCallbackRaw(context, request, cq));
    }
    ::grpc::Status setOnOcioErrorCallback(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setOnOcioErrorCallbackRequest& request, ::octaneapi::ApiRenderEngine_setOnOcioErrorCallbackResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_setOnOcioErrorCallbackResponse>> AsyncsetOnOcioErrorCallback(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setOnOcioErrorCallbackRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_setOnOcioErrorCallbackResponse>>(AsyncsetOnOcioErrorCallbackRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_setOnOcioErrorCallbackResponse>> PrepareAsyncsetOnOcioErrorCallback(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setOnOcioErrorCallbackRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_setOnOcioErrorCallbackResponse>>(PrepareAsyncsetOnOcioErrorCallbackRaw(context, request, cq));
    }
    ::grpc::Status setOnRenderFailureCallback(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setOnRenderFailureCallbackRequest& request, ::octaneapi::ApiRenderEngine_setOnRenderFailureCallbackResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_setOnRenderFailureCallbackResponse>> AsyncsetOnRenderFailureCallback(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setOnRenderFailureCallbackRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_setOnRenderFailureCallbackResponse>>(AsyncsetOnRenderFailureCallbackRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_setOnRenderFailureCallbackResponse>> PrepareAsyncsetOnRenderFailureCallback(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setOnRenderFailureCallbackRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_setOnRenderFailureCallbackResponse>>(PrepareAsyncsetOnRenderFailureCallbackRaw(context, request, cq));
    }
    ::grpc::Status setForceCallbacksInRenderThreads(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setForceCallbacksInRenderThreadsRequest& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncsetForceCallbacksInRenderThreads(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setForceCallbacksInRenderThreadsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncsetForceCallbacksInRenderThreadsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncsetForceCallbacksInRenderThreads(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setForceCallbacksInRenderThreadsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncsetForceCallbacksInRenderThreadsRaw(context, request, cq));
    }
    ::grpc::Status grabRenderResult(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_grabRenderResultRequest& request, ::octaneapi::ApiRenderEngine_grabRenderResultResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_grabRenderResultResponse>> AsyncgrabRenderResult(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_grabRenderResultRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_grabRenderResultResponse>>(AsyncgrabRenderResultRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_grabRenderResultResponse>> PrepareAsyncgrabRenderResult(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_grabRenderResultRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_grabRenderResultResponse>>(PrepareAsyncgrabRenderResultRaw(context, request, cq));
    }
    ::grpc::Status releaseRenderResult(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_releaseRenderResultRequest& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncreleaseRenderResult(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_releaseRenderResultRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncreleaseRenderResultRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncreleaseRenderResult(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_releaseRenderResultRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncreleaseRenderResultRaw(context, request, cq));
    }
    ::grpc::Status synchronousTonemap(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_synchronousTonemapRequest& request, ::octaneapi::ApiRenderEngine_synchronousTonemapResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_synchronousTonemapResponse>> AsyncsynchronousTonemap(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_synchronousTonemapRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_synchronousTonemapResponse>>(AsyncsynchronousTonemapRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_synchronousTonemapResponse>> PrepareAsyncsynchronousTonemap(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_synchronousTonemapRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_synchronousTonemapResponse>>(PrepareAsyncsynchronousTonemapRaw(context, request, cq));
    }
    ::grpc::Status synchronousTonemap1(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_synchronousTonemap1Request& request, ::octaneapi::ApiRenderEngine_synchronousTonemap1Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_synchronousTonemap1Response>> AsyncsynchronousTonemap1(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_synchronousTonemap1Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_synchronousTonemap1Response>>(AsyncsynchronousTonemap1Raw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_synchronousTonemap1Response>> PrepareAsyncsynchronousTonemap1(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_synchronousTonemap1Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_synchronousTonemap1Response>>(PrepareAsyncsynchronousTonemap1Raw(context, request, cq));
    }
    ::grpc::Status synchronousTonemapAllRenderPasses(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPassesRequest& request, ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPassesResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPassesResponse>> AsyncsynchronousTonemapAllRenderPasses(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPassesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPassesResponse>>(AsyncsynchronousTonemapAllRenderPassesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPassesResponse>> PrepareAsyncsynchronousTonemapAllRenderPasses(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPassesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPassesResponse>>(PrepareAsyncsynchronousTonemapAllRenderPassesRaw(context, request, cq));
    }
    ::grpc::Status synchronousTonemapAllRenderPasses1(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPasses1Request& request, ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPasses1Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPasses1Response>> AsyncsynchronousTonemapAllRenderPasses1(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPasses1Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPasses1Response>>(AsyncsynchronousTonemapAllRenderPasses1Raw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPasses1Response>> PrepareAsyncsynchronousTonemapAllRenderPasses1(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPasses1Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPasses1Response>>(PrepareAsyncsynchronousTonemapAllRenderPasses1Raw(context, request, cq));
    }
    ::grpc::Status getRenderStatistics(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRenderStatisticsRequest& request, ::octaneapi::ApiRenderEngine_getRenderStatisticsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getRenderStatisticsResponse>> AsyncgetRenderStatistics(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRenderStatisticsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getRenderStatisticsResponse>>(AsyncgetRenderStatisticsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getRenderStatisticsResponse>> PrepareAsyncgetRenderStatistics(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRenderStatisticsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getRenderStatisticsResponse>>(PrepareAsyncgetRenderStatisticsRaw(context, request, cq));
    }
    ::grpc::Status getRenderResultStatistics(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRenderResultStatisticsRequest& request, ::octaneapi::ApiRenderEngine_getRenderResultStatisticsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getRenderResultStatisticsResponse>> AsyncgetRenderResultStatistics(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRenderResultStatisticsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getRenderResultStatisticsResponse>>(AsyncgetRenderResultStatisticsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getRenderResultStatisticsResponse>> PrepareAsyncgetRenderResultStatistics(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRenderResultStatisticsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getRenderResultStatisticsResponse>>(PrepareAsyncgetRenderResultStatisticsRaw(context, request, cq));
    }
    ::grpc::Status saveImage(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveImageRequest& request, ::octaneapi::ApiRenderEngine_saveImageResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_saveImageResponse>> AsyncsaveImage(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveImageRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_saveImageResponse>>(AsyncsaveImageRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_saveImageResponse>> PrepareAsyncsaveImage(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveImageRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_saveImageResponse>>(PrepareAsyncsaveImageRaw(context, request, cq));
    }
    ::grpc::Status saveImage1(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveImage1Request& request, ::octaneapi::ApiRenderEngine_saveImage1Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_saveImage1Response>> AsyncsaveImage1(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveImage1Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_saveImage1Response>>(AsyncsaveImage1Raw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_saveImage1Response>> PrepareAsyncsaveImage1(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveImage1Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_saveImage1Response>>(PrepareAsyncsaveImage1Raw(context, request, cq));
    }
    ::grpc::Status saveImage2(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveImage2Request& request, ::octaneapi::ApiRenderEngine_saveImage2Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_saveImage2Response>> AsyncsaveImage2(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveImage2Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_saveImage2Response>>(AsyncsaveImage2Raw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_saveImage2Response>> PrepareAsyncsaveImage2(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveImage2Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_saveImage2Response>>(PrepareAsyncsaveImage2Raw(context, request, cq));
    }
    ::grpc::Status saveRenderPasses(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveRenderPassesRequest& request, ::octaneapi::ApiRenderEngine_saveRenderPassesResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_saveRenderPassesResponse>> AsyncsaveRenderPasses(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveRenderPassesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_saveRenderPassesResponse>>(AsyncsaveRenderPassesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_saveRenderPassesResponse>> PrepareAsyncsaveRenderPasses(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveRenderPassesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_saveRenderPassesResponse>>(PrepareAsyncsaveRenderPassesRaw(context, request, cq));
    }
    ::grpc::Status saveRenderPasses1(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveRenderPasses1Request& request, ::octaneapi::ApiRenderEngine_saveRenderPasses1Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_saveRenderPasses1Response>> AsyncsaveRenderPasses1(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveRenderPasses1Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_saveRenderPasses1Response>>(AsyncsaveRenderPasses1Raw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_saveRenderPasses1Response>> PrepareAsyncsaveRenderPasses1(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveRenderPasses1Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_saveRenderPasses1Response>>(PrepareAsyncsaveRenderPasses1Raw(context, request, cq));
    }
    ::grpc::Status saveRenderPasses2(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveRenderPasses2Request& request, ::octaneapi::ApiRenderEngine_saveRenderPasses2Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_saveRenderPasses2Response>> AsyncsaveRenderPasses2(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveRenderPasses2Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_saveRenderPasses2Response>>(AsyncsaveRenderPasses2Raw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_saveRenderPasses2Response>> PrepareAsyncsaveRenderPasses2(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveRenderPasses2Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_saveRenderPasses2Response>>(PrepareAsyncsaveRenderPasses2Raw(context, request, cq));
    }
    ::grpc::Status saveRenderPassesMultiExr(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExrRequest& request, ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExrResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExrResponse>> AsyncsaveRenderPassesMultiExr(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExrRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExrResponse>>(AsyncsaveRenderPassesMultiExrRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExrResponse>> PrepareAsyncsaveRenderPassesMultiExr(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExrRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExrResponse>>(PrepareAsyncsaveRenderPassesMultiExrRaw(context, request, cq));
    }
    ::grpc::Status saveRenderPassesMultiExr1(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExr1Request& request, ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExr1Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExr1Response>> AsyncsaveRenderPassesMultiExr1(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExr1Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExr1Response>>(AsyncsaveRenderPassesMultiExr1Raw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExr1Response>> PrepareAsyncsaveRenderPassesMultiExr1(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExr1Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExr1Response>>(PrepareAsyncsaveRenderPassesMultiExr1Raw(context, request, cq));
    }
    ::grpc::Status saveRenderPassesDeepExr(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveRenderPassesDeepExrRequest& request, ::octaneapi::ApiRenderEngine_saveRenderPassesDeepExrResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_saveRenderPassesDeepExrResponse>> AsyncsaveRenderPassesDeepExr(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveRenderPassesDeepExrRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_saveRenderPassesDeepExrResponse>>(AsyncsaveRenderPassesDeepExrRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_saveRenderPassesDeepExrResponse>> PrepareAsyncsaveRenderPassesDeepExr(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveRenderPassesDeepExrRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_saveRenderPassesDeepExrResponse>>(PrepareAsyncsaveRenderPassesDeepExrRaw(context, request, cq));
    }
    ::grpc::Status deepImageEnabled(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deepImageEnabledRequest& request, ::octaneapi::ApiRenderEngine_deepImageEnabledResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_deepImageEnabledResponse>> AsyncdeepImageEnabled(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deepImageEnabledRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_deepImageEnabledResponse>>(AsyncdeepImageEnabledRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_deepImageEnabledResponse>> PrepareAsyncdeepImageEnabled(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deepImageEnabledRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_deepImageEnabledResponse>>(PrepareAsyncdeepImageEnabledRaw(context, request, cq));
    }
    ::grpc::Status deepImageEnabled1(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deepImageEnabled1Request& request, ::octaneapi::ApiRenderEngine_deepImageEnabled1Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_deepImageEnabled1Response>> AsyncdeepImageEnabled1(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deepImageEnabled1Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_deepImageEnabled1Response>>(AsyncdeepImageEnabled1Raw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_deepImageEnabled1Response>> PrepareAsyncdeepImageEnabled1(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deepImageEnabled1Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_deepImageEnabled1Response>>(PrepareAsyncdeepImageEnabled1Raw(context, request, cq));
    }
    ::grpc::Status deepPassesEnabled(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deepPassesEnabledRequest& request, ::octaneapi::ApiRenderEngine_deepPassesEnabledResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_deepPassesEnabledResponse>> AsyncdeepPassesEnabled(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deepPassesEnabledRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_deepPassesEnabledResponse>>(AsyncdeepPassesEnabledRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_deepPassesEnabledResponse>> PrepareAsyncdeepPassesEnabled(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deepPassesEnabledRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_deepPassesEnabledResponse>>(PrepareAsyncdeepPassesEnabledRaw(context, request, cq));
    }
    ::grpc::Status canSaveDeepImage(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_canSaveDeepImageRequest& request, ::octaneapi::ApiRenderEngine_canSaveDeepImageResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_canSaveDeepImageResponse>> AsynccanSaveDeepImage(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_canSaveDeepImageRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_canSaveDeepImageResponse>>(AsynccanSaveDeepImageRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_canSaveDeepImageResponse>> PrepareAsynccanSaveDeepImage(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_canSaveDeepImageRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_canSaveDeepImageResponse>>(PrepareAsynccanSaveDeepImageRaw(context, request, cq));
    }
    ::grpc::Status saveDeepImage(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveDeepImageRequest& request, ::octaneapi::ApiRenderEngine_saveDeepImageResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_saveDeepImageResponse>> AsyncsaveDeepImage(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveDeepImageRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_saveDeepImageResponse>>(AsyncsaveDeepImageRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_saveDeepImageResponse>> PrepareAsyncsaveDeepImage(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveDeepImageRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_saveDeepImageResponse>>(PrepareAsyncsaveDeepImageRaw(context, request, cq));
    }
    ::grpc::Status saveRenderState(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveRenderStateRequest& request, ::octaneapi::ApiRenderEngine_saveRenderStateResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_saveRenderStateResponse>> AsyncsaveRenderState(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveRenderStateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_saveRenderStateResponse>>(AsyncsaveRenderStateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_saveRenderStateResponse>> PrepareAsyncsaveRenderState(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveRenderStateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_saveRenderStateResponse>>(PrepareAsyncsaveRenderStateRaw(context, request, cq));
    }
    ::grpc::Status loadRenderState(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_loadRenderStateRequest& request, ::octaneapi::ApiRenderEngine_loadRenderStateResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_loadRenderStateResponse>> AsyncloadRenderState(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_loadRenderStateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_loadRenderStateResponse>>(AsyncloadRenderStateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_loadRenderStateResponse>> PrepareAsyncloadRenderState(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_loadRenderStateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_loadRenderStateResponse>>(PrepareAsyncloadRenderStateRaw(context, request, cq));
    }
    ::grpc::Status previewMaterial(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_previewMaterialRequest& request, ::octaneapi::ApiRenderEngine_previewMaterialResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_previewMaterialResponse>> AsyncpreviewMaterial(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_previewMaterialRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_previewMaterialResponse>>(AsyncpreviewMaterialRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_previewMaterialResponse>> PrepareAsyncpreviewMaterial(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_previewMaterialRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_previewMaterialResponse>>(PrepareAsyncpreviewMaterialRaw(context, request, cq));
    }
    ::grpc::Status previewMaterialHdr(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_previewMaterialHdrRequest& request, ::octaneapi::ApiRenderEngine_previewMaterialHdrResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_previewMaterialHdrResponse>> AsyncpreviewMaterialHdr(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_previewMaterialHdrRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_previewMaterialHdrResponse>>(AsyncpreviewMaterialHdrRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_previewMaterialHdrResponse>> PrepareAsyncpreviewMaterialHdr(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_previewMaterialHdrRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_previewMaterialHdrResponse>>(PrepareAsyncpreviewMaterialHdrRaw(context, request, cq));
    }
    ::grpc::Status previewMaterial1(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_previewMaterial1Request& request, ::octaneapi::ApiRenderEngine_previewMaterial1Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_previewMaterial1Response>> AsyncpreviewMaterial1(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_previewMaterial1Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_previewMaterial1Response>>(AsyncpreviewMaterial1Raw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_previewMaterial1Response>> PrepareAsyncpreviewMaterial1(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_previewMaterial1Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_previewMaterial1Response>>(PrepareAsyncpreviewMaterial1Raw(context, request, cq));
    }
    ::grpc::Status getMemoryUsage(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getMemoryUsageRequest& request, ::octaneapi::ApiRenderEngine_getMemoryUsageResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getMemoryUsageResponse>> AsyncgetMemoryUsage(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getMemoryUsageRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getMemoryUsageResponse>>(AsyncgetMemoryUsageRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getMemoryUsageResponse>> PrepareAsyncgetMemoryUsage(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getMemoryUsageRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getMemoryUsageResponse>>(PrepareAsyncgetMemoryUsageRaw(context, request, cq));
    }
    ::grpc::Status getResourceStatistics(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getResourceStatisticsRequest& request, ::octaneapi::ApiRenderEngine_getResourceStatisticsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getResourceStatisticsResponse>> AsyncgetResourceStatistics(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getResourceStatisticsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getResourceStatisticsResponse>>(AsyncgetResourceStatisticsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getResourceStatisticsResponse>> PrepareAsyncgetResourceStatistics(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getResourceStatisticsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getResourceStatisticsResponse>>(PrepareAsyncgetResourceStatisticsRaw(context, request, cq));
    }
    ::grpc::Status getGeometryStatistics(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getGeometryStatisticsRequest& request, ::octaneapi::ApiRenderEngine_getGeometryStatisticsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getGeometryStatisticsResponse>> AsyncgetGeometryStatistics(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getGeometryStatisticsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getGeometryStatisticsResponse>>(AsyncgetGeometryStatisticsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getGeometryStatisticsResponse>> PrepareAsyncgetGeometryStatistics(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getGeometryStatisticsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getGeometryStatisticsResponse>>(PrepareAsyncgetGeometryStatisticsRaw(context, request, cq));
    }
    ::grpc::Status getTexturesStatistics(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getTexturesStatisticsRequest& request, ::octaneapi::ApiRenderEngine_getTexturesStatisticsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getTexturesStatisticsResponse>> AsyncgetTexturesStatistics(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getTexturesStatisticsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getTexturesStatisticsResponse>>(AsyncgetTexturesStatisticsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getTexturesStatisticsResponse>> PrepareAsyncgetTexturesStatistics(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getTexturesStatisticsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getTexturesStatisticsResponse>>(PrepareAsyncgetTexturesStatisticsRaw(context, request, cq));
    }
    ::grpc::Status getSceneBounds(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getSceneBoundsRequest& request, ::octaneapi::ApiRenderEngine_getSceneBoundsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getSceneBoundsResponse>> AsyncgetSceneBounds(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getSceneBoundsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getSceneBoundsResponse>>(AsyncgetSceneBoundsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getSceneBoundsResponse>> PrepareAsyncgetSceneBounds(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getSceneBoundsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getSceneBoundsResponse>>(PrepareAsyncgetSceneBoundsRaw(context, request, cq));
    }
    ::grpc::Status getDeviceCount(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getDeviceCountRequest& request, ::octaneapi::ApiRenderEngine_getDeviceCountResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getDeviceCountResponse>> AsyncgetDeviceCount(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getDeviceCountRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getDeviceCountResponse>>(AsyncgetDeviceCountRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getDeviceCountResponse>> PrepareAsyncgetDeviceCount(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getDeviceCountRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getDeviceCountResponse>>(PrepareAsyncgetDeviceCountRaw(context, request, cq));
    }
    ::grpc::Status getDeviceComputeModel(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getDeviceComputeModelRequest& request, ::octaneapi::ApiRenderEngine_getDeviceComputeModelResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getDeviceComputeModelResponse>> AsyncgetDeviceComputeModel(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getDeviceComputeModelRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getDeviceComputeModelResponse>>(AsyncgetDeviceComputeModelRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getDeviceComputeModelResponse>> PrepareAsyncgetDeviceComputeModel(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getDeviceComputeModelRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getDeviceComputeModelResponse>>(PrepareAsyncgetDeviceComputeModelRaw(context, request, cq));
    }
    ::grpc::Status getDeviceName(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getDeviceNameRequest& request, ::octaneapi::ApiRenderEngine_getDeviceNameResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getDeviceNameResponse>> AsyncgetDeviceName(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getDeviceNameRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getDeviceNameResponse>>(AsyncgetDeviceNameRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getDeviceNameResponse>> PrepareAsyncgetDeviceName(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getDeviceNameRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getDeviceNameResponse>>(PrepareAsyncgetDeviceNameRaw(context, request, cq));
    }
    ::grpc::Status isSupportedDevice(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isSupportedDeviceRequest& request, ::octaneapi::ApiRenderEngine_isSupportedDeviceResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_isSupportedDeviceResponse>> AsyncisSupportedDevice(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isSupportedDeviceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_isSupportedDeviceResponse>>(AsyncisSupportedDeviceRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_isSupportedDeviceResponse>> PrepareAsyncisSupportedDevice(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isSupportedDeviceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_isSupportedDeviceResponse>>(PrepareAsyncisSupportedDeviceRaw(context, request, cq));
    }
    ::grpc::Status deviceCanRender(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deviceCanRenderRequest& request, ::octaneapi::ApiRenderEngine_deviceCanRenderResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_deviceCanRenderResponse>> AsyncdeviceCanRender(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deviceCanRenderRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_deviceCanRenderResponse>>(AsyncdeviceCanRenderRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_deviceCanRenderResponse>> PrepareAsyncdeviceCanRender(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deviceCanRenderRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_deviceCanRenderResponse>>(PrepareAsyncdeviceCanRenderRaw(context, request, cq));
    }
    ::grpc::Status deviceCanDenoise(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deviceCanDenoiseRequest& request, ::octaneapi::ApiRenderEngine_deviceCanDenoiseResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_deviceCanDenoiseResponse>> AsyncdeviceCanDenoise(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deviceCanDenoiseRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_deviceCanDenoiseResponse>>(AsyncdeviceCanDenoiseRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_deviceCanDenoiseResponse>> PrepareAsyncdeviceCanDenoise(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deviceCanDenoiseRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_deviceCanDenoiseResponse>>(PrepareAsyncdeviceCanDenoiseRaw(context, request, cq));
    }
    ::grpc::Status deviceSupportsHardwareRayTracing(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deviceSupportsHardwareRayTracingRequest& request, ::octaneapi::ApiRenderEngine_deviceSupportsHardwareRayTracingResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_deviceSupportsHardwareRayTracingResponse>> AsyncdeviceSupportsHardwareRayTracing(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deviceSupportsHardwareRayTracingRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_deviceSupportsHardwareRayTracingResponse>>(AsyncdeviceSupportsHardwareRayTracingRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_deviceSupportsHardwareRayTracingResponse>> PrepareAsyncdeviceSupportsHardwareRayTracing(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deviceSupportsHardwareRayTracingRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_deviceSupportsHardwareRayTracingResponse>>(PrepareAsyncdeviceSupportsHardwareRayTracingRaw(context, request, cq));
    }
    ::grpc::Status deviceSharedSurfaceInfo(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deviceSharedSurfaceInfoRequest& request, ::octaneapi::ApiRenderEngine_deviceSharedSurfaceInfoResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_deviceSharedSurfaceInfoResponse>> AsyncdeviceSharedSurfaceInfo(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deviceSharedSurfaceInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_deviceSharedSurfaceInfoResponse>>(AsyncdeviceSharedSurfaceInfoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_deviceSharedSurfaceInfoResponse>> PrepareAsyncdeviceSharedSurfaceInfo(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deviceSharedSurfaceInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_deviceSharedSurfaceInfoResponse>>(PrepareAsyncdeviceSharedSurfaceInfoRaw(context, request, cq));
    }
    ::grpc::Status getAvailablePeerToPeerPairs(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getAvailablePeerToPeerPairsRequest& request, ::octaneapi::ApiRenderEngine_getAvailablePeerToPeerPairsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getAvailablePeerToPeerPairsResponse>> AsyncgetAvailablePeerToPeerPairs(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getAvailablePeerToPeerPairsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getAvailablePeerToPeerPairsResponse>>(AsyncgetAvailablePeerToPeerPairsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getAvailablePeerToPeerPairsResponse>> PrepareAsyncgetAvailablePeerToPeerPairs(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getAvailablePeerToPeerPairsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getAvailablePeerToPeerPairsResponse>>(PrepareAsyncgetAvailablePeerToPeerPairsRaw(context, request, cq));
    }
    ::grpc::Status setDevicesActivity(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setDevicesActivityRequest& request, ::octaneapi::ApiRenderEngine_setDevicesActivityResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_setDevicesActivityResponse>> AsyncsetDevicesActivity(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setDevicesActivityRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_setDevicesActivityResponse>>(AsyncsetDevicesActivityRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_setDevicesActivityResponse>> PrepareAsyncsetDevicesActivity(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setDevicesActivityRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_setDevicesActivityResponse>>(PrepareAsyncsetDevicesActivityRaw(context, request, cq));
    }
    ::grpc::Status isDeviceUsedForRendering(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isDeviceUsedForRenderingRequest& request, ::octaneapi::ApiRenderEngine_isDeviceUsedForRenderingResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_isDeviceUsedForRenderingResponse>> AsyncisDeviceUsedForRendering(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isDeviceUsedForRenderingRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_isDeviceUsedForRenderingResponse>>(AsyncisDeviceUsedForRenderingRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_isDeviceUsedForRenderingResponse>> PrepareAsyncisDeviceUsedForRendering(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isDeviceUsedForRenderingRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_isDeviceUsedForRenderingResponse>>(PrepareAsyncisDeviceUsedForRenderingRaw(context, request, cq));
    }
    ::grpc::Status deviceUsesPriority(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deviceUsesPriorityRequest& request, ::octaneapi::ApiRenderEngine_deviceUsesPriorityResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_deviceUsesPriorityResponse>> AsyncdeviceUsesPriority(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deviceUsesPriorityRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_deviceUsesPriorityResponse>>(AsyncdeviceUsesPriorityRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_deviceUsesPriorityResponse>> PrepareAsyncdeviceUsesPriority(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deviceUsesPriorityRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_deviceUsesPriorityResponse>>(PrepareAsyncdeviceUsesPriorityRaw(context, request, cq));
    }
    ::grpc::Status deviceUsesHardwareRayTracing(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deviceUsesHardwareRayTracingRequest& request, ::octaneapi::ApiRenderEngine_deviceUsesHardwareRayTracingResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_deviceUsesHardwareRayTracingResponse>> AsyncdeviceUsesHardwareRayTracing(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deviceUsesHardwareRayTracingRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_deviceUsesHardwareRayTracingResponse>>(AsyncdeviceUsesHardwareRayTracingRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_deviceUsesHardwareRayTracingResponse>> PrepareAsyncdeviceUsesHardwareRayTracing(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deviceUsesHardwareRayTracingRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_deviceUsesHardwareRayTracingResponse>>(PrepareAsyncdeviceUsesHardwareRayTracingRaw(context, request, cq));
    }
    ::grpc::Status imageDeviceIndex(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_imageDeviceIndexRequest& request, ::octaneapi::ApiRenderEngine_imageDeviceIndexResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_imageDeviceIndexResponse>> AsyncimageDeviceIndex(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_imageDeviceIndexRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_imageDeviceIndexResponse>>(AsyncimageDeviceIndexRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_imageDeviceIndexResponse>> PrepareAsyncimageDeviceIndex(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_imageDeviceIndexRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_imageDeviceIndexResponse>>(PrepareAsyncimageDeviceIndexRaw(context, request, cq));
    }
    ::grpc::Status isDeviceUsedForDenoising(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isDeviceUsedForDenoisingRequest& request, ::octaneapi::ApiRenderEngine_isDeviceUsedForDenoisingResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_isDeviceUsedForDenoisingResponse>> AsyncisDeviceUsedForDenoising(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isDeviceUsedForDenoisingRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_isDeviceUsedForDenoisingResponse>>(AsyncisDeviceUsedForDenoisingRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_isDeviceUsedForDenoisingResponse>> PrepareAsyncisDeviceUsedForDenoising(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isDeviceUsedForDenoisingRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_isDeviceUsedForDenoisingResponse>>(PrepareAsyncisDeviceUsedForDenoisingRaw(context, request, cq));
    }
    ::grpc::Status renderPriority(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_renderPriorityRequest& request, ::octaneapi::ApiRenderEngine_renderPriorityResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_renderPriorityResponse>> AsyncrenderPriority(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_renderPriorityRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_renderPriorityResponse>>(AsyncrenderPriorityRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_renderPriorityResponse>> PrepareAsyncrenderPriority(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_renderPriorityRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_renderPriorityResponse>>(PrepareAsyncrenderPriorityRaw(context, request, cq));
    }
    ::grpc::Status setRenderPriority(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setRenderPriorityRequest& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncsetRenderPriority(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setRenderPriorityRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncsetRenderPriorityRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncsetRenderPriority(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setRenderPriorityRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncsetRenderPriorityRaw(context, request, cq));
    }
    ::grpc::Status currentPeerToPeerGroups(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_currentPeerToPeerGroupsRequest& request, ::octaneapi::ApiRenderEngine_currentPeerToPeerGroupsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_currentPeerToPeerGroupsResponse>> AsynccurrentPeerToPeerGroups(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_currentPeerToPeerGroupsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_currentPeerToPeerGroupsResponse>>(AsynccurrentPeerToPeerGroupsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_currentPeerToPeerGroupsResponse>> PrepareAsynccurrentPeerToPeerGroups(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_currentPeerToPeerGroupsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_currentPeerToPeerGroupsResponse>>(PrepareAsynccurrentPeerToPeerGroupsRaw(context, request, cq));
    }
    ::grpc::Status hardwareRayTracingEnabled(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_hardwareRayTracingEnabledRequest& request, ::octaneapi::ApiRenderEngine_hardwareRayTracingEnabledResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_hardwareRayTracingEnabledResponse>> AsynchardwareRayTracingEnabled(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_hardwareRayTracingEnabledRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_hardwareRayTracingEnabledResponse>>(AsynchardwareRayTracingEnabledRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_hardwareRayTracingEnabledResponse>> PrepareAsynchardwareRayTracingEnabled(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_hardwareRayTracingEnabledRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_hardwareRayTracingEnabledResponse>>(PrepareAsynchardwareRayTracingEnabledRaw(context, request, cq));
    }
    ::grpc::Status openDeviceSettings(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_openDeviceSettingsRequest& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncopenDeviceSettings(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_openDeviceSettingsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncopenDeviceSettingsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncopenDeviceSettings(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_openDeviceSettingsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncopenDeviceSettingsRaw(context, request, cq));
    }
    ::grpc::Status renderDeviceState(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_renderDeviceStateRequest& request, ::octaneapi::ApiRenderEngine_renderDeviceStateResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_renderDeviceStateResponse>> AsyncrenderDeviceState(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_renderDeviceStateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_renderDeviceStateResponse>>(AsyncrenderDeviceStateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_renderDeviceStateResponse>> PrepareAsyncrenderDeviceState(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_renderDeviceStateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_renderDeviceStateResponse>>(PrepareAsyncrenderDeviceStateRaw(context, request, cq));
    }
    ::grpc::Status renderDeviceErrorCode(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_renderDeviceErrorCodeRequest& request, ::octaneapi::ApiRenderEngine_renderDeviceErrorCodeResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_renderDeviceErrorCodeResponse>> AsyncrenderDeviceErrorCode(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_renderDeviceErrorCodeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_renderDeviceErrorCodeResponse>>(AsyncrenderDeviceErrorCodeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_renderDeviceErrorCodeResponse>> PrepareAsyncrenderDeviceErrorCode(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_renderDeviceErrorCodeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_renderDeviceErrorCodeResponse>>(PrepareAsyncrenderDeviceErrorCodeRaw(context, request, cq));
    }
    ::grpc::Status errorcodeToString(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_errorcodeToStringRequest& request, ::octaneapi::ApiRenderEngine_errorcodeToStringResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_errorcodeToStringResponse>> AsyncerrorcodeToString(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_errorcodeToStringRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_errorcodeToStringResponse>>(AsyncerrorcodeToStringRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_errorcodeToStringResponse>> PrepareAsyncerrorcodeToString(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_errorcodeToStringRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_errorcodeToStringResponse>>(PrepareAsyncerrorcodeToStringRaw(context, request, cq));
    }
    ::grpc::Status renderDeviceErrorMessage(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_renderDeviceErrorMessageRequest& request, ::octaneapi::ApiRenderEngine_renderDeviceErrorMessageResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_renderDeviceErrorMessageResponse>> AsyncrenderDeviceErrorMessage(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_renderDeviceErrorMessageRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_renderDeviceErrorMessageResponse>>(AsyncrenderDeviceErrorMessageRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_renderDeviceErrorMessageResponse>> PrepareAsyncrenderDeviceErrorMessage(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_renderDeviceErrorMessageRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_renderDeviceErrorMessageResponse>>(PrepareAsyncrenderDeviceErrorMessageRaw(context, request, cq));
    }
    ::grpc::Status saveRenderDeviceConfig(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveRenderDeviceConfigRequest& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncsaveRenderDeviceConfig(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveRenderDeviceConfigRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncsaveRenderDeviceConfigRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncsaveRenderDeviceConfig(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveRenderDeviceConfigRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncsaveRenderDeviceConfigRaw(context, request, cq));
    }
    ::grpc::Status outOfCoreEnabled(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_outOfCoreEnabledRequest& request, ::octaneapi::ApiRenderEngine_outOfCoreEnabledResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_outOfCoreEnabledResponse>> AsyncoutOfCoreEnabled(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_outOfCoreEnabledRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_outOfCoreEnabledResponse>>(AsyncoutOfCoreEnabledRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_outOfCoreEnabledResponse>> PrepareAsyncoutOfCoreEnabled(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_outOfCoreEnabledRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_outOfCoreEnabledResponse>>(PrepareAsyncoutOfCoreEnabledRaw(context, request, cq));
    }
    ::grpc::Status enableOutOfCore(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_enableOutOfCoreRequest& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncenableOutOfCore(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_enableOutOfCoreRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncenableOutOfCoreRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncenableOutOfCore(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_enableOutOfCoreRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncenableOutOfCoreRaw(context, request, cq));
    }
    ::grpc::Status disableOutOfCore(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_disableOutOfCoreRequest& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncdisableOutOfCore(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_disableOutOfCoreRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncdisableOutOfCoreRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncdisableOutOfCore(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_disableOutOfCoreRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncdisableOutOfCoreRaw(context, request, cq));
    }
    ::grpc::Status getOutOfCoreMemoryUsage(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getOutOfCoreMemoryUsageRequest& request, ::octaneapi::ApiRenderEngine_getOutOfCoreMemoryUsageResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getOutOfCoreMemoryUsageResponse>> AsyncgetOutOfCoreMemoryUsage(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getOutOfCoreMemoryUsageRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getOutOfCoreMemoryUsageResponse>>(AsyncgetOutOfCoreMemoryUsageRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getOutOfCoreMemoryUsageResponse>> PrepareAsyncgetOutOfCoreMemoryUsage(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getOutOfCoreMemoryUsageRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getOutOfCoreMemoryUsageResponse>>(PrepareAsyncgetOutOfCoreMemoryUsageRaw(context, request, cq));
    }
    ::grpc::Status setGpuHeadroom(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setGpuHeadroomRequest& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncsetGpuHeadroom(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setGpuHeadroomRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncsetGpuHeadroomRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncsetGpuHeadroom(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setGpuHeadroomRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncsetGpuHeadroomRaw(context, request, cq));
    }
    ::grpc::Status getGpuHeadroom(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getGpuHeadroomRequest& request, ::octaneapi::ApiRenderEngine_getGpuHeadroomResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getGpuHeadroomResponse>> AsyncgetGpuHeadroom(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getGpuHeadroomRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getGpuHeadroomResponse>>(AsyncgetGpuHeadroomRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getGpuHeadroomResponse>> PrepareAsyncgetGpuHeadroom(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getGpuHeadroomRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getGpuHeadroomResponse>>(PrepareAsyncgetGpuHeadroomRaw(context, request, cq));
    }
    ::grpc::Status setCoreLimit(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setCoreLimitRequest& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncsetCoreLimit(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setCoreLimitRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncsetCoreLimitRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncsetCoreLimit(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setCoreLimitRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncsetCoreLimitRaw(context, request, cq));
    }
    ::grpc::Status disableCoreLimit(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_disableCoreLimitRequest& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncdisableCoreLimit(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_disableCoreLimitRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncdisableCoreLimitRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncdisableCoreLimit(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_disableCoreLimitRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncdisableCoreLimitRaw(context, request, cq));
    }
    ::grpc::Status registerInputSharedSurface(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_registerInputSharedSurfaceRequest& request, ::octaneapi::ApiRenderEngine_registerInputSharedSurfaceResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_registerInputSharedSurfaceResponse>> AsyncregisterInputSharedSurface(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_registerInputSharedSurfaceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_registerInputSharedSurfaceResponse>>(AsyncregisterInputSharedSurfaceRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_registerInputSharedSurfaceResponse>> PrepareAsyncregisterInputSharedSurface(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_registerInputSharedSurfaceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_registerInputSharedSurfaceResponse>>(PrepareAsyncregisterInputSharedSurfaceRaw(context, request, cq));
    }
    ::grpc::Status unregisterInputSharedSurface(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_unregisterInputSharedSurfaceRequest& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncunregisterInputSharedSurface(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_unregisterInputSharedSurfaceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncunregisterInputSharedSurfaceRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncunregisterInputSharedSurface(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_unregisterInputSharedSurfaceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncunregisterInputSharedSurfaceRaw(context, request, cq));
    }
    ::grpc::Status triggerAsyncTonemap(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_triggerAsyncTonemapRequest& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsynctriggerAsyncTonemap(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_triggerAsyncTonemapRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsynctriggerAsyncTonemapRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsynctriggerAsyncTonemap(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_triggerAsyncTonemapRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsynctriggerAsyncTonemapRaw(context, request, cq));
    }
    ::grpc::Status setSharedSurfaceOutputType(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setSharedSurfaceOutputTypeRequest& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncsetSharedSurfaceOutputType(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setSharedSurfaceOutputTypeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncsetSharedSurfaceOutputTypeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncsetSharedSurfaceOutputType(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setSharedSurfaceOutputTypeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncsetSharedSurfaceOutputTypeRaw(context, request, cq));
    }
    ::grpc::Status getSharedSurfaceOutputType(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getSharedSurfaceOutputTypeRequest& request, ::octaneapi::ApiRenderEngine_getSharedSurfaceOutputTypeResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getSharedSurfaceOutputTypeResponse>> AsyncgetSharedSurfaceOutputType(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getSharedSurfaceOutputTypeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getSharedSurfaceOutputTypeResponse>>(AsyncgetSharedSurfaceOutputTypeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getSharedSurfaceOutputTypeResponse>> PrepareAsyncgetSharedSurfaceOutputType(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getSharedSurfaceOutputTypeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getSharedSurfaceOutputTypeResponse>>(PrepareAsyncgetSharedSurfaceOutputTypeRaw(context, request, cq));
    }
    ::grpc::Status getRealTime(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRealTimeRequest& request, ::octaneapi::ApiRenderEngine_getRealTimeResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getRealTimeResponse>> AsyncgetRealTime(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRealTimeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getRealTimeResponse>>(AsyncgetRealTimeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getRealTimeResponse>> PrepareAsyncgetRealTime(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRealTimeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getRealTimeResponse>>(PrepareAsyncgetRealTimeRaw(context, request, cq));
    }
    ::grpc::Status pauseRendering(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_pauseRenderingRequest& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncpauseRendering(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_pauseRenderingRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncpauseRenderingRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncpauseRendering(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_pauseRenderingRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncpauseRenderingRaw(context, request, cq));
    }
    ::grpc::Status continueRendering(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_continueRenderingRequest& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsynccontinueRendering(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_continueRenderingRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsynccontinueRenderingRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsynccontinueRendering(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_continueRenderingRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsynccontinueRenderingRaw(context, request, cq));
    }
    ::grpc::Status isRenderingPaused(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isRenderingPausedRequest& request, ::octaneapi::ApiRenderEngine_isRenderingPausedResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_isRenderingPausedResponse>> AsyncisRenderingPaused(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isRenderingPausedRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_isRenderingPausedResponse>>(AsyncisRenderingPausedRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_isRenderingPausedResponse>> PrepareAsyncisRenderingPaused(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isRenderingPausedRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_isRenderingPausedResponse>>(PrepareAsyncisRenderingPausedRaw(context, request, cq));
    }
    ::grpc::Status restartRendering(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_restartRenderingRequest& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncrestartRendering(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_restartRenderingRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncrestartRenderingRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncrestartRendering(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_restartRenderingRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncrestartRenderingRaw(context, request, cq));
    }
    ::grpc::Status stopRendering(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_stopRenderingRequest& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncstopRendering(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_stopRenderingRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncstopRenderingRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncstopRendering(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_stopRenderingRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncstopRenderingRaw(context, request, cq));
    }
    ::grpc::Status pick(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_pickRequest& request, ::octaneapi::ApiRenderEngine_pickResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_pickResponse>> Asyncpick(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_pickRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_pickResponse>>(AsyncpickRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_pickResponse>> PrepareAsyncpick(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_pickRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_pickResponse>>(PrepareAsyncpickRaw(context, request, cq));
    }
    ::grpc::Status pickWhitePoint(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_pickWhitePointRequest& request, ::octaneapi::ApiRenderEngine_pickWhitePointResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_pickWhitePointResponse>> AsyncpickWhitePoint(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_pickWhitePointRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_pickWhitePointResponse>>(AsyncpickWhitePointRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_pickWhitePointResponse>> PrepareAsyncpickWhitePoint(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_pickWhitePointRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_pickWhitePointResponse>>(PrepareAsyncpickWhitePointRaw(context, request, cq));
    }
    ::grpc::Status pickImagerWhitePoint(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_pickImagerWhitePointRequest& request, ::octaneapi::ApiRenderEngine_pickImagerWhitePointResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_pickImagerWhitePointResponse>> AsyncpickImagerWhitePoint(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_pickImagerWhitePointRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_pickImagerWhitePointResponse>>(AsyncpickImagerWhitePointRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_pickImagerWhitePointResponse>> PrepareAsyncpickImagerWhitePoint(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_pickImagerWhitePointRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_pickImagerWhitePointResponse>>(PrepareAsyncpickImagerWhitePointRaw(context, request, cq));
    }
    ::grpc::Status isOutputAovWhitePointPickable(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isOutputAovWhitePointPickableRequest& request, ::octaneapi::ApiRenderEngine_isOutputAovWhitePointPickableResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_isOutputAovWhitePointPickableResponse>> AsyncisOutputAovWhitePointPickable(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isOutputAovWhitePointPickableRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_isOutputAovWhitePointPickableResponse>>(AsyncisOutputAovWhitePointPickableRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_isOutputAovWhitePointPickableResponse>> PrepareAsyncisOutputAovWhitePointPickable(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isOutputAovWhitePointPickableRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_isOutputAovWhitePointPickableResponse>>(PrepareAsyncisOutputAovWhitePointPickableRaw(context, request, cq));
    }
    ::grpc::Status pickOutputAovWhitePoint(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_pickOutputAovWhitePointRequest& request, ::octaneapi::ApiRenderEngine_pickOutputAovWhitePointResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_pickOutputAovWhitePointResponse>> AsyncpickOutputAovWhitePoint(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_pickOutputAovWhitePointRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_pickOutputAovWhitePointResponse>>(AsyncpickOutputAovWhitePointRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_pickOutputAovWhitePointResponse>> PrepareAsyncpickOutputAovWhitePoint(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_pickOutputAovWhitePointRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_pickOutputAovWhitePointResponse>>(PrepareAsyncpickOutputAovWhitePointRaw(context, request, cq));
    }
    ::grpc::Status pickCryptomatteMatte(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_pickCryptomatteMatteRequest& request, ::octaneapi::ApiRenderEngine_pickCryptomatteMatteResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_pickCryptomatteMatteResponse>> AsyncpickCryptomatteMatte(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_pickCryptomatteMatteRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_pickCryptomatteMatteResponse>>(AsyncpickCryptomatteMatteRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_pickCryptomatteMatteResponse>> PrepareAsyncpickCryptomatteMatte(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_pickCryptomatteMatteRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_pickCryptomatteMatteResponse>>(PrepareAsyncpickCryptomatteMatteRaw(context, request, cq));
    }
    ::grpc::Status modifyCryptomatteMatteSelection(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_modifyCryptomatteMatteSelectionRequest& request, ::octaneapi::ApiRenderEngine_modifyCryptomatteMatteSelectionResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_modifyCryptomatteMatteSelectionResponse>> AsyncmodifyCryptomatteMatteSelection(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_modifyCryptomatteMatteSelectionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_modifyCryptomatteMatteSelectionResponse>>(AsyncmodifyCryptomatteMatteSelectionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_modifyCryptomatteMatteSelectionResponse>> PrepareAsyncmodifyCryptomatteMatteSelection(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_modifyCryptomatteMatteSelectionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_modifyCryptomatteMatteSelectionResponse>>(PrepareAsyncmodifyCryptomatteMatteSelectionRaw(context, request, cq));
    }
    ::grpc::Status toString(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_toStringRequest& request, ::octaneapi::ApiRenderEngine_toStringResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_toStringResponse>> AsynctoString(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_toStringRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_toStringResponse>>(AsynctoStringRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_toStringResponse>> PrepareAsynctoString(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_toStringRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_toStringResponse>>(PrepareAsynctoStringRaw(context, request, cq));
    }
    ::grpc::Status getDevicePciIds(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getDevicePciIdsRequest& request, ::octaneapi::ApiRenderEngine_getDevicePciIdsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getDevicePciIdsResponse>> AsyncgetDevicePciIds(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getDevicePciIdsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getDevicePciIdsResponse>>(AsyncgetDevicePciIdsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getDevicePciIdsResponse>> PrepareAsyncgetDevicePciIds(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getDevicePciIdsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getDevicePciIdsResponse>>(PrepareAsyncgetDevicePciIdsRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void setRenderTargetNode(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setRenderTargetNodeRequest* request, ::octaneapi::ApiRenderEngine_setRenderTargetNodeResponse* response, std::function<void(::grpc::Status)>) override;
      void setRenderTargetNode(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setRenderTargetNodeRequest* request, ::octaneapi::ApiRenderEngine_setRenderTargetNodeResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void getRenderTargetNode(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRenderTargetNodeRequest* request, ::octaneapi::ApiRenderEngine_getRenderTargetNodeResponse* response, std::function<void(::grpc::Status)>) override;
      void getRenderTargetNode(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRenderTargetNodeRequest* request, ::octaneapi::ApiRenderEngine_getRenderTargetNodeResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void getRenderGeometryNode(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRenderGeometryNodeRequest* request, ::octaneapi::ApiRenderEngine_getRenderGeometryNodeResponse* response, std::function<void(::grpc::Status)>) override;
      void getRenderGeometryNode(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRenderGeometryNodeRequest* request, ::octaneapi::ApiRenderEngine_getRenderGeometryNodeResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void getRenderCameraNode(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRenderCameraNodeRequest* request, ::octaneapi::ApiRenderEngine_getRenderCameraNodeResponse* response, std::function<void(::grpc::Status)>) override;
      void getRenderCameraNode(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRenderCameraNodeRequest* request, ::octaneapi::ApiRenderEngine_getRenderCameraNodeResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void setRenderRegion(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setRenderRegionRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      void setRenderRegion(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setRenderRegionRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void getRenderRegion(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRenderRegionRequest* request, ::octaneapi::ApiRenderEngine_getRenderRegionResponse* response, std::function<void(::grpc::Status)>) override;
      void getRenderRegion(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRenderRegionRequest* request, ::octaneapi::ApiRenderEngine_getRenderRegionResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void setAsyncTonemapParams(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setAsyncTonemapParamsRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      void setAsyncTonemapParams(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setAsyncTonemapParamsRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void setAsyncTonemapParams1(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setAsyncTonemapParams1Request* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      void setAsyncTonemapParams1(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setAsyncTonemapParams1Request* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void asyncTonemapBufferType(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_asyncTonemapBufferTypeRequest* request, ::octaneapi::ApiRenderEngine_asyncTonemapBufferTypeResponse* response, std::function<void(::grpc::Status)>) override;
      void asyncTonemapBufferType(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_asyncTonemapBufferTypeRequest* request, ::octaneapi::ApiRenderEngine_asyncTonemapBufferTypeResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void asyncTonemapCryptomatteFalseColor(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_asyncTonemapCryptomatteFalseColorRequest* request, ::octaneapi::ApiRenderEngine_asyncTonemapCryptomatteFalseColorResponse* response, std::function<void(::grpc::Status)>) override;
      void asyncTonemapCryptomatteFalseColor(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_asyncTonemapCryptomatteFalseColorRequest* request, ::octaneapi::ApiRenderEngine_asyncTonemapCryptomatteFalseColorResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void asyncTonemapOutputColorSpaceInfo(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_asyncTonemapOutputColorSpaceInfoRequest* request, ::octaneapi::ApiRenderEngine_asyncTonemapOutputColorSpaceInfoResponse* response, std::function<void(::grpc::Status)>) override;
      void asyncTonemapOutputColorSpaceInfo(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_asyncTonemapOutputColorSpaceInfoRequest* request, ::octaneapi::ApiRenderEngine_asyncTonemapOutputColorSpaceInfoResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void asyncTonemapColorSpace(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_asyncTonemapColorSpaceRequest* request, ::octaneapi::ApiRenderEngine_asyncTonemapColorSpaceResponse* response, std::function<void(::grpc::Status)>) override;
      void asyncTonemapColorSpace(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_asyncTonemapColorSpaceRequest* request, ::octaneapi::ApiRenderEngine_asyncTonemapColorSpaceResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void asyncTonemapPremultipliedAlphaType(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_asyncTonemapPremultipliedAlphaTypeRequest* request, ::octaneapi::ApiRenderEngine_asyncTonemapPremultipliedAlphaTypeResponse* response, std::function<void(::grpc::Status)>) override;
      void asyncTonemapPremultipliedAlphaType(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_asyncTonemapPremultipliedAlphaTypeRequest* request, ::octaneapi::ApiRenderEngine_asyncTonemapPremultipliedAlphaTypeResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void setAsyncTonemapRenderPasses(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setAsyncTonemapRenderPassesRequest* request, ::octaneapi::ApiRenderEngine_setAsyncTonemapRenderPassesResponse* response, std::function<void(::grpc::Status)>) override;
      void setAsyncTonemapRenderPasses(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setAsyncTonemapRenderPassesRequest* request, ::octaneapi::ApiRenderEngine_setAsyncTonemapRenderPassesResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void asyncTonemapRenderPasses(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_asyncTonemapRenderPassesRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      void asyncTonemapRenderPasses(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_asyncTonemapRenderPassesRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void getEnabledAovs(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getEnabledAovsRequest* request, ::octaneapi::ApiRenderEngine_getEnabledAovsResponse* response, std::function<void(::grpc::Status)>) override;
      void getEnabledAovs(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getEnabledAovsRequest* request, ::octaneapi::ApiRenderEngine_getEnabledAovsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void freeTonemapPasses(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_freeTonemapPassesRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      void freeTonemapPasses(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_freeTonemapPassesRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void displayRenderPassId(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_displayRenderPassIdRequest* request, ::octaneapi::ApiRenderEngine_displayRenderPassIdResponse* response, std::function<void(::grpc::Status)>) override;
      void displayRenderPassId(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_displayRenderPassIdRequest* request, ::octaneapi::ApiRenderEngine_displayRenderPassIdResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void setSubSampleMode(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setSubSampleModeRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      void setSubSampleMode(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setSubSampleModeRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void getSubSampleMode(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getSubSampleModeRequest* request, ::octaneapi::ApiRenderEngine_getSubSampleModeResponse* response, std::function<void(::grpc::Status)>) override;
      void getSubSampleMode(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getSubSampleModeRequest* request, ::octaneapi::ApiRenderEngine_getSubSampleModeResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void setClayMode(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setClayModeRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      void setClayMode(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setClayModeRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void clayMode(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_clayModeRequest* request, ::octaneapi::ApiRenderEngine_clayModeResponse* response, std::function<void(::grpc::Status)>) override;
      void clayMode(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_clayModeRequest* request, ::octaneapi::ApiRenderEngine_clayModeResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void fps(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_fpsRequest* request, ::octaneapi::ApiRenderEngine_fpsResponse* response, std::function<void(::grpc::Status)>) override;
      void fps(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_fpsRequest* request, ::octaneapi::ApiRenderEngine_fpsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void setFps(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setFpsRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      void setFps(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setFpsRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void isCompiling(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isCompilingRequest* request, ::octaneapi::ApiRenderEngine_isCompilingResponse* response, std::function<void(::grpc::Status)>) override;
      void isCompiling(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isCompilingRequest* request, ::octaneapi::ApiRenderEngine_isCompilingResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void isCompressingTextures(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isCompressingTexturesRequest* request, ::octaneapi::ApiRenderEngine_isCompressingTexturesResponse* response, std::function<void(::grpc::Status)>) override;
      void isCompressingTextures(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isCompressingTexturesRequest* request, ::octaneapi::ApiRenderEngine_isCompressingTexturesResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void hasPendingRenderData(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_hasPendingRenderDataRequest* request, ::octaneapi::ApiRenderEngine_hasPendingRenderDataResponse* response, std::function<void(::grpc::Status)>) override;
      void hasPendingRenderData(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_hasPendingRenderDataRequest* request, ::octaneapi::ApiRenderEngine_hasPendingRenderDataResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void getCurrentChangeLevel(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getCurrentChangeLevelRequest* request, ::octaneapi::ApiRenderEngine_getCurrentChangeLevelResponse* response, std::function<void(::grpc::Status)>) override;
      void getCurrentChangeLevel(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getCurrentChangeLevelRequest* request, ::octaneapi::ApiRenderEngine_getCurrentChangeLevelResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void getRenderImageChangeLevel(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRenderImageChangeLevelRequest* request, ::octaneapi::ApiRenderEngine_getRenderImageChangeLevelResponse* response, std::function<void(::grpc::Status)>) override;
      void getRenderImageChangeLevel(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRenderImageChangeLevelRequest* request, ::octaneapi::ApiRenderEngine_getRenderImageChangeLevelResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void getRenderRestartedChangeLevel(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRenderRestartedChangeLevelRequest* request, ::octaneapi::ApiRenderEngine_getRenderRestartedChangeLevelResponse* response, std::function<void(::grpc::Status)>) override;
      void getRenderRestartedChangeLevel(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRenderRestartedChangeLevelRequest* request, ::octaneapi::ApiRenderEngine_getRenderRestartedChangeLevelResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void setAsyncUpdateCallback(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setAsyncUpdateCallbackRequest* request, ::octaneapi::ApiRenderEngine_setAsyncUpdateCallbackResponse* response, std::function<void(::grpc::Status)>) override;
      void setAsyncUpdateCallback(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setAsyncUpdateCallbackRequest* request, ::octaneapi::ApiRenderEngine_setAsyncUpdateCallbackResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void updatesAreAsync(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_updatesAreAsyncRequest* request, ::octaneapi::ApiRenderEngine_updatesAreAsyncResponse* response, std::function<void(::grpc::Status)>) override;
      void updatesAreAsync(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_updatesAreAsyncRequest* request, ::octaneapi::ApiRenderEngine_updatesAreAsyncResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void isImageReady(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isImageReadyRequest* request, ::octaneapi::ApiRenderEngine_isImageReadyResponse* response, std::function<void(::grpc::Status)>) override;
      void isImageReady(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isImageReadyRequest* request, ::octaneapi::ApiRenderEngine_isImageReadyResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void resetImageReady(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_resetImageReadyRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      void resetImageReady(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_resetImageReadyRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void isRenderFailure(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isRenderFailureRequest* request, ::octaneapi::ApiRenderEngine_isRenderFailureResponse* response, std::function<void(::grpc::Status)>) override;
      void isRenderFailure(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isRenderFailureRequest* request, ::octaneapi::ApiRenderEngine_isRenderFailureResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void resetRenderFailure(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_resetRenderFailureRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      void resetRenderFailure(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_resetRenderFailureRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void setOnTileBlendedCallback(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setOnTileBlendedCallbackRequest* request, ::octaneapi::ApiRenderEngine_setOnTileBlendedCallbackResponse* response, std::function<void(::grpc::Status)>) override;
      void setOnTileBlendedCallback(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setOnTileBlendedCallbackRequest* request, ::octaneapi::ApiRenderEngine_setOnTileBlendedCallbackResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void setOnNewStatisticsCallback(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setOnNewStatisticsCallbackRequest* request, ::octaneapi::ApiRenderEngine_setOnNewStatisticsCallbackResponse* response, std::function<void(::grpc::Status)>) override;
      void setOnNewStatisticsCallback(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setOnNewStatisticsCallbackRequest* request, ::octaneapi::ApiRenderEngine_setOnNewStatisticsCallbackResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void setOnNewImageCallback(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setOnNewImageCallbackRequest* request, ::octaneapi::ApiRenderEngine_setOnNewImageCallbackResponse* response, std::function<void(::grpc::Status)>) override;
      void setOnNewImageCallback(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setOnNewImageCallbackRequest* request, ::octaneapi::ApiRenderEngine_setOnNewImageCallbackResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void setOnOcioErrorCallback(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setOnOcioErrorCallbackRequest* request, ::octaneapi::ApiRenderEngine_setOnOcioErrorCallbackResponse* response, std::function<void(::grpc::Status)>) override;
      void setOnOcioErrorCallback(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setOnOcioErrorCallbackRequest* request, ::octaneapi::ApiRenderEngine_setOnOcioErrorCallbackResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void setOnRenderFailureCallback(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setOnRenderFailureCallbackRequest* request, ::octaneapi::ApiRenderEngine_setOnRenderFailureCallbackResponse* response, std::function<void(::grpc::Status)>) override;
      void setOnRenderFailureCallback(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setOnRenderFailureCallbackRequest* request, ::octaneapi::ApiRenderEngine_setOnRenderFailureCallbackResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void setForceCallbacksInRenderThreads(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setForceCallbacksInRenderThreadsRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      void setForceCallbacksInRenderThreads(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setForceCallbacksInRenderThreadsRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void grabRenderResult(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_grabRenderResultRequest* request, ::octaneapi::ApiRenderEngine_grabRenderResultResponse* response, std::function<void(::grpc::Status)>) override;
      void grabRenderResult(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_grabRenderResultRequest* request, ::octaneapi::ApiRenderEngine_grabRenderResultResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void releaseRenderResult(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_releaseRenderResultRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      void releaseRenderResult(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_releaseRenderResultRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void synchronousTonemap(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_synchronousTonemapRequest* request, ::octaneapi::ApiRenderEngine_synchronousTonemapResponse* response, std::function<void(::grpc::Status)>) override;
      void synchronousTonemap(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_synchronousTonemapRequest* request, ::octaneapi::ApiRenderEngine_synchronousTonemapResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void synchronousTonemap1(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_synchronousTonemap1Request* request, ::octaneapi::ApiRenderEngine_synchronousTonemap1Response* response, std::function<void(::grpc::Status)>) override;
      void synchronousTonemap1(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_synchronousTonemap1Request* request, ::octaneapi::ApiRenderEngine_synchronousTonemap1Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void synchronousTonemapAllRenderPasses(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPassesRequest* request, ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPassesResponse* response, std::function<void(::grpc::Status)>) override;
      void synchronousTonemapAllRenderPasses(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPassesRequest* request, ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPassesResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void synchronousTonemapAllRenderPasses1(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPasses1Request* request, ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPasses1Response* response, std::function<void(::grpc::Status)>) override;
      void synchronousTonemapAllRenderPasses1(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPasses1Request* request, ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPasses1Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void getRenderStatistics(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRenderStatisticsRequest* request, ::octaneapi::ApiRenderEngine_getRenderStatisticsResponse* response, std::function<void(::grpc::Status)>) override;
      void getRenderStatistics(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRenderStatisticsRequest* request, ::octaneapi::ApiRenderEngine_getRenderStatisticsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void getRenderResultStatistics(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRenderResultStatisticsRequest* request, ::octaneapi::ApiRenderEngine_getRenderResultStatisticsResponse* response, std::function<void(::grpc::Status)>) override;
      void getRenderResultStatistics(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRenderResultStatisticsRequest* request, ::octaneapi::ApiRenderEngine_getRenderResultStatisticsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void saveImage(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveImageRequest* request, ::octaneapi::ApiRenderEngine_saveImageResponse* response, std::function<void(::grpc::Status)>) override;
      void saveImage(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveImageRequest* request, ::octaneapi::ApiRenderEngine_saveImageResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void saveImage1(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveImage1Request* request, ::octaneapi::ApiRenderEngine_saveImage1Response* response, std::function<void(::grpc::Status)>) override;
      void saveImage1(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveImage1Request* request, ::octaneapi::ApiRenderEngine_saveImage1Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void saveImage2(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveImage2Request* request, ::octaneapi::ApiRenderEngine_saveImage2Response* response, std::function<void(::grpc::Status)>) override;
      void saveImage2(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveImage2Request* request, ::octaneapi::ApiRenderEngine_saveImage2Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void saveRenderPasses(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveRenderPassesRequest* request, ::octaneapi::ApiRenderEngine_saveRenderPassesResponse* response, std::function<void(::grpc::Status)>) override;
      void saveRenderPasses(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveRenderPassesRequest* request, ::octaneapi::ApiRenderEngine_saveRenderPassesResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void saveRenderPasses1(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveRenderPasses1Request* request, ::octaneapi::ApiRenderEngine_saveRenderPasses1Response* response, std::function<void(::grpc::Status)>) override;
      void saveRenderPasses1(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveRenderPasses1Request* request, ::octaneapi::ApiRenderEngine_saveRenderPasses1Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void saveRenderPasses2(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveRenderPasses2Request* request, ::octaneapi::ApiRenderEngine_saveRenderPasses2Response* response, std::function<void(::grpc::Status)>) override;
      void saveRenderPasses2(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveRenderPasses2Request* request, ::octaneapi::ApiRenderEngine_saveRenderPasses2Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void saveRenderPassesMultiExr(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExrRequest* request, ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExrResponse* response, std::function<void(::grpc::Status)>) override;
      void saveRenderPassesMultiExr(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExrRequest* request, ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExrResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void saveRenderPassesMultiExr1(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExr1Request* request, ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExr1Response* response, std::function<void(::grpc::Status)>) override;
      void saveRenderPassesMultiExr1(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExr1Request* request, ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExr1Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void saveRenderPassesDeepExr(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveRenderPassesDeepExrRequest* request, ::octaneapi::ApiRenderEngine_saveRenderPassesDeepExrResponse* response, std::function<void(::grpc::Status)>) override;
      void saveRenderPassesDeepExr(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveRenderPassesDeepExrRequest* request, ::octaneapi::ApiRenderEngine_saveRenderPassesDeepExrResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void deepImageEnabled(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deepImageEnabledRequest* request, ::octaneapi::ApiRenderEngine_deepImageEnabledResponse* response, std::function<void(::grpc::Status)>) override;
      void deepImageEnabled(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deepImageEnabledRequest* request, ::octaneapi::ApiRenderEngine_deepImageEnabledResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void deepImageEnabled1(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deepImageEnabled1Request* request, ::octaneapi::ApiRenderEngine_deepImageEnabled1Response* response, std::function<void(::grpc::Status)>) override;
      void deepImageEnabled1(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deepImageEnabled1Request* request, ::octaneapi::ApiRenderEngine_deepImageEnabled1Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void deepPassesEnabled(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deepPassesEnabledRequest* request, ::octaneapi::ApiRenderEngine_deepPassesEnabledResponse* response, std::function<void(::grpc::Status)>) override;
      void deepPassesEnabled(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deepPassesEnabledRequest* request, ::octaneapi::ApiRenderEngine_deepPassesEnabledResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void canSaveDeepImage(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_canSaveDeepImageRequest* request, ::octaneapi::ApiRenderEngine_canSaveDeepImageResponse* response, std::function<void(::grpc::Status)>) override;
      void canSaveDeepImage(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_canSaveDeepImageRequest* request, ::octaneapi::ApiRenderEngine_canSaveDeepImageResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void saveDeepImage(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveDeepImageRequest* request, ::octaneapi::ApiRenderEngine_saveDeepImageResponse* response, std::function<void(::grpc::Status)>) override;
      void saveDeepImage(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveDeepImageRequest* request, ::octaneapi::ApiRenderEngine_saveDeepImageResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void saveRenderState(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveRenderStateRequest* request, ::octaneapi::ApiRenderEngine_saveRenderStateResponse* response, std::function<void(::grpc::Status)>) override;
      void saveRenderState(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveRenderStateRequest* request, ::octaneapi::ApiRenderEngine_saveRenderStateResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void loadRenderState(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_loadRenderStateRequest* request, ::octaneapi::ApiRenderEngine_loadRenderStateResponse* response, std::function<void(::grpc::Status)>) override;
      void loadRenderState(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_loadRenderStateRequest* request, ::octaneapi::ApiRenderEngine_loadRenderStateResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void previewMaterial(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_previewMaterialRequest* request, ::octaneapi::ApiRenderEngine_previewMaterialResponse* response, std::function<void(::grpc::Status)>) override;
      void previewMaterial(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_previewMaterialRequest* request, ::octaneapi::ApiRenderEngine_previewMaterialResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void previewMaterialHdr(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_previewMaterialHdrRequest* request, ::octaneapi::ApiRenderEngine_previewMaterialHdrResponse* response, std::function<void(::grpc::Status)>) override;
      void previewMaterialHdr(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_previewMaterialHdrRequest* request, ::octaneapi::ApiRenderEngine_previewMaterialHdrResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void previewMaterial1(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_previewMaterial1Request* request, ::octaneapi::ApiRenderEngine_previewMaterial1Response* response, std::function<void(::grpc::Status)>) override;
      void previewMaterial1(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_previewMaterial1Request* request, ::octaneapi::ApiRenderEngine_previewMaterial1Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void getMemoryUsage(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getMemoryUsageRequest* request, ::octaneapi::ApiRenderEngine_getMemoryUsageResponse* response, std::function<void(::grpc::Status)>) override;
      void getMemoryUsage(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getMemoryUsageRequest* request, ::octaneapi::ApiRenderEngine_getMemoryUsageResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void getResourceStatistics(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getResourceStatisticsRequest* request, ::octaneapi::ApiRenderEngine_getResourceStatisticsResponse* response, std::function<void(::grpc::Status)>) override;
      void getResourceStatistics(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getResourceStatisticsRequest* request, ::octaneapi::ApiRenderEngine_getResourceStatisticsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void getGeometryStatistics(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getGeometryStatisticsRequest* request, ::octaneapi::ApiRenderEngine_getGeometryStatisticsResponse* response, std::function<void(::grpc::Status)>) override;
      void getGeometryStatistics(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getGeometryStatisticsRequest* request, ::octaneapi::ApiRenderEngine_getGeometryStatisticsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void getTexturesStatistics(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getTexturesStatisticsRequest* request, ::octaneapi::ApiRenderEngine_getTexturesStatisticsResponse* response, std::function<void(::grpc::Status)>) override;
      void getTexturesStatistics(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getTexturesStatisticsRequest* request, ::octaneapi::ApiRenderEngine_getTexturesStatisticsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void getSceneBounds(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getSceneBoundsRequest* request, ::octaneapi::ApiRenderEngine_getSceneBoundsResponse* response, std::function<void(::grpc::Status)>) override;
      void getSceneBounds(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getSceneBoundsRequest* request, ::octaneapi::ApiRenderEngine_getSceneBoundsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void getDeviceCount(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getDeviceCountRequest* request, ::octaneapi::ApiRenderEngine_getDeviceCountResponse* response, std::function<void(::grpc::Status)>) override;
      void getDeviceCount(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getDeviceCountRequest* request, ::octaneapi::ApiRenderEngine_getDeviceCountResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void getDeviceComputeModel(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getDeviceComputeModelRequest* request, ::octaneapi::ApiRenderEngine_getDeviceComputeModelResponse* response, std::function<void(::grpc::Status)>) override;
      void getDeviceComputeModel(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getDeviceComputeModelRequest* request, ::octaneapi::ApiRenderEngine_getDeviceComputeModelResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void getDeviceName(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getDeviceNameRequest* request, ::octaneapi::ApiRenderEngine_getDeviceNameResponse* response, std::function<void(::grpc::Status)>) override;
      void getDeviceName(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getDeviceNameRequest* request, ::octaneapi::ApiRenderEngine_getDeviceNameResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void isSupportedDevice(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isSupportedDeviceRequest* request, ::octaneapi::ApiRenderEngine_isSupportedDeviceResponse* response, std::function<void(::grpc::Status)>) override;
      void isSupportedDevice(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isSupportedDeviceRequest* request, ::octaneapi::ApiRenderEngine_isSupportedDeviceResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void deviceCanRender(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deviceCanRenderRequest* request, ::octaneapi::ApiRenderEngine_deviceCanRenderResponse* response, std::function<void(::grpc::Status)>) override;
      void deviceCanRender(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deviceCanRenderRequest* request, ::octaneapi::ApiRenderEngine_deviceCanRenderResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void deviceCanDenoise(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deviceCanDenoiseRequest* request, ::octaneapi::ApiRenderEngine_deviceCanDenoiseResponse* response, std::function<void(::grpc::Status)>) override;
      void deviceCanDenoise(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deviceCanDenoiseRequest* request, ::octaneapi::ApiRenderEngine_deviceCanDenoiseResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void deviceSupportsHardwareRayTracing(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deviceSupportsHardwareRayTracingRequest* request, ::octaneapi::ApiRenderEngine_deviceSupportsHardwareRayTracingResponse* response, std::function<void(::grpc::Status)>) override;
      void deviceSupportsHardwareRayTracing(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deviceSupportsHardwareRayTracingRequest* request, ::octaneapi::ApiRenderEngine_deviceSupportsHardwareRayTracingResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void deviceSharedSurfaceInfo(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deviceSharedSurfaceInfoRequest* request, ::octaneapi::ApiRenderEngine_deviceSharedSurfaceInfoResponse* response, std::function<void(::grpc::Status)>) override;
      void deviceSharedSurfaceInfo(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deviceSharedSurfaceInfoRequest* request, ::octaneapi::ApiRenderEngine_deviceSharedSurfaceInfoResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void getAvailablePeerToPeerPairs(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getAvailablePeerToPeerPairsRequest* request, ::octaneapi::ApiRenderEngine_getAvailablePeerToPeerPairsResponse* response, std::function<void(::grpc::Status)>) override;
      void getAvailablePeerToPeerPairs(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getAvailablePeerToPeerPairsRequest* request, ::octaneapi::ApiRenderEngine_getAvailablePeerToPeerPairsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void setDevicesActivity(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setDevicesActivityRequest* request, ::octaneapi::ApiRenderEngine_setDevicesActivityResponse* response, std::function<void(::grpc::Status)>) override;
      void setDevicesActivity(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setDevicesActivityRequest* request, ::octaneapi::ApiRenderEngine_setDevicesActivityResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void isDeviceUsedForRendering(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isDeviceUsedForRenderingRequest* request, ::octaneapi::ApiRenderEngine_isDeviceUsedForRenderingResponse* response, std::function<void(::grpc::Status)>) override;
      void isDeviceUsedForRendering(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isDeviceUsedForRenderingRequest* request, ::octaneapi::ApiRenderEngine_isDeviceUsedForRenderingResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void deviceUsesPriority(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deviceUsesPriorityRequest* request, ::octaneapi::ApiRenderEngine_deviceUsesPriorityResponse* response, std::function<void(::grpc::Status)>) override;
      void deviceUsesPriority(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deviceUsesPriorityRequest* request, ::octaneapi::ApiRenderEngine_deviceUsesPriorityResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void deviceUsesHardwareRayTracing(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deviceUsesHardwareRayTracingRequest* request, ::octaneapi::ApiRenderEngine_deviceUsesHardwareRayTracingResponse* response, std::function<void(::grpc::Status)>) override;
      void deviceUsesHardwareRayTracing(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deviceUsesHardwareRayTracingRequest* request, ::octaneapi::ApiRenderEngine_deviceUsesHardwareRayTracingResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void imageDeviceIndex(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_imageDeviceIndexRequest* request, ::octaneapi::ApiRenderEngine_imageDeviceIndexResponse* response, std::function<void(::grpc::Status)>) override;
      void imageDeviceIndex(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_imageDeviceIndexRequest* request, ::octaneapi::ApiRenderEngine_imageDeviceIndexResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void isDeviceUsedForDenoising(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isDeviceUsedForDenoisingRequest* request, ::octaneapi::ApiRenderEngine_isDeviceUsedForDenoisingResponse* response, std::function<void(::grpc::Status)>) override;
      void isDeviceUsedForDenoising(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isDeviceUsedForDenoisingRequest* request, ::octaneapi::ApiRenderEngine_isDeviceUsedForDenoisingResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void renderPriority(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_renderPriorityRequest* request, ::octaneapi::ApiRenderEngine_renderPriorityResponse* response, std::function<void(::grpc::Status)>) override;
      void renderPriority(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_renderPriorityRequest* request, ::octaneapi::ApiRenderEngine_renderPriorityResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void setRenderPriority(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setRenderPriorityRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      void setRenderPriority(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setRenderPriorityRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void currentPeerToPeerGroups(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_currentPeerToPeerGroupsRequest* request, ::octaneapi::ApiRenderEngine_currentPeerToPeerGroupsResponse* response, std::function<void(::grpc::Status)>) override;
      void currentPeerToPeerGroups(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_currentPeerToPeerGroupsRequest* request, ::octaneapi::ApiRenderEngine_currentPeerToPeerGroupsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void hardwareRayTracingEnabled(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_hardwareRayTracingEnabledRequest* request, ::octaneapi::ApiRenderEngine_hardwareRayTracingEnabledResponse* response, std::function<void(::grpc::Status)>) override;
      void hardwareRayTracingEnabled(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_hardwareRayTracingEnabledRequest* request, ::octaneapi::ApiRenderEngine_hardwareRayTracingEnabledResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void openDeviceSettings(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_openDeviceSettingsRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      void openDeviceSettings(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_openDeviceSettingsRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void renderDeviceState(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_renderDeviceStateRequest* request, ::octaneapi::ApiRenderEngine_renderDeviceStateResponse* response, std::function<void(::grpc::Status)>) override;
      void renderDeviceState(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_renderDeviceStateRequest* request, ::octaneapi::ApiRenderEngine_renderDeviceStateResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void renderDeviceErrorCode(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_renderDeviceErrorCodeRequest* request, ::octaneapi::ApiRenderEngine_renderDeviceErrorCodeResponse* response, std::function<void(::grpc::Status)>) override;
      void renderDeviceErrorCode(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_renderDeviceErrorCodeRequest* request, ::octaneapi::ApiRenderEngine_renderDeviceErrorCodeResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void errorcodeToString(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_errorcodeToStringRequest* request, ::octaneapi::ApiRenderEngine_errorcodeToStringResponse* response, std::function<void(::grpc::Status)>) override;
      void errorcodeToString(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_errorcodeToStringRequest* request, ::octaneapi::ApiRenderEngine_errorcodeToStringResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void renderDeviceErrorMessage(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_renderDeviceErrorMessageRequest* request, ::octaneapi::ApiRenderEngine_renderDeviceErrorMessageResponse* response, std::function<void(::grpc::Status)>) override;
      void renderDeviceErrorMessage(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_renderDeviceErrorMessageRequest* request, ::octaneapi::ApiRenderEngine_renderDeviceErrorMessageResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void saveRenderDeviceConfig(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveRenderDeviceConfigRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      void saveRenderDeviceConfig(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveRenderDeviceConfigRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void outOfCoreEnabled(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_outOfCoreEnabledRequest* request, ::octaneapi::ApiRenderEngine_outOfCoreEnabledResponse* response, std::function<void(::grpc::Status)>) override;
      void outOfCoreEnabled(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_outOfCoreEnabledRequest* request, ::octaneapi::ApiRenderEngine_outOfCoreEnabledResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void enableOutOfCore(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_enableOutOfCoreRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      void enableOutOfCore(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_enableOutOfCoreRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void disableOutOfCore(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_disableOutOfCoreRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      void disableOutOfCore(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_disableOutOfCoreRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void getOutOfCoreMemoryUsage(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getOutOfCoreMemoryUsageRequest* request, ::octaneapi::ApiRenderEngine_getOutOfCoreMemoryUsageResponse* response, std::function<void(::grpc::Status)>) override;
      void getOutOfCoreMemoryUsage(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getOutOfCoreMemoryUsageRequest* request, ::octaneapi::ApiRenderEngine_getOutOfCoreMemoryUsageResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void setGpuHeadroom(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setGpuHeadroomRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      void setGpuHeadroom(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setGpuHeadroomRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void getGpuHeadroom(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getGpuHeadroomRequest* request, ::octaneapi::ApiRenderEngine_getGpuHeadroomResponse* response, std::function<void(::grpc::Status)>) override;
      void getGpuHeadroom(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getGpuHeadroomRequest* request, ::octaneapi::ApiRenderEngine_getGpuHeadroomResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void setCoreLimit(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setCoreLimitRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      void setCoreLimit(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setCoreLimitRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void disableCoreLimit(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_disableCoreLimitRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      void disableCoreLimit(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_disableCoreLimitRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void registerInputSharedSurface(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_registerInputSharedSurfaceRequest* request, ::octaneapi::ApiRenderEngine_registerInputSharedSurfaceResponse* response, std::function<void(::grpc::Status)>) override;
      void registerInputSharedSurface(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_registerInputSharedSurfaceRequest* request, ::octaneapi::ApiRenderEngine_registerInputSharedSurfaceResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void unregisterInputSharedSurface(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_unregisterInputSharedSurfaceRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      void unregisterInputSharedSurface(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_unregisterInputSharedSurfaceRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void triggerAsyncTonemap(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_triggerAsyncTonemapRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      void triggerAsyncTonemap(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_triggerAsyncTonemapRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void setSharedSurfaceOutputType(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setSharedSurfaceOutputTypeRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      void setSharedSurfaceOutputType(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setSharedSurfaceOutputTypeRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void getSharedSurfaceOutputType(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getSharedSurfaceOutputTypeRequest* request, ::octaneapi::ApiRenderEngine_getSharedSurfaceOutputTypeResponse* response, std::function<void(::grpc::Status)>) override;
      void getSharedSurfaceOutputType(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getSharedSurfaceOutputTypeRequest* request, ::octaneapi::ApiRenderEngine_getSharedSurfaceOutputTypeResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void getRealTime(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRealTimeRequest* request, ::octaneapi::ApiRenderEngine_getRealTimeResponse* response, std::function<void(::grpc::Status)>) override;
      void getRealTime(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRealTimeRequest* request, ::octaneapi::ApiRenderEngine_getRealTimeResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void pauseRendering(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_pauseRenderingRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      void pauseRendering(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_pauseRenderingRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void continueRendering(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_continueRenderingRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      void continueRendering(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_continueRenderingRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void isRenderingPaused(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isRenderingPausedRequest* request, ::octaneapi::ApiRenderEngine_isRenderingPausedResponse* response, std::function<void(::grpc::Status)>) override;
      void isRenderingPaused(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isRenderingPausedRequest* request, ::octaneapi::ApiRenderEngine_isRenderingPausedResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void restartRendering(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_restartRenderingRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      void restartRendering(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_restartRenderingRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void stopRendering(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_stopRenderingRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      void stopRendering(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_stopRenderingRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void pick(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_pickRequest* request, ::octaneapi::ApiRenderEngine_pickResponse* response, std::function<void(::grpc::Status)>) override;
      void pick(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_pickRequest* request, ::octaneapi::ApiRenderEngine_pickResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void pickWhitePoint(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_pickWhitePointRequest* request, ::octaneapi::ApiRenderEngine_pickWhitePointResponse* response, std::function<void(::grpc::Status)>) override;
      void pickWhitePoint(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_pickWhitePointRequest* request, ::octaneapi::ApiRenderEngine_pickWhitePointResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void pickImagerWhitePoint(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_pickImagerWhitePointRequest* request, ::octaneapi::ApiRenderEngine_pickImagerWhitePointResponse* response, std::function<void(::grpc::Status)>) override;
      void pickImagerWhitePoint(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_pickImagerWhitePointRequest* request, ::octaneapi::ApiRenderEngine_pickImagerWhitePointResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void isOutputAovWhitePointPickable(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isOutputAovWhitePointPickableRequest* request, ::octaneapi::ApiRenderEngine_isOutputAovWhitePointPickableResponse* response, std::function<void(::grpc::Status)>) override;
      void isOutputAovWhitePointPickable(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isOutputAovWhitePointPickableRequest* request, ::octaneapi::ApiRenderEngine_isOutputAovWhitePointPickableResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void pickOutputAovWhitePoint(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_pickOutputAovWhitePointRequest* request, ::octaneapi::ApiRenderEngine_pickOutputAovWhitePointResponse* response, std::function<void(::grpc::Status)>) override;
      void pickOutputAovWhitePoint(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_pickOutputAovWhitePointRequest* request, ::octaneapi::ApiRenderEngine_pickOutputAovWhitePointResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void pickCryptomatteMatte(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_pickCryptomatteMatteRequest* request, ::octaneapi::ApiRenderEngine_pickCryptomatteMatteResponse* response, std::function<void(::grpc::Status)>) override;
      void pickCryptomatteMatte(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_pickCryptomatteMatteRequest* request, ::octaneapi::ApiRenderEngine_pickCryptomatteMatteResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void modifyCryptomatteMatteSelection(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_modifyCryptomatteMatteSelectionRequest* request, ::octaneapi::ApiRenderEngine_modifyCryptomatteMatteSelectionResponse* response, std::function<void(::grpc::Status)>) override;
      void modifyCryptomatteMatteSelection(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_modifyCryptomatteMatteSelectionRequest* request, ::octaneapi::ApiRenderEngine_modifyCryptomatteMatteSelectionResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void toString(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_toStringRequest* request, ::octaneapi::ApiRenderEngine_toStringResponse* response, std::function<void(::grpc::Status)>) override;
      void toString(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_toStringRequest* request, ::octaneapi::ApiRenderEngine_toStringResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void getDevicePciIds(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getDevicePciIdsRequest* request, ::octaneapi::ApiRenderEngine_getDevicePciIdsResponse* response, std::function<void(::grpc::Status)>) override;
      void getDevicePciIds(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getDevicePciIdsRequest* request, ::octaneapi::ApiRenderEngine_getDevicePciIdsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_setRenderTargetNodeResponse>* AsyncsetRenderTargetNodeRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setRenderTargetNodeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_setRenderTargetNodeResponse>* PrepareAsyncsetRenderTargetNodeRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setRenderTargetNodeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getRenderTargetNodeResponse>* AsyncgetRenderTargetNodeRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRenderTargetNodeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getRenderTargetNodeResponse>* PrepareAsyncgetRenderTargetNodeRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRenderTargetNodeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getRenderGeometryNodeResponse>* AsyncgetRenderGeometryNodeRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRenderGeometryNodeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getRenderGeometryNodeResponse>* PrepareAsyncgetRenderGeometryNodeRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRenderGeometryNodeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getRenderCameraNodeResponse>* AsyncgetRenderCameraNodeRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRenderCameraNodeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getRenderCameraNodeResponse>* PrepareAsyncgetRenderCameraNodeRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRenderCameraNodeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncsetRenderRegionRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setRenderRegionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncsetRenderRegionRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setRenderRegionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getRenderRegionResponse>* AsyncgetRenderRegionRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRenderRegionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getRenderRegionResponse>* PrepareAsyncgetRenderRegionRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRenderRegionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncsetAsyncTonemapParamsRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setAsyncTonemapParamsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncsetAsyncTonemapParamsRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setAsyncTonemapParamsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncsetAsyncTonemapParams1Raw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setAsyncTonemapParams1Request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncsetAsyncTonemapParams1Raw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setAsyncTonemapParams1Request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_asyncTonemapBufferTypeResponse>* AsyncasyncTonemapBufferTypeRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_asyncTonemapBufferTypeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_asyncTonemapBufferTypeResponse>* PrepareAsyncasyncTonemapBufferTypeRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_asyncTonemapBufferTypeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_asyncTonemapCryptomatteFalseColorResponse>* AsyncasyncTonemapCryptomatteFalseColorRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_asyncTonemapCryptomatteFalseColorRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_asyncTonemapCryptomatteFalseColorResponse>* PrepareAsyncasyncTonemapCryptomatteFalseColorRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_asyncTonemapCryptomatteFalseColorRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_asyncTonemapOutputColorSpaceInfoResponse>* AsyncasyncTonemapOutputColorSpaceInfoRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_asyncTonemapOutputColorSpaceInfoRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_asyncTonemapOutputColorSpaceInfoResponse>* PrepareAsyncasyncTonemapOutputColorSpaceInfoRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_asyncTonemapOutputColorSpaceInfoRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_asyncTonemapColorSpaceResponse>* AsyncasyncTonemapColorSpaceRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_asyncTonemapColorSpaceRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_asyncTonemapColorSpaceResponse>* PrepareAsyncasyncTonemapColorSpaceRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_asyncTonemapColorSpaceRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_asyncTonemapPremultipliedAlphaTypeResponse>* AsyncasyncTonemapPremultipliedAlphaTypeRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_asyncTonemapPremultipliedAlphaTypeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_asyncTonemapPremultipliedAlphaTypeResponse>* PrepareAsyncasyncTonemapPremultipliedAlphaTypeRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_asyncTonemapPremultipliedAlphaTypeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_setAsyncTonemapRenderPassesResponse>* AsyncsetAsyncTonemapRenderPassesRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setAsyncTonemapRenderPassesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_setAsyncTonemapRenderPassesResponse>* PrepareAsyncsetAsyncTonemapRenderPassesRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setAsyncTonemapRenderPassesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncasyncTonemapRenderPassesRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_asyncTonemapRenderPassesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncasyncTonemapRenderPassesRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_asyncTonemapRenderPassesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getEnabledAovsResponse>* AsyncgetEnabledAovsRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getEnabledAovsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getEnabledAovsResponse>* PrepareAsyncgetEnabledAovsRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getEnabledAovsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncfreeTonemapPassesRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_freeTonemapPassesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncfreeTonemapPassesRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_freeTonemapPassesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_displayRenderPassIdResponse>* AsyncdisplayRenderPassIdRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_displayRenderPassIdRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_displayRenderPassIdResponse>* PrepareAsyncdisplayRenderPassIdRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_displayRenderPassIdRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncsetSubSampleModeRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setSubSampleModeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncsetSubSampleModeRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setSubSampleModeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getSubSampleModeResponse>* AsyncgetSubSampleModeRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getSubSampleModeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getSubSampleModeResponse>* PrepareAsyncgetSubSampleModeRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getSubSampleModeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncsetClayModeRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setClayModeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncsetClayModeRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setClayModeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_clayModeResponse>* AsyncclayModeRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_clayModeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_clayModeResponse>* PrepareAsyncclayModeRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_clayModeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_fpsResponse>* AsyncfpsRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_fpsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_fpsResponse>* PrepareAsyncfpsRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_fpsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncsetFpsRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setFpsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncsetFpsRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setFpsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_isCompilingResponse>* AsyncisCompilingRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isCompilingRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_isCompilingResponse>* PrepareAsyncisCompilingRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isCompilingRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_isCompressingTexturesResponse>* AsyncisCompressingTexturesRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isCompressingTexturesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_isCompressingTexturesResponse>* PrepareAsyncisCompressingTexturesRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isCompressingTexturesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_hasPendingRenderDataResponse>* AsynchasPendingRenderDataRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_hasPendingRenderDataRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_hasPendingRenderDataResponse>* PrepareAsynchasPendingRenderDataRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_hasPendingRenderDataRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getCurrentChangeLevelResponse>* AsyncgetCurrentChangeLevelRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getCurrentChangeLevelRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getCurrentChangeLevelResponse>* PrepareAsyncgetCurrentChangeLevelRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getCurrentChangeLevelRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getRenderImageChangeLevelResponse>* AsyncgetRenderImageChangeLevelRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRenderImageChangeLevelRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getRenderImageChangeLevelResponse>* PrepareAsyncgetRenderImageChangeLevelRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRenderImageChangeLevelRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getRenderRestartedChangeLevelResponse>* AsyncgetRenderRestartedChangeLevelRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRenderRestartedChangeLevelRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getRenderRestartedChangeLevelResponse>* PrepareAsyncgetRenderRestartedChangeLevelRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRenderRestartedChangeLevelRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_setAsyncUpdateCallbackResponse>* AsyncsetAsyncUpdateCallbackRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setAsyncUpdateCallbackRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_setAsyncUpdateCallbackResponse>* PrepareAsyncsetAsyncUpdateCallbackRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setAsyncUpdateCallbackRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_updatesAreAsyncResponse>* AsyncupdatesAreAsyncRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_updatesAreAsyncRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_updatesAreAsyncResponse>* PrepareAsyncupdatesAreAsyncRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_updatesAreAsyncRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_isImageReadyResponse>* AsyncisImageReadyRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isImageReadyRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_isImageReadyResponse>* PrepareAsyncisImageReadyRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isImageReadyRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncresetImageReadyRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_resetImageReadyRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncresetImageReadyRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_resetImageReadyRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_isRenderFailureResponse>* AsyncisRenderFailureRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isRenderFailureRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_isRenderFailureResponse>* PrepareAsyncisRenderFailureRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isRenderFailureRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncresetRenderFailureRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_resetRenderFailureRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncresetRenderFailureRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_resetRenderFailureRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_setOnTileBlendedCallbackResponse>* AsyncsetOnTileBlendedCallbackRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setOnTileBlendedCallbackRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_setOnTileBlendedCallbackResponse>* PrepareAsyncsetOnTileBlendedCallbackRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setOnTileBlendedCallbackRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_setOnNewStatisticsCallbackResponse>* AsyncsetOnNewStatisticsCallbackRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setOnNewStatisticsCallbackRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_setOnNewStatisticsCallbackResponse>* PrepareAsyncsetOnNewStatisticsCallbackRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setOnNewStatisticsCallbackRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_setOnNewImageCallbackResponse>* AsyncsetOnNewImageCallbackRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setOnNewImageCallbackRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_setOnNewImageCallbackResponse>* PrepareAsyncsetOnNewImageCallbackRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setOnNewImageCallbackRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_setOnOcioErrorCallbackResponse>* AsyncsetOnOcioErrorCallbackRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setOnOcioErrorCallbackRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_setOnOcioErrorCallbackResponse>* PrepareAsyncsetOnOcioErrorCallbackRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setOnOcioErrorCallbackRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_setOnRenderFailureCallbackResponse>* AsyncsetOnRenderFailureCallbackRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setOnRenderFailureCallbackRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_setOnRenderFailureCallbackResponse>* PrepareAsyncsetOnRenderFailureCallbackRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setOnRenderFailureCallbackRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncsetForceCallbacksInRenderThreadsRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setForceCallbacksInRenderThreadsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncsetForceCallbacksInRenderThreadsRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setForceCallbacksInRenderThreadsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_grabRenderResultResponse>* AsyncgrabRenderResultRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_grabRenderResultRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_grabRenderResultResponse>* PrepareAsyncgrabRenderResultRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_grabRenderResultRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncreleaseRenderResultRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_releaseRenderResultRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncreleaseRenderResultRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_releaseRenderResultRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_synchronousTonemapResponse>* AsyncsynchronousTonemapRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_synchronousTonemapRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_synchronousTonemapResponse>* PrepareAsyncsynchronousTonemapRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_synchronousTonemapRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_synchronousTonemap1Response>* AsyncsynchronousTonemap1Raw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_synchronousTonemap1Request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_synchronousTonemap1Response>* PrepareAsyncsynchronousTonemap1Raw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_synchronousTonemap1Request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPassesResponse>* AsyncsynchronousTonemapAllRenderPassesRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPassesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPassesResponse>* PrepareAsyncsynchronousTonemapAllRenderPassesRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPassesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPasses1Response>* AsyncsynchronousTonemapAllRenderPasses1Raw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPasses1Request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPasses1Response>* PrepareAsyncsynchronousTonemapAllRenderPasses1Raw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPasses1Request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getRenderStatisticsResponse>* AsyncgetRenderStatisticsRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRenderStatisticsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getRenderStatisticsResponse>* PrepareAsyncgetRenderStatisticsRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRenderStatisticsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getRenderResultStatisticsResponse>* AsyncgetRenderResultStatisticsRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRenderResultStatisticsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getRenderResultStatisticsResponse>* PrepareAsyncgetRenderResultStatisticsRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRenderResultStatisticsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_saveImageResponse>* AsyncsaveImageRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveImageRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_saveImageResponse>* PrepareAsyncsaveImageRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveImageRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_saveImage1Response>* AsyncsaveImage1Raw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveImage1Request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_saveImage1Response>* PrepareAsyncsaveImage1Raw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveImage1Request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_saveImage2Response>* AsyncsaveImage2Raw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveImage2Request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_saveImage2Response>* PrepareAsyncsaveImage2Raw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveImage2Request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_saveRenderPassesResponse>* AsyncsaveRenderPassesRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveRenderPassesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_saveRenderPassesResponse>* PrepareAsyncsaveRenderPassesRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveRenderPassesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_saveRenderPasses1Response>* AsyncsaveRenderPasses1Raw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveRenderPasses1Request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_saveRenderPasses1Response>* PrepareAsyncsaveRenderPasses1Raw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveRenderPasses1Request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_saveRenderPasses2Response>* AsyncsaveRenderPasses2Raw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveRenderPasses2Request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_saveRenderPasses2Response>* PrepareAsyncsaveRenderPasses2Raw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveRenderPasses2Request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExrResponse>* AsyncsaveRenderPassesMultiExrRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExrRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExrResponse>* PrepareAsyncsaveRenderPassesMultiExrRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExrRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExr1Response>* AsyncsaveRenderPassesMultiExr1Raw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExr1Request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExr1Response>* PrepareAsyncsaveRenderPassesMultiExr1Raw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExr1Request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_saveRenderPassesDeepExrResponse>* AsyncsaveRenderPassesDeepExrRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveRenderPassesDeepExrRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_saveRenderPassesDeepExrResponse>* PrepareAsyncsaveRenderPassesDeepExrRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveRenderPassesDeepExrRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_deepImageEnabledResponse>* AsyncdeepImageEnabledRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deepImageEnabledRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_deepImageEnabledResponse>* PrepareAsyncdeepImageEnabledRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deepImageEnabledRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_deepImageEnabled1Response>* AsyncdeepImageEnabled1Raw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deepImageEnabled1Request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_deepImageEnabled1Response>* PrepareAsyncdeepImageEnabled1Raw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deepImageEnabled1Request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_deepPassesEnabledResponse>* AsyncdeepPassesEnabledRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deepPassesEnabledRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_deepPassesEnabledResponse>* PrepareAsyncdeepPassesEnabledRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deepPassesEnabledRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_canSaveDeepImageResponse>* AsynccanSaveDeepImageRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_canSaveDeepImageRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_canSaveDeepImageResponse>* PrepareAsynccanSaveDeepImageRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_canSaveDeepImageRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_saveDeepImageResponse>* AsyncsaveDeepImageRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveDeepImageRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_saveDeepImageResponse>* PrepareAsyncsaveDeepImageRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveDeepImageRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_saveRenderStateResponse>* AsyncsaveRenderStateRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveRenderStateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_saveRenderStateResponse>* PrepareAsyncsaveRenderStateRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveRenderStateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_loadRenderStateResponse>* AsyncloadRenderStateRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_loadRenderStateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_loadRenderStateResponse>* PrepareAsyncloadRenderStateRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_loadRenderStateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_previewMaterialResponse>* AsyncpreviewMaterialRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_previewMaterialRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_previewMaterialResponse>* PrepareAsyncpreviewMaterialRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_previewMaterialRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_previewMaterialHdrResponse>* AsyncpreviewMaterialHdrRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_previewMaterialHdrRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_previewMaterialHdrResponse>* PrepareAsyncpreviewMaterialHdrRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_previewMaterialHdrRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_previewMaterial1Response>* AsyncpreviewMaterial1Raw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_previewMaterial1Request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_previewMaterial1Response>* PrepareAsyncpreviewMaterial1Raw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_previewMaterial1Request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getMemoryUsageResponse>* AsyncgetMemoryUsageRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getMemoryUsageRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getMemoryUsageResponse>* PrepareAsyncgetMemoryUsageRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getMemoryUsageRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getResourceStatisticsResponse>* AsyncgetResourceStatisticsRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getResourceStatisticsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getResourceStatisticsResponse>* PrepareAsyncgetResourceStatisticsRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getResourceStatisticsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getGeometryStatisticsResponse>* AsyncgetGeometryStatisticsRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getGeometryStatisticsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getGeometryStatisticsResponse>* PrepareAsyncgetGeometryStatisticsRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getGeometryStatisticsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getTexturesStatisticsResponse>* AsyncgetTexturesStatisticsRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getTexturesStatisticsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getTexturesStatisticsResponse>* PrepareAsyncgetTexturesStatisticsRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getTexturesStatisticsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getSceneBoundsResponse>* AsyncgetSceneBoundsRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getSceneBoundsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getSceneBoundsResponse>* PrepareAsyncgetSceneBoundsRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getSceneBoundsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getDeviceCountResponse>* AsyncgetDeviceCountRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getDeviceCountRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getDeviceCountResponse>* PrepareAsyncgetDeviceCountRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getDeviceCountRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getDeviceComputeModelResponse>* AsyncgetDeviceComputeModelRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getDeviceComputeModelRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getDeviceComputeModelResponse>* PrepareAsyncgetDeviceComputeModelRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getDeviceComputeModelRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getDeviceNameResponse>* AsyncgetDeviceNameRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getDeviceNameRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getDeviceNameResponse>* PrepareAsyncgetDeviceNameRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getDeviceNameRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_isSupportedDeviceResponse>* AsyncisSupportedDeviceRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isSupportedDeviceRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_isSupportedDeviceResponse>* PrepareAsyncisSupportedDeviceRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isSupportedDeviceRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_deviceCanRenderResponse>* AsyncdeviceCanRenderRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deviceCanRenderRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_deviceCanRenderResponse>* PrepareAsyncdeviceCanRenderRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deviceCanRenderRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_deviceCanDenoiseResponse>* AsyncdeviceCanDenoiseRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deviceCanDenoiseRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_deviceCanDenoiseResponse>* PrepareAsyncdeviceCanDenoiseRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deviceCanDenoiseRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_deviceSupportsHardwareRayTracingResponse>* AsyncdeviceSupportsHardwareRayTracingRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deviceSupportsHardwareRayTracingRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_deviceSupportsHardwareRayTracingResponse>* PrepareAsyncdeviceSupportsHardwareRayTracingRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deviceSupportsHardwareRayTracingRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_deviceSharedSurfaceInfoResponse>* AsyncdeviceSharedSurfaceInfoRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deviceSharedSurfaceInfoRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_deviceSharedSurfaceInfoResponse>* PrepareAsyncdeviceSharedSurfaceInfoRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deviceSharedSurfaceInfoRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getAvailablePeerToPeerPairsResponse>* AsyncgetAvailablePeerToPeerPairsRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getAvailablePeerToPeerPairsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getAvailablePeerToPeerPairsResponse>* PrepareAsyncgetAvailablePeerToPeerPairsRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getAvailablePeerToPeerPairsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_setDevicesActivityResponse>* AsyncsetDevicesActivityRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setDevicesActivityRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_setDevicesActivityResponse>* PrepareAsyncsetDevicesActivityRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setDevicesActivityRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_isDeviceUsedForRenderingResponse>* AsyncisDeviceUsedForRenderingRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isDeviceUsedForRenderingRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_isDeviceUsedForRenderingResponse>* PrepareAsyncisDeviceUsedForRenderingRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isDeviceUsedForRenderingRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_deviceUsesPriorityResponse>* AsyncdeviceUsesPriorityRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deviceUsesPriorityRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_deviceUsesPriorityResponse>* PrepareAsyncdeviceUsesPriorityRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deviceUsesPriorityRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_deviceUsesHardwareRayTracingResponse>* AsyncdeviceUsesHardwareRayTracingRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deviceUsesHardwareRayTracingRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_deviceUsesHardwareRayTracingResponse>* PrepareAsyncdeviceUsesHardwareRayTracingRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_deviceUsesHardwareRayTracingRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_imageDeviceIndexResponse>* AsyncimageDeviceIndexRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_imageDeviceIndexRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_imageDeviceIndexResponse>* PrepareAsyncimageDeviceIndexRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_imageDeviceIndexRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_isDeviceUsedForDenoisingResponse>* AsyncisDeviceUsedForDenoisingRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isDeviceUsedForDenoisingRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_isDeviceUsedForDenoisingResponse>* PrepareAsyncisDeviceUsedForDenoisingRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isDeviceUsedForDenoisingRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_renderPriorityResponse>* AsyncrenderPriorityRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_renderPriorityRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_renderPriorityResponse>* PrepareAsyncrenderPriorityRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_renderPriorityRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncsetRenderPriorityRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setRenderPriorityRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncsetRenderPriorityRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setRenderPriorityRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_currentPeerToPeerGroupsResponse>* AsynccurrentPeerToPeerGroupsRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_currentPeerToPeerGroupsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_currentPeerToPeerGroupsResponse>* PrepareAsynccurrentPeerToPeerGroupsRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_currentPeerToPeerGroupsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_hardwareRayTracingEnabledResponse>* AsynchardwareRayTracingEnabledRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_hardwareRayTracingEnabledRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_hardwareRayTracingEnabledResponse>* PrepareAsynchardwareRayTracingEnabledRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_hardwareRayTracingEnabledRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncopenDeviceSettingsRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_openDeviceSettingsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncopenDeviceSettingsRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_openDeviceSettingsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_renderDeviceStateResponse>* AsyncrenderDeviceStateRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_renderDeviceStateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_renderDeviceStateResponse>* PrepareAsyncrenderDeviceStateRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_renderDeviceStateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_renderDeviceErrorCodeResponse>* AsyncrenderDeviceErrorCodeRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_renderDeviceErrorCodeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_renderDeviceErrorCodeResponse>* PrepareAsyncrenderDeviceErrorCodeRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_renderDeviceErrorCodeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_errorcodeToStringResponse>* AsyncerrorcodeToStringRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_errorcodeToStringRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_errorcodeToStringResponse>* PrepareAsyncerrorcodeToStringRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_errorcodeToStringRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_renderDeviceErrorMessageResponse>* AsyncrenderDeviceErrorMessageRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_renderDeviceErrorMessageRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_renderDeviceErrorMessageResponse>* PrepareAsyncrenderDeviceErrorMessageRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_renderDeviceErrorMessageRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncsaveRenderDeviceConfigRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveRenderDeviceConfigRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncsaveRenderDeviceConfigRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_saveRenderDeviceConfigRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_outOfCoreEnabledResponse>* AsyncoutOfCoreEnabledRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_outOfCoreEnabledRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_outOfCoreEnabledResponse>* PrepareAsyncoutOfCoreEnabledRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_outOfCoreEnabledRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncenableOutOfCoreRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_enableOutOfCoreRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncenableOutOfCoreRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_enableOutOfCoreRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncdisableOutOfCoreRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_disableOutOfCoreRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncdisableOutOfCoreRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_disableOutOfCoreRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getOutOfCoreMemoryUsageResponse>* AsyncgetOutOfCoreMemoryUsageRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getOutOfCoreMemoryUsageRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getOutOfCoreMemoryUsageResponse>* PrepareAsyncgetOutOfCoreMemoryUsageRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getOutOfCoreMemoryUsageRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncsetGpuHeadroomRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setGpuHeadroomRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncsetGpuHeadroomRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setGpuHeadroomRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getGpuHeadroomResponse>* AsyncgetGpuHeadroomRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getGpuHeadroomRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getGpuHeadroomResponse>* PrepareAsyncgetGpuHeadroomRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getGpuHeadroomRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncsetCoreLimitRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setCoreLimitRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncsetCoreLimitRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setCoreLimitRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncdisableCoreLimitRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_disableCoreLimitRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncdisableCoreLimitRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_disableCoreLimitRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_registerInputSharedSurfaceResponse>* AsyncregisterInputSharedSurfaceRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_registerInputSharedSurfaceRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_registerInputSharedSurfaceResponse>* PrepareAsyncregisterInputSharedSurfaceRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_registerInputSharedSurfaceRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncunregisterInputSharedSurfaceRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_unregisterInputSharedSurfaceRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncunregisterInputSharedSurfaceRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_unregisterInputSharedSurfaceRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsynctriggerAsyncTonemapRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_triggerAsyncTonemapRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsynctriggerAsyncTonemapRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_triggerAsyncTonemapRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncsetSharedSurfaceOutputTypeRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setSharedSurfaceOutputTypeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncsetSharedSurfaceOutputTypeRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_setSharedSurfaceOutputTypeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getSharedSurfaceOutputTypeResponse>* AsyncgetSharedSurfaceOutputTypeRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getSharedSurfaceOutputTypeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getSharedSurfaceOutputTypeResponse>* PrepareAsyncgetSharedSurfaceOutputTypeRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getSharedSurfaceOutputTypeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getRealTimeResponse>* AsyncgetRealTimeRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRealTimeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getRealTimeResponse>* PrepareAsyncgetRealTimeRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getRealTimeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncpauseRenderingRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_pauseRenderingRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncpauseRenderingRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_pauseRenderingRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsynccontinueRenderingRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_continueRenderingRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsynccontinueRenderingRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_continueRenderingRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_isRenderingPausedResponse>* AsyncisRenderingPausedRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isRenderingPausedRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_isRenderingPausedResponse>* PrepareAsyncisRenderingPausedRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isRenderingPausedRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncrestartRenderingRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_restartRenderingRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncrestartRenderingRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_restartRenderingRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncstopRenderingRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_stopRenderingRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncstopRenderingRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_stopRenderingRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_pickResponse>* AsyncpickRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_pickRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_pickResponse>* PrepareAsyncpickRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_pickRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_pickWhitePointResponse>* AsyncpickWhitePointRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_pickWhitePointRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_pickWhitePointResponse>* PrepareAsyncpickWhitePointRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_pickWhitePointRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_pickImagerWhitePointResponse>* AsyncpickImagerWhitePointRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_pickImagerWhitePointRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_pickImagerWhitePointResponse>* PrepareAsyncpickImagerWhitePointRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_pickImagerWhitePointRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_isOutputAovWhitePointPickableResponse>* AsyncisOutputAovWhitePointPickableRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isOutputAovWhitePointPickableRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_isOutputAovWhitePointPickableResponse>* PrepareAsyncisOutputAovWhitePointPickableRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_isOutputAovWhitePointPickableRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_pickOutputAovWhitePointResponse>* AsyncpickOutputAovWhitePointRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_pickOutputAovWhitePointRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_pickOutputAovWhitePointResponse>* PrepareAsyncpickOutputAovWhitePointRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_pickOutputAovWhitePointRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_pickCryptomatteMatteResponse>* AsyncpickCryptomatteMatteRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_pickCryptomatteMatteRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_pickCryptomatteMatteResponse>* PrepareAsyncpickCryptomatteMatteRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_pickCryptomatteMatteRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_modifyCryptomatteMatteSelectionResponse>* AsyncmodifyCryptomatteMatteSelectionRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_modifyCryptomatteMatteSelectionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_modifyCryptomatteMatteSelectionResponse>* PrepareAsyncmodifyCryptomatteMatteSelectionRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_modifyCryptomatteMatteSelectionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_toStringResponse>* AsynctoStringRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_toStringRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_toStringResponse>* PrepareAsynctoStringRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_toStringRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getDevicePciIdsResponse>* AsyncgetDevicePciIdsRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getDevicePciIdsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderEngine_getDevicePciIdsResponse>* PrepareAsyncgetDevicePciIdsRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderEngine_getDevicePciIdsRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_setRenderTargetNode_;
    const ::grpc::internal::RpcMethod rpcmethod_getRenderTargetNode_;
    const ::grpc::internal::RpcMethod rpcmethod_getRenderGeometryNode_;
    const ::grpc::internal::RpcMethod rpcmethod_getRenderCameraNode_;
    const ::grpc::internal::RpcMethod rpcmethod_setRenderRegion_;
    const ::grpc::internal::RpcMethod rpcmethod_getRenderRegion_;
    const ::grpc::internal::RpcMethod rpcmethod_setAsyncTonemapParams_;
    const ::grpc::internal::RpcMethod rpcmethod_setAsyncTonemapParams1_;
    const ::grpc::internal::RpcMethod rpcmethod_asyncTonemapBufferType_;
    const ::grpc::internal::RpcMethod rpcmethod_asyncTonemapCryptomatteFalseColor_;
    const ::grpc::internal::RpcMethod rpcmethod_asyncTonemapOutputColorSpaceInfo_;
    const ::grpc::internal::RpcMethod rpcmethod_asyncTonemapColorSpace_;
    const ::grpc::internal::RpcMethod rpcmethod_asyncTonemapPremultipliedAlphaType_;
    const ::grpc::internal::RpcMethod rpcmethod_setAsyncTonemapRenderPasses_;
    const ::grpc::internal::RpcMethod rpcmethod_asyncTonemapRenderPasses_;
    const ::grpc::internal::RpcMethod rpcmethod_getEnabledAovs_;
    const ::grpc::internal::RpcMethod rpcmethod_freeTonemapPasses_;
    const ::grpc::internal::RpcMethod rpcmethod_displayRenderPassId_;
    const ::grpc::internal::RpcMethod rpcmethod_setSubSampleMode_;
    const ::grpc::internal::RpcMethod rpcmethod_getSubSampleMode_;
    const ::grpc::internal::RpcMethod rpcmethod_setClayMode_;
    const ::grpc::internal::RpcMethod rpcmethod_clayMode_;
    const ::grpc::internal::RpcMethod rpcmethod_fps_;
    const ::grpc::internal::RpcMethod rpcmethod_setFps_;
    const ::grpc::internal::RpcMethod rpcmethod_isCompiling_;
    const ::grpc::internal::RpcMethod rpcmethod_isCompressingTextures_;
    const ::grpc::internal::RpcMethod rpcmethod_hasPendingRenderData_;
    const ::grpc::internal::RpcMethod rpcmethod_getCurrentChangeLevel_;
    const ::grpc::internal::RpcMethod rpcmethod_getRenderImageChangeLevel_;
    const ::grpc::internal::RpcMethod rpcmethod_getRenderRestartedChangeLevel_;
    const ::grpc::internal::RpcMethod rpcmethod_setAsyncUpdateCallback_;
    const ::grpc::internal::RpcMethod rpcmethod_updatesAreAsync_;
    const ::grpc::internal::RpcMethod rpcmethod_isImageReady_;
    const ::grpc::internal::RpcMethod rpcmethod_resetImageReady_;
    const ::grpc::internal::RpcMethod rpcmethod_isRenderFailure_;
    const ::grpc::internal::RpcMethod rpcmethod_resetRenderFailure_;
    const ::grpc::internal::RpcMethod rpcmethod_setOnTileBlendedCallback_;
    const ::grpc::internal::RpcMethod rpcmethod_setOnNewStatisticsCallback_;
    const ::grpc::internal::RpcMethod rpcmethod_setOnNewImageCallback_;
    const ::grpc::internal::RpcMethod rpcmethod_setOnOcioErrorCallback_;
    const ::grpc::internal::RpcMethod rpcmethod_setOnRenderFailureCallback_;
    const ::grpc::internal::RpcMethod rpcmethod_setForceCallbacksInRenderThreads_;
    const ::grpc::internal::RpcMethod rpcmethod_grabRenderResult_;
    const ::grpc::internal::RpcMethod rpcmethod_releaseRenderResult_;
    const ::grpc::internal::RpcMethod rpcmethod_synchronousTonemap_;
    const ::grpc::internal::RpcMethod rpcmethod_synchronousTonemap1_;
    const ::grpc::internal::RpcMethod rpcmethod_synchronousTonemapAllRenderPasses_;
    const ::grpc::internal::RpcMethod rpcmethod_synchronousTonemapAllRenderPasses1_;
    const ::grpc::internal::RpcMethod rpcmethod_getRenderStatistics_;
    const ::grpc::internal::RpcMethod rpcmethod_getRenderResultStatistics_;
    const ::grpc::internal::RpcMethod rpcmethod_saveImage_;
    const ::grpc::internal::RpcMethod rpcmethod_saveImage1_;
    const ::grpc::internal::RpcMethod rpcmethod_saveImage2_;
    const ::grpc::internal::RpcMethod rpcmethod_saveRenderPasses_;
    const ::grpc::internal::RpcMethod rpcmethod_saveRenderPasses1_;
    const ::grpc::internal::RpcMethod rpcmethod_saveRenderPasses2_;
    const ::grpc::internal::RpcMethod rpcmethod_saveRenderPassesMultiExr_;
    const ::grpc::internal::RpcMethod rpcmethod_saveRenderPassesMultiExr1_;
    const ::grpc::internal::RpcMethod rpcmethod_saveRenderPassesDeepExr_;
    const ::grpc::internal::RpcMethod rpcmethod_deepImageEnabled_;
    const ::grpc::internal::RpcMethod rpcmethod_deepImageEnabled1_;
    const ::grpc::internal::RpcMethod rpcmethod_deepPassesEnabled_;
    const ::grpc::internal::RpcMethod rpcmethod_canSaveDeepImage_;
    const ::grpc::internal::RpcMethod rpcmethod_saveDeepImage_;
    const ::grpc::internal::RpcMethod rpcmethod_saveRenderState_;
    const ::grpc::internal::RpcMethod rpcmethod_loadRenderState_;
    const ::grpc::internal::RpcMethod rpcmethod_previewMaterial_;
    const ::grpc::internal::RpcMethod rpcmethod_previewMaterialHdr_;
    const ::grpc::internal::RpcMethod rpcmethod_previewMaterial1_;
    const ::grpc::internal::RpcMethod rpcmethod_getMemoryUsage_;
    const ::grpc::internal::RpcMethod rpcmethod_getResourceStatistics_;
    const ::grpc::internal::RpcMethod rpcmethod_getGeometryStatistics_;
    const ::grpc::internal::RpcMethod rpcmethod_getTexturesStatistics_;
    const ::grpc::internal::RpcMethod rpcmethod_getSceneBounds_;
    const ::grpc::internal::RpcMethod rpcmethod_getDeviceCount_;
    const ::grpc::internal::RpcMethod rpcmethod_getDeviceComputeModel_;
    const ::grpc::internal::RpcMethod rpcmethod_getDeviceName_;
    const ::grpc::internal::RpcMethod rpcmethod_isSupportedDevice_;
    const ::grpc::internal::RpcMethod rpcmethod_deviceCanRender_;
    const ::grpc::internal::RpcMethod rpcmethod_deviceCanDenoise_;
    const ::grpc::internal::RpcMethod rpcmethod_deviceSupportsHardwareRayTracing_;
    const ::grpc::internal::RpcMethod rpcmethod_deviceSharedSurfaceInfo_;
    const ::grpc::internal::RpcMethod rpcmethod_getAvailablePeerToPeerPairs_;
    const ::grpc::internal::RpcMethod rpcmethod_setDevicesActivity_;
    const ::grpc::internal::RpcMethod rpcmethod_isDeviceUsedForRendering_;
    const ::grpc::internal::RpcMethod rpcmethod_deviceUsesPriority_;
    const ::grpc::internal::RpcMethod rpcmethod_deviceUsesHardwareRayTracing_;
    const ::grpc::internal::RpcMethod rpcmethod_imageDeviceIndex_;
    const ::grpc::internal::RpcMethod rpcmethod_isDeviceUsedForDenoising_;
    const ::grpc::internal::RpcMethod rpcmethod_renderPriority_;
    const ::grpc::internal::RpcMethod rpcmethod_setRenderPriority_;
    const ::grpc::internal::RpcMethod rpcmethod_currentPeerToPeerGroups_;
    const ::grpc::internal::RpcMethod rpcmethod_hardwareRayTracingEnabled_;
    const ::grpc::internal::RpcMethod rpcmethod_openDeviceSettings_;
    const ::grpc::internal::RpcMethod rpcmethod_renderDeviceState_;
    const ::grpc::internal::RpcMethod rpcmethod_renderDeviceErrorCode_;
    const ::grpc::internal::RpcMethod rpcmethod_errorcodeToString_;
    const ::grpc::internal::RpcMethod rpcmethod_renderDeviceErrorMessage_;
    const ::grpc::internal::RpcMethod rpcmethod_saveRenderDeviceConfig_;
    const ::grpc::internal::RpcMethod rpcmethod_outOfCoreEnabled_;
    const ::grpc::internal::RpcMethod rpcmethod_enableOutOfCore_;
    const ::grpc::internal::RpcMethod rpcmethod_disableOutOfCore_;
    const ::grpc::internal::RpcMethod rpcmethod_getOutOfCoreMemoryUsage_;
    const ::grpc::internal::RpcMethod rpcmethod_setGpuHeadroom_;
    const ::grpc::internal::RpcMethod rpcmethod_getGpuHeadroom_;
    const ::grpc::internal::RpcMethod rpcmethod_setCoreLimit_;
    const ::grpc::internal::RpcMethod rpcmethod_disableCoreLimit_;
    const ::grpc::internal::RpcMethod rpcmethod_registerInputSharedSurface_;
    const ::grpc::internal::RpcMethod rpcmethod_unregisterInputSharedSurface_;
    const ::grpc::internal::RpcMethod rpcmethod_triggerAsyncTonemap_;
    const ::grpc::internal::RpcMethod rpcmethod_setSharedSurfaceOutputType_;
    const ::grpc::internal::RpcMethod rpcmethod_getSharedSurfaceOutputType_;
    const ::grpc::internal::RpcMethod rpcmethod_getRealTime_;
    const ::grpc::internal::RpcMethod rpcmethod_pauseRendering_;
    const ::grpc::internal::RpcMethod rpcmethod_continueRendering_;
    const ::grpc::internal::RpcMethod rpcmethod_isRenderingPaused_;
    const ::grpc::internal::RpcMethod rpcmethod_restartRendering_;
    const ::grpc::internal::RpcMethod rpcmethod_stopRendering_;
    const ::grpc::internal::RpcMethod rpcmethod_pick_;
    const ::grpc::internal::RpcMethod rpcmethod_pickWhitePoint_;
    const ::grpc::internal::RpcMethod rpcmethod_pickImagerWhitePoint_;
    const ::grpc::internal::RpcMethod rpcmethod_isOutputAovWhitePointPickable_;
    const ::grpc::internal::RpcMethod rpcmethod_pickOutputAovWhitePoint_;
    const ::grpc::internal::RpcMethod rpcmethod_pickCryptomatteMatte_;
    const ::grpc::internal::RpcMethod rpcmethod_modifyCryptomatteMatteSelection_;
    const ::grpc::internal::RpcMethod rpcmethod_toString_;
    const ::grpc::internal::RpcMethod rpcmethod_getDevicePciIds_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // / Sets the render target node that should be rendered
    virtual ::grpc::Status setRenderTargetNode(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_setRenderTargetNodeRequest* request, ::octaneapi::ApiRenderEngine_setRenderTargetNodeResponse* response);
    // / Returns render target node that's currently being rendered (can be NULL)
    virtual ::grpc::Status getRenderTargetNode(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_getRenderTargetNodeRequest* request, ::octaneapi::ApiRenderEngine_getRenderTargetNodeResponse* response);
    // / Returns the geometry root node that's currently being rendered (can be NULL)
    virtual ::grpc::Status getRenderGeometryNode(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_getRenderGeometryNodeRequest* request, ::octaneapi::ApiRenderEngine_getRenderGeometryNodeResponse* response);
    // / Returns the camera node that's currently being rendered (can be NULL)
    virtual ::grpc::Status getRenderCameraNode(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_getRenderCameraNodeRequest* request, ::octaneapi::ApiRenderEngine_getRenderCameraNodeResponse* response);
    // / Sets the render region
    virtual ::grpc::Status setRenderRegion(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_setRenderRegionRequest* request, ::google::protobuf::Empty* response);
    // / Fetches the current render region settings
    virtual ::grpc::Status getRenderRegion(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_getRenderRegionRequest* request, ::octaneapi::ApiRenderEngine_getRenderRegionResponse* response);
    // / Sets parameters for asynchronous tonemapping
    virtual ::grpc::Status setAsyncTonemapParams(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_setAsyncTonemapParamsRequest* request, ::google::protobuf::Empty* response);
    // / Convenience overload that does the same thing as:
    // /
    // /     auto info = ApiOutputColorSpaceInfo::createKnownColorSpace(colorSpace, false);
    // /     setAsyncTonemapParams(
    virtual ::grpc::Status setAsyncTonemapParams1(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_setAsyncTonemapParams1Request* request, ::google::protobuf::Empty* response);
    // / Returns the current asynchronous tonemap buffer type
    virtual ::grpc::Status asyncTonemapBufferType(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_asyncTonemapBufferTypeRequest* request, ::octaneapi::ApiRenderEngine_asyncTonemapBufferTypeResponse* response);
    // / Returns the current value of whether to apply false color to cryptomatte passes for
    // / asynchronous tonemapping
    virtual ::grpc::Status asyncTonemapCryptomatteFalseColor(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_asyncTonemapCryptomatteFalseColorRequest* request, ::octaneapi::ApiRenderEngine_asyncTonemapCryptomatteFalseColorResponse* response);
    // / Returns the current asynchronous tonemap output color space info
    virtual ::grpc::Status asyncTonemapOutputColorSpaceInfo(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_asyncTonemapOutputColorSpaceInfoRequest* request, ::octaneapi::ApiRenderEngine_asyncTonemapOutputColorSpaceInfoResponse* response);
    // / Returns the current asynchronous tonemap output color space
    virtual ::grpc::Status asyncTonemapColorSpace(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_asyncTonemapColorSpaceRequest* request, ::octaneapi::ApiRenderEngine_asyncTonemapColorSpaceResponse* response);
    // / Returns the current asynchronous tonemap premultiplied alpha type
    virtual ::grpc::Status asyncTonemapPremultipliedAlphaType(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_asyncTonemapPremultipliedAlphaTypeRequest* request, ::octaneapi::ApiRenderEngine_asyncTonemapPremultipliedAlphaTypeResponse* response);
    // / Sets the render passes that are tonemapped all the time
    virtual ::grpc::Status setAsyncTonemapRenderPasses(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_setAsyncTonemapRenderPassesRequest* request, ::octaneapi::ApiRenderEngine_setAsyncTonemapRenderPassesResponse* response);
    // / Returns the set of tonemap render passes
    virtual ::grpc::Status asyncTonemapRenderPasses(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_asyncTonemapRenderPassesRequest* request, ::google::protobuf::Empty* response);
    // / Returns the render AOVs and output AOVs that are enabled in the specified render target
    // / node as a set of render pass IDs
    virtual ::grpc::Status getEnabledAovs(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_getEnabledAovsRequest* request, ::octaneapi::ApiRenderEngine_getEnabledAovsResponse* response);
    // / Frees the set of tonemap passes returned by 
    virtual ::grpc::Status freeTonemapPasses(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_freeTonemapPassesRequest* request, ::google::protobuf::Empty* response);
    // / Returns the display pass in the current render
    virtual ::grpc::Status displayRenderPassId(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_displayRenderPassIdRequest* request, ::octaneapi::ApiRenderEngine_displayRenderPassIdResponse* response);
    // / Sets the sub-sampling mode
    virtual ::grpc::Status setSubSampleMode(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_setSubSampleModeRequest* request, ::google::protobuf::Empty* response);
    // / Returns the current sub-sampling mode
    virtual ::grpc::Status getSubSampleMode(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_getSubSampleModeRequest* request, ::octaneapi::ApiRenderEngine_getSubSampleModeResponse* response);
    // / Sets the current clay render mode
    virtual ::grpc::Status setClayMode(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_setClayModeRequest* request, ::google::protobuf::Empty* response);
    // / Returns the current clay mode
    virtual ::grpc::Status clayMode(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_clayModeRequest* request, ::octaneapi::ApiRenderEngine_clayModeResponse* response);
    // / Returns the current fps
    virtual ::grpc::Status fps(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_fpsRequest* request, ::octaneapi::ApiRenderEngine_fpsResponse* response);
    // / Sets the current fps
    virtual ::grpc::Status setFps(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_setFpsRequest* request, ::google::protobuf::Empty* response);
    // / Returns TRUE if the render engine is currently running a compilation job
    virtual ::grpc::Status isCompiling(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_isCompilingRequest* request, ::octaneapi::ApiRenderEngine_isCompilingResponse* response);
    // / Deprecated, this returns the same value as hasPendingRenderData()
    virtual ::grpc::Status isCompressingTextures(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_isCompressingTexturesRequest* request, ::octaneapi::ApiRenderEngine_isCompressingTexturesResponse* response);
    // / Returns TRUE if there is render data that has not finished compiling
    virtual ::grpc::Status hasPendingRenderData(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_hasPendingRenderDataRequest* request, ::octaneapi::ApiRenderEngine_hasPendingRenderDataResponse* response);
    // / Returns the change level after the last update
    virtual ::grpc::Status getCurrentChangeLevel(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_getCurrentChangeLevelRequest* request, ::octaneapi::ApiRenderEngine_getCurrentChangeLevelResponse* response);
    // / Returns the change level of the last rendered image, which can be lower than
    // / getCurrentChangeLevel()
    virtual ::grpc::Status getRenderImageChangeLevel(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_getRenderImageChangeLevelRequest* request, ::octaneapi::ApiRenderEngine_getRenderImageChangeLevelResponse* response);
    // / Returns the change level of the last time the rendering was restarted
    virtual ::grpc::Status getRenderRestartedChangeLevel(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_getRenderRestartedChangeLevelRequest* request, ::octaneapi::ApiRenderEngine_getRenderRestartedChangeLevelResponse* response);
    // / Registers an asynchronous update callback
    virtual ::grpc::Status setAsyncUpdateCallback(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_setAsyncUpdateCallbackRequest* request, ::octaneapi::ApiRenderEngine_setAsyncUpdateCallbackResponse* response);
    // / Checks if updates are done asynchronously
    virtual ::grpc::Status updatesAreAsync(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_updatesAreAsyncRequest* request, ::octaneapi::ApiRenderEngine_updatesAreAsyncResponse* response);
    // / 
    virtual ::grpc::Status isImageReady(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_isImageReadyRequest* request, ::octaneapi::ApiRenderEngine_isImageReadyResponse* response);
    virtual ::grpc::Status resetImageReady(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_resetImageReadyRequest* request, ::google::protobuf::Empty* response);
    virtual ::grpc::Status isRenderFailure(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_isRenderFailureRequest* request, ::octaneapi::ApiRenderEngine_isRenderFailureResponse* response);
    virtual ::grpc::Status resetRenderFailure(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_resetRenderFailureRequest* request, ::google::protobuf::Empty* response);
    // / Registers a callback with the render target that is called when a tile was blended in one
    // / of the two render films and the render statistics did not change
    virtual ::grpc::Status setOnTileBlendedCallback(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_setOnTileBlendedCallbackRequest* request, ::octaneapi::ApiRenderEngine_setOnTileBlendedCallbackResponse* response);
    // / Registers a callback with the render target that is called when the statistics in the
    // / render target changed
    virtual ::grpc::Status setOnNewStatisticsCallback(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_setOnNewStatisticsCallbackRequest* request, ::octaneapi::ApiRenderEngine_setOnNewStatisticsCallbackResponse* response);
    // / Registers a callback with the render target that is called when a new tonemapped result
    // / is available
    virtual ::grpc::Status setOnNewImageCallback(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_setOnNewImageCallbackRequest* request, ::octaneapi::ApiRenderEngine_setOnNewImageCallbackResponse* response);
    // / Registers a callback with the render target that is called when OCIO errors are encountered
    // / when updating render data
    virtual ::grpc::Status setOnOcioErrorCallback(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_setOnOcioErrorCallbackRequest* request, ::octaneapi::ApiRenderEngine_setOnOcioErrorCallbackResponse* response);
    // / Registers a callback with the render target that is called when rendering fails
    virtual ::grpc::Status setOnRenderFailureCallback(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_setOnRenderFailureCallbackRequest* request, ::octaneapi::ApiRenderEngine_setOnRenderFailureCallbackResponse* response);
    // / Forces render engine callbacks to be made in render threads instead of the main message
    // / thread
    virtual ::grpc::Status setForceCallbacksInRenderThreads(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_setForceCallbacksInRenderThreadsRequest* request, ::google::protobuf::Empty* response);
    // / Grabs the latest render result in the passed in array
    virtual ::grpc::Status grabRenderResult(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_grabRenderResultRequest* request, ::octaneapi::ApiRenderEngine_grabRenderResultResponse* response);
    // / Releases the results again so that the engine can reuse it
    virtual ::grpc::Status releaseRenderResult(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_releaseRenderResultRequest* request, ::google::protobuf::Empty* response);
    // / Runs a synchronous tonemap and returns the result
    virtual ::grpc::Status synchronousTonemap(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_synchronousTonemapRequest* request, ::octaneapi::ApiRenderEngine_synchronousTonemapResponse* response);
    // / Convenience overload that does the same thing as:
    // /
    // /     auto info = ApiOutputColorSpaceInfo::createKnownColorSpace(colorSpace, false);
    // /     auto result = synchronousTonemap(
    virtual ::grpc::Status synchronousTonemap1(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_synchronousTonemap1Request* request, ::octaneapi::ApiRenderEngine_synchronousTonemap1Response* response);
    // / Runs a synchronous tonemap for all render passes that are already started by the render 
    // / engine and returns the results
    virtual ::grpc::Status synchronousTonemapAllRenderPasses(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPassesRequest* request, ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPassesResponse* response);
    // / Convenience overload that does the same thing as:
    // /
    // /     auto info = ApiOutputColorSpaceInfo::createKnownColorSpace(colorSpace, false);
    // /     auto result = synchronousTonemapAllRenderPasses(
    virtual ::grpc::Status synchronousTonemapAllRenderPasses1(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPasses1Request* request, ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPasses1Response* response);
    // / Returns the statistics for the current render progress
    virtual ::grpc::Status getRenderStatistics(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_getRenderStatisticsRequest* request, ::octaneapi::ApiRenderEngine_getRenderStatisticsResponse* response);
    // / Returns the statistics for the render results
    virtual ::grpc::Status getRenderResultStatistics(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_getRenderResultStatisticsRequest* request, ::octaneapi::ApiRenderEngine_getRenderResultStatisticsResponse* response);
    // / Saves the current result of the render target to the specified file
    virtual ::grpc::Status saveImage(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_saveImageRequest* request, ::octaneapi::ApiRenderEngine_saveImageResponse* response);
    // / Convenience overload that does the same thing as:
    // /
    // /     auto info = ApiOutputColorSpaceInfo::createKnownColorSpace(colorSpace, false);
    // /     auto result = saveImage(
    virtual ::grpc::Status saveImage1(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_saveImage1Request* request, ::octaneapi::ApiRenderEngine_saveImage1Response* response);
    // / Saves the current result of the render target to the specified file using provided export settings
    // /
    // / 
    virtual ::grpc::Status saveImage2(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_saveImage2Request* request, ::octaneapi::ApiRenderEngine_saveImage2Response* response);
    // / Saves the render passes as discrete files in the provided output directory
    virtual ::grpc::Status saveRenderPasses(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_saveRenderPassesRequest* request, ::octaneapi::ApiRenderEngine_saveRenderPassesResponse* response);
    // / Convenience overload that does the same thing as:
    // /
    // /     auto info = ApiOutputColorSpaceInfo::createKnownColorSpace(colorSpace, false);
    // /     auto result = saveRenderPasses(
    virtual ::grpc::Status saveRenderPasses1(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_saveRenderPasses1Request* request, ::octaneapi::ApiRenderEngine_saveRenderPasses1Response* response);
    // / Saves the render passes as discrete files in the provided output directory
    virtual ::grpc::Status saveRenderPasses2(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_saveRenderPasses2Request* request, ::octaneapi::ApiRenderEngine_saveRenderPasses2Response* response);
    // / Saves the render passes in a multi layer EXR file
    virtual ::grpc::Status saveRenderPassesMultiExr(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExrRequest* request, ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExrResponse* response);
    // / Convenience overload that does the same thing as:
    // /
    // /     auto info = ApiOutputColorSpaceInfo::createKnownColorSpace(colorSpace, false);
    // /     auto result = saveRenderPassesMultiExr(
    virtual ::grpc::Status saveRenderPassesMultiExr1(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExr1Request* request, ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExr1Response* response);
    // / Saves the render passes in a deep image EXR file
    virtual ::grpc::Status saveRenderPassesDeepExr(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_saveRenderPassesDeepExrRequest* request, ::octaneapi::ApiRenderEngine_saveRenderPassesDeepExrResponse* response);
    // / Checks whether the provided render target both supports and has enabled deep pixel rendering
    virtual ::grpc::Status deepImageEnabled(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_deepImageEnabledRequest* request, ::octaneapi::ApiRenderEngine_deepImageEnabledResponse* response);
    // / Checks if deep image rendering is enabled for the current render task
    virtual ::grpc::Status deepImageEnabled1(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_deepImageEnabled1Request* request, ::octaneapi::ApiRenderEngine_deepImageEnabled1Response* response);
    // / Checks if deep image rendering and deep render AOVs are enabled for the current render task
    virtual ::grpc::Status deepPassesEnabled(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_deepPassesEnabledRequest* request, ::octaneapi::ApiRenderEngine_deepPassesEnabledResponse* response);
    // / Checks if we can save a deep image
    virtual ::grpc::Status canSaveDeepImage(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_canSaveDeepImageRequest* request, ::octaneapi::ApiRenderEngine_canSaveDeepImageResponse* response);
    // / Saves the current render as a deep image
    virtual ::grpc::Status saveDeepImage(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_saveDeepImageRequest* request, ::octaneapi::ApiRenderEngine_saveDeepImageResponse* response);
    // / Saves the current render state plus a reference to the project file
    virtual ::grpc::Status saveRenderState(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_saveRenderStateRequest* request, ::octaneapi::ApiRenderEngine_saveRenderStateResponse* response);
    // / Loads an Octane render state file
    virtual ::grpc::Status loadRenderState(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_loadRenderStateRequest* request, ::octaneapi::ApiRenderEngine_loadRenderStateResponse* response);
    // / Renders a preview image of a texture / material node
    virtual ::grpc::Status previewMaterial(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_previewMaterialRequest* request, ::octaneapi::ApiRenderEngine_previewMaterialResponse* response);
    // / Same as above but return HDR buffer
    // /
    // / 
    virtual ::grpc::Status previewMaterialHdr(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_previewMaterialHdrRequest* request, ::octaneapi::ApiRenderEngine_previewMaterialHdrResponse* response);
    // / Preview a material or texture node
    // /
    // / 
    virtual ::grpc::Status previewMaterial1(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_previewMaterial1Request* request, ::octaneapi::ApiRenderEngine_previewMaterial1Response* response);
    // / Returns the overall memory usage of a device
    virtual ::grpc::Status getMemoryUsage(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_getMemoryUsageRequest* request, ::octaneapi::ApiRenderEngine_getMemoryUsageResponse* response);
    // / Returns memory usage statistics for a device
    // /
    // / 
    virtual ::grpc::Status getResourceStatistics(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_getResourceStatisticsRequest* request, ::octaneapi::ApiRenderEngine_getResourceStatisticsResponse* response);
    // / Returns the geometry statistics of the current scene
    virtual ::grpc::Status getGeometryStatistics(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_getGeometryStatisticsRequest* request, ::octaneapi::ApiRenderEngine_getGeometryStatisticsResponse* response);
    // / Returns the texture usage
    virtual ::grpc::Status getTexturesStatistics(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_getTexturesStatisticsRequest* request, ::octaneapi::ApiRenderEngine_getTexturesStatisticsResponse* response);
    // / If the currently rendered scene contains geometry, its bounding box is stored in the
    // / provided vectors and TRUE is returned
    virtual ::grpc::Status getSceneBounds(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_getSceneBoundsRequest* request, ::octaneapi::ApiRenderEngine_getSceneBoundsResponse* response);
    // / Returns the number of render devices (GPUs) in this machine
    virtual ::grpc::Status getDeviceCount(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_getDeviceCountRequest* request, ::octaneapi::ApiRenderEngine_getDeviceCountResponse* response);
    // / Returns the compute model of the device
    virtual ::grpc::Status getDeviceComputeModel(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_getDeviceComputeModelRequest* request, ::octaneapi::ApiRenderEngine_getDeviceComputeModelResponse* response);
    // / Returns the name of the device
    virtual ::grpc::Status getDeviceName(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_getDeviceNameRequest* request, ::octaneapi::ApiRenderEngine_getDeviceNameResponse* response);
    // / Returns TRUE if the device with the provided index is supported by Octane, i
    virtual ::grpc::Status isSupportedDevice(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_isSupportedDeviceRequest* request, ::octaneapi::ApiRenderEngine_isSupportedDeviceResponse* response);
    // / Returns TRUE if the device with the provided index can be used for rendering
    virtual ::grpc::Status deviceCanRender(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_deviceCanRenderRequest* request, ::octaneapi::ApiRenderEngine_deviceCanRenderResponse* response);
    // / Returns TRUE if the device with the provided index can be used for denoising
    virtual ::grpc::Status deviceCanDenoise(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_deviceCanDenoiseRequest* request, ::octaneapi::ApiRenderEngine_deviceCanDenoiseResponse* response);
    // / Returns TRUE if the device with the provided index supports hardware ray-tracing
    virtual ::grpc::Status deviceSupportsHardwareRayTracing(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_deviceSupportsHardwareRayTracingRequest* request, ::octaneapi::ApiRenderEngine_deviceSupportsHardwareRayTracingResponse* response);
    // / Returns details of the shared surface capabilities of the device with the provided index
    virtual ::grpc::Status deviceSharedSurfaceInfo(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_deviceSharedSurfaceInfoRequest* request, ::octaneapi::ApiRenderEngine_deviceSharedSurfaceInfoResponse* response);
    // / Returns an array of available peer-to-peer (NVlink) pairs
    virtual ::grpc::Status getAvailablePeerToPeerPairs(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_getAvailablePeerToPeerPairsRequest* request, ::octaneapi::ApiRenderEngine_getAvailablePeerToPeerPairsResponse* response);
    // / List of devices to enable for rendering and denoising
    virtual ::grpc::Status setDevicesActivity(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_setDevicesActivityRequest* request, ::octaneapi::ApiRenderEngine_setDevicesActivityResponse* response);
    // / Returns TRUE if the device is used for rendering
    virtual ::grpc::Status isDeviceUsedForRendering(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_isDeviceUsedForRenderingRequest* request, ::octaneapi::ApiRenderEngine_isDeviceUsedForRenderingResponse* response);
    // / Returns TRUE if the device with index uses render priority
    virtual ::grpc::Status deviceUsesPriority(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_deviceUsesPriorityRequest* request, ::octaneapi::ApiRenderEngine_deviceUsesPriorityResponse* response);
    // / Returns TRUE if the device at the provided index is using hardware ray-tracing
    virtual ::grpc::Status deviceUsesHardwareRayTracing(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_deviceUsesHardwareRayTracingRequest* request, ::octaneapi::ApiRenderEngine_deviceUsesHardwareRayTracingResponse* response);
    // / Returns the index of the device used for imaging, or -1 if no device is capable
    virtual ::grpc::Status imageDeviceIndex(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_imageDeviceIndexRequest* request, ::octaneapi::ApiRenderEngine_imageDeviceIndexResponse* response);
    // / Returns TRUE if the device is used for denoising
    virtual ::grpc::Status isDeviceUsedForDenoising(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_isDeviceUsedForDenoisingRequest* request, ::octaneapi::ApiRenderEngine_isDeviceUsedForDenoisingResponse* response);
    // / Returns the current render priority
    virtual ::grpc::Status renderPriority(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_renderPriorityRequest* request, ::octaneapi::ApiRenderEngine_renderPriorityResponse* response);
    // / Sets the current render priority
    virtual ::grpc::Status setRenderPriority(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_setRenderPriorityRequest* request, ::google::protobuf::Empty* response);
    // / Returns the current peer-to-peer configuration
    virtual ::grpc::Status currentPeerToPeerGroups(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_currentPeerToPeerGroupsRequest* request, ::octaneapi::ApiRenderEngine_currentPeerToPeerGroupsResponse* response);
    // / Returns TRUE if hardware raytracing is currently enabled for all devices with support for it
    virtual ::grpc::Status hardwareRayTracingEnabled(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_hardwareRayTracingEnabledRequest* request, ::octaneapi::ApiRenderEngine_hardwareRayTracingEnabledResponse* response);
    // / Opens a modal dialog to allow the user to set devices configuration
    virtual ::grpc::Status openDeviceSettings(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_openDeviceSettingsRequest* request, ::google::protobuf::Empty* response);
    // / Returns the state of the device
    virtual ::grpc::Status renderDeviceState(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_renderDeviceStateRequest* request, ::octaneapi::ApiRenderEngine_renderDeviceStateResponse* response);
    // / Returns the error state of a device or RENDER_ERROR_NONE if the device has not failed or
    // / is not active
    virtual ::grpc::Status renderDeviceErrorCode(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_renderDeviceErrorCodeRequest* request, ::octaneapi::ApiRenderEngine_renderDeviceErrorCodeResponse* response);
    // / Returns the error state of a device as string or an empty string if the device is not in an
    // / error state or is not active
    virtual ::grpc::Status errorcodeToString(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_errorcodeToStringRequest* request, ::octaneapi::ApiRenderEngine_errorcodeToStringResponse* response);
    // / Returns the (low-level) error message that triggered the device to fail or an empty string
    // / if it hasn't failed or isn't active
    virtual ::grpc::Status renderDeviceErrorMessage(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_renderDeviceErrorMessageRequest* request, ::octaneapi::ApiRenderEngine_renderDeviceErrorMessageResponse* response);
    // / Saves the current render device configuration (device activity and priority usage in the
    // / Octane preferences, which are shared between Octane Standalone and all plugins)
    virtual ::grpc::Status saveRenderDeviceConfig(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_saveRenderDeviceConfigRequest* request, ::google::protobuf::Empty* response);
    // / Returns true if out-of-core textures are enabled
    virtual ::grpc::Status outOfCoreEnabled(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_outOfCoreEnabledRequest* request, ::octaneapi::ApiRenderEngine_outOfCoreEnabledResponse* response);
    // / Enable out-of-core textures and geometry, or update the maximum amount of system memory
    // / to allow for use
    virtual ::grpc::Status enableOutOfCore(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_enableOutOfCoreRequest* request, ::google::protobuf::Empty* response);
    // / Disables out-of-core
    virtual ::grpc::Status disableOutOfCore(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_disableOutOfCoreRequest* request, ::google::protobuf::Empty* response);
    // / Returns RAM usage by out-of-core textures
    virtual ::grpc::Status getOutOfCoreMemoryUsage(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_getOutOfCoreMemoryUsageRequest* request, ::octaneapi::ApiRenderEngine_getOutOfCoreMemoryUsageResponse* response);
    // / To run the render kernels successfully, there needs to be some amount of free GPU memory
    virtual ::grpc::Status setGpuHeadroom(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_setGpuHeadroomRequest* request, ::google::protobuf::Empty* response);
    // / Gets the GPU headroom value
    virtual ::grpc::Status getGpuHeadroom(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_getGpuHeadroomRequest* request, ::octaneapi::ApiRenderEngine_getGpuHeadroomResponse* response);
    // / Sets the maximum number of system cores to use for the following subsystems:
    // / 1
    virtual ::grpc::Status setCoreLimit(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_setCoreLimitRequest* request, ::google::protobuf::Empty* response);
    // / Disables the core limit, meaning Octane will use all cores available for the subsystems
    // / listed in the comments above on setCoreLimit()
    virtual ::grpc::Status disableCoreLimit(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_disableCoreLimitRequest* request, ::google::protobuf::Empty* response);
    // / Registers a shared surface to be used for compositor input
    virtual ::grpc::Status registerInputSharedSurface(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_registerInputSharedSurfaceRequest* request, ::octaneapi::ApiRenderEngine_registerInputSharedSurfaceResponse* response);
    // / Unregisters an input shared surface that was registered with registerInputSharedSurface
    virtual ::grpc::Status unregisterInputSharedSurface(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_unregisterInputSharedSurfaceRequest* request, ::google::protobuf::Empty* response);
    // / Causes an asynchronous tonemap operation to run even if one wouldn't otherwise have been
    // / run
    virtual ::grpc::Status triggerAsyncTonemap(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_triggerAsyncTonemapRequest* request, ::google::protobuf::Empty* response);
    // / Sets the shared surface output type and whether to use real time mode
    virtual ::grpc::Status setSharedSurfaceOutputType(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_setSharedSurfaceOutputTypeRequest* request, ::google::protobuf::Empty* response);
    // / Gets the current shared surface output type
    virtual ::grpc::Status getSharedSurfaceOutputType(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_getSharedSurfaceOutputTypeRequest* request, ::octaneapi::ApiRenderEngine_getSharedSurfaceOutputTypeResponse* response);
    // / Gets whether the renderer is in real time mode
    virtual ::grpc::Status getRealTime(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_getRealTimeRequest* request, ::octaneapi::ApiRenderEngine_getRealTimeResponse* response);
    // / Pauses rendering
    virtual ::grpc::Status pauseRendering(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_pauseRenderingRequest* request, ::google::protobuf::Empty* response);
    // / Continues rendering
    virtual ::grpc::Status continueRendering(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_continueRenderingRequest* request, ::google::protobuf::Empty* response);
    // / Returns TRUE if rendering is currently paused
    virtual ::grpc::Status isRenderingPaused(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_isRenderingPausedRequest* request, ::octaneapi::ApiRenderEngine_isRenderingPausedResponse* response);
    // / Restarts the rendering, i
    virtual ::grpc::Status restartRendering(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_restartRenderingRequest* request, ::google::protobuf::Empty* response);
    // / Stops the rendering completely, i
    virtual ::grpc::Status stopRendering(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_stopRenderingRequest* request, ::google::protobuf::Empty* response);
    // / Shoots a viewing ray from the camera through the specified pixel and records all
    // / intersections with the scene ordered by distance from camera
    virtual ::grpc::Status pick(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_pickRequest* request, ::octaneapi::ApiRenderEngine_pickResponse* response);
    // / 
    virtual ::grpc::Status pickWhitePoint(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_pickWhitePointRequest* request, ::octaneapi::ApiRenderEngine_pickWhitePointResponse* response);
    // / Determines the average color around a specified location in the main beauty pass and
    // / calculates the required color to white balance those pixels, i
    virtual ::grpc::Status pickImagerWhitePoint(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_pickImagerWhitePointRequest* request, ::octaneapi::ApiRenderEngine_pickImagerWhitePointResponse* response);
    // / Checks whether a white point is pickable for a given output AOV and "Adjust white balance"
    // / output AOV layer node
    virtual ::grpc::Status isOutputAovWhitePointPickable(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_isOutputAovWhitePointPickableRequest* request, ::octaneapi::ApiRenderEngine_isOutputAovWhitePointPickableResponse* response);
    // / Determines the average color around a specified location before applying an "Adjust white
    // / balance" output AOV layer while compositing an output AOV, and calculates the required white
    // / point to use for the layer so that it will make that location neutral
    virtual ::grpc::Status pickOutputAovWhitePoint(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_pickOutputAovWhitePointRequest* request, ::octaneapi::ApiRenderEngine_pickOutputAovWhitePointResponse* response);
    // / Gets the name of the cryptomatte matte with the most coverage at a given position
    virtual ::grpc::Status pickCryptomatteMatte(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_pickCryptomatteMatteRequest* request, ::octaneapi::ApiRenderEngine_pickCryptomatteMatteResponse* response);
    // / Modifies a cryptomatte matte selection string (e
    virtual ::grpc::Status modifyCryptomatteMatteSelection(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_modifyCryptomatteMatteSelectionRequest* request, ::octaneapi::ApiRenderEngine_modifyCryptomatteMatteSelectionResponse* response);
    // / Returns a human readable string for a render priority
    virtual ::grpc::Status toString(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_toStringRequest* request, ::octaneapi::ApiRenderEngine_toStringResponse* response);
    // / Returns PCI bus and device ids of the device
    // /
    // / 
    virtual ::grpc::Status getDevicePciIds(::grpc::ServerContext* context, const ::octaneapi::ApiRenderEngine_getDevicePciIdsRequest* request, ::octaneapi::ApiRenderEngine_getDevicePciIdsResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_setRenderTargetNode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_setRenderTargetNode() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_setRenderTargetNode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setRenderTargetNode(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setRenderTargetNodeRequest* /*request*/, ::octaneapi::ApiRenderEngine_setRenderTargetNodeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsetRenderTargetNode(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_setRenderTargetNodeRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiRenderEngine_setRenderTargetNodeResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_getRenderTargetNode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_getRenderTargetNode() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_getRenderTargetNode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getRenderTargetNode(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getRenderTargetNodeRequest* /*request*/, ::octaneapi::ApiRenderEngine_getRenderTargetNodeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetRenderTargetNode(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_getRenderTargetNodeRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiRenderEngine_getRenderTargetNodeResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_getRenderGeometryNode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_getRenderGeometryNode() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_getRenderGeometryNode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getRenderGeometryNode(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getRenderGeometryNodeRequest* /*request*/, ::octaneapi::ApiRenderEngine_getRenderGeometryNodeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetRenderGeometryNode(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_getRenderGeometryNodeRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiRenderEngine_getRenderGeometryNodeResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_getRenderCameraNode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_getRenderCameraNode() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_getRenderCameraNode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getRenderCameraNode(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getRenderCameraNodeRequest* /*request*/, ::octaneapi::ApiRenderEngine_getRenderCameraNodeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetRenderCameraNode(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_getRenderCameraNodeRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiRenderEngine_getRenderCameraNodeResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_setRenderRegion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_setRenderRegion() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_setRenderRegion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setRenderRegion(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setRenderRegionRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsetRenderRegion(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_setRenderRegionRequest* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_getRenderRegion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_getRenderRegion() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_getRenderRegion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getRenderRegion(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getRenderRegionRequest* /*request*/, ::octaneapi::ApiRenderEngine_getRenderRegionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetRenderRegion(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_getRenderRegionRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiRenderEngine_getRenderRegionResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_setAsyncTonemapParams : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_setAsyncTonemapParams() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_setAsyncTonemapParams() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setAsyncTonemapParams(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setAsyncTonemapParamsRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsetAsyncTonemapParams(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_setAsyncTonemapParamsRequest* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_setAsyncTonemapParams1 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_setAsyncTonemapParams1() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_setAsyncTonemapParams1() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setAsyncTonemapParams1(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setAsyncTonemapParams1Request* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsetAsyncTonemapParams1(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_setAsyncTonemapParams1Request* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_asyncTonemapBufferType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_asyncTonemapBufferType() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_asyncTonemapBufferType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status asyncTonemapBufferType(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_asyncTonemapBufferTypeRequest* /*request*/, ::octaneapi::ApiRenderEngine_asyncTonemapBufferTypeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestasyncTonemapBufferType(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_asyncTonemapBufferTypeRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiRenderEngine_asyncTonemapBufferTypeResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_asyncTonemapCryptomatteFalseColor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_asyncTonemapCryptomatteFalseColor() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_asyncTonemapCryptomatteFalseColor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status asyncTonemapCryptomatteFalseColor(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_asyncTonemapCryptomatteFalseColorRequest* /*request*/, ::octaneapi::ApiRenderEngine_asyncTonemapCryptomatteFalseColorResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestasyncTonemapCryptomatteFalseColor(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_asyncTonemapCryptomatteFalseColorRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiRenderEngine_asyncTonemapCryptomatteFalseColorResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_asyncTonemapOutputColorSpaceInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_asyncTonemapOutputColorSpaceInfo() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_asyncTonemapOutputColorSpaceInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status asyncTonemapOutputColorSpaceInfo(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_asyncTonemapOutputColorSpaceInfoRequest* /*request*/, ::octaneapi::ApiRenderEngine_asyncTonemapOutputColorSpaceInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestasyncTonemapOutputColorSpaceInfo(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_asyncTonemapOutputColorSpaceInfoRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiRenderEngine_asyncTonemapOutputColorSpaceInfoResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_asyncTonemapColorSpace : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_asyncTonemapColorSpace() {
      ::grpc::Service::MarkMethodAsync(11);
    }
    ~WithAsyncMethod_asyncTonemapColorSpace() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status asyncTonemapColorSpace(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_asyncTonemapColorSpaceRequest* /*request*/, ::octaneapi::ApiRenderEngine_asyncTonemapColorSpaceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestasyncTonemapColorSpace(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_asyncTonemapColorSpaceRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiRenderEngine_asyncTonemapColorSpaceResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_asyncTonemapPremultipliedAlphaType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_asyncTonemapPremultipliedAlphaType() {
      ::grpc::Service::MarkMethodAsync(12);
    }
    ~WithAsyncMethod_asyncTonemapPremultipliedAlphaType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status asyncTonemapPremultipliedAlphaType(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_asyncTonemapPremultipliedAlphaTypeRequest* /*request*/, ::octaneapi::ApiRenderEngine_asyncTonemapPremultipliedAlphaTypeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestasyncTonemapPremultipliedAlphaType(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_asyncTonemapPremultipliedAlphaTypeRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiRenderEngine_asyncTonemapPremultipliedAlphaTypeResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_setAsyncTonemapRenderPasses : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_setAsyncTonemapRenderPasses() {
      ::grpc::Service::MarkMethodAsync(13);
    }
    ~WithAsyncMethod_setAsyncTonemapRenderPasses() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setAsyncTonemapRenderPasses(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setAsyncTonemapRenderPassesRequest* /*request*/, ::octaneapi::ApiRenderEngine_setAsyncTonemapRenderPassesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsetAsyncTonemapRenderPasses(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_setAsyncTonemapRenderPassesRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiRenderEngine_setAsyncTonemapRenderPassesResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_asyncTonemapRenderPasses : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_asyncTonemapRenderPasses() {
      ::grpc::Service::MarkMethodAsync(14);
    }
    ~WithAsyncMethod_asyncTonemapRenderPasses() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status asyncTonemapRenderPasses(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_asyncTonemapRenderPassesRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestasyncTonemapRenderPasses(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_asyncTonemapRenderPassesRequest* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_getEnabledAovs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_getEnabledAovs() {
      ::grpc::Service::MarkMethodAsync(15);
    }
    ~WithAsyncMethod_getEnabledAovs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getEnabledAovs(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getEnabledAovsRequest* /*request*/, ::octaneapi::ApiRenderEngine_getEnabledAovsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetEnabledAovs(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_getEnabledAovsRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiRenderEngine_getEnabledAovsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_freeTonemapPasses : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_freeTonemapPasses() {
      ::grpc::Service::MarkMethodAsync(16);
    }
    ~WithAsyncMethod_freeTonemapPasses() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status freeTonemapPasses(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_freeTonemapPassesRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestfreeTonemapPasses(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_freeTonemapPassesRequest* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_displayRenderPassId : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_displayRenderPassId() {
      ::grpc::Service::MarkMethodAsync(17);
    }
    ~WithAsyncMethod_displayRenderPassId() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status displayRenderPassId(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_displayRenderPassIdRequest* /*request*/, ::octaneapi::ApiRenderEngine_displayRenderPassIdResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestdisplayRenderPassId(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_displayRenderPassIdRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiRenderEngine_displayRenderPassIdResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_setSubSampleMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_setSubSampleMode() {
      ::grpc::Service::MarkMethodAsync(18);
    }
    ~WithAsyncMethod_setSubSampleMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setSubSampleMode(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setSubSampleModeRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsetSubSampleMode(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_setSubSampleModeRequest* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_getSubSampleMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_getSubSampleMode() {
      ::grpc::Service::MarkMethodAsync(19);
    }
    ~WithAsyncMethod_getSubSampleMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getSubSampleMode(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getSubSampleModeRequest* /*request*/, ::octaneapi::ApiRenderEngine_getSubSampleModeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetSubSampleMode(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_getSubSampleModeRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiRenderEngine_getSubSampleModeResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(19, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_setClayMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_setClayMode() {
      ::grpc::Service::MarkMethodAsync(20);
    }
    ~WithAsyncMethod_setClayMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setClayMode(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setClayModeRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsetClayMode(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_setClayModeRequest* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(20, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_clayMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_clayMode() {
      ::grpc::Service::MarkMethodAsync(21);
    }
    ~WithAsyncMethod_clayMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status clayMode(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_clayModeRequest* /*request*/, ::octaneapi::ApiRenderEngine_clayModeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestclayMode(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_clayModeRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiRenderEngine_clayModeResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(21, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_fps : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_fps() {
      ::grpc::Service::MarkMethodAsync(22);
    }
    ~WithAsyncMethod_fps() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status fps(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_fpsRequest* /*request*/, ::octaneapi::ApiRenderEngine_fpsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestfps(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_fpsRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiRenderEngine_fpsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(22, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_setFps : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_setFps() {
      ::grpc::Service::MarkMethodAsync(23);
    }
    ~WithAsyncMethod_setFps() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setFps(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setFpsRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsetFps(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_setFpsRequest* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(23, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_isCompiling : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_isCompiling() {
      ::grpc::Service::MarkMethodAsync(24);
    }
    ~WithAsyncMethod_isCompiling() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isCompiling(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_isCompilingRequest* /*request*/, ::octaneapi::ApiRenderEngine_isCompilingResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestisCompiling(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_isCompilingRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiRenderEngine_isCompilingResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(24, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_isCompressingTextures : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_isCompressingTextures() {
      ::grpc::Service::MarkMethodAsync(25);
    }
    ~WithAsyncMethod_isCompressingTextures() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isCompressingTextures(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_isCompressingTexturesRequest* /*request*/, ::octaneapi::ApiRenderEngine_isCompressingTexturesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestisCompressingTextures(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_isCompressingTexturesRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiRenderEngine_isCompressingTexturesResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(25, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_hasPendingRenderData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_hasPendingRenderData() {
      ::grpc::Service::MarkMethodAsync(26);
    }
    ~WithAsyncMethod_hasPendingRenderData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status hasPendingRenderData(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_hasPendingRenderDataRequest* /*request*/, ::octaneapi::ApiRenderEngine_hasPendingRenderDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequesthasPendingRenderData(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_hasPendingRenderDataRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiRenderEngine_hasPendingRenderDataResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(26, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_getCurrentChangeLevel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_getCurrentChangeLevel() {
      ::grpc::Service::MarkMethodAsync(27);
    }
    ~WithAsyncMethod_getCurrentChangeLevel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getCurrentChangeLevel(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getCurrentChangeLevelRequest* /*request*/, ::octaneapi::ApiRenderEngine_getCurrentChangeLevelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetCurrentChangeLevel(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_getCurrentChangeLevelRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiRenderEngine_getCurrentChangeLevelResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(27, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_getRenderImageChangeLevel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_getRenderImageChangeLevel() {
      ::grpc::Service::MarkMethodAsync(28);
    }
    ~WithAsyncMethod_getRenderImageChangeLevel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getRenderImageChangeLevel(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getRenderImageChangeLevelRequest* /*request*/, ::octaneapi::ApiRenderEngine_getRenderImageChangeLevelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetRenderImageChangeLevel(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_getRenderImageChangeLevelRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiRenderEngine_getRenderImageChangeLevelResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(28, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_getRenderRestartedChangeLevel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_getRenderRestartedChangeLevel() {
      ::grpc::Service::MarkMethodAsync(29);
    }
    ~WithAsyncMethod_getRenderRestartedChangeLevel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getRenderRestartedChangeLevel(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getRenderRestartedChangeLevelRequest* /*request*/, ::octaneapi::ApiRenderEngine_getRenderRestartedChangeLevelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetRenderRestartedChangeLevel(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_getRenderRestartedChangeLevelRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiRenderEngine_getRenderRestartedChangeLevelResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(29, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_setAsyncUpdateCallback : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_setAsyncUpdateCallback() {
      ::grpc::Service::MarkMethodAsync(30);
    }
    ~WithAsyncMethod_setAsyncUpdateCallback() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setAsyncUpdateCallback(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setAsyncUpdateCallbackRequest* /*request*/, ::octaneapi::ApiRenderEngine_setAsyncUpdateCallbackResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsetAsyncUpdateCallback(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_setAsyncUpdateCallbackRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiRenderEngine_setAsyncUpdateCallbackResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(30, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_updatesAreAsync : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_updatesAreAsync() {
      ::grpc::Service::MarkMethodAsync(31);
    }
    ~WithAsyncMethod_updatesAreAsync() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status updatesAreAsync(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_updatesAreAsyncRequest* /*request*/, ::octaneapi::ApiRenderEngine_updatesAreAsyncResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestupdatesAreAsync(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_updatesAreAsyncRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiRenderEngine_updatesAreAsyncResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(31, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_isImageReady : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_isImageReady() {
      ::grpc::Service::MarkMethodAsync(32);
    }
    ~WithAsyncMethod_isImageReady() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isImageReady(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_isImageReadyRequest* /*request*/, ::octaneapi::ApiRenderEngine_isImageReadyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestisImageReady(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_isImageReadyRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiRenderEngine_isImageReadyResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(32, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_resetImageReady : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_resetImageReady() {
      ::grpc::Service::MarkMethodAsync(33);
    }
    ~WithAsyncMethod_resetImageReady() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status resetImageReady(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_resetImageReadyRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestresetImageReady(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_resetImageReadyRequest* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(33, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_isRenderFailure : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_isRenderFailure() {
      ::grpc::Service::MarkMethodAsync(34);
    }
    ~WithAsyncMethod_isRenderFailure() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isRenderFailure(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_isRenderFailureRequest* /*request*/, ::octaneapi::ApiRenderEngine_isRenderFailureResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestisRenderFailure(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_isRenderFailureRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiRenderEngine_isRenderFailureResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(34, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_resetRenderFailure : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_resetRenderFailure() {
      ::grpc::Service::MarkMethodAsync(35);
    }
    ~WithAsyncMethod_resetRenderFailure() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status resetRenderFailure(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_resetRenderFailureRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestresetRenderFailure(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_resetRenderFailureRequest* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(35, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_setOnTileBlendedCallback : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_setOnTileBlendedCallback() {
      ::grpc::Service::MarkMethodAsync(36);
    }
    ~WithAsyncMethod_setOnTileBlendedCallback() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setOnTileBlendedCallback(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setOnTileBlendedCallbackRequest* /*request*/, ::octaneapi::ApiRenderEngine_setOnTileBlendedCallbackResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsetOnTileBlendedCallback(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_setOnTileBlendedCallbackRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiRenderEngine_setOnTileBlendedCallbackResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(36, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_setOnNewStatisticsCallback : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_setOnNewStatisticsCallback() {
      ::grpc::Service::MarkMethodAsync(37);
    }
    ~WithAsyncMethod_setOnNewStatisticsCallback() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setOnNewStatisticsCallback(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setOnNewStatisticsCallbackRequest* /*request*/, ::octaneapi::ApiRenderEngine_setOnNewStatisticsCallbackResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsetOnNewStatisticsCallback(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_setOnNewStatisticsCallbackRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiRenderEngine_setOnNewStatisticsCallbackResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(37, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_setOnNewImageCallback : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_setOnNewImageCallback() {
      ::grpc::Service::MarkMethodAsync(38);
    }
    ~WithAsyncMethod_setOnNewImageCallback() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setOnNewImageCallback(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setOnNewImageCallbackRequest* /*request*/, ::octaneapi::ApiRenderEngine_setOnNewImageCallbackResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsetOnNewImageCallback(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_setOnNewImageCallbackRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiRenderEngine_setOnNewImageCallbackResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(38, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_setOnOcioErrorCallback : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_setOnOcioErrorCallback() {
      ::grpc::Service::MarkMethodAsync(39);
    }
    ~WithAsyncMethod_setOnOcioErrorCallback() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setOnOcioErrorCallback(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setOnOcioErrorCallbackRequest* /*request*/, ::octaneapi::ApiRenderEngine_setOnOcioErrorCallbackResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsetOnOcioErrorCallback(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_setOnOcioErrorCallbackRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiRenderEngine_setOnOcioErrorCallbackResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(39, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_setOnRenderFailureCallback : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_setOnRenderFailureCallback() {
      ::grpc::Service::MarkMethodAsync(40);
    }
    ~WithAsyncMethod_setOnRenderFailureCallback() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setOnRenderFailureCallback(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setOnRenderFailureCallbackRequest* /*request*/, ::octaneapi::ApiRenderEngine_setOnRenderFailureCallbackResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsetOnRenderFailureCallback(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_setOnRenderFailureCallbackRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiRenderEngine_setOnRenderFailureCallbackResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(40, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_setForceCallbacksInRenderThreads : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_setForceCallbacksInRenderThreads() {
      ::grpc::Service::MarkMethodAsync(41);
    }
    ~WithAsyncMethod_setForceCallbacksInRenderThreads() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setForceCallbacksInRenderThreads(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setForceCallbacksInRenderThreadsRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsetForceCallbacksInRenderThreads(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_setForceCallbacksInRenderThreadsRequest* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(41, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_grabRenderResult : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_grabRenderResult() {
      ::grpc::Service::MarkMethodAsync(42);
    }
    ~WithAsyncMethod_grabRenderResult() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status grabRenderResult(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_grabRenderResultRequest* /*request*/, ::octaneapi::ApiRenderEngine_grabRenderResultResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgrabRenderResult(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_grabRenderResultRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiRenderEngine_grabRenderResultResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(42, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_releaseRenderResult : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_releaseRenderResult() {
      ::grpc::Service::MarkMethodAsync(43);
    }
    ~WithAsyncMethod_releaseRenderResult() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status releaseRenderResult(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_releaseRenderResultRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestreleaseRenderResult(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_releaseRenderResultRequest* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(43, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_synchronousTonemap : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_synchronousTonemap() {
      ::grpc::Service::MarkMethodAsync(44);
    }
    ~WithAsyncMethod_synchronousTonemap() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status synchronousTonemap(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_synchronousTonemapRequest* /*request*/, ::octaneapi::ApiRenderEngine_synchronousTonemapResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsynchronousTonemap(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_synchronousTonemapRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiRenderEngine_synchronousTonemapResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(44, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_synchronousTonemap1 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_synchronousTonemap1() {
      ::grpc::Service::MarkMethodAsync(45);
    }
    ~WithAsyncMethod_synchronousTonemap1() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status synchronousTonemap1(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_synchronousTonemap1Request* /*request*/, ::octaneapi::ApiRenderEngine_synchronousTonemap1Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsynchronousTonemap1(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_synchronousTonemap1Request* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiRenderEngine_synchronousTonemap1Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(45, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_synchronousTonemapAllRenderPasses : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_synchronousTonemapAllRenderPasses() {
      ::grpc::Service::MarkMethodAsync(46);
    }
    ~WithAsyncMethod_synchronousTonemapAllRenderPasses() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status synchronousTonemapAllRenderPasses(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPassesRequest* /*request*/, ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPassesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsynchronousTonemapAllRenderPasses(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPassesRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPassesResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(46, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_synchronousTonemapAllRenderPasses1 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_synchronousTonemapAllRenderPasses1() {
      ::grpc::Service::MarkMethodAsync(47);
    }
    ~WithAsyncMethod_synchronousTonemapAllRenderPasses1() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status synchronousTonemapAllRenderPasses1(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPasses1Request* /*request*/, ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPasses1Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsynchronousTonemapAllRenderPasses1(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPasses1Request* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPasses1Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(47, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_getRenderStatistics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_getRenderStatistics() {
      ::grpc::Service::MarkMethodAsync(48);
    }
    ~WithAsyncMethod_getRenderStatistics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getRenderStatistics(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getRenderStatisticsRequest* /*request*/, ::octaneapi::ApiRenderEngine_getRenderStatisticsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetRenderStatistics(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_getRenderStatisticsRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiRenderEngine_getRenderStatisticsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(48, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_getRenderResultStatistics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_getRenderResultStatistics() {
      ::grpc::Service::MarkMethodAsync(49);
    }
    ~WithAsyncMethod_getRenderResultStatistics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getRenderResultStatistics(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getRenderResultStatisticsRequest* /*request*/, ::octaneapi::ApiRenderEngine_getRenderResultStatisticsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetRenderResultStatistics(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_getRenderResultStatisticsRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiRenderEngine_getRenderResultStatisticsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(49, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_saveImage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_saveImage() {
      ::grpc::Service::MarkMethodAsync(50);
    }
    ~WithAsyncMethod_saveImage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status saveImage(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_saveImageRequest* /*request*/, ::octaneapi::ApiRenderEngine_saveImageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsaveImage(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_saveImageRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiRenderEngine_saveImageResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(50, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_saveImage1 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_saveImage1() {
      ::grpc::Service::MarkMethodAsync(51);
    }
    ~WithAsyncMethod_saveImage1() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status saveImage1(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_saveImage1Request* /*request*/, ::octaneapi::ApiRenderEngine_saveImage1Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsaveImage1(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_saveImage1Request* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiRenderEngine_saveImage1Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(51, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_saveImage2 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_saveImage2() {
      ::grpc::Service::MarkMethodAsync(52);
    }
    ~WithAsyncMethod_saveImage2() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status saveImage2(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_saveImage2Request* /*request*/, ::octaneapi::ApiRenderEngine_saveImage2Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsaveImage2(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_saveImage2Request* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiRenderEngine_saveImage2Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(52, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_saveRenderPasses : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_saveRenderPasses() {
      ::grpc::Service::MarkMethodAsync(53);
    }
    ~WithAsyncMethod_saveRenderPasses() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status saveRenderPasses(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_saveRenderPassesRequest* /*request*/, ::octaneapi::ApiRenderEngine_saveRenderPassesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsaveRenderPasses(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_saveRenderPassesRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiRenderEngine_saveRenderPassesResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(53, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_saveRenderPasses1 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_saveRenderPasses1() {
      ::grpc::Service::MarkMethodAsync(54);
    }
    ~WithAsyncMethod_saveRenderPasses1() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status saveRenderPasses1(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_saveRenderPasses1Request* /*request*/, ::octaneapi::ApiRenderEngine_saveRenderPasses1Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsaveRenderPasses1(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_saveRenderPasses1Request* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiRenderEngine_saveRenderPasses1Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(54, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_saveRenderPasses2 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_saveRenderPasses2() {
      ::grpc::Service::MarkMethodAsync(55);
    }
    ~WithAsyncMethod_saveRenderPasses2() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status saveRenderPasses2(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_saveRenderPasses2Request* /*request*/, ::octaneapi::ApiRenderEngine_saveRenderPasses2Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsaveRenderPasses2(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_saveRenderPasses2Request* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiRenderEngine_saveRenderPasses2Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(55, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_saveRenderPassesMultiExr : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_saveRenderPassesMultiExr() {
      ::grpc::Service::MarkMethodAsync(56);
    }
    ~WithAsyncMethod_saveRenderPassesMultiExr() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status saveRenderPassesMultiExr(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExrRequest* /*request*/, ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExrResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsaveRenderPassesMultiExr(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExrRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExrResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(56, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_saveRenderPassesMultiExr1 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_saveRenderPassesMultiExr1() {
      ::grpc::Service::MarkMethodAsync(57);
    }
    ~WithAsyncMethod_saveRenderPassesMultiExr1() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status saveRenderPassesMultiExr1(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExr1Request* /*request*/, ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExr1Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsaveRenderPassesMultiExr1(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExr1Request* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExr1Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(57, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_saveRenderPassesDeepExr : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_saveRenderPassesDeepExr() {
      ::grpc::Service::MarkMethodAsync(58);
    }
    ~WithAsyncMethod_saveRenderPassesDeepExr() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status saveRenderPassesDeepExr(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_saveRenderPassesDeepExrRequest* /*request*/, ::octaneapi::ApiRenderEngine_saveRenderPassesDeepExrResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsaveRenderPassesDeepExr(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_saveRenderPassesDeepExrRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiRenderEngine_saveRenderPassesDeepExrResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(58, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_deepImageEnabled : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_deepImageEnabled() {
      ::grpc::Service::MarkMethodAsync(59);
    }
    ~WithAsyncMethod_deepImageEnabled() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status deepImageEnabled(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_deepImageEnabledRequest* /*request*/, ::octaneapi::ApiRenderEngine_deepImageEnabledResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestdeepImageEnabled(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_deepImageEnabledRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiRenderEngine_deepImageEnabledResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(59, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_deepImageEnabled1 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_deepImageEnabled1() {
      ::grpc::Service::MarkMethodAsync(60);
    }
    ~WithAsyncMethod_deepImageEnabled1() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status deepImageEnabled1(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_deepImageEnabled1Request* /*request*/, ::octaneapi::ApiRenderEngine_deepImageEnabled1Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestdeepImageEnabled1(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_deepImageEnabled1Request* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiRenderEngine_deepImageEnabled1Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(60, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_deepPassesEnabled : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_deepPassesEnabled() {
      ::grpc::Service::MarkMethodAsync(61);
    }
    ~WithAsyncMethod_deepPassesEnabled() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status deepPassesEnabled(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_deepPassesEnabledRequest* /*request*/, ::octaneapi::ApiRenderEngine_deepPassesEnabledResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestdeepPassesEnabled(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_deepPassesEnabledRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiRenderEngine_deepPassesEnabledResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(61, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_canSaveDeepImage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_canSaveDeepImage() {
      ::grpc::Service::MarkMethodAsync(62);
    }
    ~WithAsyncMethod_canSaveDeepImage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status canSaveDeepImage(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_canSaveDeepImageRequest* /*request*/, ::octaneapi::ApiRenderEngine_canSaveDeepImageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestcanSaveDeepImage(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_canSaveDeepImageRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiRenderEngine_canSaveDeepImageResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(62, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_saveDeepImage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_saveDeepImage() {
      ::grpc::Service::MarkMethodAsync(63);
    }
    ~WithAsyncMethod_saveDeepImage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status saveDeepImage(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_saveDeepImageRequest* /*request*/, ::octaneapi::ApiRenderEngine_saveDeepImageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsaveDeepImage(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_saveDeepImageRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiRenderEngine_saveDeepImageResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(63, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_saveRenderState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_saveRenderState() {
      ::grpc::Service::MarkMethodAsync(64);
    }
    ~WithAsyncMethod_saveRenderState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status saveRenderState(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_saveRenderStateRequest* /*request*/, ::octaneapi::ApiRenderEngine_saveRenderStateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsaveRenderState(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_saveRenderStateRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiRenderEngine_saveRenderStateResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(64, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_loadRenderState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_loadRenderState() {
      ::grpc::Service::MarkMethodAsync(65);
    }
    ~WithAsyncMethod_loadRenderState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status loadRenderState(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_loadRenderStateRequest* /*request*/, ::octaneapi::ApiRenderEngine_loadRenderStateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestloadRenderState(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_loadRenderStateRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiRenderEngine_loadRenderStateResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(65, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_previewMaterial : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_previewMaterial() {
      ::grpc::Service::MarkMethodAsync(66);
    }
    ~WithAsyncMethod_previewMaterial() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status previewMaterial(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_previewMaterialRequest* /*request*/, ::octaneapi::ApiRenderEngine_previewMaterialResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestpreviewMaterial(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_previewMaterialRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiRenderEngine_previewMaterialResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(66, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_previewMaterialHdr : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_previewMaterialHdr() {
      ::grpc::Service::MarkMethodAsync(67);
    }
    ~WithAsyncMethod_previewMaterialHdr() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status previewMaterialHdr(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_previewMaterialHdrRequest* /*request*/, ::octaneapi::ApiRenderEngine_previewMaterialHdrResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestpreviewMaterialHdr(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_previewMaterialHdrRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiRenderEngine_previewMaterialHdrResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(67, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_previewMaterial1 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_previewMaterial1() {
      ::grpc::Service::MarkMethodAsync(68);
    }
    ~WithAsyncMethod_previewMaterial1() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status previewMaterial1(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_previewMaterial1Request* /*request*/, ::octaneapi::ApiRenderEngine_previewMaterial1Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestpreviewMaterial1(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_previewMaterial1Request* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiRenderEngine_previewMaterial1Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(68, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_getMemoryUsage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_getMemoryUsage() {
      ::grpc::Service::MarkMethodAsync(69);
    }
    ~WithAsyncMethod_getMemoryUsage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getMemoryUsage(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getMemoryUsageRequest* /*request*/, ::octaneapi::ApiRenderEngine_getMemoryUsageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetMemoryUsage(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_getMemoryUsageRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiRenderEngine_getMemoryUsageResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(69, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_getResourceStatistics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_getResourceStatistics() {
      ::grpc::Service::MarkMethodAsync(70);
    }
    ~WithAsyncMethod_getResourceStatistics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getResourceStatistics(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getResourceStatisticsRequest* /*request*/, ::octaneapi::ApiRenderEngine_getResourceStatisticsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetResourceStatistics(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_getResourceStatisticsRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiRenderEngine_getResourceStatisticsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(70, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_getGeometryStatistics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_getGeometryStatistics() {
      ::grpc::Service::MarkMethodAsync(71);
    }
    ~WithAsyncMethod_getGeometryStatistics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getGeometryStatistics(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getGeometryStatisticsRequest* /*request*/, ::octaneapi::ApiRenderEngine_getGeometryStatisticsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetGeometryStatistics(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_getGeometryStatisticsRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiRenderEngine_getGeometryStatisticsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(71, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_getTexturesStatistics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_getTexturesStatistics() {
      ::grpc::Service::MarkMethodAsync(72);
    }
    ~WithAsyncMethod_getTexturesStatistics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getTexturesStatistics(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getTexturesStatisticsRequest* /*request*/, ::octaneapi::ApiRenderEngine_getTexturesStatisticsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetTexturesStatistics(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_getTexturesStatisticsRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiRenderEngine_getTexturesStatisticsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(72, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_getSceneBounds : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_getSceneBounds() {
      ::grpc::Service::MarkMethodAsync(73);
    }
    ~WithAsyncMethod_getSceneBounds() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getSceneBounds(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getSceneBoundsRequest* /*request*/, ::octaneapi::ApiRenderEngine_getSceneBoundsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetSceneBounds(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_getSceneBoundsRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiRenderEngine_getSceneBoundsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(73, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_getDeviceCount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_getDeviceCount() {
      ::grpc::Service::MarkMethodAsync(74);
    }
    ~WithAsyncMethod_getDeviceCount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getDeviceCount(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getDeviceCountRequest* /*request*/, ::octaneapi::ApiRenderEngine_getDeviceCountResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetDeviceCount(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_getDeviceCountRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiRenderEngine_getDeviceCountResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(74, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_getDeviceComputeModel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_getDeviceComputeModel() {
      ::grpc::Service::MarkMethodAsync(75);
    }
    ~WithAsyncMethod_getDeviceComputeModel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getDeviceComputeModel(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getDeviceComputeModelRequest* /*request*/, ::octaneapi::ApiRenderEngine_getDeviceComputeModelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetDeviceComputeModel(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_getDeviceComputeModelRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiRenderEngine_getDeviceComputeModelResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(75, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_getDeviceName : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_getDeviceName() {
      ::grpc::Service::MarkMethodAsync(76);
    }
    ~WithAsyncMethod_getDeviceName() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getDeviceName(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getDeviceNameRequest* /*request*/, ::octaneapi::ApiRenderEngine_getDeviceNameResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetDeviceName(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_getDeviceNameRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiRenderEngine_getDeviceNameResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(76, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_isSupportedDevice : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_isSupportedDevice() {
      ::grpc::Service::MarkMethodAsync(77);
    }
    ~WithAsyncMethod_isSupportedDevice() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isSupportedDevice(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_isSupportedDeviceRequest* /*request*/, ::octaneapi::ApiRenderEngine_isSupportedDeviceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestisSupportedDevice(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_isSupportedDeviceRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiRenderEngine_isSupportedDeviceResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(77, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_deviceCanRender : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_deviceCanRender() {
      ::grpc::Service::MarkMethodAsync(78);
    }
    ~WithAsyncMethod_deviceCanRender() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status deviceCanRender(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_deviceCanRenderRequest* /*request*/, ::octaneapi::ApiRenderEngine_deviceCanRenderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestdeviceCanRender(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_deviceCanRenderRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiRenderEngine_deviceCanRenderResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(78, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_deviceCanDenoise : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_deviceCanDenoise() {
      ::grpc::Service::MarkMethodAsync(79);
    }
    ~WithAsyncMethod_deviceCanDenoise() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status deviceCanDenoise(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_deviceCanDenoiseRequest* /*request*/, ::octaneapi::ApiRenderEngine_deviceCanDenoiseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestdeviceCanDenoise(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_deviceCanDenoiseRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiRenderEngine_deviceCanDenoiseResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(79, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_deviceSupportsHardwareRayTracing : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_deviceSupportsHardwareRayTracing() {
      ::grpc::Service::MarkMethodAsync(80);
    }
    ~WithAsyncMethod_deviceSupportsHardwareRayTracing() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status deviceSupportsHardwareRayTracing(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_deviceSupportsHardwareRayTracingRequest* /*request*/, ::octaneapi::ApiRenderEngine_deviceSupportsHardwareRayTracingResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestdeviceSupportsHardwareRayTracing(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_deviceSupportsHardwareRayTracingRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiRenderEngine_deviceSupportsHardwareRayTracingResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(80, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_deviceSharedSurfaceInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_deviceSharedSurfaceInfo() {
      ::grpc::Service::MarkMethodAsync(81);
    }
    ~WithAsyncMethod_deviceSharedSurfaceInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status deviceSharedSurfaceInfo(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_deviceSharedSurfaceInfoRequest* /*request*/, ::octaneapi::ApiRenderEngine_deviceSharedSurfaceInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestdeviceSharedSurfaceInfo(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_deviceSharedSurfaceInfoRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiRenderEngine_deviceSharedSurfaceInfoResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(81, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_getAvailablePeerToPeerPairs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_getAvailablePeerToPeerPairs() {
      ::grpc::Service::MarkMethodAsync(82);
    }
    ~WithAsyncMethod_getAvailablePeerToPeerPairs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getAvailablePeerToPeerPairs(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getAvailablePeerToPeerPairsRequest* /*request*/, ::octaneapi::ApiRenderEngine_getAvailablePeerToPeerPairsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetAvailablePeerToPeerPairs(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_getAvailablePeerToPeerPairsRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiRenderEngine_getAvailablePeerToPeerPairsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(82, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_setDevicesActivity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_setDevicesActivity() {
      ::grpc::Service::MarkMethodAsync(83);
    }
    ~WithAsyncMethod_setDevicesActivity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setDevicesActivity(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setDevicesActivityRequest* /*request*/, ::octaneapi::ApiRenderEngine_setDevicesActivityResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsetDevicesActivity(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_setDevicesActivityRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiRenderEngine_setDevicesActivityResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(83, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_isDeviceUsedForRendering : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_isDeviceUsedForRendering() {
      ::grpc::Service::MarkMethodAsync(84);
    }
    ~WithAsyncMethod_isDeviceUsedForRendering() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isDeviceUsedForRendering(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_isDeviceUsedForRenderingRequest* /*request*/, ::octaneapi::ApiRenderEngine_isDeviceUsedForRenderingResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestisDeviceUsedForRendering(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_isDeviceUsedForRenderingRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiRenderEngine_isDeviceUsedForRenderingResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(84, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_deviceUsesPriority : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_deviceUsesPriority() {
      ::grpc::Service::MarkMethodAsync(85);
    }
    ~WithAsyncMethod_deviceUsesPriority() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status deviceUsesPriority(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_deviceUsesPriorityRequest* /*request*/, ::octaneapi::ApiRenderEngine_deviceUsesPriorityResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestdeviceUsesPriority(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_deviceUsesPriorityRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiRenderEngine_deviceUsesPriorityResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(85, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_deviceUsesHardwareRayTracing : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_deviceUsesHardwareRayTracing() {
      ::grpc::Service::MarkMethodAsync(86);
    }
    ~WithAsyncMethod_deviceUsesHardwareRayTracing() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status deviceUsesHardwareRayTracing(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_deviceUsesHardwareRayTracingRequest* /*request*/, ::octaneapi::ApiRenderEngine_deviceUsesHardwareRayTracingResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestdeviceUsesHardwareRayTracing(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_deviceUsesHardwareRayTracingRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiRenderEngine_deviceUsesHardwareRayTracingResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(86, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_imageDeviceIndex : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_imageDeviceIndex() {
      ::grpc::Service::MarkMethodAsync(87);
    }
    ~WithAsyncMethod_imageDeviceIndex() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status imageDeviceIndex(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_imageDeviceIndexRequest* /*request*/, ::octaneapi::ApiRenderEngine_imageDeviceIndexResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestimageDeviceIndex(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_imageDeviceIndexRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiRenderEngine_imageDeviceIndexResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(87, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_isDeviceUsedForDenoising : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_isDeviceUsedForDenoising() {
      ::grpc::Service::MarkMethodAsync(88);
    }
    ~WithAsyncMethod_isDeviceUsedForDenoising() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isDeviceUsedForDenoising(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_isDeviceUsedForDenoisingRequest* /*request*/, ::octaneapi::ApiRenderEngine_isDeviceUsedForDenoisingResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestisDeviceUsedForDenoising(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_isDeviceUsedForDenoisingRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiRenderEngine_isDeviceUsedForDenoisingResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(88, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_renderPriority : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_renderPriority() {
      ::grpc::Service::MarkMethodAsync(89);
    }
    ~WithAsyncMethod_renderPriority() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status renderPriority(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_renderPriorityRequest* /*request*/, ::octaneapi::ApiRenderEngine_renderPriorityResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestrenderPriority(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_renderPriorityRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiRenderEngine_renderPriorityResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(89, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_setRenderPriority : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_setRenderPriority() {
      ::grpc::Service::MarkMethodAsync(90);
    }
    ~WithAsyncMethod_setRenderPriority() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setRenderPriority(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setRenderPriorityRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsetRenderPriority(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_setRenderPriorityRequest* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(90, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_currentPeerToPeerGroups : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_currentPeerToPeerGroups() {
      ::grpc::Service::MarkMethodAsync(91);
    }
    ~WithAsyncMethod_currentPeerToPeerGroups() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status currentPeerToPeerGroups(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_currentPeerToPeerGroupsRequest* /*request*/, ::octaneapi::ApiRenderEngine_currentPeerToPeerGroupsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestcurrentPeerToPeerGroups(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_currentPeerToPeerGroupsRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiRenderEngine_currentPeerToPeerGroupsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(91, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_hardwareRayTracingEnabled : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_hardwareRayTracingEnabled() {
      ::grpc::Service::MarkMethodAsync(92);
    }
    ~WithAsyncMethod_hardwareRayTracingEnabled() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status hardwareRayTracingEnabled(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_hardwareRayTracingEnabledRequest* /*request*/, ::octaneapi::ApiRenderEngine_hardwareRayTracingEnabledResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequesthardwareRayTracingEnabled(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_hardwareRayTracingEnabledRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiRenderEngine_hardwareRayTracingEnabledResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(92, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_openDeviceSettings : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_openDeviceSettings() {
      ::grpc::Service::MarkMethodAsync(93);
    }
    ~WithAsyncMethod_openDeviceSettings() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status openDeviceSettings(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_openDeviceSettingsRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestopenDeviceSettings(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_openDeviceSettingsRequest* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(93, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_renderDeviceState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_renderDeviceState() {
      ::grpc::Service::MarkMethodAsync(94);
    }
    ~WithAsyncMethod_renderDeviceState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status renderDeviceState(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_renderDeviceStateRequest* /*request*/, ::octaneapi::ApiRenderEngine_renderDeviceStateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestrenderDeviceState(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_renderDeviceStateRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiRenderEngine_renderDeviceStateResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(94, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_renderDeviceErrorCode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_renderDeviceErrorCode() {
      ::grpc::Service::MarkMethodAsync(95);
    }
    ~WithAsyncMethod_renderDeviceErrorCode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status renderDeviceErrorCode(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_renderDeviceErrorCodeRequest* /*request*/, ::octaneapi::ApiRenderEngine_renderDeviceErrorCodeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestrenderDeviceErrorCode(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_renderDeviceErrorCodeRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiRenderEngine_renderDeviceErrorCodeResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(95, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_errorcodeToString : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_errorcodeToString() {
      ::grpc::Service::MarkMethodAsync(96);
    }
    ~WithAsyncMethod_errorcodeToString() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status errorcodeToString(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_errorcodeToStringRequest* /*request*/, ::octaneapi::ApiRenderEngine_errorcodeToStringResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequesterrorcodeToString(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_errorcodeToStringRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiRenderEngine_errorcodeToStringResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(96, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_renderDeviceErrorMessage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_renderDeviceErrorMessage() {
      ::grpc::Service::MarkMethodAsync(97);
    }
    ~WithAsyncMethod_renderDeviceErrorMessage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status renderDeviceErrorMessage(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_renderDeviceErrorMessageRequest* /*request*/, ::octaneapi::ApiRenderEngine_renderDeviceErrorMessageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestrenderDeviceErrorMessage(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_renderDeviceErrorMessageRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiRenderEngine_renderDeviceErrorMessageResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(97, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_saveRenderDeviceConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_saveRenderDeviceConfig() {
      ::grpc::Service::MarkMethodAsync(98);
    }
    ~WithAsyncMethod_saveRenderDeviceConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status saveRenderDeviceConfig(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_saveRenderDeviceConfigRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsaveRenderDeviceConfig(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_saveRenderDeviceConfigRequest* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(98, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_outOfCoreEnabled : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_outOfCoreEnabled() {
      ::grpc::Service::MarkMethodAsync(99);
    }
    ~WithAsyncMethod_outOfCoreEnabled() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status outOfCoreEnabled(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_outOfCoreEnabledRequest* /*request*/, ::octaneapi::ApiRenderEngine_outOfCoreEnabledResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestoutOfCoreEnabled(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_outOfCoreEnabledRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiRenderEngine_outOfCoreEnabledResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(99, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_enableOutOfCore : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_enableOutOfCore() {
      ::grpc::Service::MarkMethodAsync(100);
    }
    ~WithAsyncMethod_enableOutOfCore() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status enableOutOfCore(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_enableOutOfCoreRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestenableOutOfCore(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_enableOutOfCoreRequest* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(100, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_disableOutOfCore : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_disableOutOfCore() {
      ::grpc::Service::MarkMethodAsync(101);
    }
    ~WithAsyncMethod_disableOutOfCore() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status disableOutOfCore(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_disableOutOfCoreRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestdisableOutOfCore(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_disableOutOfCoreRequest* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(101, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_getOutOfCoreMemoryUsage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_getOutOfCoreMemoryUsage() {
      ::grpc::Service::MarkMethodAsync(102);
    }
    ~WithAsyncMethod_getOutOfCoreMemoryUsage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getOutOfCoreMemoryUsage(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getOutOfCoreMemoryUsageRequest* /*request*/, ::octaneapi::ApiRenderEngine_getOutOfCoreMemoryUsageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetOutOfCoreMemoryUsage(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_getOutOfCoreMemoryUsageRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiRenderEngine_getOutOfCoreMemoryUsageResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(102, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_setGpuHeadroom : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_setGpuHeadroom() {
      ::grpc::Service::MarkMethodAsync(103);
    }
    ~WithAsyncMethod_setGpuHeadroom() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setGpuHeadroom(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setGpuHeadroomRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsetGpuHeadroom(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_setGpuHeadroomRequest* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(103, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_getGpuHeadroom : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_getGpuHeadroom() {
      ::grpc::Service::MarkMethodAsync(104);
    }
    ~WithAsyncMethod_getGpuHeadroom() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getGpuHeadroom(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getGpuHeadroomRequest* /*request*/, ::octaneapi::ApiRenderEngine_getGpuHeadroomResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetGpuHeadroom(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_getGpuHeadroomRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiRenderEngine_getGpuHeadroomResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(104, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_setCoreLimit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_setCoreLimit() {
      ::grpc::Service::MarkMethodAsync(105);
    }
    ~WithAsyncMethod_setCoreLimit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setCoreLimit(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setCoreLimitRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsetCoreLimit(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_setCoreLimitRequest* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(105, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_disableCoreLimit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_disableCoreLimit() {
      ::grpc::Service::MarkMethodAsync(106);
    }
    ~WithAsyncMethod_disableCoreLimit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status disableCoreLimit(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_disableCoreLimitRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestdisableCoreLimit(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_disableCoreLimitRequest* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(106, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_registerInputSharedSurface : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_registerInputSharedSurface() {
      ::grpc::Service::MarkMethodAsync(107);
    }
    ~WithAsyncMethod_registerInputSharedSurface() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status registerInputSharedSurface(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_registerInputSharedSurfaceRequest* /*request*/, ::octaneapi::ApiRenderEngine_registerInputSharedSurfaceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestregisterInputSharedSurface(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_registerInputSharedSurfaceRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiRenderEngine_registerInputSharedSurfaceResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(107, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_unregisterInputSharedSurface : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_unregisterInputSharedSurface() {
      ::grpc::Service::MarkMethodAsync(108);
    }
    ~WithAsyncMethod_unregisterInputSharedSurface() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status unregisterInputSharedSurface(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_unregisterInputSharedSurfaceRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestunregisterInputSharedSurface(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_unregisterInputSharedSurfaceRequest* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(108, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_triggerAsyncTonemap : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_triggerAsyncTonemap() {
      ::grpc::Service::MarkMethodAsync(109);
    }
    ~WithAsyncMethod_triggerAsyncTonemap() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status triggerAsyncTonemap(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_triggerAsyncTonemapRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequesttriggerAsyncTonemap(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_triggerAsyncTonemapRequest* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(109, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_setSharedSurfaceOutputType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_setSharedSurfaceOutputType() {
      ::grpc::Service::MarkMethodAsync(110);
    }
    ~WithAsyncMethod_setSharedSurfaceOutputType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setSharedSurfaceOutputType(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setSharedSurfaceOutputTypeRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsetSharedSurfaceOutputType(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_setSharedSurfaceOutputTypeRequest* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(110, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_getSharedSurfaceOutputType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_getSharedSurfaceOutputType() {
      ::grpc::Service::MarkMethodAsync(111);
    }
    ~WithAsyncMethod_getSharedSurfaceOutputType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getSharedSurfaceOutputType(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getSharedSurfaceOutputTypeRequest* /*request*/, ::octaneapi::ApiRenderEngine_getSharedSurfaceOutputTypeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetSharedSurfaceOutputType(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_getSharedSurfaceOutputTypeRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiRenderEngine_getSharedSurfaceOutputTypeResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(111, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_getRealTime : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_getRealTime() {
      ::grpc::Service::MarkMethodAsync(112);
    }
    ~WithAsyncMethod_getRealTime() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getRealTime(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getRealTimeRequest* /*request*/, ::octaneapi::ApiRenderEngine_getRealTimeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetRealTime(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_getRealTimeRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiRenderEngine_getRealTimeResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(112, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_pauseRendering : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_pauseRendering() {
      ::grpc::Service::MarkMethodAsync(113);
    }
    ~WithAsyncMethod_pauseRendering() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status pauseRendering(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_pauseRenderingRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestpauseRendering(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_pauseRenderingRequest* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(113, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_continueRendering : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_continueRendering() {
      ::grpc::Service::MarkMethodAsync(114);
    }
    ~WithAsyncMethod_continueRendering() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status continueRendering(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_continueRenderingRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestcontinueRendering(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_continueRenderingRequest* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(114, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_isRenderingPaused : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_isRenderingPaused() {
      ::grpc::Service::MarkMethodAsync(115);
    }
    ~WithAsyncMethod_isRenderingPaused() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isRenderingPaused(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_isRenderingPausedRequest* /*request*/, ::octaneapi::ApiRenderEngine_isRenderingPausedResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestisRenderingPaused(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_isRenderingPausedRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiRenderEngine_isRenderingPausedResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(115, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_restartRendering : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_restartRendering() {
      ::grpc::Service::MarkMethodAsync(116);
    }
    ~WithAsyncMethod_restartRendering() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status restartRendering(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_restartRenderingRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestrestartRendering(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_restartRenderingRequest* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(116, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_stopRendering : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_stopRendering() {
      ::grpc::Service::MarkMethodAsync(117);
    }
    ~WithAsyncMethod_stopRendering() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status stopRendering(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_stopRenderingRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequeststopRendering(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_stopRenderingRequest* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(117, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_pick : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_pick() {
      ::grpc::Service::MarkMethodAsync(118);
    }
    ~WithAsyncMethod_pick() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status pick(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_pickRequest* /*request*/, ::octaneapi::ApiRenderEngine_pickResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestpick(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_pickRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiRenderEngine_pickResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(118, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_pickWhitePoint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_pickWhitePoint() {
      ::grpc::Service::MarkMethodAsync(119);
    }
    ~WithAsyncMethod_pickWhitePoint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status pickWhitePoint(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_pickWhitePointRequest* /*request*/, ::octaneapi::ApiRenderEngine_pickWhitePointResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestpickWhitePoint(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_pickWhitePointRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiRenderEngine_pickWhitePointResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(119, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_pickImagerWhitePoint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_pickImagerWhitePoint() {
      ::grpc::Service::MarkMethodAsync(120);
    }
    ~WithAsyncMethod_pickImagerWhitePoint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status pickImagerWhitePoint(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_pickImagerWhitePointRequest* /*request*/, ::octaneapi::ApiRenderEngine_pickImagerWhitePointResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestpickImagerWhitePoint(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_pickImagerWhitePointRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiRenderEngine_pickImagerWhitePointResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(120, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_isOutputAovWhitePointPickable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_isOutputAovWhitePointPickable() {
      ::grpc::Service::MarkMethodAsync(121);
    }
    ~WithAsyncMethod_isOutputAovWhitePointPickable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isOutputAovWhitePointPickable(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_isOutputAovWhitePointPickableRequest* /*request*/, ::octaneapi::ApiRenderEngine_isOutputAovWhitePointPickableResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestisOutputAovWhitePointPickable(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_isOutputAovWhitePointPickableRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiRenderEngine_isOutputAovWhitePointPickableResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(121, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_pickOutputAovWhitePoint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_pickOutputAovWhitePoint() {
      ::grpc::Service::MarkMethodAsync(122);
    }
    ~WithAsyncMethod_pickOutputAovWhitePoint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status pickOutputAovWhitePoint(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_pickOutputAovWhitePointRequest* /*request*/, ::octaneapi::ApiRenderEngine_pickOutputAovWhitePointResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestpickOutputAovWhitePoint(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_pickOutputAovWhitePointRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiRenderEngine_pickOutputAovWhitePointResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(122, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_pickCryptomatteMatte : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_pickCryptomatteMatte() {
      ::grpc::Service::MarkMethodAsync(123);
    }
    ~WithAsyncMethod_pickCryptomatteMatte() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status pickCryptomatteMatte(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_pickCryptomatteMatteRequest* /*request*/, ::octaneapi::ApiRenderEngine_pickCryptomatteMatteResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestpickCryptomatteMatte(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_pickCryptomatteMatteRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiRenderEngine_pickCryptomatteMatteResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(123, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_modifyCryptomatteMatteSelection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_modifyCryptomatteMatteSelection() {
      ::grpc::Service::MarkMethodAsync(124);
    }
    ~WithAsyncMethod_modifyCryptomatteMatteSelection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status modifyCryptomatteMatteSelection(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_modifyCryptomatteMatteSelectionRequest* /*request*/, ::octaneapi::ApiRenderEngine_modifyCryptomatteMatteSelectionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestmodifyCryptomatteMatteSelection(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_modifyCryptomatteMatteSelectionRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiRenderEngine_modifyCryptomatteMatteSelectionResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(124, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_toString : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_toString() {
      ::grpc::Service::MarkMethodAsync(125);
    }
    ~WithAsyncMethod_toString() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status toString(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_toStringRequest* /*request*/, ::octaneapi::ApiRenderEngine_toStringResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequesttoString(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_toStringRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiRenderEngine_toStringResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(125, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_getDevicePciIds : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_getDevicePciIds() {
      ::grpc::Service::MarkMethodAsync(126);
    }
    ~WithAsyncMethod_getDevicePciIds() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getDevicePciIds(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getDevicePciIdsRequest* /*request*/, ::octaneapi::ApiRenderEngine_getDevicePciIdsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetDevicePciIds(::grpc::ServerContext* context, ::octaneapi::ApiRenderEngine_getDevicePciIdsRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiRenderEngine_getDevicePciIdsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(126, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_setRenderTargetNode<WithAsyncMethod_getRenderTargetNode<WithAsyncMethod_getRenderGeometryNode<WithAsyncMethod_getRenderCameraNode<WithAsyncMethod_setRenderRegion<WithAsyncMethod_getRenderRegion<WithAsyncMethod_setAsyncTonemapParams<WithAsyncMethod_setAsyncTonemapParams1<WithAsyncMethod_asyncTonemapBufferType<WithAsyncMethod_asyncTonemapCryptomatteFalseColor<WithAsyncMethod_asyncTonemapOutputColorSpaceInfo<WithAsyncMethod_asyncTonemapColorSpace<WithAsyncMethod_asyncTonemapPremultipliedAlphaType<WithAsyncMethod_setAsyncTonemapRenderPasses<WithAsyncMethod_asyncTonemapRenderPasses<WithAsyncMethod_getEnabledAovs<WithAsyncMethod_freeTonemapPasses<WithAsyncMethod_displayRenderPassId<WithAsyncMethod_setSubSampleMode<WithAsyncMethod_getSubSampleMode<WithAsyncMethod_setClayMode<WithAsyncMethod_clayMode<WithAsyncMethod_fps<WithAsyncMethod_setFps<WithAsyncMethod_isCompiling<WithAsyncMethod_isCompressingTextures<WithAsyncMethod_hasPendingRenderData<WithAsyncMethod_getCurrentChangeLevel<WithAsyncMethod_getRenderImageChangeLevel<WithAsyncMethod_getRenderRestartedChangeLevel<WithAsyncMethod_setAsyncUpdateCallback<WithAsyncMethod_updatesAreAsync<WithAsyncMethod_isImageReady<WithAsyncMethod_resetImageReady<WithAsyncMethod_isRenderFailure<WithAsyncMethod_resetRenderFailure<WithAsyncMethod_setOnTileBlendedCallback<WithAsyncMethod_setOnNewStatisticsCallback<WithAsyncMethod_setOnNewImageCallback<WithAsyncMethod_setOnOcioErrorCallback<WithAsyncMethod_setOnRenderFailureCallback<WithAsyncMethod_setForceCallbacksInRenderThreads<WithAsyncMethod_grabRenderResult<WithAsyncMethod_releaseRenderResult<WithAsyncMethod_synchronousTonemap<WithAsyncMethod_synchronousTonemap1<WithAsyncMethod_synchronousTonemapAllRenderPasses<WithAsyncMethod_synchronousTonemapAllRenderPasses1<WithAsyncMethod_getRenderStatistics<WithAsyncMethod_getRenderResultStatistics<WithAsyncMethod_saveImage<WithAsyncMethod_saveImage1<WithAsyncMethod_saveImage2<WithAsyncMethod_saveRenderPasses<WithAsyncMethod_saveRenderPasses1<WithAsyncMethod_saveRenderPasses2<WithAsyncMethod_saveRenderPassesMultiExr<WithAsyncMethod_saveRenderPassesMultiExr1<WithAsyncMethod_saveRenderPassesDeepExr<WithAsyncMethod_deepImageEnabled<WithAsyncMethod_deepImageEnabled1<WithAsyncMethod_deepPassesEnabled<WithAsyncMethod_canSaveDeepImage<WithAsyncMethod_saveDeepImage<WithAsyncMethod_saveRenderState<WithAsyncMethod_loadRenderState<WithAsyncMethod_previewMaterial<WithAsyncMethod_previewMaterialHdr<WithAsyncMethod_previewMaterial1<WithAsyncMethod_getMemoryUsage<WithAsyncMethod_getResourceStatistics<WithAsyncMethod_getGeometryStatistics<WithAsyncMethod_getTexturesStatistics<WithAsyncMethod_getSceneBounds<WithAsyncMethod_getDeviceCount<WithAsyncMethod_getDeviceComputeModel<WithAsyncMethod_getDeviceName<WithAsyncMethod_isSupportedDevice<WithAsyncMethod_deviceCanRender<WithAsyncMethod_deviceCanDenoise<WithAsyncMethod_deviceSupportsHardwareRayTracing<WithAsyncMethod_deviceSharedSurfaceInfo<WithAsyncMethod_getAvailablePeerToPeerPairs<WithAsyncMethod_setDevicesActivity<WithAsyncMethod_isDeviceUsedForRendering<WithAsyncMethod_deviceUsesPriority<WithAsyncMethod_deviceUsesHardwareRayTracing<WithAsyncMethod_imageDeviceIndex<WithAsyncMethod_isDeviceUsedForDenoising<WithAsyncMethod_renderPriority<WithAsyncMethod_setRenderPriority<WithAsyncMethod_currentPeerToPeerGroups<WithAsyncMethod_hardwareRayTracingEnabled<WithAsyncMethod_openDeviceSettings<WithAsyncMethod_renderDeviceState<WithAsyncMethod_renderDeviceErrorCode<WithAsyncMethod_errorcodeToString<WithAsyncMethod_renderDeviceErrorMessage<WithAsyncMethod_saveRenderDeviceConfig<WithAsyncMethod_outOfCoreEnabled<WithAsyncMethod_enableOutOfCore<WithAsyncMethod_disableOutOfCore<WithAsyncMethod_getOutOfCoreMemoryUsage<WithAsyncMethod_setGpuHeadroom<WithAsyncMethod_getGpuHeadroom<WithAsyncMethod_setCoreLimit<WithAsyncMethod_disableCoreLimit<WithAsyncMethod_registerInputSharedSurface<WithAsyncMethod_unregisterInputSharedSurface<WithAsyncMethod_triggerAsyncTonemap<WithAsyncMethod_setSharedSurfaceOutputType<WithAsyncMethod_getSharedSurfaceOutputType<WithAsyncMethod_getRealTime<WithAsyncMethod_pauseRendering<WithAsyncMethod_continueRendering<WithAsyncMethod_isRenderingPaused<WithAsyncMethod_restartRendering<WithAsyncMethod_stopRendering<WithAsyncMethod_pick<WithAsyncMethod_pickWhitePoint<WithAsyncMethod_pickImagerWhitePoint<WithAsyncMethod_isOutputAovWhitePointPickable<WithAsyncMethod_pickOutputAovWhitePoint<WithAsyncMethod_pickCryptomatteMatte<WithAsyncMethod_modifyCryptomatteMatteSelection<WithAsyncMethod_toString<WithAsyncMethod_getDevicePciIds<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_setRenderTargetNode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_setRenderTargetNode() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_setRenderTargetNodeRequest, ::octaneapi::ApiRenderEngine_setRenderTargetNodeResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_setRenderTargetNodeRequest* request, ::octaneapi::ApiRenderEngine_setRenderTargetNodeResponse* response) { return this->setRenderTargetNode(context, request, response); }));}
    void SetMessageAllocatorFor_setRenderTargetNode(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_setRenderTargetNodeRequest, ::octaneapi::ApiRenderEngine_setRenderTargetNodeResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_setRenderTargetNodeRequest, ::octaneapi::ApiRenderEngine_setRenderTargetNodeResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_setRenderTargetNode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setRenderTargetNode(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setRenderTargetNodeRequest* /*request*/, ::octaneapi::ApiRenderEngine_setRenderTargetNodeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* setRenderTargetNode(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setRenderTargetNodeRequest* /*request*/, ::octaneapi::ApiRenderEngine_setRenderTargetNodeResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_getRenderTargetNode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_getRenderTargetNode() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_getRenderTargetNodeRequest, ::octaneapi::ApiRenderEngine_getRenderTargetNodeResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_getRenderTargetNodeRequest* request, ::octaneapi::ApiRenderEngine_getRenderTargetNodeResponse* response) { return this->getRenderTargetNode(context, request, response); }));}
    void SetMessageAllocatorFor_getRenderTargetNode(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_getRenderTargetNodeRequest, ::octaneapi::ApiRenderEngine_getRenderTargetNodeResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_getRenderTargetNodeRequest, ::octaneapi::ApiRenderEngine_getRenderTargetNodeResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_getRenderTargetNode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getRenderTargetNode(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getRenderTargetNodeRequest* /*request*/, ::octaneapi::ApiRenderEngine_getRenderTargetNodeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getRenderTargetNode(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getRenderTargetNodeRequest* /*request*/, ::octaneapi::ApiRenderEngine_getRenderTargetNodeResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_getRenderGeometryNode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_getRenderGeometryNode() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_getRenderGeometryNodeRequest, ::octaneapi::ApiRenderEngine_getRenderGeometryNodeResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_getRenderGeometryNodeRequest* request, ::octaneapi::ApiRenderEngine_getRenderGeometryNodeResponse* response) { return this->getRenderGeometryNode(context, request, response); }));}
    void SetMessageAllocatorFor_getRenderGeometryNode(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_getRenderGeometryNodeRequest, ::octaneapi::ApiRenderEngine_getRenderGeometryNodeResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_getRenderGeometryNodeRequest, ::octaneapi::ApiRenderEngine_getRenderGeometryNodeResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_getRenderGeometryNode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getRenderGeometryNode(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getRenderGeometryNodeRequest* /*request*/, ::octaneapi::ApiRenderEngine_getRenderGeometryNodeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getRenderGeometryNode(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getRenderGeometryNodeRequest* /*request*/, ::octaneapi::ApiRenderEngine_getRenderGeometryNodeResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_getRenderCameraNode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_getRenderCameraNode() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_getRenderCameraNodeRequest, ::octaneapi::ApiRenderEngine_getRenderCameraNodeResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_getRenderCameraNodeRequest* request, ::octaneapi::ApiRenderEngine_getRenderCameraNodeResponse* response) { return this->getRenderCameraNode(context, request, response); }));}
    void SetMessageAllocatorFor_getRenderCameraNode(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_getRenderCameraNodeRequest, ::octaneapi::ApiRenderEngine_getRenderCameraNodeResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_getRenderCameraNodeRequest, ::octaneapi::ApiRenderEngine_getRenderCameraNodeResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_getRenderCameraNode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getRenderCameraNode(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getRenderCameraNodeRequest* /*request*/, ::octaneapi::ApiRenderEngine_getRenderCameraNodeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getRenderCameraNode(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getRenderCameraNodeRequest* /*request*/, ::octaneapi::ApiRenderEngine_getRenderCameraNodeResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_setRenderRegion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_setRenderRegion() {
      ::grpc::Service::MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_setRenderRegionRequest, ::google::protobuf::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_setRenderRegionRequest* request, ::google::protobuf::Empty* response) { return this->setRenderRegion(context, request, response); }));}
    void SetMessageAllocatorFor_setRenderRegion(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_setRenderRegionRequest, ::google::protobuf::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_setRenderRegionRequest, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_setRenderRegion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setRenderRegion(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setRenderRegionRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* setRenderRegion(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setRenderRegionRequest* /*request*/, ::google::protobuf::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_getRenderRegion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_getRenderRegion() {
      ::grpc::Service::MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_getRenderRegionRequest, ::octaneapi::ApiRenderEngine_getRenderRegionResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_getRenderRegionRequest* request, ::octaneapi::ApiRenderEngine_getRenderRegionResponse* response) { return this->getRenderRegion(context, request, response); }));}
    void SetMessageAllocatorFor_getRenderRegion(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_getRenderRegionRequest, ::octaneapi::ApiRenderEngine_getRenderRegionResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_getRenderRegionRequest, ::octaneapi::ApiRenderEngine_getRenderRegionResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_getRenderRegion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getRenderRegion(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getRenderRegionRequest* /*request*/, ::octaneapi::ApiRenderEngine_getRenderRegionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getRenderRegion(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getRenderRegionRequest* /*request*/, ::octaneapi::ApiRenderEngine_getRenderRegionResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_setAsyncTonemapParams : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_setAsyncTonemapParams() {
      ::grpc::Service::MarkMethodCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_setAsyncTonemapParamsRequest, ::google::protobuf::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_setAsyncTonemapParamsRequest* request, ::google::protobuf::Empty* response) { return this->setAsyncTonemapParams(context, request, response); }));}
    void SetMessageAllocatorFor_setAsyncTonemapParams(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_setAsyncTonemapParamsRequest, ::google::protobuf::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_setAsyncTonemapParamsRequest, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_setAsyncTonemapParams() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setAsyncTonemapParams(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setAsyncTonemapParamsRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* setAsyncTonemapParams(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setAsyncTonemapParamsRequest* /*request*/, ::google::protobuf::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_setAsyncTonemapParams1 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_setAsyncTonemapParams1() {
      ::grpc::Service::MarkMethodCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_setAsyncTonemapParams1Request, ::google::protobuf::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_setAsyncTonemapParams1Request* request, ::google::protobuf::Empty* response) { return this->setAsyncTonemapParams1(context, request, response); }));}
    void SetMessageAllocatorFor_setAsyncTonemapParams1(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_setAsyncTonemapParams1Request, ::google::protobuf::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(7);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_setAsyncTonemapParams1Request, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_setAsyncTonemapParams1() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setAsyncTonemapParams1(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setAsyncTonemapParams1Request* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* setAsyncTonemapParams1(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setAsyncTonemapParams1Request* /*request*/, ::google::protobuf::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_asyncTonemapBufferType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_asyncTonemapBufferType() {
      ::grpc::Service::MarkMethodCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_asyncTonemapBufferTypeRequest, ::octaneapi::ApiRenderEngine_asyncTonemapBufferTypeResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_asyncTonemapBufferTypeRequest* request, ::octaneapi::ApiRenderEngine_asyncTonemapBufferTypeResponse* response) { return this->asyncTonemapBufferType(context, request, response); }));}
    void SetMessageAllocatorFor_asyncTonemapBufferType(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_asyncTonemapBufferTypeRequest, ::octaneapi::ApiRenderEngine_asyncTonemapBufferTypeResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(8);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_asyncTonemapBufferTypeRequest, ::octaneapi::ApiRenderEngine_asyncTonemapBufferTypeResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_asyncTonemapBufferType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status asyncTonemapBufferType(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_asyncTonemapBufferTypeRequest* /*request*/, ::octaneapi::ApiRenderEngine_asyncTonemapBufferTypeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* asyncTonemapBufferType(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_asyncTonemapBufferTypeRequest* /*request*/, ::octaneapi::ApiRenderEngine_asyncTonemapBufferTypeResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_asyncTonemapCryptomatteFalseColor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_asyncTonemapCryptomatteFalseColor() {
      ::grpc::Service::MarkMethodCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_asyncTonemapCryptomatteFalseColorRequest, ::octaneapi::ApiRenderEngine_asyncTonemapCryptomatteFalseColorResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_asyncTonemapCryptomatteFalseColorRequest* request, ::octaneapi::ApiRenderEngine_asyncTonemapCryptomatteFalseColorResponse* response) { return this->asyncTonemapCryptomatteFalseColor(context, request, response); }));}
    void SetMessageAllocatorFor_asyncTonemapCryptomatteFalseColor(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_asyncTonemapCryptomatteFalseColorRequest, ::octaneapi::ApiRenderEngine_asyncTonemapCryptomatteFalseColorResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(9);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_asyncTonemapCryptomatteFalseColorRequest, ::octaneapi::ApiRenderEngine_asyncTonemapCryptomatteFalseColorResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_asyncTonemapCryptomatteFalseColor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status asyncTonemapCryptomatteFalseColor(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_asyncTonemapCryptomatteFalseColorRequest* /*request*/, ::octaneapi::ApiRenderEngine_asyncTonemapCryptomatteFalseColorResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* asyncTonemapCryptomatteFalseColor(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_asyncTonemapCryptomatteFalseColorRequest* /*request*/, ::octaneapi::ApiRenderEngine_asyncTonemapCryptomatteFalseColorResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_asyncTonemapOutputColorSpaceInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_asyncTonemapOutputColorSpaceInfo() {
      ::grpc::Service::MarkMethodCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_asyncTonemapOutputColorSpaceInfoRequest, ::octaneapi::ApiRenderEngine_asyncTonemapOutputColorSpaceInfoResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_asyncTonemapOutputColorSpaceInfoRequest* request, ::octaneapi::ApiRenderEngine_asyncTonemapOutputColorSpaceInfoResponse* response) { return this->asyncTonemapOutputColorSpaceInfo(context, request, response); }));}
    void SetMessageAllocatorFor_asyncTonemapOutputColorSpaceInfo(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_asyncTonemapOutputColorSpaceInfoRequest, ::octaneapi::ApiRenderEngine_asyncTonemapOutputColorSpaceInfoResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(10);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_asyncTonemapOutputColorSpaceInfoRequest, ::octaneapi::ApiRenderEngine_asyncTonemapOutputColorSpaceInfoResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_asyncTonemapOutputColorSpaceInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status asyncTonemapOutputColorSpaceInfo(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_asyncTonemapOutputColorSpaceInfoRequest* /*request*/, ::octaneapi::ApiRenderEngine_asyncTonemapOutputColorSpaceInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* asyncTonemapOutputColorSpaceInfo(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_asyncTonemapOutputColorSpaceInfoRequest* /*request*/, ::octaneapi::ApiRenderEngine_asyncTonemapOutputColorSpaceInfoResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_asyncTonemapColorSpace : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_asyncTonemapColorSpace() {
      ::grpc::Service::MarkMethodCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_asyncTonemapColorSpaceRequest, ::octaneapi::ApiRenderEngine_asyncTonemapColorSpaceResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_asyncTonemapColorSpaceRequest* request, ::octaneapi::ApiRenderEngine_asyncTonemapColorSpaceResponse* response) { return this->asyncTonemapColorSpace(context, request, response); }));}
    void SetMessageAllocatorFor_asyncTonemapColorSpace(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_asyncTonemapColorSpaceRequest, ::octaneapi::ApiRenderEngine_asyncTonemapColorSpaceResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(11);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_asyncTonemapColorSpaceRequest, ::octaneapi::ApiRenderEngine_asyncTonemapColorSpaceResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_asyncTonemapColorSpace() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status asyncTonemapColorSpace(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_asyncTonemapColorSpaceRequest* /*request*/, ::octaneapi::ApiRenderEngine_asyncTonemapColorSpaceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* asyncTonemapColorSpace(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_asyncTonemapColorSpaceRequest* /*request*/, ::octaneapi::ApiRenderEngine_asyncTonemapColorSpaceResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_asyncTonemapPremultipliedAlphaType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_asyncTonemapPremultipliedAlphaType() {
      ::grpc::Service::MarkMethodCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_asyncTonemapPremultipliedAlphaTypeRequest, ::octaneapi::ApiRenderEngine_asyncTonemapPremultipliedAlphaTypeResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_asyncTonemapPremultipliedAlphaTypeRequest* request, ::octaneapi::ApiRenderEngine_asyncTonemapPremultipliedAlphaTypeResponse* response) { return this->asyncTonemapPremultipliedAlphaType(context, request, response); }));}
    void SetMessageAllocatorFor_asyncTonemapPremultipliedAlphaType(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_asyncTonemapPremultipliedAlphaTypeRequest, ::octaneapi::ApiRenderEngine_asyncTonemapPremultipliedAlphaTypeResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(12);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_asyncTonemapPremultipliedAlphaTypeRequest, ::octaneapi::ApiRenderEngine_asyncTonemapPremultipliedAlphaTypeResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_asyncTonemapPremultipliedAlphaType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status asyncTonemapPremultipliedAlphaType(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_asyncTonemapPremultipliedAlphaTypeRequest* /*request*/, ::octaneapi::ApiRenderEngine_asyncTonemapPremultipliedAlphaTypeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* asyncTonemapPremultipliedAlphaType(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_asyncTonemapPremultipliedAlphaTypeRequest* /*request*/, ::octaneapi::ApiRenderEngine_asyncTonemapPremultipliedAlphaTypeResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_setAsyncTonemapRenderPasses : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_setAsyncTonemapRenderPasses() {
      ::grpc::Service::MarkMethodCallback(13,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_setAsyncTonemapRenderPassesRequest, ::octaneapi::ApiRenderEngine_setAsyncTonemapRenderPassesResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_setAsyncTonemapRenderPassesRequest* request, ::octaneapi::ApiRenderEngine_setAsyncTonemapRenderPassesResponse* response) { return this->setAsyncTonemapRenderPasses(context, request, response); }));}
    void SetMessageAllocatorFor_setAsyncTonemapRenderPasses(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_setAsyncTonemapRenderPassesRequest, ::octaneapi::ApiRenderEngine_setAsyncTonemapRenderPassesResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(13);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_setAsyncTonemapRenderPassesRequest, ::octaneapi::ApiRenderEngine_setAsyncTonemapRenderPassesResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_setAsyncTonemapRenderPasses() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setAsyncTonemapRenderPasses(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setAsyncTonemapRenderPassesRequest* /*request*/, ::octaneapi::ApiRenderEngine_setAsyncTonemapRenderPassesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* setAsyncTonemapRenderPasses(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setAsyncTonemapRenderPassesRequest* /*request*/, ::octaneapi::ApiRenderEngine_setAsyncTonemapRenderPassesResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_asyncTonemapRenderPasses : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_asyncTonemapRenderPasses() {
      ::grpc::Service::MarkMethodCallback(14,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_asyncTonemapRenderPassesRequest, ::google::protobuf::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_asyncTonemapRenderPassesRequest* request, ::google::protobuf::Empty* response) { return this->asyncTonemapRenderPasses(context, request, response); }));}
    void SetMessageAllocatorFor_asyncTonemapRenderPasses(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_asyncTonemapRenderPassesRequest, ::google::protobuf::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(14);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_asyncTonemapRenderPassesRequest, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_asyncTonemapRenderPasses() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status asyncTonemapRenderPasses(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_asyncTonemapRenderPassesRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* asyncTonemapRenderPasses(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_asyncTonemapRenderPassesRequest* /*request*/, ::google::protobuf::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_getEnabledAovs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_getEnabledAovs() {
      ::grpc::Service::MarkMethodCallback(15,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_getEnabledAovsRequest, ::octaneapi::ApiRenderEngine_getEnabledAovsResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_getEnabledAovsRequest* request, ::octaneapi::ApiRenderEngine_getEnabledAovsResponse* response) { return this->getEnabledAovs(context, request, response); }));}
    void SetMessageAllocatorFor_getEnabledAovs(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_getEnabledAovsRequest, ::octaneapi::ApiRenderEngine_getEnabledAovsResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(15);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_getEnabledAovsRequest, ::octaneapi::ApiRenderEngine_getEnabledAovsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_getEnabledAovs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getEnabledAovs(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getEnabledAovsRequest* /*request*/, ::octaneapi::ApiRenderEngine_getEnabledAovsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getEnabledAovs(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getEnabledAovsRequest* /*request*/, ::octaneapi::ApiRenderEngine_getEnabledAovsResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_freeTonemapPasses : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_freeTonemapPasses() {
      ::grpc::Service::MarkMethodCallback(16,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_freeTonemapPassesRequest, ::google::protobuf::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_freeTonemapPassesRequest* request, ::google::protobuf::Empty* response) { return this->freeTonemapPasses(context, request, response); }));}
    void SetMessageAllocatorFor_freeTonemapPasses(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_freeTonemapPassesRequest, ::google::protobuf::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(16);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_freeTonemapPassesRequest, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_freeTonemapPasses() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status freeTonemapPasses(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_freeTonemapPassesRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* freeTonemapPasses(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_freeTonemapPassesRequest* /*request*/, ::google::protobuf::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_displayRenderPassId : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_displayRenderPassId() {
      ::grpc::Service::MarkMethodCallback(17,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_displayRenderPassIdRequest, ::octaneapi::ApiRenderEngine_displayRenderPassIdResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_displayRenderPassIdRequest* request, ::octaneapi::ApiRenderEngine_displayRenderPassIdResponse* response) { return this->displayRenderPassId(context, request, response); }));}
    void SetMessageAllocatorFor_displayRenderPassId(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_displayRenderPassIdRequest, ::octaneapi::ApiRenderEngine_displayRenderPassIdResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(17);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_displayRenderPassIdRequest, ::octaneapi::ApiRenderEngine_displayRenderPassIdResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_displayRenderPassId() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status displayRenderPassId(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_displayRenderPassIdRequest* /*request*/, ::octaneapi::ApiRenderEngine_displayRenderPassIdResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* displayRenderPassId(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_displayRenderPassIdRequest* /*request*/, ::octaneapi::ApiRenderEngine_displayRenderPassIdResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_setSubSampleMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_setSubSampleMode() {
      ::grpc::Service::MarkMethodCallback(18,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_setSubSampleModeRequest, ::google::protobuf::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_setSubSampleModeRequest* request, ::google::protobuf::Empty* response) { return this->setSubSampleMode(context, request, response); }));}
    void SetMessageAllocatorFor_setSubSampleMode(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_setSubSampleModeRequest, ::google::protobuf::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(18);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_setSubSampleModeRequest, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_setSubSampleMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setSubSampleMode(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setSubSampleModeRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* setSubSampleMode(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setSubSampleModeRequest* /*request*/, ::google::protobuf::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_getSubSampleMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_getSubSampleMode() {
      ::grpc::Service::MarkMethodCallback(19,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_getSubSampleModeRequest, ::octaneapi::ApiRenderEngine_getSubSampleModeResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_getSubSampleModeRequest* request, ::octaneapi::ApiRenderEngine_getSubSampleModeResponse* response) { return this->getSubSampleMode(context, request, response); }));}
    void SetMessageAllocatorFor_getSubSampleMode(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_getSubSampleModeRequest, ::octaneapi::ApiRenderEngine_getSubSampleModeResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(19);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_getSubSampleModeRequest, ::octaneapi::ApiRenderEngine_getSubSampleModeResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_getSubSampleMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getSubSampleMode(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getSubSampleModeRequest* /*request*/, ::octaneapi::ApiRenderEngine_getSubSampleModeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getSubSampleMode(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getSubSampleModeRequest* /*request*/, ::octaneapi::ApiRenderEngine_getSubSampleModeResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_setClayMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_setClayMode() {
      ::grpc::Service::MarkMethodCallback(20,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_setClayModeRequest, ::google::protobuf::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_setClayModeRequest* request, ::google::protobuf::Empty* response) { return this->setClayMode(context, request, response); }));}
    void SetMessageAllocatorFor_setClayMode(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_setClayModeRequest, ::google::protobuf::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(20);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_setClayModeRequest, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_setClayMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setClayMode(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setClayModeRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* setClayMode(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setClayModeRequest* /*request*/, ::google::protobuf::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_clayMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_clayMode() {
      ::grpc::Service::MarkMethodCallback(21,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_clayModeRequest, ::octaneapi::ApiRenderEngine_clayModeResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_clayModeRequest* request, ::octaneapi::ApiRenderEngine_clayModeResponse* response) { return this->clayMode(context, request, response); }));}
    void SetMessageAllocatorFor_clayMode(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_clayModeRequest, ::octaneapi::ApiRenderEngine_clayModeResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(21);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_clayModeRequest, ::octaneapi::ApiRenderEngine_clayModeResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_clayMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status clayMode(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_clayModeRequest* /*request*/, ::octaneapi::ApiRenderEngine_clayModeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* clayMode(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_clayModeRequest* /*request*/, ::octaneapi::ApiRenderEngine_clayModeResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_fps : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_fps() {
      ::grpc::Service::MarkMethodCallback(22,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_fpsRequest, ::octaneapi::ApiRenderEngine_fpsResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_fpsRequest* request, ::octaneapi::ApiRenderEngine_fpsResponse* response) { return this->fps(context, request, response); }));}
    void SetMessageAllocatorFor_fps(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_fpsRequest, ::octaneapi::ApiRenderEngine_fpsResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(22);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_fpsRequest, ::octaneapi::ApiRenderEngine_fpsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_fps() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status fps(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_fpsRequest* /*request*/, ::octaneapi::ApiRenderEngine_fpsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* fps(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_fpsRequest* /*request*/, ::octaneapi::ApiRenderEngine_fpsResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_setFps : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_setFps() {
      ::grpc::Service::MarkMethodCallback(23,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_setFpsRequest, ::google::protobuf::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_setFpsRequest* request, ::google::protobuf::Empty* response) { return this->setFps(context, request, response); }));}
    void SetMessageAllocatorFor_setFps(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_setFpsRequest, ::google::protobuf::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(23);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_setFpsRequest, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_setFps() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setFps(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setFpsRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* setFps(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setFpsRequest* /*request*/, ::google::protobuf::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_isCompiling : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_isCompiling() {
      ::grpc::Service::MarkMethodCallback(24,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_isCompilingRequest, ::octaneapi::ApiRenderEngine_isCompilingResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_isCompilingRequest* request, ::octaneapi::ApiRenderEngine_isCompilingResponse* response) { return this->isCompiling(context, request, response); }));}
    void SetMessageAllocatorFor_isCompiling(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_isCompilingRequest, ::octaneapi::ApiRenderEngine_isCompilingResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(24);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_isCompilingRequest, ::octaneapi::ApiRenderEngine_isCompilingResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_isCompiling() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isCompiling(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_isCompilingRequest* /*request*/, ::octaneapi::ApiRenderEngine_isCompilingResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* isCompiling(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_isCompilingRequest* /*request*/, ::octaneapi::ApiRenderEngine_isCompilingResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_isCompressingTextures : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_isCompressingTextures() {
      ::grpc::Service::MarkMethodCallback(25,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_isCompressingTexturesRequest, ::octaneapi::ApiRenderEngine_isCompressingTexturesResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_isCompressingTexturesRequest* request, ::octaneapi::ApiRenderEngine_isCompressingTexturesResponse* response) { return this->isCompressingTextures(context, request, response); }));}
    void SetMessageAllocatorFor_isCompressingTextures(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_isCompressingTexturesRequest, ::octaneapi::ApiRenderEngine_isCompressingTexturesResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(25);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_isCompressingTexturesRequest, ::octaneapi::ApiRenderEngine_isCompressingTexturesResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_isCompressingTextures() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isCompressingTextures(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_isCompressingTexturesRequest* /*request*/, ::octaneapi::ApiRenderEngine_isCompressingTexturesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* isCompressingTextures(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_isCompressingTexturesRequest* /*request*/, ::octaneapi::ApiRenderEngine_isCompressingTexturesResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_hasPendingRenderData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_hasPendingRenderData() {
      ::grpc::Service::MarkMethodCallback(26,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_hasPendingRenderDataRequest, ::octaneapi::ApiRenderEngine_hasPendingRenderDataResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_hasPendingRenderDataRequest* request, ::octaneapi::ApiRenderEngine_hasPendingRenderDataResponse* response) { return this->hasPendingRenderData(context, request, response); }));}
    void SetMessageAllocatorFor_hasPendingRenderData(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_hasPendingRenderDataRequest, ::octaneapi::ApiRenderEngine_hasPendingRenderDataResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(26);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_hasPendingRenderDataRequest, ::octaneapi::ApiRenderEngine_hasPendingRenderDataResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_hasPendingRenderData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status hasPendingRenderData(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_hasPendingRenderDataRequest* /*request*/, ::octaneapi::ApiRenderEngine_hasPendingRenderDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* hasPendingRenderData(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_hasPendingRenderDataRequest* /*request*/, ::octaneapi::ApiRenderEngine_hasPendingRenderDataResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_getCurrentChangeLevel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_getCurrentChangeLevel() {
      ::grpc::Service::MarkMethodCallback(27,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_getCurrentChangeLevelRequest, ::octaneapi::ApiRenderEngine_getCurrentChangeLevelResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_getCurrentChangeLevelRequest* request, ::octaneapi::ApiRenderEngine_getCurrentChangeLevelResponse* response) { return this->getCurrentChangeLevel(context, request, response); }));}
    void SetMessageAllocatorFor_getCurrentChangeLevel(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_getCurrentChangeLevelRequest, ::octaneapi::ApiRenderEngine_getCurrentChangeLevelResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(27);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_getCurrentChangeLevelRequest, ::octaneapi::ApiRenderEngine_getCurrentChangeLevelResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_getCurrentChangeLevel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getCurrentChangeLevel(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getCurrentChangeLevelRequest* /*request*/, ::octaneapi::ApiRenderEngine_getCurrentChangeLevelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getCurrentChangeLevel(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getCurrentChangeLevelRequest* /*request*/, ::octaneapi::ApiRenderEngine_getCurrentChangeLevelResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_getRenderImageChangeLevel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_getRenderImageChangeLevel() {
      ::grpc::Service::MarkMethodCallback(28,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_getRenderImageChangeLevelRequest, ::octaneapi::ApiRenderEngine_getRenderImageChangeLevelResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_getRenderImageChangeLevelRequest* request, ::octaneapi::ApiRenderEngine_getRenderImageChangeLevelResponse* response) { return this->getRenderImageChangeLevel(context, request, response); }));}
    void SetMessageAllocatorFor_getRenderImageChangeLevel(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_getRenderImageChangeLevelRequest, ::octaneapi::ApiRenderEngine_getRenderImageChangeLevelResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(28);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_getRenderImageChangeLevelRequest, ::octaneapi::ApiRenderEngine_getRenderImageChangeLevelResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_getRenderImageChangeLevel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getRenderImageChangeLevel(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getRenderImageChangeLevelRequest* /*request*/, ::octaneapi::ApiRenderEngine_getRenderImageChangeLevelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getRenderImageChangeLevel(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getRenderImageChangeLevelRequest* /*request*/, ::octaneapi::ApiRenderEngine_getRenderImageChangeLevelResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_getRenderRestartedChangeLevel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_getRenderRestartedChangeLevel() {
      ::grpc::Service::MarkMethodCallback(29,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_getRenderRestartedChangeLevelRequest, ::octaneapi::ApiRenderEngine_getRenderRestartedChangeLevelResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_getRenderRestartedChangeLevelRequest* request, ::octaneapi::ApiRenderEngine_getRenderRestartedChangeLevelResponse* response) { return this->getRenderRestartedChangeLevel(context, request, response); }));}
    void SetMessageAllocatorFor_getRenderRestartedChangeLevel(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_getRenderRestartedChangeLevelRequest, ::octaneapi::ApiRenderEngine_getRenderRestartedChangeLevelResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(29);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_getRenderRestartedChangeLevelRequest, ::octaneapi::ApiRenderEngine_getRenderRestartedChangeLevelResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_getRenderRestartedChangeLevel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getRenderRestartedChangeLevel(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getRenderRestartedChangeLevelRequest* /*request*/, ::octaneapi::ApiRenderEngine_getRenderRestartedChangeLevelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getRenderRestartedChangeLevel(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getRenderRestartedChangeLevelRequest* /*request*/, ::octaneapi::ApiRenderEngine_getRenderRestartedChangeLevelResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_setAsyncUpdateCallback : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_setAsyncUpdateCallback() {
      ::grpc::Service::MarkMethodCallback(30,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_setAsyncUpdateCallbackRequest, ::octaneapi::ApiRenderEngine_setAsyncUpdateCallbackResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_setAsyncUpdateCallbackRequest* request, ::octaneapi::ApiRenderEngine_setAsyncUpdateCallbackResponse* response) { return this->setAsyncUpdateCallback(context, request, response); }));}
    void SetMessageAllocatorFor_setAsyncUpdateCallback(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_setAsyncUpdateCallbackRequest, ::octaneapi::ApiRenderEngine_setAsyncUpdateCallbackResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(30);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_setAsyncUpdateCallbackRequest, ::octaneapi::ApiRenderEngine_setAsyncUpdateCallbackResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_setAsyncUpdateCallback() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setAsyncUpdateCallback(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setAsyncUpdateCallbackRequest* /*request*/, ::octaneapi::ApiRenderEngine_setAsyncUpdateCallbackResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* setAsyncUpdateCallback(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setAsyncUpdateCallbackRequest* /*request*/, ::octaneapi::ApiRenderEngine_setAsyncUpdateCallbackResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_updatesAreAsync : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_updatesAreAsync() {
      ::grpc::Service::MarkMethodCallback(31,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_updatesAreAsyncRequest, ::octaneapi::ApiRenderEngine_updatesAreAsyncResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_updatesAreAsyncRequest* request, ::octaneapi::ApiRenderEngine_updatesAreAsyncResponse* response) { return this->updatesAreAsync(context, request, response); }));}
    void SetMessageAllocatorFor_updatesAreAsync(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_updatesAreAsyncRequest, ::octaneapi::ApiRenderEngine_updatesAreAsyncResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(31);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_updatesAreAsyncRequest, ::octaneapi::ApiRenderEngine_updatesAreAsyncResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_updatesAreAsync() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status updatesAreAsync(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_updatesAreAsyncRequest* /*request*/, ::octaneapi::ApiRenderEngine_updatesAreAsyncResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* updatesAreAsync(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_updatesAreAsyncRequest* /*request*/, ::octaneapi::ApiRenderEngine_updatesAreAsyncResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_isImageReady : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_isImageReady() {
      ::grpc::Service::MarkMethodCallback(32,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_isImageReadyRequest, ::octaneapi::ApiRenderEngine_isImageReadyResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_isImageReadyRequest* request, ::octaneapi::ApiRenderEngine_isImageReadyResponse* response) { return this->isImageReady(context, request, response); }));}
    void SetMessageAllocatorFor_isImageReady(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_isImageReadyRequest, ::octaneapi::ApiRenderEngine_isImageReadyResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(32);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_isImageReadyRequest, ::octaneapi::ApiRenderEngine_isImageReadyResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_isImageReady() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isImageReady(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_isImageReadyRequest* /*request*/, ::octaneapi::ApiRenderEngine_isImageReadyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* isImageReady(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_isImageReadyRequest* /*request*/, ::octaneapi::ApiRenderEngine_isImageReadyResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_resetImageReady : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_resetImageReady() {
      ::grpc::Service::MarkMethodCallback(33,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_resetImageReadyRequest, ::google::protobuf::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_resetImageReadyRequest* request, ::google::protobuf::Empty* response) { return this->resetImageReady(context, request, response); }));}
    void SetMessageAllocatorFor_resetImageReady(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_resetImageReadyRequest, ::google::protobuf::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(33);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_resetImageReadyRequest, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_resetImageReady() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status resetImageReady(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_resetImageReadyRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* resetImageReady(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_resetImageReadyRequest* /*request*/, ::google::protobuf::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_isRenderFailure : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_isRenderFailure() {
      ::grpc::Service::MarkMethodCallback(34,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_isRenderFailureRequest, ::octaneapi::ApiRenderEngine_isRenderFailureResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_isRenderFailureRequest* request, ::octaneapi::ApiRenderEngine_isRenderFailureResponse* response) { return this->isRenderFailure(context, request, response); }));}
    void SetMessageAllocatorFor_isRenderFailure(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_isRenderFailureRequest, ::octaneapi::ApiRenderEngine_isRenderFailureResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(34);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_isRenderFailureRequest, ::octaneapi::ApiRenderEngine_isRenderFailureResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_isRenderFailure() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isRenderFailure(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_isRenderFailureRequest* /*request*/, ::octaneapi::ApiRenderEngine_isRenderFailureResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* isRenderFailure(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_isRenderFailureRequest* /*request*/, ::octaneapi::ApiRenderEngine_isRenderFailureResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_resetRenderFailure : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_resetRenderFailure() {
      ::grpc::Service::MarkMethodCallback(35,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_resetRenderFailureRequest, ::google::protobuf::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_resetRenderFailureRequest* request, ::google::protobuf::Empty* response) { return this->resetRenderFailure(context, request, response); }));}
    void SetMessageAllocatorFor_resetRenderFailure(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_resetRenderFailureRequest, ::google::protobuf::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(35);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_resetRenderFailureRequest, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_resetRenderFailure() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status resetRenderFailure(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_resetRenderFailureRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* resetRenderFailure(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_resetRenderFailureRequest* /*request*/, ::google::protobuf::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_setOnTileBlendedCallback : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_setOnTileBlendedCallback() {
      ::grpc::Service::MarkMethodCallback(36,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_setOnTileBlendedCallbackRequest, ::octaneapi::ApiRenderEngine_setOnTileBlendedCallbackResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_setOnTileBlendedCallbackRequest* request, ::octaneapi::ApiRenderEngine_setOnTileBlendedCallbackResponse* response) { return this->setOnTileBlendedCallback(context, request, response); }));}
    void SetMessageAllocatorFor_setOnTileBlendedCallback(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_setOnTileBlendedCallbackRequest, ::octaneapi::ApiRenderEngine_setOnTileBlendedCallbackResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(36);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_setOnTileBlendedCallbackRequest, ::octaneapi::ApiRenderEngine_setOnTileBlendedCallbackResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_setOnTileBlendedCallback() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setOnTileBlendedCallback(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setOnTileBlendedCallbackRequest* /*request*/, ::octaneapi::ApiRenderEngine_setOnTileBlendedCallbackResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* setOnTileBlendedCallback(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setOnTileBlendedCallbackRequest* /*request*/, ::octaneapi::ApiRenderEngine_setOnTileBlendedCallbackResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_setOnNewStatisticsCallback : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_setOnNewStatisticsCallback() {
      ::grpc::Service::MarkMethodCallback(37,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_setOnNewStatisticsCallbackRequest, ::octaneapi::ApiRenderEngine_setOnNewStatisticsCallbackResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_setOnNewStatisticsCallbackRequest* request, ::octaneapi::ApiRenderEngine_setOnNewStatisticsCallbackResponse* response) { return this->setOnNewStatisticsCallback(context, request, response); }));}
    void SetMessageAllocatorFor_setOnNewStatisticsCallback(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_setOnNewStatisticsCallbackRequest, ::octaneapi::ApiRenderEngine_setOnNewStatisticsCallbackResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(37);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_setOnNewStatisticsCallbackRequest, ::octaneapi::ApiRenderEngine_setOnNewStatisticsCallbackResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_setOnNewStatisticsCallback() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setOnNewStatisticsCallback(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setOnNewStatisticsCallbackRequest* /*request*/, ::octaneapi::ApiRenderEngine_setOnNewStatisticsCallbackResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* setOnNewStatisticsCallback(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setOnNewStatisticsCallbackRequest* /*request*/, ::octaneapi::ApiRenderEngine_setOnNewStatisticsCallbackResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_setOnNewImageCallback : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_setOnNewImageCallback() {
      ::grpc::Service::MarkMethodCallback(38,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_setOnNewImageCallbackRequest, ::octaneapi::ApiRenderEngine_setOnNewImageCallbackResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_setOnNewImageCallbackRequest* request, ::octaneapi::ApiRenderEngine_setOnNewImageCallbackResponse* response) { return this->setOnNewImageCallback(context, request, response); }));}
    void SetMessageAllocatorFor_setOnNewImageCallback(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_setOnNewImageCallbackRequest, ::octaneapi::ApiRenderEngine_setOnNewImageCallbackResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(38);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_setOnNewImageCallbackRequest, ::octaneapi::ApiRenderEngine_setOnNewImageCallbackResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_setOnNewImageCallback() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setOnNewImageCallback(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setOnNewImageCallbackRequest* /*request*/, ::octaneapi::ApiRenderEngine_setOnNewImageCallbackResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* setOnNewImageCallback(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setOnNewImageCallbackRequest* /*request*/, ::octaneapi::ApiRenderEngine_setOnNewImageCallbackResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_setOnOcioErrorCallback : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_setOnOcioErrorCallback() {
      ::grpc::Service::MarkMethodCallback(39,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_setOnOcioErrorCallbackRequest, ::octaneapi::ApiRenderEngine_setOnOcioErrorCallbackResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_setOnOcioErrorCallbackRequest* request, ::octaneapi::ApiRenderEngine_setOnOcioErrorCallbackResponse* response) { return this->setOnOcioErrorCallback(context, request, response); }));}
    void SetMessageAllocatorFor_setOnOcioErrorCallback(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_setOnOcioErrorCallbackRequest, ::octaneapi::ApiRenderEngine_setOnOcioErrorCallbackResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(39);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_setOnOcioErrorCallbackRequest, ::octaneapi::ApiRenderEngine_setOnOcioErrorCallbackResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_setOnOcioErrorCallback() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setOnOcioErrorCallback(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setOnOcioErrorCallbackRequest* /*request*/, ::octaneapi::ApiRenderEngine_setOnOcioErrorCallbackResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* setOnOcioErrorCallback(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setOnOcioErrorCallbackRequest* /*request*/, ::octaneapi::ApiRenderEngine_setOnOcioErrorCallbackResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_setOnRenderFailureCallback : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_setOnRenderFailureCallback() {
      ::grpc::Service::MarkMethodCallback(40,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_setOnRenderFailureCallbackRequest, ::octaneapi::ApiRenderEngine_setOnRenderFailureCallbackResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_setOnRenderFailureCallbackRequest* request, ::octaneapi::ApiRenderEngine_setOnRenderFailureCallbackResponse* response) { return this->setOnRenderFailureCallback(context, request, response); }));}
    void SetMessageAllocatorFor_setOnRenderFailureCallback(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_setOnRenderFailureCallbackRequest, ::octaneapi::ApiRenderEngine_setOnRenderFailureCallbackResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(40);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_setOnRenderFailureCallbackRequest, ::octaneapi::ApiRenderEngine_setOnRenderFailureCallbackResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_setOnRenderFailureCallback() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setOnRenderFailureCallback(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setOnRenderFailureCallbackRequest* /*request*/, ::octaneapi::ApiRenderEngine_setOnRenderFailureCallbackResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* setOnRenderFailureCallback(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setOnRenderFailureCallbackRequest* /*request*/, ::octaneapi::ApiRenderEngine_setOnRenderFailureCallbackResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_setForceCallbacksInRenderThreads : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_setForceCallbacksInRenderThreads() {
      ::grpc::Service::MarkMethodCallback(41,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_setForceCallbacksInRenderThreadsRequest, ::google::protobuf::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_setForceCallbacksInRenderThreadsRequest* request, ::google::protobuf::Empty* response) { return this->setForceCallbacksInRenderThreads(context, request, response); }));}
    void SetMessageAllocatorFor_setForceCallbacksInRenderThreads(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_setForceCallbacksInRenderThreadsRequest, ::google::protobuf::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(41);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_setForceCallbacksInRenderThreadsRequest, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_setForceCallbacksInRenderThreads() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setForceCallbacksInRenderThreads(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setForceCallbacksInRenderThreadsRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* setForceCallbacksInRenderThreads(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setForceCallbacksInRenderThreadsRequest* /*request*/, ::google::protobuf::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_grabRenderResult : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_grabRenderResult() {
      ::grpc::Service::MarkMethodCallback(42,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_grabRenderResultRequest, ::octaneapi::ApiRenderEngine_grabRenderResultResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_grabRenderResultRequest* request, ::octaneapi::ApiRenderEngine_grabRenderResultResponse* response) { return this->grabRenderResult(context, request, response); }));}
    void SetMessageAllocatorFor_grabRenderResult(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_grabRenderResultRequest, ::octaneapi::ApiRenderEngine_grabRenderResultResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(42);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_grabRenderResultRequest, ::octaneapi::ApiRenderEngine_grabRenderResultResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_grabRenderResult() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status grabRenderResult(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_grabRenderResultRequest* /*request*/, ::octaneapi::ApiRenderEngine_grabRenderResultResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* grabRenderResult(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_grabRenderResultRequest* /*request*/, ::octaneapi::ApiRenderEngine_grabRenderResultResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_releaseRenderResult : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_releaseRenderResult() {
      ::grpc::Service::MarkMethodCallback(43,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_releaseRenderResultRequest, ::google::protobuf::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_releaseRenderResultRequest* request, ::google::protobuf::Empty* response) { return this->releaseRenderResult(context, request, response); }));}
    void SetMessageAllocatorFor_releaseRenderResult(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_releaseRenderResultRequest, ::google::protobuf::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(43);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_releaseRenderResultRequest, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_releaseRenderResult() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status releaseRenderResult(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_releaseRenderResultRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* releaseRenderResult(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_releaseRenderResultRequest* /*request*/, ::google::protobuf::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_synchronousTonemap : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_synchronousTonemap() {
      ::grpc::Service::MarkMethodCallback(44,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_synchronousTonemapRequest, ::octaneapi::ApiRenderEngine_synchronousTonemapResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_synchronousTonemapRequest* request, ::octaneapi::ApiRenderEngine_synchronousTonemapResponse* response) { return this->synchronousTonemap(context, request, response); }));}
    void SetMessageAllocatorFor_synchronousTonemap(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_synchronousTonemapRequest, ::octaneapi::ApiRenderEngine_synchronousTonemapResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(44);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_synchronousTonemapRequest, ::octaneapi::ApiRenderEngine_synchronousTonemapResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_synchronousTonemap() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status synchronousTonemap(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_synchronousTonemapRequest* /*request*/, ::octaneapi::ApiRenderEngine_synchronousTonemapResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* synchronousTonemap(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_synchronousTonemapRequest* /*request*/, ::octaneapi::ApiRenderEngine_synchronousTonemapResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_synchronousTonemap1 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_synchronousTonemap1() {
      ::grpc::Service::MarkMethodCallback(45,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_synchronousTonemap1Request, ::octaneapi::ApiRenderEngine_synchronousTonemap1Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_synchronousTonemap1Request* request, ::octaneapi::ApiRenderEngine_synchronousTonemap1Response* response) { return this->synchronousTonemap1(context, request, response); }));}
    void SetMessageAllocatorFor_synchronousTonemap1(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_synchronousTonemap1Request, ::octaneapi::ApiRenderEngine_synchronousTonemap1Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(45);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_synchronousTonemap1Request, ::octaneapi::ApiRenderEngine_synchronousTonemap1Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_synchronousTonemap1() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status synchronousTonemap1(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_synchronousTonemap1Request* /*request*/, ::octaneapi::ApiRenderEngine_synchronousTonemap1Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* synchronousTonemap1(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_synchronousTonemap1Request* /*request*/, ::octaneapi::ApiRenderEngine_synchronousTonemap1Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_synchronousTonemapAllRenderPasses : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_synchronousTonemapAllRenderPasses() {
      ::grpc::Service::MarkMethodCallback(46,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPassesRequest, ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPassesResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPassesRequest* request, ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPassesResponse* response) { return this->synchronousTonemapAllRenderPasses(context, request, response); }));}
    void SetMessageAllocatorFor_synchronousTonemapAllRenderPasses(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPassesRequest, ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPassesResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(46);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPassesRequest, ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPassesResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_synchronousTonemapAllRenderPasses() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status synchronousTonemapAllRenderPasses(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPassesRequest* /*request*/, ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPassesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* synchronousTonemapAllRenderPasses(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPassesRequest* /*request*/, ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPassesResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_synchronousTonemapAllRenderPasses1 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_synchronousTonemapAllRenderPasses1() {
      ::grpc::Service::MarkMethodCallback(47,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPasses1Request, ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPasses1Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPasses1Request* request, ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPasses1Response* response) { return this->synchronousTonemapAllRenderPasses1(context, request, response); }));}
    void SetMessageAllocatorFor_synchronousTonemapAllRenderPasses1(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPasses1Request, ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPasses1Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(47);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPasses1Request, ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPasses1Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_synchronousTonemapAllRenderPasses1() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status synchronousTonemapAllRenderPasses1(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPasses1Request* /*request*/, ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPasses1Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* synchronousTonemapAllRenderPasses1(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPasses1Request* /*request*/, ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPasses1Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_getRenderStatistics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_getRenderStatistics() {
      ::grpc::Service::MarkMethodCallback(48,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_getRenderStatisticsRequest, ::octaneapi::ApiRenderEngine_getRenderStatisticsResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_getRenderStatisticsRequest* request, ::octaneapi::ApiRenderEngine_getRenderStatisticsResponse* response) { return this->getRenderStatistics(context, request, response); }));}
    void SetMessageAllocatorFor_getRenderStatistics(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_getRenderStatisticsRequest, ::octaneapi::ApiRenderEngine_getRenderStatisticsResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(48);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_getRenderStatisticsRequest, ::octaneapi::ApiRenderEngine_getRenderStatisticsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_getRenderStatistics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getRenderStatistics(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getRenderStatisticsRequest* /*request*/, ::octaneapi::ApiRenderEngine_getRenderStatisticsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getRenderStatistics(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getRenderStatisticsRequest* /*request*/, ::octaneapi::ApiRenderEngine_getRenderStatisticsResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_getRenderResultStatistics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_getRenderResultStatistics() {
      ::grpc::Service::MarkMethodCallback(49,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_getRenderResultStatisticsRequest, ::octaneapi::ApiRenderEngine_getRenderResultStatisticsResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_getRenderResultStatisticsRequest* request, ::octaneapi::ApiRenderEngine_getRenderResultStatisticsResponse* response) { return this->getRenderResultStatistics(context, request, response); }));}
    void SetMessageAllocatorFor_getRenderResultStatistics(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_getRenderResultStatisticsRequest, ::octaneapi::ApiRenderEngine_getRenderResultStatisticsResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(49);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_getRenderResultStatisticsRequest, ::octaneapi::ApiRenderEngine_getRenderResultStatisticsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_getRenderResultStatistics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getRenderResultStatistics(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getRenderResultStatisticsRequest* /*request*/, ::octaneapi::ApiRenderEngine_getRenderResultStatisticsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getRenderResultStatistics(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getRenderResultStatisticsRequest* /*request*/, ::octaneapi::ApiRenderEngine_getRenderResultStatisticsResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_saveImage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_saveImage() {
      ::grpc::Service::MarkMethodCallback(50,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_saveImageRequest, ::octaneapi::ApiRenderEngine_saveImageResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_saveImageRequest* request, ::octaneapi::ApiRenderEngine_saveImageResponse* response) { return this->saveImage(context, request, response); }));}
    void SetMessageAllocatorFor_saveImage(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_saveImageRequest, ::octaneapi::ApiRenderEngine_saveImageResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(50);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_saveImageRequest, ::octaneapi::ApiRenderEngine_saveImageResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_saveImage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status saveImage(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_saveImageRequest* /*request*/, ::octaneapi::ApiRenderEngine_saveImageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* saveImage(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_saveImageRequest* /*request*/, ::octaneapi::ApiRenderEngine_saveImageResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_saveImage1 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_saveImage1() {
      ::grpc::Service::MarkMethodCallback(51,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_saveImage1Request, ::octaneapi::ApiRenderEngine_saveImage1Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_saveImage1Request* request, ::octaneapi::ApiRenderEngine_saveImage1Response* response) { return this->saveImage1(context, request, response); }));}
    void SetMessageAllocatorFor_saveImage1(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_saveImage1Request, ::octaneapi::ApiRenderEngine_saveImage1Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(51);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_saveImage1Request, ::octaneapi::ApiRenderEngine_saveImage1Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_saveImage1() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status saveImage1(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_saveImage1Request* /*request*/, ::octaneapi::ApiRenderEngine_saveImage1Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* saveImage1(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_saveImage1Request* /*request*/, ::octaneapi::ApiRenderEngine_saveImage1Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_saveImage2 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_saveImage2() {
      ::grpc::Service::MarkMethodCallback(52,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_saveImage2Request, ::octaneapi::ApiRenderEngine_saveImage2Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_saveImage2Request* request, ::octaneapi::ApiRenderEngine_saveImage2Response* response) { return this->saveImage2(context, request, response); }));}
    void SetMessageAllocatorFor_saveImage2(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_saveImage2Request, ::octaneapi::ApiRenderEngine_saveImage2Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(52);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_saveImage2Request, ::octaneapi::ApiRenderEngine_saveImage2Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_saveImage2() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status saveImage2(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_saveImage2Request* /*request*/, ::octaneapi::ApiRenderEngine_saveImage2Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* saveImage2(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_saveImage2Request* /*request*/, ::octaneapi::ApiRenderEngine_saveImage2Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_saveRenderPasses : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_saveRenderPasses() {
      ::grpc::Service::MarkMethodCallback(53,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_saveRenderPassesRequest, ::octaneapi::ApiRenderEngine_saveRenderPassesResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_saveRenderPassesRequest* request, ::octaneapi::ApiRenderEngine_saveRenderPassesResponse* response) { return this->saveRenderPasses(context, request, response); }));}
    void SetMessageAllocatorFor_saveRenderPasses(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_saveRenderPassesRequest, ::octaneapi::ApiRenderEngine_saveRenderPassesResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(53);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_saveRenderPassesRequest, ::octaneapi::ApiRenderEngine_saveRenderPassesResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_saveRenderPasses() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status saveRenderPasses(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_saveRenderPassesRequest* /*request*/, ::octaneapi::ApiRenderEngine_saveRenderPassesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* saveRenderPasses(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_saveRenderPassesRequest* /*request*/, ::octaneapi::ApiRenderEngine_saveRenderPassesResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_saveRenderPasses1 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_saveRenderPasses1() {
      ::grpc::Service::MarkMethodCallback(54,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_saveRenderPasses1Request, ::octaneapi::ApiRenderEngine_saveRenderPasses1Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_saveRenderPasses1Request* request, ::octaneapi::ApiRenderEngine_saveRenderPasses1Response* response) { return this->saveRenderPasses1(context, request, response); }));}
    void SetMessageAllocatorFor_saveRenderPasses1(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_saveRenderPasses1Request, ::octaneapi::ApiRenderEngine_saveRenderPasses1Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(54);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_saveRenderPasses1Request, ::octaneapi::ApiRenderEngine_saveRenderPasses1Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_saveRenderPasses1() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status saveRenderPasses1(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_saveRenderPasses1Request* /*request*/, ::octaneapi::ApiRenderEngine_saveRenderPasses1Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* saveRenderPasses1(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_saveRenderPasses1Request* /*request*/, ::octaneapi::ApiRenderEngine_saveRenderPasses1Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_saveRenderPasses2 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_saveRenderPasses2() {
      ::grpc::Service::MarkMethodCallback(55,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_saveRenderPasses2Request, ::octaneapi::ApiRenderEngine_saveRenderPasses2Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_saveRenderPasses2Request* request, ::octaneapi::ApiRenderEngine_saveRenderPasses2Response* response) { return this->saveRenderPasses2(context, request, response); }));}
    void SetMessageAllocatorFor_saveRenderPasses2(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_saveRenderPasses2Request, ::octaneapi::ApiRenderEngine_saveRenderPasses2Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(55);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_saveRenderPasses2Request, ::octaneapi::ApiRenderEngine_saveRenderPasses2Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_saveRenderPasses2() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status saveRenderPasses2(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_saveRenderPasses2Request* /*request*/, ::octaneapi::ApiRenderEngine_saveRenderPasses2Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* saveRenderPasses2(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_saveRenderPasses2Request* /*request*/, ::octaneapi::ApiRenderEngine_saveRenderPasses2Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_saveRenderPassesMultiExr : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_saveRenderPassesMultiExr() {
      ::grpc::Service::MarkMethodCallback(56,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExrRequest, ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExrResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExrRequest* request, ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExrResponse* response) { return this->saveRenderPassesMultiExr(context, request, response); }));}
    void SetMessageAllocatorFor_saveRenderPassesMultiExr(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExrRequest, ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExrResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(56);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExrRequest, ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExrResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_saveRenderPassesMultiExr() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status saveRenderPassesMultiExr(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExrRequest* /*request*/, ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExrResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* saveRenderPassesMultiExr(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExrRequest* /*request*/, ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExrResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_saveRenderPassesMultiExr1 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_saveRenderPassesMultiExr1() {
      ::grpc::Service::MarkMethodCallback(57,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExr1Request, ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExr1Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExr1Request* request, ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExr1Response* response) { return this->saveRenderPassesMultiExr1(context, request, response); }));}
    void SetMessageAllocatorFor_saveRenderPassesMultiExr1(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExr1Request, ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExr1Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(57);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExr1Request, ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExr1Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_saveRenderPassesMultiExr1() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status saveRenderPassesMultiExr1(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExr1Request* /*request*/, ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExr1Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* saveRenderPassesMultiExr1(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExr1Request* /*request*/, ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExr1Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_saveRenderPassesDeepExr : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_saveRenderPassesDeepExr() {
      ::grpc::Service::MarkMethodCallback(58,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_saveRenderPassesDeepExrRequest, ::octaneapi::ApiRenderEngine_saveRenderPassesDeepExrResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_saveRenderPassesDeepExrRequest* request, ::octaneapi::ApiRenderEngine_saveRenderPassesDeepExrResponse* response) { return this->saveRenderPassesDeepExr(context, request, response); }));}
    void SetMessageAllocatorFor_saveRenderPassesDeepExr(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_saveRenderPassesDeepExrRequest, ::octaneapi::ApiRenderEngine_saveRenderPassesDeepExrResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(58);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_saveRenderPassesDeepExrRequest, ::octaneapi::ApiRenderEngine_saveRenderPassesDeepExrResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_saveRenderPassesDeepExr() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status saveRenderPassesDeepExr(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_saveRenderPassesDeepExrRequest* /*request*/, ::octaneapi::ApiRenderEngine_saveRenderPassesDeepExrResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* saveRenderPassesDeepExr(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_saveRenderPassesDeepExrRequest* /*request*/, ::octaneapi::ApiRenderEngine_saveRenderPassesDeepExrResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_deepImageEnabled : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_deepImageEnabled() {
      ::grpc::Service::MarkMethodCallback(59,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_deepImageEnabledRequest, ::octaneapi::ApiRenderEngine_deepImageEnabledResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_deepImageEnabledRequest* request, ::octaneapi::ApiRenderEngine_deepImageEnabledResponse* response) { return this->deepImageEnabled(context, request, response); }));}
    void SetMessageAllocatorFor_deepImageEnabled(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_deepImageEnabledRequest, ::octaneapi::ApiRenderEngine_deepImageEnabledResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(59);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_deepImageEnabledRequest, ::octaneapi::ApiRenderEngine_deepImageEnabledResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_deepImageEnabled() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status deepImageEnabled(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_deepImageEnabledRequest* /*request*/, ::octaneapi::ApiRenderEngine_deepImageEnabledResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* deepImageEnabled(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_deepImageEnabledRequest* /*request*/, ::octaneapi::ApiRenderEngine_deepImageEnabledResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_deepImageEnabled1 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_deepImageEnabled1() {
      ::grpc::Service::MarkMethodCallback(60,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_deepImageEnabled1Request, ::octaneapi::ApiRenderEngine_deepImageEnabled1Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_deepImageEnabled1Request* request, ::octaneapi::ApiRenderEngine_deepImageEnabled1Response* response) { return this->deepImageEnabled1(context, request, response); }));}
    void SetMessageAllocatorFor_deepImageEnabled1(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_deepImageEnabled1Request, ::octaneapi::ApiRenderEngine_deepImageEnabled1Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(60);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_deepImageEnabled1Request, ::octaneapi::ApiRenderEngine_deepImageEnabled1Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_deepImageEnabled1() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status deepImageEnabled1(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_deepImageEnabled1Request* /*request*/, ::octaneapi::ApiRenderEngine_deepImageEnabled1Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* deepImageEnabled1(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_deepImageEnabled1Request* /*request*/, ::octaneapi::ApiRenderEngine_deepImageEnabled1Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_deepPassesEnabled : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_deepPassesEnabled() {
      ::grpc::Service::MarkMethodCallback(61,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_deepPassesEnabledRequest, ::octaneapi::ApiRenderEngine_deepPassesEnabledResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_deepPassesEnabledRequest* request, ::octaneapi::ApiRenderEngine_deepPassesEnabledResponse* response) { return this->deepPassesEnabled(context, request, response); }));}
    void SetMessageAllocatorFor_deepPassesEnabled(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_deepPassesEnabledRequest, ::octaneapi::ApiRenderEngine_deepPassesEnabledResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(61);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_deepPassesEnabledRequest, ::octaneapi::ApiRenderEngine_deepPassesEnabledResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_deepPassesEnabled() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status deepPassesEnabled(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_deepPassesEnabledRequest* /*request*/, ::octaneapi::ApiRenderEngine_deepPassesEnabledResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* deepPassesEnabled(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_deepPassesEnabledRequest* /*request*/, ::octaneapi::ApiRenderEngine_deepPassesEnabledResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_canSaveDeepImage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_canSaveDeepImage() {
      ::grpc::Service::MarkMethodCallback(62,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_canSaveDeepImageRequest, ::octaneapi::ApiRenderEngine_canSaveDeepImageResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_canSaveDeepImageRequest* request, ::octaneapi::ApiRenderEngine_canSaveDeepImageResponse* response) { return this->canSaveDeepImage(context, request, response); }));}
    void SetMessageAllocatorFor_canSaveDeepImage(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_canSaveDeepImageRequest, ::octaneapi::ApiRenderEngine_canSaveDeepImageResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(62);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_canSaveDeepImageRequest, ::octaneapi::ApiRenderEngine_canSaveDeepImageResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_canSaveDeepImage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status canSaveDeepImage(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_canSaveDeepImageRequest* /*request*/, ::octaneapi::ApiRenderEngine_canSaveDeepImageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* canSaveDeepImage(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_canSaveDeepImageRequest* /*request*/, ::octaneapi::ApiRenderEngine_canSaveDeepImageResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_saveDeepImage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_saveDeepImage() {
      ::grpc::Service::MarkMethodCallback(63,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_saveDeepImageRequest, ::octaneapi::ApiRenderEngine_saveDeepImageResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_saveDeepImageRequest* request, ::octaneapi::ApiRenderEngine_saveDeepImageResponse* response) { return this->saveDeepImage(context, request, response); }));}
    void SetMessageAllocatorFor_saveDeepImage(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_saveDeepImageRequest, ::octaneapi::ApiRenderEngine_saveDeepImageResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(63);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_saveDeepImageRequest, ::octaneapi::ApiRenderEngine_saveDeepImageResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_saveDeepImage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status saveDeepImage(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_saveDeepImageRequest* /*request*/, ::octaneapi::ApiRenderEngine_saveDeepImageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* saveDeepImage(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_saveDeepImageRequest* /*request*/, ::octaneapi::ApiRenderEngine_saveDeepImageResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_saveRenderState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_saveRenderState() {
      ::grpc::Service::MarkMethodCallback(64,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_saveRenderStateRequest, ::octaneapi::ApiRenderEngine_saveRenderStateResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_saveRenderStateRequest* request, ::octaneapi::ApiRenderEngine_saveRenderStateResponse* response) { return this->saveRenderState(context, request, response); }));}
    void SetMessageAllocatorFor_saveRenderState(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_saveRenderStateRequest, ::octaneapi::ApiRenderEngine_saveRenderStateResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(64);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_saveRenderStateRequest, ::octaneapi::ApiRenderEngine_saveRenderStateResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_saveRenderState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status saveRenderState(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_saveRenderStateRequest* /*request*/, ::octaneapi::ApiRenderEngine_saveRenderStateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* saveRenderState(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_saveRenderStateRequest* /*request*/, ::octaneapi::ApiRenderEngine_saveRenderStateResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_loadRenderState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_loadRenderState() {
      ::grpc::Service::MarkMethodCallback(65,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_loadRenderStateRequest, ::octaneapi::ApiRenderEngine_loadRenderStateResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_loadRenderStateRequest* request, ::octaneapi::ApiRenderEngine_loadRenderStateResponse* response) { return this->loadRenderState(context, request, response); }));}
    void SetMessageAllocatorFor_loadRenderState(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_loadRenderStateRequest, ::octaneapi::ApiRenderEngine_loadRenderStateResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(65);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_loadRenderStateRequest, ::octaneapi::ApiRenderEngine_loadRenderStateResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_loadRenderState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status loadRenderState(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_loadRenderStateRequest* /*request*/, ::octaneapi::ApiRenderEngine_loadRenderStateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* loadRenderState(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_loadRenderStateRequest* /*request*/, ::octaneapi::ApiRenderEngine_loadRenderStateResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_previewMaterial : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_previewMaterial() {
      ::grpc::Service::MarkMethodCallback(66,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_previewMaterialRequest, ::octaneapi::ApiRenderEngine_previewMaterialResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_previewMaterialRequest* request, ::octaneapi::ApiRenderEngine_previewMaterialResponse* response) { return this->previewMaterial(context, request, response); }));}
    void SetMessageAllocatorFor_previewMaterial(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_previewMaterialRequest, ::octaneapi::ApiRenderEngine_previewMaterialResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(66);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_previewMaterialRequest, ::octaneapi::ApiRenderEngine_previewMaterialResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_previewMaterial() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status previewMaterial(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_previewMaterialRequest* /*request*/, ::octaneapi::ApiRenderEngine_previewMaterialResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* previewMaterial(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_previewMaterialRequest* /*request*/, ::octaneapi::ApiRenderEngine_previewMaterialResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_previewMaterialHdr : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_previewMaterialHdr() {
      ::grpc::Service::MarkMethodCallback(67,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_previewMaterialHdrRequest, ::octaneapi::ApiRenderEngine_previewMaterialHdrResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_previewMaterialHdrRequest* request, ::octaneapi::ApiRenderEngine_previewMaterialHdrResponse* response) { return this->previewMaterialHdr(context, request, response); }));}
    void SetMessageAllocatorFor_previewMaterialHdr(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_previewMaterialHdrRequest, ::octaneapi::ApiRenderEngine_previewMaterialHdrResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(67);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_previewMaterialHdrRequest, ::octaneapi::ApiRenderEngine_previewMaterialHdrResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_previewMaterialHdr() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status previewMaterialHdr(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_previewMaterialHdrRequest* /*request*/, ::octaneapi::ApiRenderEngine_previewMaterialHdrResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* previewMaterialHdr(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_previewMaterialHdrRequest* /*request*/, ::octaneapi::ApiRenderEngine_previewMaterialHdrResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_previewMaterial1 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_previewMaterial1() {
      ::grpc::Service::MarkMethodCallback(68,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_previewMaterial1Request, ::octaneapi::ApiRenderEngine_previewMaterial1Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_previewMaterial1Request* request, ::octaneapi::ApiRenderEngine_previewMaterial1Response* response) { return this->previewMaterial1(context, request, response); }));}
    void SetMessageAllocatorFor_previewMaterial1(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_previewMaterial1Request, ::octaneapi::ApiRenderEngine_previewMaterial1Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(68);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_previewMaterial1Request, ::octaneapi::ApiRenderEngine_previewMaterial1Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_previewMaterial1() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status previewMaterial1(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_previewMaterial1Request* /*request*/, ::octaneapi::ApiRenderEngine_previewMaterial1Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* previewMaterial1(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_previewMaterial1Request* /*request*/, ::octaneapi::ApiRenderEngine_previewMaterial1Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_getMemoryUsage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_getMemoryUsage() {
      ::grpc::Service::MarkMethodCallback(69,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_getMemoryUsageRequest, ::octaneapi::ApiRenderEngine_getMemoryUsageResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_getMemoryUsageRequest* request, ::octaneapi::ApiRenderEngine_getMemoryUsageResponse* response) { return this->getMemoryUsage(context, request, response); }));}
    void SetMessageAllocatorFor_getMemoryUsage(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_getMemoryUsageRequest, ::octaneapi::ApiRenderEngine_getMemoryUsageResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(69);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_getMemoryUsageRequest, ::octaneapi::ApiRenderEngine_getMemoryUsageResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_getMemoryUsage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getMemoryUsage(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getMemoryUsageRequest* /*request*/, ::octaneapi::ApiRenderEngine_getMemoryUsageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getMemoryUsage(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getMemoryUsageRequest* /*request*/, ::octaneapi::ApiRenderEngine_getMemoryUsageResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_getResourceStatistics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_getResourceStatistics() {
      ::grpc::Service::MarkMethodCallback(70,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_getResourceStatisticsRequest, ::octaneapi::ApiRenderEngine_getResourceStatisticsResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_getResourceStatisticsRequest* request, ::octaneapi::ApiRenderEngine_getResourceStatisticsResponse* response) { return this->getResourceStatistics(context, request, response); }));}
    void SetMessageAllocatorFor_getResourceStatistics(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_getResourceStatisticsRequest, ::octaneapi::ApiRenderEngine_getResourceStatisticsResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(70);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_getResourceStatisticsRequest, ::octaneapi::ApiRenderEngine_getResourceStatisticsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_getResourceStatistics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getResourceStatistics(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getResourceStatisticsRequest* /*request*/, ::octaneapi::ApiRenderEngine_getResourceStatisticsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getResourceStatistics(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getResourceStatisticsRequest* /*request*/, ::octaneapi::ApiRenderEngine_getResourceStatisticsResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_getGeometryStatistics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_getGeometryStatistics() {
      ::grpc::Service::MarkMethodCallback(71,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_getGeometryStatisticsRequest, ::octaneapi::ApiRenderEngine_getGeometryStatisticsResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_getGeometryStatisticsRequest* request, ::octaneapi::ApiRenderEngine_getGeometryStatisticsResponse* response) { return this->getGeometryStatistics(context, request, response); }));}
    void SetMessageAllocatorFor_getGeometryStatistics(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_getGeometryStatisticsRequest, ::octaneapi::ApiRenderEngine_getGeometryStatisticsResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(71);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_getGeometryStatisticsRequest, ::octaneapi::ApiRenderEngine_getGeometryStatisticsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_getGeometryStatistics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getGeometryStatistics(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getGeometryStatisticsRequest* /*request*/, ::octaneapi::ApiRenderEngine_getGeometryStatisticsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getGeometryStatistics(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getGeometryStatisticsRequest* /*request*/, ::octaneapi::ApiRenderEngine_getGeometryStatisticsResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_getTexturesStatistics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_getTexturesStatistics() {
      ::grpc::Service::MarkMethodCallback(72,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_getTexturesStatisticsRequest, ::octaneapi::ApiRenderEngine_getTexturesStatisticsResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_getTexturesStatisticsRequest* request, ::octaneapi::ApiRenderEngine_getTexturesStatisticsResponse* response) { return this->getTexturesStatistics(context, request, response); }));}
    void SetMessageAllocatorFor_getTexturesStatistics(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_getTexturesStatisticsRequest, ::octaneapi::ApiRenderEngine_getTexturesStatisticsResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(72);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_getTexturesStatisticsRequest, ::octaneapi::ApiRenderEngine_getTexturesStatisticsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_getTexturesStatistics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getTexturesStatistics(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getTexturesStatisticsRequest* /*request*/, ::octaneapi::ApiRenderEngine_getTexturesStatisticsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getTexturesStatistics(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getTexturesStatisticsRequest* /*request*/, ::octaneapi::ApiRenderEngine_getTexturesStatisticsResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_getSceneBounds : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_getSceneBounds() {
      ::grpc::Service::MarkMethodCallback(73,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_getSceneBoundsRequest, ::octaneapi::ApiRenderEngine_getSceneBoundsResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_getSceneBoundsRequest* request, ::octaneapi::ApiRenderEngine_getSceneBoundsResponse* response) { return this->getSceneBounds(context, request, response); }));}
    void SetMessageAllocatorFor_getSceneBounds(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_getSceneBoundsRequest, ::octaneapi::ApiRenderEngine_getSceneBoundsResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(73);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_getSceneBoundsRequest, ::octaneapi::ApiRenderEngine_getSceneBoundsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_getSceneBounds() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getSceneBounds(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getSceneBoundsRequest* /*request*/, ::octaneapi::ApiRenderEngine_getSceneBoundsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getSceneBounds(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getSceneBoundsRequest* /*request*/, ::octaneapi::ApiRenderEngine_getSceneBoundsResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_getDeviceCount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_getDeviceCount() {
      ::grpc::Service::MarkMethodCallback(74,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_getDeviceCountRequest, ::octaneapi::ApiRenderEngine_getDeviceCountResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_getDeviceCountRequest* request, ::octaneapi::ApiRenderEngine_getDeviceCountResponse* response) { return this->getDeviceCount(context, request, response); }));}
    void SetMessageAllocatorFor_getDeviceCount(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_getDeviceCountRequest, ::octaneapi::ApiRenderEngine_getDeviceCountResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(74);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_getDeviceCountRequest, ::octaneapi::ApiRenderEngine_getDeviceCountResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_getDeviceCount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getDeviceCount(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getDeviceCountRequest* /*request*/, ::octaneapi::ApiRenderEngine_getDeviceCountResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getDeviceCount(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getDeviceCountRequest* /*request*/, ::octaneapi::ApiRenderEngine_getDeviceCountResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_getDeviceComputeModel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_getDeviceComputeModel() {
      ::grpc::Service::MarkMethodCallback(75,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_getDeviceComputeModelRequest, ::octaneapi::ApiRenderEngine_getDeviceComputeModelResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_getDeviceComputeModelRequest* request, ::octaneapi::ApiRenderEngine_getDeviceComputeModelResponse* response) { return this->getDeviceComputeModel(context, request, response); }));}
    void SetMessageAllocatorFor_getDeviceComputeModel(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_getDeviceComputeModelRequest, ::octaneapi::ApiRenderEngine_getDeviceComputeModelResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(75);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_getDeviceComputeModelRequest, ::octaneapi::ApiRenderEngine_getDeviceComputeModelResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_getDeviceComputeModel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getDeviceComputeModel(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getDeviceComputeModelRequest* /*request*/, ::octaneapi::ApiRenderEngine_getDeviceComputeModelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getDeviceComputeModel(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getDeviceComputeModelRequest* /*request*/, ::octaneapi::ApiRenderEngine_getDeviceComputeModelResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_getDeviceName : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_getDeviceName() {
      ::grpc::Service::MarkMethodCallback(76,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_getDeviceNameRequest, ::octaneapi::ApiRenderEngine_getDeviceNameResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_getDeviceNameRequest* request, ::octaneapi::ApiRenderEngine_getDeviceNameResponse* response) { return this->getDeviceName(context, request, response); }));}
    void SetMessageAllocatorFor_getDeviceName(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_getDeviceNameRequest, ::octaneapi::ApiRenderEngine_getDeviceNameResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(76);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_getDeviceNameRequest, ::octaneapi::ApiRenderEngine_getDeviceNameResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_getDeviceName() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getDeviceName(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getDeviceNameRequest* /*request*/, ::octaneapi::ApiRenderEngine_getDeviceNameResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getDeviceName(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getDeviceNameRequest* /*request*/, ::octaneapi::ApiRenderEngine_getDeviceNameResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_isSupportedDevice : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_isSupportedDevice() {
      ::grpc::Service::MarkMethodCallback(77,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_isSupportedDeviceRequest, ::octaneapi::ApiRenderEngine_isSupportedDeviceResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_isSupportedDeviceRequest* request, ::octaneapi::ApiRenderEngine_isSupportedDeviceResponse* response) { return this->isSupportedDevice(context, request, response); }));}
    void SetMessageAllocatorFor_isSupportedDevice(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_isSupportedDeviceRequest, ::octaneapi::ApiRenderEngine_isSupportedDeviceResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(77);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_isSupportedDeviceRequest, ::octaneapi::ApiRenderEngine_isSupportedDeviceResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_isSupportedDevice() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isSupportedDevice(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_isSupportedDeviceRequest* /*request*/, ::octaneapi::ApiRenderEngine_isSupportedDeviceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* isSupportedDevice(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_isSupportedDeviceRequest* /*request*/, ::octaneapi::ApiRenderEngine_isSupportedDeviceResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_deviceCanRender : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_deviceCanRender() {
      ::grpc::Service::MarkMethodCallback(78,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_deviceCanRenderRequest, ::octaneapi::ApiRenderEngine_deviceCanRenderResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_deviceCanRenderRequest* request, ::octaneapi::ApiRenderEngine_deviceCanRenderResponse* response) { return this->deviceCanRender(context, request, response); }));}
    void SetMessageAllocatorFor_deviceCanRender(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_deviceCanRenderRequest, ::octaneapi::ApiRenderEngine_deviceCanRenderResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(78);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_deviceCanRenderRequest, ::octaneapi::ApiRenderEngine_deviceCanRenderResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_deviceCanRender() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status deviceCanRender(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_deviceCanRenderRequest* /*request*/, ::octaneapi::ApiRenderEngine_deviceCanRenderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* deviceCanRender(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_deviceCanRenderRequest* /*request*/, ::octaneapi::ApiRenderEngine_deviceCanRenderResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_deviceCanDenoise : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_deviceCanDenoise() {
      ::grpc::Service::MarkMethodCallback(79,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_deviceCanDenoiseRequest, ::octaneapi::ApiRenderEngine_deviceCanDenoiseResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_deviceCanDenoiseRequest* request, ::octaneapi::ApiRenderEngine_deviceCanDenoiseResponse* response) { return this->deviceCanDenoise(context, request, response); }));}
    void SetMessageAllocatorFor_deviceCanDenoise(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_deviceCanDenoiseRequest, ::octaneapi::ApiRenderEngine_deviceCanDenoiseResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(79);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_deviceCanDenoiseRequest, ::octaneapi::ApiRenderEngine_deviceCanDenoiseResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_deviceCanDenoise() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status deviceCanDenoise(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_deviceCanDenoiseRequest* /*request*/, ::octaneapi::ApiRenderEngine_deviceCanDenoiseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* deviceCanDenoise(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_deviceCanDenoiseRequest* /*request*/, ::octaneapi::ApiRenderEngine_deviceCanDenoiseResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_deviceSupportsHardwareRayTracing : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_deviceSupportsHardwareRayTracing() {
      ::grpc::Service::MarkMethodCallback(80,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_deviceSupportsHardwareRayTracingRequest, ::octaneapi::ApiRenderEngine_deviceSupportsHardwareRayTracingResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_deviceSupportsHardwareRayTracingRequest* request, ::octaneapi::ApiRenderEngine_deviceSupportsHardwareRayTracingResponse* response) { return this->deviceSupportsHardwareRayTracing(context, request, response); }));}
    void SetMessageAllocatorFor_deviceSupportsHardwareRayTracing(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_deviceSupportsHardwareRayTracingRequest, ::octaneapi::ApiRenderEngine_deviceSupportsHardwareRayTracingResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(80);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_deviceSupportsHardwareRayTracingRequest, ::octaneapi::ApiRenderEngine_deviceSupportsHardwareRayTracingResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_deviceSupportsHardwareRayTracing() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status deviceSupportsHardwareRayTracing(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_deviceSupportsHardwareRayTracingRequest* /*request*/, ::octaneapi::ApiRenderEngine_deviceSupportsHardwareRayTracingResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* deviceSupportsHardwareRayTracing(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_deviceSupportsHardwareRayTracingRequest* /*request*/, ::octaneapi::ApiRenderEngine_deviceSupportsHardwareRayTracingResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_deviceSharedSurfaceInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_deviceSharedSurfaceInfo() {
      ::grpc::Service::MarkMethodCallback(81,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_deviceSharedSurfaceInfoRequest, ::octaneapi::ApiRenderEngine_deviceSharedSurfaceInfoResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_deviceSharedSurfaceInfoRequest* request, ::octaneapi::ApiRenderEngine_deviceSharedSurfaceInfoResponse* response) { return this->deviceSharedSurfaceInfo(context, request, response); }));}
    void SetMessageAllocatorFor_deviceSharedSurfaceInfo(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_deviceSharedSurfaceInfoRequest, ::octaneapi::ApiRenderEngine_deviceSharedSurfaceInfoResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(81);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_deviceSharedSurfaceInfoRequest, ::octaneapi::ApiRenderEngine_deviceSharedSurfaceInfoResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_deviceSharedSurfaceInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status deviceSharedSurfaceInfo(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_deviceSharedSurfaceInfoRequest* /*request*/, ::octaneapi::ApiRenderEngine_deviceSharedSurfaceInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* deviceSharedSurfaceInfo(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_deviceSharedSurfaceInfoRequest* /*request*/, ::octaneapi::ApiRenderEngine_deviceSharedSurfaceInfoResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_getAvailablePeerToPeerPairs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_getAvailablePeerToPeerPairs() {
      ::grpc::Service::MarkMethodCallback(82,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_getAvailablePeerToPeerPairsRequest, ::octaneapi::ApiRenderEngine_getAvailablePeerToPeerPairsResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_getAvailablePeerToPeerPairsRequest* request, ::octaneapi::ApiRenderEngine_getAvailablePeerToPeerPairsResponse* response) { return this->getAvailablePeerToPeerPairs(context, request, response); }));}
    void SetMessageAllocatorFor_getAvailablePeerToPeerPairs(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_getAvailablePeerToPeerPairsRequest, ::octaneapi::ApiRenderEngine_getAvailablePeerToPeerPairsResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(82);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_getAvailablePeerToPeerPairsRequest, ::octaneapi::ApiRenderEngine_getAvailablePeerToPeerPairsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_getAvailablePeerToPeerPairs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getAvailablePeerToPeerPairs(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getAvailablePeerToPeerPairsRequest* /*request*/, ::octaneapi::ApiRenderEngine_getAvailablePeerToPeerPairsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getAvailablePeerToPeerPairs(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getAvailablePeerToPeerPairsRequest* /*request*/, ::octaneapi::ApiRenderEngine_getAvailablePeerToPeerPairsResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_setDevicesActivity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_setDevicesActivity() {
      ::grpc::Service::MarkMethodCallback(83,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_setDevicesActivityRequest, ::octaneapi::ApiRenderEngine_setDevicesActivityResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_setDevicesActivityRequest* request, ::octaneapi::ApiRenderEngine_setDevicesActivityResponse* response) { return this->setDevicesActivity(context, request, response); }));}
    void SetMessageAllocatorFor_setDevicesActivity(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_setDevicesActivityRequest, ::octaneapi::ApiRenderEngine_setDevicesActivityResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(83);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_setDevicesActivityRequest, ::octaneapi::ApiRenderEngine_setDevicesActivityResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_setDevicesActivity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setDevicesActivity(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setDevicesActivityRequest* /*request*/, ::octaneapi::ApiRenderEngine_setDevicesActivityResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* setDevicesActivity(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setDevicesActivityRequest* /*request*/, ::octaneapi::ApiRenderEngine_setDevicesActivityResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_isDeviceUsedForRendering : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_isDeviceUsedForRendering() {
      ::grpc::Service::MarkMethodCallback(84,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_isDeviceUsedForRenderingRequest, ::octaneapi::ApiRenderEngine_isDeviceUsedForRenderingResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_isDeviceUsedForRenderingRequest* request, ::octaneapi::ApiRenderEngine_isDeviceUsedForRenderingResponse* response) { return this->isDeviceUsedForRendering(context, request, response); }));}
    void SetMessageAllocatorFor_isDeviceUsedForRendering(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_isDeviceUsedForRenderingRequest, ::octaneapi::ApiRenderEngine_isDeviceUsedForRenderingResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(84);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_isDeviceUsedForRenderingRequest, ::octaneapi::ApiRenderEngine_isDeviceUsedForRenderingResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_isDeviceUsedForRendering() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isDeviceUsedForRendering(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_isDeviceUsedForRenderingRequest* /*request*/, ::octaneapi::ApiRenderEngine_isDeviceUsedForRenderingResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* isDeviceUsedForRendering(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_isDeviceUsedForRenderingRequest* /*request*/, ::octaneapi::ApiRenderEngine_isDeviceUsedForRenderingResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_deviceUsesPriority : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_deviceUsesPriority() {
      ::grpc::Service::MarkMethodCallback(85,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_deviceUsesPriorityRequest, ::octaneapi::ApiRenderEngine_deviceUsesPriorityResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_deviceUsesPriorityRequest* request, ::octaneapi::ApiRenderEngine_deviceUsesPriorityResponse* response) { return this->deviceUsesPriority(context, request, response); }));}
    void SetMessageAllocatorFor_deviceUsesPriority(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_deviceUsesPriorityRequest, ::octaneapi::ApiRenderEngine_deviceUsesPriorityResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(85);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_deviceUsesPriorityRequest, ::octaneapi::ApiRenderEngine_deviceUsesPriorityResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_deviceUsesPriority() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status deviceUsesPriority(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_deviceUsesPriorityRequest* /*request*/, ::octaneapi::ApiRenderEngine_deviceUsesPriorityResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* deviceUsesPriority(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_deviceUsesPriorityRequest* /*request*/, ::octaneapi::ApiRenderEngine_deviceUsesPriorityResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_deviceUsesHardwareRayTracing : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_deviceUsesHardwareRayTracing() {
      ::grpc::Service::MarkMethodCallback(86,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_deviceUsesHardwareRayTracingRequest, ::octaneapi::ApiRenderEngine_deviceUsesHardwareRayTracingResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_deviceUsesHardwareRayTracingRequest* request, ::octaneapi::ApiRenderEngine_deviceUsesHardwareRayTracingResponse* response) { return this->deviceUsesHardwareRayTracing(context, request, response); }));}
    void SetMessageAllocatorFor_deviceUsesHardwareRayTracing(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_deviceUsesHardwareRayTracingRequest, ::octaneapi::ApiRenderEngine_deviceUsesHardwareRayTracingResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(86);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_deviceUsesHardwareRayTracingRequest, ::octaneapi::ApiRenderEngine_deviceUsesHardwareRayTracingResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_deviceUsesHardwareRayTracing() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status deviceUsesHardwareRayTracing(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_deviceUsesHardwareRayTracingRequest* /*request*/, ::octaneapi::ApiRenderEngine_deviceUsesHardwareRayTracingResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* deviceUsesHardwareRayTracing(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_deviceUsesHardwareRayTracingRequest* /*request*/, ::octaneapi::ApiRenderEngine_deviceUsesHardwareRayTracingResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_imageDeviceIndex : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_imageDeviceIndex() {
      ::grpc::Service::MarkMethodCallback(87,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_imageDeviceIndexRequest, ::octaneapi::ApiRenderEngine_imageDeviceIndexResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_imageDeviceIndexRequest* request, ::octaneapi::ApiRenderEngine_imageDeviceIndexResponse* response) { return this->imageDeviceIndex(context, request, response); }));}
    void SetMessageAllocatorFor_imageDeviceIndex(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_imageDeviceIndexRequest, ::octaneapi::ApiRenderEngine_imageDeviceIndexResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(87);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_imageDeviceIndexRequest, ::octaneapi::ApiRenderEngine_imageDeviceIndexResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_imageDeviceIndex() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status imageDeviceIndex(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_imageDeviceIndexRequest* /*request*/, ::octaneapi::ApiRenderEngine_imageDeviceIndexResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* imageDeviceIndex(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_imageDeviceIndexRequest* /*request*/, ::octaneapi::ApiRenderEngine_imageDeviceIndexResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_isDeviceUsedForDenoising : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_isDeviceUsedForDenoising() {
      ::grpc::Service::MarkMethodCallback(88,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_isDeviceUsedForDenoisingRequest, ::octaneapi::ApiRenderEngine_isDeviceUsedForDenoisingResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_isDeviceUsedForDenoisingRequest* request, ::octaneapi::ApiRenderEngine_isDeviceUsedForDenoisingResponse* response) { return this->isDeviceUsedForDenoising(context, request, response); }));}
    void SetMessageAllocatorFor_isDeviceUsedForDenoising(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_isDeviceUsedForDenoisingRequest, ::octaneapi::ApiRenderEngine_isDeviceUsedForDenoisingResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(88);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_isDeviceUsedForDenoisingRequest, ::octaneapi::ApiRenderEngine_isDeviceUsedForDenoisingResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_isDeviceUsedForDenoising() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isDeviceUsedForDenoising(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_isDeviceUsedForDenoisingRequest* /*request*/, ::octaneapi::ApiRenderEngine_isDeviceUsedForDenoisingResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* isDeviceUsedForDenoising(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_isDeviceUsedForDenoisingRequest* /*request*/, ::octaneapi::ApiRenderEngine_isDeviceUsedForDenoisingResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_renderPriority : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_renderPriority() {
      ::grpc::Service::MarkMethodCallback(89,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_renderPriorityRequest, ::octaneapi::ApiRenderEngine_renderPriorityResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_renderPriorityRequest* request, ::octaneapi::ApiRenderEngine_renderPriorityResponse* response) { return this->renderPriority(context, request, response); }));}
    void SetMessageAllocatorFor_renderPriority(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_renderPriorityRequest, ::octaneapi::ApiRenderEngine_renderPriorityResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(89);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_renderPriorityRequest, ::octaneapi::ApiRenderEngine_renderPriorityResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_renderPriority() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status renderPriority(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_renderPriorityRequest* /*request*/, ::octaneapi::ApiRenderEngine_renderPriorityResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* renderPriority(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_renderPriorityRequest* /*request*/, ::octaneapi::ApiRenderEngine_renderPriorityResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_setRenderPriority : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_setRenderPriority() {
      ::grpc::Service::MarkMethodCallback(90,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_setRenderPriorityRequest, ::google::protobuf::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_setRenderPriorityRequest* request, ::google::protobuf::Empty* response) { return this->setRenderPriority(context, request, response); }));}
    void SetMessageAllocatorFor_setRenderPriority(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_setRenderPriorityRequest, ::google::protobuf::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(90);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_setRenderPriorityRequest, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_setRenderPriority() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setRenderPriority(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setRenderPriorityRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* setRenderPriority(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setRenderPriorityRequest* /*request*/, ::google::protobuf::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_currentPeerToPeerGroups : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_currentPeerToPeerGroups() {
      ::grpc::Service::MarkMethodCallback(91,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_currentPeerToPeerGroupsRequest, ::octaneapi::ApiRenderEngine_currentPeerToPeerGroupsResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_currentPeerToPeerGroupsRequest* request, ::octaneapi::ApiRenderEngine_currentPeerToPeerGroupsResponse* response) { return this->currentPeerToPeerGroups(context, request, response); }));}
    void SetMessageAllocatorFor_currentPeerToPeerGroups(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_currentPeerToPeerGroupsRequest, ::octaneapi::ApiRenderEngine_currentPeerToPeerGroupsResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(91);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_currentPeerToPeerGroupsRequest, ::octaneapi::ApiRenderEngine_currentPeerToPeerGroupsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_currentPeerToPeerGroups() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status currentPeerToPeerGroups(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_currentPeerToPeerGroupsRequest* /*request*/, ::octaneapi::ApiRenderEngine_currentPeerToPeerGroupsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* currentPeerToPeerGroups(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_currentPeerToPeerGroupsRequest* /*request*/, ::octaneapi::ApiRenderEngine_currentPeerToPeerGroupsResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_hardwareRayTracingEnabled : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_hardwareRayTracingEnabled() {
      ::grpc::Service::MarkMethodCallback(92,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_hardwareRayTracingEnabledRequest, ::octaneapi::ApiRenderEngine_hardwareRayTracingEnabledResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_hardwareRayTracingEnabledRequest* request, ::octaneapi::ApiRenderEngine_hardwareRayTracingEnabledResponse* response) { return this->hardwareRayTracingEnabled(context, request, response); }));}
    void SetMessageAllocatorFor_hardwareRayTracingEnabled(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_hardwareRayTracingEnabledRequest, ::octaneapi::ApiRenderEngine_hardwareRayTracingEnabledResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(92);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_hardwareRayTracingEnabledRequest, ::octaneapi::ApiRenderEngine_hardwareRayTracingEnabledResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_hardwareRayTracingEnabled() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status hardwareRayTracingEnabled(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_hardwareRayTracingEnabledRequest* /*request*/, ::octaneapi::ApiRenderEngine_hardwareRayTracingEnabledResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* hardwareRayTracingEnabled(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_hardwareRayTracingEnabledRequest* /*request*/, ::octaneapi::ApiRenderEngine_hardwareRayTracingEnabledResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_openDeviceSettings : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_openDeviceSettings() {
      ::grpc::Service::MarkMethodCallback(93,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_openDeviceSettingsRequest, ::google::protobuf::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_openDeviceSettingsRequest* request, ::google::protobuf::Empty* response) { return this->openDeviceSettings(context, request, response); }));}
    void SetMessageAllocatorFor_openDeviceSettings(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_openDeviceSettingsRequest, ::google::protobuf::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(93);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_openDeviceSettingsRequest, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_openDeviceSettings() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status openDeviceSettings(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_openDeviceSettingsRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* openDeviceSettings(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_openDeviceSettingsRequest* /*request*/, ::google::protobuf::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_renderDeviceState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_renderDeviceState() {
      ::grpc::Service::MarkMethodCallback(94,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_renderDeviceStateRequest, ::octaneapi::ApiRenderEngine_renderDeviceStateResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_renderDeviceStateRequest* request, ::octaneapi::ApiRenderEngine_renderDeviceStateResponse* response) { return this->renderDeviceState(context, request, response); }));}
    void SetMessageAllocatorFor_renderDeviceState(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_renderDeviceStateRequest, ::octaneapi::ApiRenderEngine_renderDeviceStateResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(94);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_renderDeviceStateRequest, ::octaneapi::ApiRenderEngine_renderDeviceStateResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_renderDeviceState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status renderDeviceState(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_renderDeviceStateRequest* /*request*/, ::octaneapi::ApiRenderEngine_renderDeviceStateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* renderDeviceState(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_renderDeviceStateRequest* /*request*/, ::octaneapi::ApiRenderEngine_renderDeviceStateResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_renderDeviceErrorCode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_renderDeviceErrorCode() {
      ::grpc::Service::MarkMethodCallback(95,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_renderDeviceErrorCodeRequest, ::octaneapi::ApiRenderEngine_renderDeviceErrorCodeResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_renderDeviceErrorCodeRequest* request, ::octaneapi::ApiRenderEngine_renderDeviceErrorCodeResponse* response) { return this->renderDeviceErrorCode(context, request, response); }));}
    void SetMessageAllocatorFor_renderDeviceErrorCode(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_renderDeviceErrorCodeRequest, ::octaneapi::ApiRenderEngine_renderDeviceErrorCodeResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(95);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_renderDeviceErrorCodeRequest, ::octaneapi::ApiRenderEngine_renderDeviceErrorCodeResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_renderDeviceErrorCode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status renderDeviceErrorCode(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_renderDeviceErrorCodeRequest* /*request*/, ::octaneapi::ApiRenderEngine_renderDeviceErrorCodeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* renderDeviceErrorCode(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_renderDeviceErrorCodeRequest* /*request*/, ::octaneapi::ApiRenderEngine_renderDeviceErrorCodeResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_errorcodeToString : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_errorcodeToString() {
      ::grpc::Service::MarkMethodCallback(96,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_errorcodeToStringRequest, ::octaneapi::ApiRenderEngine_errorcodeToStringResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_errorcodeToStringRequest* request, ::octaneapi::ApiRenderEngine_errorcodeToStringResponse* response) { return this->errorcodeToString(context, request, response); }));}
    void SetMessageAllocatorFor_errorcodeToString(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_errorcodeToStringRequest, ::octaneapi::ApiRenderEngine_errorcodeToStringResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(96);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_errorcodeToStringRequest, ::octaneapi::ApiRenderEngine_errorcodeToStringResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_errorcodeToString() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status errorcodeToString(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_errorcodeToStringRequest* /*request*/, ::octaneapi::ApiRenderEngine_errorcodeToStringResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* errorcodeToString(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_errorcodeToStringRequest* /*request*/, ::octaneapi::ApiRenderEngine_errorcodeToStringResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_renderDeviceErrorMessage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_renderDeviceErrorMessage() {
      ::grpc::Service::MarkMethodCallback(97,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_renderDeviceErrorMessageRequest, ::octaneapi::ApiRenderEngine_renderDeviceErrorMessageResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_renderDeviceErrorMessageRequest* request, ::octaneapi::ApiRenderEngine_renderDeviceErrorMessageResponse* response) { return this->renderDeviceErrorMessage(context, request, response); }));}
    void SetMessageAllocatorFor_renderDeviceErrorMessage(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_renderDeviceErrorMessageRequest, ::octaneapi::ApiRenderEngine_renderDeviceErrorMessageResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(97);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_renderDeviceErrorMessageRequest, ::octaneapi::ApiRenderEngine_renderDeviceErrorMessageResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_renderDeviceErrorMessage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status renderDeviceErrorMessage(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_renderDeviceErrorMessageRequest* /*request*/, ::octaneapi::ApiRenderEngine_renderDeviceErrorMessageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* renderDeviceErrorMessage(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_renderDeviceErrorMessageRequest* /*request*/, ::octaneapi::ApiRenderEngine_renderDeviceErrorMessageResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_saveRenderDeviceConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_saveRenderDeviceConfig() {
      ::grpc::Service::MarkMethodCallback(98,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_saveRenderDeviceConfigRequest, ::google::protobuf::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_saveRenderDeviceConfigRequest* request, ::google::protobuf::Empty* response) { return this->saveRenderDeviceConfig(context, request, response); }));}
    void SetMessageAllocatorFor_saveRenderDeviceConfig(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_saveRenderDeviceConfigRequest, ::google::protobuf::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(98);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_saveRenderDeviceConfigRequest, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_saveRenderDeviceConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status saveRenderDeviceConfig(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_saveRenderDeviceConfigRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* saveRenderDeviceConfig(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_saveRenderDeviceConfigRequest* /*request*/, ::google::protobuf::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_outOfCoreEnabled : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_outOfCoreEnabled() {
      ::grpc::Service::MarkMethodCallback(99,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_outOfCoreEnabledRequest, ::octaneapi::ApiRenderEngine_outOfCoreEnabledResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_outOfCoreEnabledRequest* request, ::octaneapi::ApiRenderEngine_outOfCoreEnabledResponse* response) { return this->outOfCoreEnabled(context, request, response); }));}
    void SetMessageAllocatorFor_outOfCoreEnabled(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_outOfCoreEnabledRequest, ::octaneapi::ApiRenderEngine_outOfCoreEnabledResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(99);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_outOfCoreEnabledRequest, ::octaneapi::ApiRenderEngine_outOfCoreEnabledResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_outOfCoreEnabled() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status outOfCoreEnabled(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_outOfCoreEnabledRequest* /*request*/, ::octaneapi::ApiRenderEngine_outOfCoreEnabledResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* outOfCoreEnabled(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_outOfCoreEnabledRequest* /*request*/, ::octaneapi::ApiRenderEngine_outOfCoreEnabledResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_enableOutOfCore : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_enableOutOfCore() {
      ::grpc::Service::MarkMethodCallback(100,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_enableOutOfCoreRequest, ::google::protobuf::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_enableOutOfCoreRequest* request, ::google::protobuf::Empty* response) { return this->enableOutOfCore(context, request, response); }));}
    void SetMessageAllocatorFor_enableOutOfCore(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_enableOutOfCoreRequest, ::google::protobuf::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(100);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_enableOutOfCoreRequest, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_enableOutOfCore() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status enableOutOfCore(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_enableOutOfCoreRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* enableOutOfCore(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_enableOutOfCoreRequest* /*request*/, ::google::protobuf::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_disableOutOfCore : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_disableOutOfCore() {
      ::grpc::Service::MarkMethodCallback(101,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_disableOutOfCoreRequest, ::google::protobuf::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_disableOutOfCoreRequest* request, ::google::protobuf::Empty* response) { return this->disableOutOfCore(context, request, response); }));}
    void SetMessageAllocatorFor_disableOutOfCore(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_disableOutOfCoreRequest, ::google::protobuf::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(101);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_disableOutOfCoreRequest, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_disableOutOfCore() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status disableOutOfCore(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_disableOutOfCoreRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* disableOutOfCore(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_disableOutOfCoreRequest* /*request*/, ::google::protobuf::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_getOutOfCoreMemoryUsage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_getOutOfCoreMemoryUsage() {
      ::grpc::Service::MarkMethodCallback(102,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_getOutOfCoreMemoryUsageRequest, ::octaneapi::ApiRenderEngine_getOutOfCoreMemoryUsageResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_getOutOfCoreMemoryUsageRequest* request, ::octaneapi::ApiRenderEngine_getOutOfCoreMemoryUsageResponse* response) { return this->getOutOfCoreMemoryUsage(context, request, response); }));}
    void SetMessageAllocatorFor_getOutOfCoreMemoryUsage(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_getOutOfCoreMemoryUsageRequest, ::octaneapi::ApiRenderEngine_getOutOfCoreMemoryUsageResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(102);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_getOutOfCoreMemoryUsageRequest, ::octaneapi::ApiRenderEngine_getOutOfCoreMemoryUsageResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_getOutOfCoreMemoryUsage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getOutOfCoreMemoryUsage(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getOutOfCoreMemoryUsageRequest* /*request*/, ::octaneapi::ApiRenderEngine_getOutOfCoreMemoryUsageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getOutOfCoreMemoryUsage(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getOutOfCoreMemoryUsageRequest* /*request*/, ::octaneapi::ApiRenderEngine_getOutOfCoreMemoryUsageResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_setGpuHeadroom : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_setGpuHeadroom() {
      ::grpc::Service::MarkMethodCallback(103,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_setGpuHeadroomRequest, ::google::protobuf::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_setGpuHeadroomRequest* request, ::google::protobuf::Empty* response) { return this->setGpuHeadroom(context, request, response); }));}
    void SetMessageAllocatorFor_setGpuHeadroom(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_setGpuHeadroomRequest, ::google::protobuf::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(103);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_setGpuHeadroomRequest, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_setGpuHeadroom() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setGpuHeadroom(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setGpuHeadroomRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* setGpuHeadroom(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setGpuHeadroomRequest* /*request*/, ::google::protobuf::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_getGpuHeadroom : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_getGpuHeadroom() {
      ::grpc::Service::MarkMethodCallback(104,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_getGpuHeadroomRequest, ::octaneapi::ApiRenderEngine_getGpuHeadroomResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_getGpuHeadroomRequest* request, ::octaneapi::ApiRenderEngine_getGpuHeadroomResponse* response) { return this->getGpuHeadroom(context, request, response); }));}
    void SetMessageAllocatorFor_getGpuHeadroom(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_getGpuHeadroomRequest, ::octaneapi::ApiRenderEngine_getGpuHeadroomResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(104);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_getGpuHeadroomRequest, ::octaneapi::ApiRenderEngine_getGpuHeadroomResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_getGpuHeadroom() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getGpuHeadroom(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getGpuHeadroomRequest* /*request*/, ::octaneapi::ApiRenderEngine_getGpuHeadroomResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getGpuHeadroom(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getGpuHeadroomRequest* /*request*/, ::octaneapi::ApiRenderEngine_getGpuHeadroomResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_setCoreLimit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_setCoreLimit() {
      ::grpc::Service::MarkMethodCallback(105,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_setCoreLimitRequest, ::google::protobuf::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_setCoreLimitRequest* request, ::google::protobuf::Empty* response) { return this->setCoreLimit(context, request, response); }));}
    void SetMessageAllocatorFor_setCoreLimit(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_setCoreLimitRequest, ::google::protobuf::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(105);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_setCoreLimitRequest, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_setCoreLimit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setCoreLimit(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setCoreLimitRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* setCoreLimit(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setCoreLimitRequest* /*request*/, ::google::protobuf::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_disableCoreLimit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_disableCoreLimit() {
      ::grpc::Service::MarkMethodCallback(106,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_disableCoreLimitRequest, ::google::protobuf::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_disableCoreLimitRequest* request, ::google::protobuf::Empty* response) { return this->disableCoreLimit(context, request, response); }));}
    void SetMessageAllocatorFor_disableCoreLimit(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_disableCoreLimitRequest, ::google::protobuf::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(106);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_disableCoreLimitRequest, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_disableCoreLimit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status disableCoreLimit(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_disableCoreLimitRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* disableCoreLimit(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_disableCoreLimitRequest* /*request*/, ::google::protobuf::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_registerInputSharedSurface : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_registerInputSharedSurface() {
      ::grpc::Service::MarkMethodCallback(107,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_registerInputSharedSurfaceRequest, ::octaneapi::ApiRenderEngine_registerInputSharedSurfaceResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_registerInputSharedSurfaceRequest* request, ::octaneapi::ApiRenderEngine_registerInputSharedSurfaceResponse* response) { return this->registerInputSharedSurface(context, request, response); }));}
    void SetMessageAllocatorFor_registerInputSharedSurface(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_registerInputSharedSurfaceRequest, ::octaneapi::ApiRenderEngine_registerInputSharedSurfaceResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(107);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_registerInputSharedSurfaceRequest, ::octaneapi::ApiRenderEngine_registerInputSharedSurfaceResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_registerInputSharedSurface() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status registerInputSharedSurface(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_registerInputSharedSurfaceRequest* /*request*/, ::octaneapi::ApiRenderEngine_registerInputSharedSurfaceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* registerInputSharedSurface(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_registerInputSharedSurfaceRequest* /*request*/, ::octaneapi::ApiRenderEngine_registerInputSharedSurfaceResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_unregisterInputSharedSurface : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_unregisterInputSharedSurface() {
      ::grpc::Service::MarkMethodCallback(108,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_unregisterInputSharedSurfaceRequest, ::google::protobuf::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_unregisterInputSharedSurfaceRequest* request, ::google::protobuf::Empty* response) { return this->unregisterInputSharedSurface(context, request, response); }));}
    void SetMessageAllocatorFor_unregisterInputSharedSurface(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_unregisterInputSharedSurfaceRequest, ::google::protobuf::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(108);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_unregisterInputSharedSurfaceRequest, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_unregisterInputSharedSurface() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status unregisterInputSharedSurface(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_unregisterInputSharedSurfaceRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* unregisterInputSharedSurface(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_unregisterInputSharedSurfaceRequest* /*request*/, ::google::protobuf::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_triggerAsyncTonemap : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_triggerAsyncTonemap() {
      ::grpc::Service::MarkMethodCallback(109,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_triggerAsyncTonemapRequest, ::google::protobuf::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_triggerAsyncTonemapRequest* request, ::google::protobuf::Empty* response) { return this->triggerAsyncTonemap(context, request, response); }));}
    void SetMessageAllocatorFor_triggerAsyncTonemap(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_triggerAsyncTonemapRequest, ::google::protobuf::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(109);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_triggerAsyncTonemapRequest, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_triggerAsyncTonemap() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status triggerAsyncTonemap(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_triggerAsyncTonemapRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* triggerAsyncTonemap(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_triggerAsyncTonemapRequest* /*request*/, ::google::protobuf::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_setSharedSurfaceOutputType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_setSharedSurfaceOutputType() {
      ::grpc::Service::MarkMethodCallback(110,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_setSharedSurfaceOutputTypeRequest, ::google::protobuf::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_setSharedSurfaceOutputTypeRequest* request, ::google::protobuf::Empty* response) { return this->setSharedSurfaceOutputType(context, request, response); }));}
    void SetMessageAllocatorFor_setSharedSurfaceOutputType(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_setSharedSurfaceOutputTypeRequest, ::google::protobuf::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(110);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_setSharedSurfaceOutputTypeRequest, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_setSharedSurfaceOutputType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setSharedSurfaceOutputType(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setSharedSurfaceOutputTypeRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* setSharedSurfaceOutputType(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setSharedSurfaceOutputTypeRequest* /*request*/, ::google::protobuf::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_getSharedSurfaceOutputType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_getSharedSurfaceOutputType() {
      ::grpc::Service::MarkMethodCallback(111,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_getSharedSurfaceOutputTypeRequest, ::octaneapi::ApiRenderEngine_getSharedSurfaceOutputTypeResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_getSharedSurfaceOutputTypeRequest* request, ::octaneapi::ApiRenderEngine_getSharedSurfaceOutputTypeResponse* response) { return this->getSharedSurfaceOutputType(context, request, response); }));}
    void SetMessageAllocatorFor_getSharedSurfaceOutputType(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_getSharedSurfaceOutputTypeRequest, ::octaneapi::ApiRenderEngine_getSharedSurfaceOutputTypeResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(111);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_getSharedSurfaceOutputTypeRequest, ::octaneapi::ApiRenderEngine_getSharedSurfaceOutputTypeResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_getSharedSurfaceOutputType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getSharedSurfaceOutputType(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getSharedSurfaceOutputTypeRequest* /*request*/, ::octaneapi::ApiRenderEngine_getSharedSurfaceOutputTypeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getSharedSurfaceOutputType(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getSharedSurfaceOutputTypeRequest* /*request*/, ::octaneapi::ApiRenderEngine_getSharedSurfaceOutputTypeResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_getRealTime : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_getRealTime() {
      ::grpc::Service::MarkMethodCallback(112,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_getRealTimeRequest, ::octaneapi::ApiRenderEngine_getRealTimeResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_getRealTimeRequest* request, ::octaneapi::ApiRenderEngine_getRealTimeResponse* response) { return this->getRealTime(context, request, response); }));}
    void SetMessageAllocatorFor_getRealTime(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_getRealTimeRequest, ::octaneapi::ApiRenderEngine_getRealTimeResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(112);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_getRealTimeRequest, ::octaneapi::ApiRenderEngine_getRealTimeResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_getRealTime() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getRealTime(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getRealTimeRequest* /*request*/, ::octaneapi::ApiRenderEngine_getRealTimeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getRealTime(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getRealTimeRequest* /*request*/, ::octaneapi::ApiRenderEngine_getRealTimeResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_pauseRendering : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_pauseRendering() {
      ::grpc::Service::MarkMethodCallback(113,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_pauseRenderingRequest, ::google::protobuf::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_pauseRenderingRequest* request, ::google::protobuf::Empty* response) { return this->pauseRendering(context, request, response); }));}
    void SetMessageAllocatorFor_pauseRendering(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_pauseRenderingRequest, ::google::protobuf::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(113);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_pauseRenderingRequest, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_pauseRendering() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status pauseRendering(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_pauseRenderingRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* pauseRendering(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_pauseRenderingRequest* /*request*/, ::google::protobuf::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_continueRendering : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_continueRendering() {
      ::grpc::Service::MarkMethodCallback(114,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_continueRenderingRequest, ::google::protobuf::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_continueRenderingRequest* request, ::google::protobuf::Empty* response) { return this->continueRendering(context, request, response); }));}
    void SetMessageAllocatorFor_continueRendering(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_continueRenderingRequest, ::google::protobuf::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(114);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_continueRenderingRequest, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_continueRendering() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status continueRendering(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_continueRenderingRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* continueRendering(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_continueRenderingRequest* /*request*/, ::google::protobuf::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_isRenderingPaused : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_isRenderingPaused() {
      ::grpc::Service::MarkMethodCallback(115,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_isRenderingPausedRequest, ::octaneapi::ApiRenderEngine_isRenderingPausedResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_isRenderingPausedRequest* request, ::octaneapi::ApiRenderEngine_isRenderingPausedResponse* response) { return this->isRenderingPaused(context, request, response); }));}
    void SetMessageAllocatorFor_isRenderingPaused(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_isRenderingPausedRequest, ::octaneapi::ApiRenderEngine_isRenderingPausedResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(115);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_isRenderingPausedRequest, ::octaneapi::ApiRenderEngine_isRenderingPausedResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_isRenderingPaused() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isRenderingPaused(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_isRenderingPausedRequest* /*request*/, ::octaneapi::ApiRenderEngine_isRenderingPausedResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* isRenderingPaused(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_isRenderingPausedRequest* /*request*/, ::octaneapi::ApiRenderEngine_isRenderingPausedResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_restartRendering : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_restartRendering() {
      ::grpc::Service::MarkMethodCallback(116,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_restartRenderingRequest, ::google::protobuf::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_restartRenderingRequest* request, ::google::protobuf::Empty* response) { return this->restartRendering(context, request, response); }));}
    void SetMessageAllocatorFor_restartRendering(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_restartRenderingRequest, ::google::protobuf::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(116);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_restartRenderingRequest, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_restartRendering() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status restartRendering(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_restartRenderingRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* restartRendering(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_restartRenderingRequest* /*request*/, ::google::protobuf::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_stopRendering : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_stopRendering() {
      ::grpc::Service::MarkMethodCallback(117,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_stopRenderingRequest, ::google::protobuf::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_stopRenderingRequest* request, ::google::protobuf::Empty* response) { return this->stopRendering(context, request, response); }));}
    void SetMessageAllocatorFor_stopRendering(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_stopRenderingRequest, ::google::protobuf::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(117);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_stopRenderingRequest, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_stopRendering() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status stopRendering(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_stopRenderingRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* stopRendering(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_stopRenderingRequest* /*request*/, ::google::protobuf::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_pick : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_pick() {
      ::grpc::Service::MarkMethodCallback(118,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_pickRequest, ::octaneapi::ApiRenderEngine_pickResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_pickRequest* request, ::octaneapi::ApiRenderEngine_pickResponse* response) { return this->pick(context, request, response); }));}
    void SetMessageAllocatorFor_pick(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_pickRequest, ::octaneapi::ApiRenderEngine_pickResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(118);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_pickRequest, ::octaneapi::ApiRenderEngine_pickResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_pick() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status pick(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_pickRequest* /*request*/, ::octaneapi::ApiRenderEngine_pickResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* pick(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_pickRequest* /*request*/, ::octaneapi::ApiRenderEngine_pickResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_pickWhitePoint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_pickWhitePoint() {
      ::grpc::Service::MarkMethodCallback(119,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_pickWhitePointRequest, ::octaneapi::ApiRenderEngine_pickWhitePointResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_pickWhitePointRequest* request, ::octaneapi::ApiRenderEngine_pickWhitePointResponse* response) { return this->pickWhitePoint(context, request, response); }));}
    void SetMessageAllocatorFor_pickWhitePoint(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_pickWhitePointRequest, ::octaneapi::ApiRenderEngine_pickWhitePointResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(119);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_pickWhitePointRequest, ::octaneapi::ApiRenderEngine_pickWhitePointResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_pickWhitePoint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status pickWhitePoint(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_pickWhitePointRequest* /*request*/, ::octaneapi::ApiRenderEngine_pickWhitePointResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* pickWhitePoint(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_pickWhitePointRequest* /*request*/, ::octaneapi::ApiRenderEngine_pickWhitePointResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_pickImagerWhitePoint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_pickImagerWhitePoint() {
      ::grpc::Service::MarkMethodCallback(120,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_pickImagerWhitePointRequest, ::octaneapi::ApiRenderEngine_pickImagerWhitePointResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_pickImagerWhitePointRequest* request, ::octaneapi::ApiRenderEngine_pickImagerWhitePointResponse* response) { return this->pickImagerWhitePoint(context, request, response); }));}
    void SetMessageAllocatorFor_pickImagerWhitePoint(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_pickImagerWhitePointRequest, ::octaneapi::ApiRenderEngine_pickImagerWhitePointResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(120);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_pickImagerWhitePointRequest, ::octaneapi::ApiRenderEngine_pickImagerWhitePointResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_pickImagerWhitePoint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status pickImagerWhitePoint(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_pickImagerWhitePointRequest* /*request*/, ::octaneapi::ApiRenderEngine_pickImagerWhitePointResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* pickImagerWhitePoint(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_pickImagerWhitePointRequest* /*request*/, ::octaneapi::ApiRenderEngine_pickImagerWhitePointResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_isOutputAovWhitePointPickable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_isOutputAovWhitePointPickable() {
      ::grpc::Service::MarkMethodCallback(121,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_isOutputAovWhitePointPickableRequest, ::octaneapi::ApiRenderEngine_isOutputAovWhitePointPickableResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_isOutputAovWhitePointPickableRequest* request, ::octaneapi::ApiRenderEngine_isOutputAovWhitePointPickableResponse* response) { return this->isOutputAovWhitePointPickable(context, request, response); }));}
    void SetMessageAllocatorFor_isOutputAovWhitePointPickable(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_isOutputAovWhitePointPickableRequest, ::octaneapi::ApiRenderEngine_isOutputAovWhitePointPickableResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(121);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_isOutputAovWhitePointPickableRequest, ::octaneapi::ApiRenderEngine_isOutputAovWhitePointPickableResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_isOutputAovWhitePointPickable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isOutputAovWhitePointPickable(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_isOutputAovWhitePointPickableRequest* /*request*/, ::octaneapi::ApiRenderEngine_isOutputAovWhitePointPickableResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* isOutputAovWhitePointPickable(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_isOutputAovWhitePointPickableRequest* /*request*/, ::octaneapi::ApiRenderEngine_isOutputAovWhitePointPickableResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_pickOutputAovWhitePoint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_pickOutputAovWhitePoint() {
      ::grpc::Service::MarkMethodCallback(122,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_pickOutputAovWhitePointRequest, ::octaneapi::ApiRenderEngine_pickOutputAovWhitePointResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_pickOutputAovWhitePointRequest* request, ::octaneapi::ApiRenderEngine_pickOutputAovWhitePointResponse* response) { return this->pickOutputAovWhitePoint(context, request, response); }));}
    void SetMessageAllocatorFor_pickOutputAovWhitePoint(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_pickOutputAovWhitePointRequest, ::octaneapi::ApiRenderEngine_pickOutputAovWhitePointResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(122);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_pickOutputAovWhitePointRequest, ::octaneapi::ApiRenderEngine_pickOutputAovWhitePointResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_pickOutputAovWhitePoint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status pickOutputAovWhitePoint(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_pickOutputAovWhitePointRequest* /*request*/, ::octaneapi::ApiRenderEngine_pickOutputAovWhitePointResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* pickOutputAovWhitePoint(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_pickOutputAovWhitePointRequest* /*request*/, ::octaneapi::ApiRenderEngine_pickOutputAovWhitePointResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_pickCryptomatteMatte : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_pickCryptomatteMatte() {
      ::grpc::Service::MarkMethodCallback(123,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_pickCryptomatteMatteRequest, ::octaneapi::ApiRenderEngine_pickCryptomatteMatteResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_pickCryptomatteMatteRequest* request, ::octaneapi::ApiRenderEngine_pickCryptomatteMatteResponse* response) { return this->pickCryptomatteMatte(context, request, response); }));}
    void SetMessageAllocatorFor_pickCryptomatteMatte(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_pickCryptomatteMatteRequest, ::octaneapi::ApiRenderEngine_pickCryptomatteMatteResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(123);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_pickCryptomatteMatteRequest, ::octaneapi::ApiRenderEngine_pickCryptomatteMatteResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_pickCryptomatteMatte() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status pickCryptomatteMatte(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_pickCryptomatteMatteRequest* /*request*/, ::octaneapi::ApiRenderEngine_pickCryptomatteMatteResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* pickCryptomatteMatte(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_pickCryptomatteMatteRequest* /*request*/, ::octaneapi::ApiRenderEngine_pickCryptomatteMatteResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_modifyCryptomatteMatteSelection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_modifyCryptomatteMatteSelection() {
      ::grpc::Service::MarkMethodCallback(124,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_modifyCryptomatteMatteSelectionRequest, ::octaneapi::ApiRenderEngine_modifyCryptomatteMatteSelectionResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_modifyCryptomatteMatteSelectionRequest* request, ::octaneapi::ApiRenderEngine_modifyCryptomatteMatteSelectionResponse* response) { return this->modifyCryptomatteMatteSelection(context, request, response); }));}
    void SetMessageAllocatorFor_modifyCryptomatteMatteSelection(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_modifyCryptomatteMatteSelectionRequest, ::octaneapi::ApiRenderEngine_modifyCryptomatteMatteSelectionResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(124);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_modifyCryptomatteMatteSelectionRequest, ::octaneapi::ApiRenderEngine_modifyCryptomatteMatteSelectionResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_modifyCryptomatteMatteSelection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status modifyCryptomatteMatteSelection(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_modifyCryptomatteMatteSelectionRequest* /*request*/, ::octaneapi::ApiRenderEngine_modifyCryptomatteMatteSelectionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* modifyCryptomatteMatteSelection(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_modifyCryptomatteMatteSelectionRequest* /*request*/, ::octaneapi::ApiRenderEngine_modifyCryptomatteMatteSelectionResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_toString : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_toString() {
      ::grpc::Service::MarkMethodCallback(125,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_toStringRequest, ::octaneapi::ApiRenderEngine_toStringResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_toStringRequest* request, ::octaneapi::ApiRenderEngine_toStringResponse* response) { return this->toString(context, request, response); }));}
    void SetMessageAllocatorFor_toString(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_toStringRequest, ::octaneapi::ApiRenderEngine_toStringResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(125);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_toStringRequest, ::octaneapi::ApiRenderEngine_toStringResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_toString() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status toString(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_toStringRequest* /*request*/, ::octaneapi::ApiRenderEngine_toStringResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* toString(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_toStringRequest* /*request*/, ::octaneapi::ApiRenderEngine_toStringResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_getDevicePciIds : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_getDevicePciIds() {
      ::grpc::Service::MarkMethodCallback(126,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_getDevicePciIdsRequest, ::octaneapi::ApiRenderEngine_getDevicePciIdsResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderEngine_getDevicePciIdsRequest* request, ::octaneapi::ApiRenderEngine_getDevicePciIdsResponse* response) { return this->getDevicePciIds(context, request, response); }));}
    void SetMessageAllocatorFor_getDevicePciIds(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderEngine_getDevicePciIdsRequest, ::octaneapi::ApiRenderEngine_getDevicePciIdsResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(126);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderEngine_getDevicePciIdsRequest, ::octaneapi::ApiRenderEngine_getDevicePciIdsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_getDevicePciIds() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getDevicePciIds(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getDevicePciIdsRequest* /*request*/, ::octaneapi::ApiRenderEngine_getDevicePciIdsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getDevicePciIds(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getDevicePciIdsRequest* /*request*/, ::octaneapi::ApiRenderEngine_getDevicePciIdsResponse* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_setRenderTargetNode<WithCallbackMethod_getRenderTargetNode<WithCallbackMethod_getRenderGeometryNode<WithCallbackMethod_getRenderCameraNode<WithCallbackMethod_setRenderRegion<WithCallbackMethod_getRenderRegion<WithCallbackMethod_setAsyncTonemapParams<WithCallbackMethod_setAsyncTonemapParams1<WithCallbackMethod_asyncTonemapBufferType<WithCallbackMethod_asyncTonemapCryptomatteFalseColor<WithCallbackMethod_asyncTonemapOutputColorSpaceInfo<WithCallbackMethod_asyncTonemapColorSpace<WithCallbackMethod_asyncTonemapPremultipliedAlphaType<WithCallbackMethod_setAsyncTonemapRenderPasses<WithCallbackMethod_asyncTonemapRenderPasses<WithCallbackMethod_getEnabledAovs<WithCallbackMethod_freeTonemapPasses<WithCallbackMethod_displayRenderPassId<WithCallbackMethod_setSubSampleMode<WithCallbackMethod_getSubSampleMode<WithCallbackMethod_setClayMode<WithCallbackMethod_clayMode<WithCallbackMethod_fps<WithCallbackMethod_setFps<WithCallbackMethod_isCompiling<WithCallbackMethod_isCompressingTextures<WithCallbackMethod_hasPendingRenderData<WithCallbackMethod_getCurrentChangeLevel<WithCallbackMethod_getRenderImageChangeLevel<WithCallbackMethod_getRenderRestartedChangeLevel<WithCallbackMethod_setAsyncUpdateCallback<WithCallbackMethod_updatesAreAsync<WithCallbackMethod_isImageReady<WithCallbackMethod_resetImageReady<WithCallbackMethod_isRenderFailure<WithCallbackMethod_resetRenderFailure<WithCallbackMethod_setOnTileBlendedCallback<WithCallbackMethod_setOnNewStatisticsCallback<WithCallbackMethod_setOnNewImageCallback<WithCallbackMethod_setOnOcioErrorCallback<WithCallbackMethod_setOnRenderFailureCallback<WithCallbackMethod_setForceCallbacksInRenderThreads<WithCallbackMethod_grabRenderResult<WithCallbackMethod_releaseRenderResult<WithCallbackMethod_synchronousTonemap<WithCallbackMethod_synchronousTonemap1<WithCallbackMethod_synchronousTonemapAllRenderPasses<WithCallbackMethod_synchronousTonemapAllRenderPasses1<WithCallbackMethod_getRenderStatistics<WithCallbackMethod_getRenderResultStatistics<WithCallbackMethod_saveImage<WithCallbackMethod_saveImage1<WithCallbackMethod_saveImage2<WithCallbackMethod_saveRenderPasses<WithCallbackMethod_saveRenderPasses1<WithCallbackMethod_saveRenderPasses2<WithCallbackMethod_saveRenderPassesMultiExr<WithCallbackMethod_saveRenderPassesMultiExr1<WithCallbackMethod_saveRenderPassesDeepExr<WithCallbackMethod_deepImageEnabled<WithCallbackMethod_deepImageEnabled1<WithCallbackMethod_deepPassesEnabled<WithCallbackMethod_canSaveDeepImage<WithCallbackMethod_saveDeepImage<WithCallbackMethod_saveRenderState<WithCallbackMethod_loadRenderState<WithCallbackMethod_previewMaterial<WithCallbackMethod_previewMaterialHdr<WithCallbackMethod_previewMaterial1<WithCallbackMethod_getMemoryUsage<WithCallbackMethod_getResourceStatistics<WithCallbackMethod_getGeometryStatistics<WithCallbackMethod_getTexturesStatistics<WithCallbackMethod_getSceneBounds<WithCallbackMethod_getDeviceCount<WithCallbackMethod_getDeviceComputeModel<WithCallbackMethod_getDeviceName<WithCallbackMethod_isSupportedDevice<WithCallbackMethod_deviceCanRender<WithCallbackMethod_deviceCanDenoise<WithCallbackMethod_deviceSupportsHardwareRayTracing<WithCallbackMethod_deviceSharedSurfaceInfo<WithCallbackMethod_getAvailablePeerToPeerPairs<WithCallbackMethod_setDevicesActivity<WithCallbackMethod_isDeviceUsedForRendering<WithCallbackMethod_deviceUsesPriority<WithCallbackMethod_deviceUsesHardwareRayTracing<WithCallbackMethod_imageDeviceIndex<WithCallbackMethod_isDeviceUsedForDenoising<WithCallbackMethod_renderPriority<WithCallbackMethod_setRenderPriority<WithCallbackMethod_currentPeerToPeerGroups<WithCallbackMethod_hardwareRayTracingEnabled<WithCallbackMethod_openDeviceSettings<WithCallbackMethod_renderDeviceState<WithCallbackMethod_renderDeviceErrorCode<WithCallbackMethod_errorcodeToString<WithCallbackMethod_renderDeviceErrorMessage<WithCallbackMethod_saveRenderDeviceConfig<WithCallbackMethod_outOfCoreEnabled<WithCallbackMethod_enableOutOfCore<WithCallbackMethod_disableOutOfCore<WithCallbackMethod_getOutOfCoreMemoryUsage<WithCallbackMethod_setGpuHeadroom<WithCallbackMethod_getGpuHeadroom<WithCallbackMethod_setCoreLimit<WithCallbackMethod_disableCoreLimit<WithCallbackMethod_registerInputSharedSurface<WithCallbackMethod_unregisterInputSharedSurface<WithCallbackMethod_triggerAsyncTonemap<WithCallbackMethod_setSharedSurfaceOutputType<WithCallbackMethod_getSharedSurfaceOutputType<WithCallbackMethod_getRealTime<WithCallbackMethod_pauseRendering<WithCallbackMethod_continueRendering<WithCallbackMethod_isRenderingPaused<WithCallbackMethod_restartRendering<WithCallbackMethod_stopRendering<WithCallbackMethod_pick<WithCallbackMethod_pickWhitePoint<WithCallbackMethod_pickImagerWhitePoint<WithCallbackMethod_isOutputAovWhitePointPickable<WithCallbackMethod_pickOutputAovWhitePoint<WithCallbackMethod_pickCryptomatteMatte<WithCallbackMethod_modifyCryptomatteMatteSelection<WithCallbackMethod_toString<WithCallbackMethod_getDevicePciIds<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_setRenderTargetNode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_setRenderTargetNode() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_setRenderTargetNode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setRenderTargetNode(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setRenderTargetNodeRequest* /*request*/, ::octaneapi::ApiRenderEngine_setRenderTargetNodeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_getRenderTargetNode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_getRenderTargetNode() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_getRenderTargetNode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getRenderTargetNode(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getRenderTargetNodeRequest* /*request*/, ::octaneapi::ApiRenderEngine_getRenderTargetNodeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_getRenderGeometryNode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_getRenderGeometryNode() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_getRenderGeometryNode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getRenderGeometryNode(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getRenderGeometryNodeRequest* /*request*/, ::octaneapi::ApiRenderEngine_getRenderGeometryNodeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_getRenderCameraNode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_getRenderCameraNode() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_getRenderCameraNode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getRenderCameraNode(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getRenderCameraNodeRequest* /*request*/, ::octaneapi::ApiRenderEngine_getRenderCameraNodeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_setRenderRegion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_setRenderRegion() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_setRenderRegion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setRenderRegion(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setRenderRegionRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_getRenderRegion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_getRenderRegion() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_getRenderRegion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getRenderRegion(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getRenderRegionRequest* /*request*/, ::octaneapi::ApiRenderEngine_getRenderRegionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_setAsyncTonemapParams : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_setAsyncTonemapParams() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_setAsyncTonemapParams() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setAsyncTonemapParams(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setAsyncTonemapParamsRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_setAsyncTonemapParams1 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_setAsyncTonemapParams1() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_setAsyncTonemapParams1() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setAsyncTonemapParams1(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setAsyncTonemapParams1Request* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_asyncTonemapBufferType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_asyncTonemapBufferType() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_asyncTonemapBufferType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status asyncTonemapBufferType(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_asyncTonemapBufferTypeRequest* /*request*/, ::octaneapi::ApiRenderEngine_asyncTonemapBufferTypeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_asyncTonemapCryptomatteFalseColor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_asyncTonemapCryptomatteFalseColor() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_asyncTonemapCryptomatteFalseColor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status asyncTonemapCryptomatteFalseColor(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_asyncTonemapCryptomatteFalseColorRequest* /*request*/, ::octaneapi::ApiRenderEngine_asyncTonemapCryptomatteFalseColorResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_asyncTonemapOutputColorSpaceInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_asyncTonemapOutputColorSpaceInfo() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_asyncTonemapOutputColorSpaceInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status asyncTonemapOutputColorSpaceInfo(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_asyncTonemapOutputColorSpaceInfoRequest* /*request*/, ::octaneapi::ApiRenderEngine_asyncTonemapOutputColorSpaceInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_asyncTonemapColorSpace : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_asyncTonemapColorSpace() {
      ::grpc::Service::MarkMethodGeneric(11);
    }
    ~WithGenericMethod_asyncTonemapColorSpace() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status asyncTonemapColorSpace(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_asyncTonemapColorSpaceRequest* /*request*/, ::octaneapi::ApiRenderEngine_asyncTonemapColorSpaceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_asyncTonemapPremultipliedAlphaType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_asyncTonemapPremultipliedAlphaType() {
      ::grpc::Service::MarkMethodGeneric(12);
    }
    ~WithGenericMethod_asyncTonemapPremultipliedAlphaType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status asyncTonemapPremultipliedAlphaType(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_asyncTonemapPremultipliedAlphaTypeRequest* /*request*/, ::octaneapi::ApiRenderEngine_asyncTonemapPremultipliedAlphaTypeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_setAsyncTonemapRenderPasses : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_setAsyncTonemapRenderPasses() {
      ::grpc::Service::MarkMethodGeneric(13);
    }
    ~WithGenericMethod_setAsyncTonemapRenderPasses() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setAsyncTonemapRenderPasses(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setAsyncTonemapRenderPassesRequest* /*request*/, ::octaneapi::ApiRenderEngine_setAsyncTonemapRenderPassesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_asyncTonemapRenderPasses : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_asyncTonemapRenderPasses() {
      ::grpc::Service::MarkMethodGeneric(14);
    }
    ~WithGenericMethod_asyncTonemapRenderPasses() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status asyncTonemapRenderPasses(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_asyncTonemapRenderPassesRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_getEnabledAovs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_getEnabledAovs() {
      ::grpc::Service::MarkMethodGeneric(15);
    }
    ~WithGenericMethod_getEnabledAovs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getEnabledAovs(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getEnabledAovsRequest* /*request*/, ::octaneapi::ApiRenderEngine_getEnabledAovsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_freeTonemapPasses : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_freeTonemapPasses() {
      ::grpc::Service::MarkMethodGeneric(16);
    }
    ~WithGenericMethod_freeTonemapPasses() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status freeTonemapPasses(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_freeTonemapPassesRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_displayRenderPassId : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_displayRenderPassId() {
      ::grpc::Service::MarkMethodGeneric(17);
    }
    ~WithGenericMethod_displayRenderPassId() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status displayRenderPassId(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_displayRenderPassIdRequest* /*request*/, ::octaneapi::ApiRenderEngine_displayRenderPassIdResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_setSubSampleMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_setSubSampleMode() {
      ::grpc::Service::MarkMethodGeneric(18);
    }
    ~WithGenericMethod_setSubSampleMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setSubSampleMode(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setSubSampleModeRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_getSubSampleMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_getSubSampleMode() {
      ::grpc::Service::MarkMethodGeneric(19);
    }
    ~WithGenericMethod_getSubSampleMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getSubSampleMode(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getSubSampleModeRequest* /*request*/, ::octaneapi::ApiRenderEngine_getSubSampleModeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_setClayMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_setClayMode() {
      ::grpc::Service::MarkMethodGeneric(20);
    }
    ~WithGenericMethod_setClayMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setClayMode(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setClayModeRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_clayMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_clayMode() {
      ::grpc::Service::MarkMethodGeneric(21);
    }
    ~WithGenericMethod_clayMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status clayMode(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_clayModeRequest* /*request*/, ::octaneapi::ApiRenderEngine_clayModeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_fps : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_fps() {
      ::grpc::Service::MarkMethodGeneric(22);
    }
    ~WithGenericMethod_fps() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status fps(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_fpsRequest* /*request*/, ::octaneapi::ApiRenderEngine_fpsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_setFps : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_setFps() {
      ::grpc::Service::MarkMethodGeneric(23);
    }
    ~WithGenericMethod_setFps() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setFps(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setFpsRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_isCompiling : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_isCompiling() {
      ::grpc::Service::MarkMethodGeneric(24);
    }
    ~WithGenericMethod_isCompiling() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isCompiling(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_isCompilingRequest* /*request*/, ::octaneapi::ApiRenderEngine_isCompilingResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_isCompressingTextures : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_isCompressingTextures() {
      ::grpc::Service::MarkMethodGeneric(25);
    }
    ~WithGenericMethod_isCompressingTextures() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isCompressingTextures(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_isCompressingTexturesRequest* /*request*/, ::octaneapi::ApiRenderEngine_isCompressingTexturesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_hasPendingRenderData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_hasPendingRenderData() {
      ::grpc::Service::MarkMethodGeneric(26);
    }
    ~WithGenericMethod_hasPendingRenderData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status hasPendingRenderData(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_hasPendingRenderDataRequest* /*request*/, ::octaneapi::ApiRenderEngine_hasPendingRenderDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_getCurrentChangeLevel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_getCurrentChangeLevel() {
      ::grpc::Service::MarkMethodGeneric(27);
    }
    ~WithGenericMethod_getCurrentChangeLevel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getCurrentChangeLevel(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getCurrentChangeLevelRequest* /*request*/, ::octaneapi::ApiRenderEngine_getCurrentChangeLevelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_getRenderImageChangeLevel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_getRenderImageChangeLevel() {
      ::grpc::Service::MarkMethodGeneric(28);
    }
    ~WithGenericMethod_getRenderImageChangeLevel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getRenderImageChangeLevel(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getRenderImageChangeLevelRequest* /*request*/, ::octaneapi::ApiRenderEngine_getRenderImageChangeLevelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_getRenderRestartedChangeLevel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_getRenderRestartedChangeLevel() {
      ::grpc::Service::MarkMethodGeneric(29);
    }
    ~WithGenericMethod_getRenderRestartedChangeLevel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getRenderRestartedChangeLevel(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getRenderRestartedChangeLevelRequest* /*request*/, ::octaneapi::ApiRenderEngine_getRenderRestartedChangeLevelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_setAsyncUpdateCallback : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_setAsyncUpdateCallback() {
      ::grpc::Service::MarkMethodGeneric(30);
    }
    ~WithGenericMethod_setAsyncUpdateCallback() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setAsyncUpdateCallback(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setAsyncUpdateCallbackRequest* /*request*/, ::octaneapi::ApiRenderEngine_setAsyncUpdateCallbackResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_updatesAreAsync : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_updatesAreAsync() {
      ::grpc::Service::MarkMethodGeneric(31);
    }
    ~WithGenericMethod_updatesAreAsync() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status updatesAreAsync(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_updatesAreAsyncRequest* /*request*/, ::octaneapi::ApiRenderEngine_updatesAreAsyncResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_isImageReady : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_isImageReady() {
      ::grpc::Service::MarkMethodGeneric(32);
    }
    ~WithGenericMethod_isImageReady() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isImageReady(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_isImageReadyRequest* /*request*/, ::octaneapi::ApiRenderEngine_isImageReadyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_resetImageReady : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_resetImageReady() {
      ::grpc::Service::MarkMethodGeneric(33);
    }
    ~WithGenericMethod_resetImageReady() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status resetImageReady(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_resetImageReadyRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_isRenderFailure : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_isRenderFailure() {
      ::grpc::Service::MarkMethodGeneric(34);
    }
    ~WithGenericMethod_isRenderFailure() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isRenderFailure(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_isRenderFailureRequest* /*request*/, ::octaneapi::ApiRenderEngine_isRenderFailureResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_resetRenderFailure : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_resetRenderFailure() {
      ::grpc::Service::MarkMethodGeneric(35);
    }
    ~WithGenericMethod_resetRenderFailure() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status resetRenderFailure(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_resetRenderFailureRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_setOnTileBlendedCallback : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_setOnTileBlendedCallback() {
      ::grpc::Service::MarkMethodGeneric(36);
    }
    ~WithGenericMethod_setOnTileBlendedCallback() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setOnTileBlendedCallback(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setOnTileBlendedCallbackRequest* /*request*/, ::octaneapi::ApiRenderEngine_setOnTileBlendedCallbackResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_setOnNewStatisticsCallback : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_setOnNewStatisticsCallback() {
      ::grpc::Service::MarkMethodGeneric(37);
    }
    ~WithGenericMethod_setOnNewStatisticsCallback() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setOnNewStatisticsCallback(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setOnNewStatisticsCallbackRequest* /*request*/, ::octaneapi::ApiRenderEngine_setOnNewStatisticsCallbackResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_setOnNewImageCallback : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_setOnNewImageCallback() {
      ::grpc::Service::MarkMethodGeneric(38);
    }
    ~WithGenericMethod_setOnNewImageCallback() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setOnNewImageCallback(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setOnNewImageCallbackRequest* /*request*/, ::octaneapi::ApiRenderEngine_setOnNewImageCallbackResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_setOnOcioErrorCallback : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_setOnOcioErrorCallback() {
      ::grpc::Service::MarkMethodGeneric(39);
    }
    ~WithGenericMethod_setOnOcioErrorCallback() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setOnOcioErrorCallback(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setOnOcioErrorCallbackRequest* /*request*/, ::octaneapi::ApiRenderEngine_setOnOcioErrorCallbackResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_setOnRenderFailureCallback : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_setOnRenderFailureCallback() {
      ::grpc::Service::MarkMethodGeneric(40);
    }
    ~WithGenericMethod_setOnRenderFailureCallback() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setOnRenderFailureCallback(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setOnRenderFailureCallbackRequest* /*request*/, ::octaneapi::ApiRenderEngine_setOnRenderFailureCallbackResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_setForceCallbacksInRenderThreads : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_setForceCallbacksInRenderThreads() {
      ::grpc::Service::MarkMethodGeneric(41);
    }
    ~WithGenericMethod_setForceCallbacksInRenderThreads() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setForceCallbacksInRenderThreads(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setForceCallbacksInRenderThreadsRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_grabRenderResult : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_grabRenderResult() {
      ::grpc::Service::MarkMethodGeneric(42);
    }
    ~WithGenericMethod_grabRenderResult() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status grabRenderResult(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_grabRenderResultRequest* /*request*/, ::octaneapi::ApiRenderEngine_grabRenderResultResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_releaseRenderResult : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_releaseRenderResult() {
      ::grpc::Service::MarkMethodGeneric(43);
    }
    ~WithGenericMethod_releaseRenderResult() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status releaseRenderResult(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_releaseRenderResultRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_synchronousTonemap : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_synchronousTonemap() {
      ::grpc::Service::MarkMethodGeneric(44);
    }
    ~WithGenericMethod_synchronousTonemap() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status synchronousTonemap(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_synchronousTonemapRequest* /*request*/, ::octaneapi::ApiRenderEngine_synchronousTonemapResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_synchronousTonemap1 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_synchronousTonemap1() {
      ::grpc::Service::MarkMethodGeneric(45);
    }
    ~WithGenericMethod_synchronousTonemap1() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status synchronousTonemap1(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_synchronousTonemap1Request* /*request*/, ::octaneapi::ApiRenderEngine_synchronousTonemap1Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_synchronousTonemapAllRenderPasses : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_synchronousTonemapAllRenderPasses() {
      ::grpc::Service::MarkMethodGeneric(46);
    }
    ~WithGenericMethod_synchronousTonemapAllRenderPasses() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status synchronousTonemapAllRenderPasses(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPassesRequest* /*request*/, ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPassesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_synchronousTonemapAllRenderPasses1 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_synchronousTonemapAllRenderPasses1() {
      ::grpc::Service::MarkMethodGeneric(47);
    }
    ~WithGenericMethod_synchronousTonemapAllRenderPasses1() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status synchronousTonemapAllRenderPasses1(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPasses1Request* /*request*/, ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPasses1Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_getRenderStatistics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_getRenderStatistics() {
      ::grpc::Service::MarkMethodGeneric(48);
    }
    ~WithGenericMethod_getRenderStatistics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getRenderStatistics(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getRenderStatisticsRequest* /*request*/, ::octaneapi::ApiRenderEngine_getRenderStatisticsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_getRenderResultStatistics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_getRenderResultStatistics() {
      ::grpc::Service::MarkMethodGeneric(49);
    }
    ~WithGenericMethod_getRenderResultStatistics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getRenderResultStatistics(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getRenderResultStatisticsRequest* /*request*/, ::octaneapi::ApiRenderEngine_getRenderResultStatisticsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_saveImage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_saveImage() {
      ::grpc::Service::MarkMethodGeneric(50);
    }
    ~WithGenericMethod_saveImage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status saveImage(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_saveImageRequest* /*request*/, ::octaneapi::ApiRenderEngine_saveImageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_saveImage1 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_saveImage1() {
      ::grpc::Service::MarkMethodGeneric(51);
    }
    ~WithGenericMethod_saveImage1() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status saveImage1(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_saveImage1Request* /*request*/, ::octaneapi::ApiRenderEngine_saveImage1Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_saveImage2 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_saveImage2() {
      ::grpc::Service::MarkMethodGeneric(52);
    }
    ~WithGenericMethod_saveImage2() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status saveImage2(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_saveImage2Request* /*request*/, ::octaneapi::ApiRenderEngine_saveImage2Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_saveRenderPasses : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_saveRenderPasses() {
      ::grpc::Service::MarkMethodGeneric(53);
    }
    ~WithGenericMethod_saveRenderPasses() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status saveRenderPasses(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_saveRenderPassesRequest* /*request*/, ::octaneapi::ApiRenderEngine_saveRenderPassesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_saveRenderPasses1 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_saveRenderPasses1() {
      ::grpc::Service::MarkMethodGeneric(54);
    }
    ~WithGenericMethod_saveRenderPasses1() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status saveRenderPasses1(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_saveRenderPasses1Request* /*request*/, ::octaneapi::ApiRenderEngine_saveRenderPasses1Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_saveRenderPasses2 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_saveRenderPasses2() {
      ::grpc::Service::MarkMethodGeneric(55);
    }
    ~WithGenericMethod_saveRenderPasses2() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status saveRenderPasses2(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_saveRenderPasses2Request* /*request*/, ::octaneapi::ApiRenderEngine_saveRenderPasses2Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_saveRenderPassesMultiExr : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_saveRenderPassesMultiExr() {
      ::grpc::Service::MarkMethodGeneric(56);
    }
    ~WithGenericMethod_saveRenderPassesMultiExr() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status saveRenderPassesMultiExr(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExrRequest* /*request*/, ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExrResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_saveRenderPassesMultiExr1 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_saveRenderPassesMultiExr1() {
      ::grpc::Service::MarkMethodGeneric(57);
    }
    ~WithGenericMethod_saveRenderPassesMultiExr1() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status saveRenderPassesMultiExr1(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExr1Request* /*request*/, ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExr1Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_saveRenderPassesDeepExr : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_saveRenderPassesDeepExr() {
      ::grpc::Service::MarkMethodGeneric(58);
    }
    ~WithGenericMethod_saveRenderPassesDeepExr() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status saveRenderPassesDeepExr(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_saveRenderPassesDeepExrRequest* /*request*/, ::octaneapi::ApiRenderEngine_saveRenderPassesDeepExrResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_deepImageEnabled : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_deepImageEnabled() {
      ::grpc::Service::MarkMethodGeneric(59);
    }
    ~WithGenericMethod_deepImageEnabled() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status deepImageEnabled(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_deepImageEnabledRequest* /*request*/, ::octaneapi::ApiRenderEngine_deepImageEnabledResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_deepImageEnabled1 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_deepImageEnabled1() {
      ::grpc::Service::MarkMethodGeneric(60);
    }
    ~WithGenericMethod_deepImageEnabled1() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status deepImageEnabled1(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_deepImageEnabled1Request* /*request*/, ::octaneapi::ApiRenderEngine_deepImageEnabled1Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_deepPassesEnabled : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_deepPassesEnabled() {
      ::grpc::Service::MarkMethodGeneric(61);
    }
    ~WithGenericMethod_deepPassesEnabled() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status deepPassesEnabled(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_deepPassesEnabledRequest* /*request*/, ::octaneapi::ApiRenderEngine_deepPassesEnabledResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_canSaveDeepImage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_canSaveDeepImage() {
      ::grpc::Service::MarkMethodGeneric(62);
    }
    ~WithGenericMethod_canSaveDeepImage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status canSaveDeepImage(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_canSaveDeepImageRequest* /*request*/, ::octaneapi::ApiRenderEngine_canSaveDeepImageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_saveDeepImage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_saveDeepImage() {
      ::grpc::Service::MarkMethodGeneric(63);
    }
    ~WithGenericMethod_saveDeepImage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status saveDeepImage(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_saveDeepImageRequest* /*request*/, ::octaneapi::ApiRenderEngine_saveDeepImageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_saveRenderState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_saveRenderState() {
      ::grpc::Service::MarkMethodGeneric(64);
    }
    ~WithGenericMethod_saveRenderState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status saveRenderState(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_saveRenderStateRequest* /*request*/, ::octaneapi::ApiRenderEngine_saveRenderStateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_loadRenderState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_loadRenderState() {
      ::grpc::Service::MarkMethodGeneric(65);
    }
    ~WithGenericMethod_loadRenderState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status loadRenderState(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_loadRenderStateRequest* /*request*/, ::octaneapi::ApiRenderEngine_loadRenderStateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_previewMaterial : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_previewMaterial() {
      ::grpc::Service::MarkMethodGeneric(66);
    }
    ~WithGenericMethod_previewMaterial() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status previewMaterial(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_previewMaterialRequest* /*request*/, ::octaneapi::ApiRenderEngine_previewMaterialResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_previewMaterialHdr : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_previewMaterialHdr() {
      ::grpc::Service::MarkMethodGeneric(67);
    }
    ~WithGenericMethod_previewMaterialHdr() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status previewMaterialHdr(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_previewMaterialHdrRequest* /*request*/, ::octaneapi::ApiRenderEngine_previewMaterialHdrResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_previewMaterial1 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_previewMaterial1() {
      ::grpc::Service::MarkMethodGeneric(68);
    }
    ~WithGenericMethod_previewMaterial1() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status previewMaterial1(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_previewMaterial1Request* /*request*/, ::octaneapi::ApiRenderEngine_previewMaterial1Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_getMemoryUsage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_getMemoryUsage() {
      ::grpc::Service::MarkMethodGeneric(69);
    }
    ~WithGenericMethod_getMemoryUsage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getMemoryUsage(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getMemoryUsageRequest* /*request*/, ::octaneapi::ApiRenderEngine_getMemoryUsageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_getResourceStatistics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_getResourceStatistics() {
      ::grpc::Service::MarkMethodGeneric(70);
    }
    ~WithGenericMethod_getResourceStatistics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getResourceStatistics(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getResourceStatisticsRequest* /*request*/, ::octaneapi::ApiRenderEngine_getResourceStatisticsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_getGeometryStatistics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_getGeometryStatistics() {
      ::grpc::Service::MarkMethodGeneric(71);
    }
    ~WithGenericMethod_getGeometryStatistics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getGeometryStatistics(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getGeometryStatisticsRequest* /*request*/, ::octaneapi::ApiRenderEngine_getGeometryStatisticsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_getTexturesStatistics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_getTexturesStatistics() {
      ::grpc::Service::MarkMethodGeneric(72);
    }
    ~WithGenericMethod_getTexturesStatistics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getTexturesStatistics(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getTexturesStatisticsRequest* /*request*/, ::octaneapi::ApiRenderEngine_getTexturesStatisticsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_getSceneBounds : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_getSceneBounds() {
      ::grpc::Service::MarkMethodGeneric(73);
    }
    ~WithGenericMethod_getSceneBounds() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getSceneBounds(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getSceneBoundsRequest* /*request*/, ::octaneapi::ApiRenderEngine_getSceneBoundsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_getDeviceCount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_getDeviceCount() {
      ::grpc::Service::MarkMethodGeneric(74);
    }
    ~WithGenericMethod_getDeviceCount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getDeviceCount(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getDeviceCountRequest* /*request*/, ::octaneapi::ApiRenderEngine_getDeviceCountResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_getDeviceComputeModel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_getDeviceComputeModel() {
      ::grpc::Service::MarkMethodGeneric(75);
    }
    ~WithGenericMethod_getDeviceComputeModel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getDeviceComputeModel(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getDeviceComputeModelRequest* /*request*/, ::octaneapi::ApiRenderEngine_getDeviceComputeModelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_getDeviceName : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_getDeviceName() {
      ::grpc::Service::MarkMethodGeneric(76);
    }
    ~WithGenericMethod_getDeviceName() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getDeviceName(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getDeviceNameRequest* /*request*/, ::octaneapi::ApiRenderEngine_getDeviceNameResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_isSupportedDevice : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_isSupportedDevice() {
      ::grpc::Service::MarkMethodGeneric(77);
    }
    ~WithGenericMethod_isSupportedDevice() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isSupportedDevice(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_isSupportedDeviceRequest* /*request*/, ::octaneapi::ApiRenderEngine_isSupportedDeviceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_deviceCanRender : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_deviceCanRender() {
      ::grpc::Service::MarkMethodGeneric(78);
    }
    ~WithGenericMethod_deviceCanRender() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status deviceCanRender(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_deviceCanRenderRequest* /*request*/, ::octaneapi::ApiRenderEngine_deviceCanRenderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_deviceCanDenoise : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_deviceCanDenoise() {
      ::grpc::Service::MarkMethodGeneric(79);
    }
    ~WithGenericMethod_deviceCanDenoise() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status deviceCanDenoise(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_deviceCanDenoiseRequest* /*request*/, ::octaneapi::ApiRenderEngine_deviceCanDenoiseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_deviceSupportsHardwareRayTracing : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_deviceSupportsHardwareRayTracing() {
      ::grpc::Service::MarkMethodGeneric(80);
    }
    ~WithGenericMethod_deviceSupportsHardwareRayTracing() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status deviceSupportsHardwareRayTracing(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_deviceSupportsHardwareRayTracingRequest* /*request*/, ::octaneapi::ApiRenderEngine_deviceSupportsHardwareRayTracingResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_deviceSharedSurfaceInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_deviceSharedSurfaceInfo() {
      ::grpc::Service::MarkMethodGeneric(81);
    }
    ~WithGenericMethod_deviceSharedSurfaceInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status deviceSharedSurfaceInfo(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_deviceSharedSurfaceInfoRequest* /*request*/, ::octaneapi::ApiRenderEngine_deviceSharedSurfaceInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_getAvailablePeerToPeerPairs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_getAvailablePeerToPeerPairs() {
      ::grpc::Service::MarkMethodGeneric(82);
    }
    ~WithGenericMethod_getAvailablePeerToPeerPairs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getAvailablePeerToPeerPairs(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getAvailablePeerToPeerPairsRequest* /*request*/, ::octaneapi::ApiRenderEngine_getAvailablePeerToPeerPairsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_setDevicesActivity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_setDevicesActivity() {
      ::grpc::Service::MarkMethodGeneric(83);
    }
    ~WithGenericMethod_setDevicesActivity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setDevicesActivity(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setDevicesActivityRequest* /*request*/, ::octaneapi::ApiRenderEngine_setDevicesActivityResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_isDeviceUsedForRendering : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_isDeviceUsedForRendering() {
      ::grpc::Service::MarkMethodGeneric(84);
    }
    ~WithGenericMethod_isDeviceUsedForRendering() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isDeviceUsedForRendering(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_isDeviceUsedForRenderingRequest* /*request*/, ::octaneapi::ApiRenderEngine_isDeviceUsedForRenderingResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_deviceUsesPriority : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_deviceUsesPriority() {
      ::grpc::Service::MarkMethodGeneric(85);
    }
    ~WithGenericMethod_deviceUsesPriority() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status deviceUsesPriority(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_deviceUsesPriorityRequest* /*request*/, ::octaneapi::ApiRenderEngine_deviceUsesPriorityResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_deviceUsesHardwareRayTracing : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_deviceUsesHardwareRayTracing() {
      ::grpc::Service::MarkMethodGeneric(86);
    }
    ~WithGenericMethod_deviceUsesHardwareRayTracing() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status deviceUsesHardwareRayTracing(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_deviceUsesHardwareRayTracingRequest* /*request*/, ::octaneapi::ApiRenderEngine_deviceUsesHardwareRayTracingResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_imageDeviceIndex : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_imageDeviceIndex() {
      ::grpc::Service::MarkMethodGeneric(87);
    }
    ~WithGenericMethod_imageDeviceIndex() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status imageDeviceIndex(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_imageDeviceIndexRequest* /*request*/, ::octaneapi::ApiRenderEngine_imageDeviceIndexResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_isDeviceUsedForDenoising : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_isDeviceUsedForDenoising() {
      ::grpc::Service::MarkMethodGeneric(88);
    }
    ~WithGenericMethod_isDeviceUsedForDenoising() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isDeviceUsedForDenoising(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_isDeviceUsedForDenoisingRequest* /*request*/, ::octaneapi::ApiRenderEngine_isDeviceUsedForDenoisingResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_renderPriority : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_renderPriority() {
      ::grpc::Service::MarkMethodGeneric(89);
    }
    ~WithGenericMethod_renderPriority() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status renderPriority(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_renderPriorityRequest* /*request*/, ::octaneapi::ApiRenderEngine_renderPriorityResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_setRenderPriority : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_setRenderPriority() {
      ::grpc::Service::MarkMethodGeneric(90);
    }
    ~WithGenericMethod_setRenderPriority() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setRenderPriority(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setRenderPriorityRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_currentPeerToPeerGroups : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_currentPeerToPeerGroups() {
      ::grpc::Service::MarkMethodGeneric(91);
    }
    ~WithGenericMethod_currentPeerToPeerGroups() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status currentPeerToPeerGroups(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_currentPeerToPeerGroupsRequest* /*request*/, ::octaneapi::ApiRenderEngine_currentPeerToPeerGroupsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_hardwareRayTracingEnabled : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_hardwareRayTracingEnabled() {
      ::grpc::Service::MarkMethodGeneric(92);
    }
    ~WithGenericMethod_hardwareRayTracingEnabled() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status hardwareRayTracingEnabled(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_hardwareRayTracingEnabledRequest* /*request*/, ::octaneapi::ApiRenderEngine_hardwareRayTracingEnabledResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_openDeviceSettings : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_openDeviceSettings() {
      ::grpc::Service::MarkMethodGeneric(93);
    }
    ~WithGenericMethod_openDeviceSettings() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status openDeviceSettings(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_openDeviceSettingsRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_renderDeviceState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_renderDeviceState() {
      ::grpc::Service::MarkMethodGeneric(94);
    }
    ~WithGenericMethod_renderDeviceState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status renderDeviceState(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_renderDeviceStateRequest* /*request*/, ::octaneapi::ApiRenderEngine_renderDeviceStateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_renderDeviceErrorCode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_renderDeviceErrorCode() {
      ::grpc::Service::MarkMethodGeneric(95);
    }
    ~WithGenericMethod_renderDeviceErrorCode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status renderDeviceErrorCode(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_renderDeviceErrorCodeRequest* /*request*/, ::octaneapi::ApiRenderEngine_renderDeviceErrorCodeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_errorcodeToString : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_errorcodeToString() {
      ::grpc::Service::MarkMethodGeneric(96);
    }
    ~WithGenericMethod_errorcodeToString() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status errorcodeToString(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_errorcodeToStringRequest* /*request*/, ::octaneapi::ApiRenderEngine_errorcodeToStringResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_renderDeviceErrorMessage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_renderDeviceErrorMessage() {
      ::grpc::Service::MarkMethodGeneric(97);
    }
    ~WithGenericMethod_renderDeviceErrorMessage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status renderDeviceErrorMessage(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_renderDeviceErrorMessageRequest* /*request*/, ::octaneapi::ApiRenderEngine_renderDeviceErrorMessageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_saveRenderDeviceConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_saveRenderDeviceConfig() {
      ::grpc::Service::MarkMethodGeneric(98);
    }
    ~WithGenericMethod_saveRenderDeviceConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status saveRenderDeviceConfig(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_saveRenderDeviceConfigRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_outOfCoreEnabled : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_outOfCoreEnabled() {
      ::grpc::Service::MarkMethodGeneric(99);
    }
    ~WithGenericMethod_outOfCoreEnabled() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status outOfCoreEnabled(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_outOfCoreEnabledRequest* /*request*/, ::octaneapi::ApiRenderEngine_outOfCoreEnabledResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_enableOutOfCore : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_enableOutOfCore() {
      ::grpc::Service::MarkMethodGeneric(100);
    }
    ~WithGenericMethod_enableOutOfCore() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status enableOutOfCore(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_enableOutOfCoreRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_disableOutOfCore : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_disableOutOfCore() {
      ::grpc::Service::MarkMethodGeneric(101);
    }
    ~WithGenericMethod_disableOutOfCore() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status disableOutOfCore(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_disableOutOfCoreRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_getOutOfCoreMemoryUsage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_getOutOfCoreMemoryUsage() {
      ::grpc::Service::MarkMethodGeneric(102);
    }
    ~WithGenericMethod_getOutOfCoreMemoryUsage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getOutOfCoreMemoryUsage(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getOutOfCoreMemoryUsageRequest* /*request*/, ::octaneapi::ApiRenderEngine_getOutOfCoreMemoryUsageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_setGpuHeadroom : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_setGpuHeadroom() {
      ::grpc::Service::MarkMethodGeneric(103);
    }
    ~WithGenericMethod_setGpuHeadroom() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setGpuHeadroom(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setGpuHeadroomRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_getGpuHeadroom : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_getGpuHeadroom() {
      ::grpc::Service::MarkMethodGeneric(104);
    }
    ~WithGenericMethod_getGpuHeadroom() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getGpuHeadroom(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getGpuHeadroomRequest* /*request*/, ::octaneapi::ApiRenderEngine_getGpuHeadroomResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_setCoreLimit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_setCoreLimit() {
      ::grpc::Service::MarkMethodGeneric(105);
    }
    ~WithGenericMethod_setCoreLimit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setCoreLimit(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setCoreLimitRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_disableCoreLimit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_disableCoreLimit() {
      ::grpc::Service::MarkMethodGeneric(106);
    }
    ~WithGenericMethod_disableCoreLimit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status disableCoreLimit(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_disableCoreLimitRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_registerInputSharedSurface : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_registerInputSharedSurface() {
      ::grpc::Service::MarkMethodGeneric(107);
    }
    ~WithGenericMethod_registerInputSharedSurface() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status registerInputSharedSurface(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_registerInputSharedSurfaceRequest* /*request*/, ::octaneapi::ApiRenderEngine_registerInputSharedSurfaceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_unregisterInputSharedSurface : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_unregisterInputSharedSurface() {
      ::grpc::Service::MarkMethodGeneric(108);
    }
    ~WithGenericMethod_unregisterInputSharedSurface() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status unregisterInputSharedSurface(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_unregisterInputSharedSurfaceRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_triggerAsyncTonemap : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_triggerAsyncTonemap() {
      ::grpc::Service::MarkMethodGeneric(109);
    }
    ~WithGenericMethod_triggerAsyncTonemap() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status triggerAsyncTonemap(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_triggerAsyncTonemapRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_setSharedSurfaceOutputType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_setSharedSurfaceOutputType() {
      ::grpc::Service::MarkMethodGeneric(110);
    }
    ~WithGenericMethod_setSharedSurfaceOutputType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setSharedSurfaceOutputType(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setSharedSurfaceOutputTypeRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_getSharedSurfaceOutputType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_getSharedSurfaceOutputType() {
      ::grpc::Service::MarkMethodGeneric(111);
    }
    ~WithGenericMethod_getSharedSurfaceOutputType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getSharedSurfaceOutputType(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getSharedSurfaceOutputTypeRequest* /*request*/, ::octaneapi::ApiRenderEngine_getSharedSurfaceOutputTypeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_getRealTime : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_getRealTime() {
      ::grpc::Service::MarkMethodGeneric(112);
    }
    ~WithGenericMethod_getRealTime() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getRealTime(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getRealTimeRequest* /*request*/, ::octaneapi::ApiRenderEngine_getRealTimeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_pauseRendering : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_pauseRendering() {
      ::grpc::Service::MarkMethodGeneric(113);
    }
    ~WithGenericMethod_pauseRendering() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status pauseRendering(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_pauseRenderingRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_continueRendering : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_continueRendering() {
      ::grpc::Service::MarkMethodGeneric(114);
    }
    ~WithGenericMethod_continueRendering() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status continueRendering(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_continueRenderingRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_isRenderingPaused : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_isRenderingPaused() {
      ::grpc::Service::MarkMethodGeneric(115);
    }
    ~WithGenericMethod_isRenderingPaused() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isRenderingPaused(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_isRenderingPausedRequest* /*request*/, ::octaneapi::ApiRenderEngine_isRenderingPausedResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_restartRendering : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_restartRendering() {
      ::grpc::Service::MarkMethodGeneric(116);
    }
    ~WithGenericMethod_restartRendering() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status restartRendering(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_restartRenderingRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_stopRendering : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_stopRendering() {
      ::grpc::Service::MarkMethodGeneric(117);
    }
    ~WithGenericMethod_stopRendering() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status stopRendering(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_stopRenderingRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_pick : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_pick() {
      ::grpc::Service::MarkMethodGeneric(118);
    }
    ~WithGenericMethod_pick() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status pick(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_pickRequest* /*request*/, ::octaneapi::ApiRenderEngine_pickResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_pickWhitePoint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_pickWhitePoint() {
      ::grpc::Service::MarkMethodGeneric(119);
    }
    ~WithGenericMethod_pickWhitePoint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status pickWhitePoint(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_pickWhitePointRequest* /*request*/, ::octaneapi::ApiRenderEngine_pickWhitePointResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_pickImagerWhitePoint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_pickImagerWhitePoint() {
      ::grpc::Service::MarkMethodGeneric(120);
    }
    ~WithGenericMethod_pickImagerWhitePoint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status pickImagerWhitePoint(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_pickImagerWhitePointRequest* /*request*/, ::octaneapi::ApiRenderEngine_pickImagerWhitePointResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_isOutputAovWhitePointPickable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_isOutputAovWhitePointPickable() {
      ::grpc::Service::MarkMethodGeneric(121);
    }
    ~WithGenericMethod_isOutputAovWhitePointPickable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isOutputAovWhitePointPickable(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_isOutputAovWhitePointPickableRequest* /*request*/, ::octaneapi::ApiRenderEngine_isOutputAovWhitePointPickableResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_pickOutputAovWhitePoint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_pickOutputAovWhitePoint() {
      ::grpc::Service::MarkMethodGeneric(122);
    }
    ~WithGenericMethod_pickOutputAovWhitePoint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status pickOutputAovWhitePoint(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_pickOutputAovWhitePointRequest* /*request*/, ::octaneapi::ApiRenderEngine_pickOutputAovWhitePointResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_pickCryptomatteMatte : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_pickCryptomatteMatte() {
      ::grpc::Service::MarkMethodGeneric(123);
    }
    ~WithGenericMethod_pickCryptomatteMatte() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status pickCryptomatteMatte(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_pickCryptomatteMatteRequest* /*request*/, ::octaneapi::ApiRenderEngine_pickCryptomatteMatteResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_modifyCryptomatteMatteSelection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_modifyCryptomatteMatteSelection() {
      ::grpc::Service::MarkMethodGeneric(124);
    }
    ~WithGenericMethod_modifyCryptomatteMatteSelection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status modifyCryptomatteMatteSelection(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_modifyCryptomatteMatteSelectionRequest* /*request*/, ::octaneapi::ApiRenderEngine_modifyCryptomatteMatteSelectionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_toString : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_toString() {
      ::grpc::Service::MarkMethodGeneric(125);
    }
    ~WithGenericMethod_toString() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status toString(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_toStringRequest* /*request*/, ::octaneapi::ApiRenderEngine_toStringResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_getDevicePciIds : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_getDevicePciIds() {
      ::grpc::Service::MarkMethodGeneric(126);
    }
    ~WithGenericMethod_getDevicePciIds() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getDevicePciIds(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getDevicePciIdsRequest* /*request*/, ::octaneapi::ApiRenderEngine_getDevicePciIdsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_setRenderTargetNode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_setRenderTargetNode() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_setRenderTargetNode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setRenderTargetNode(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setRenderTargetNodeRequest* /*request*/, ::octaneapi::ApiRenderEngine_setRenderTargetNodeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsetRenderTargetNode(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_getRenderTargetNode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_getRenderTargetNode() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_getRenderTargetNode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getRenderTargetNode(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getRenderTargetNodeRequest* /*request*/, ::octaneapi::ApiRenderEngine_getRenderTargetNodeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetRenderTargetNode(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_getRenderGeometryNode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_getRenderGeometryNode() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_getRenderGeometryNode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getRenderGeometryNode(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getRenderGeometryNodeRequest* /*request*/, ::octaneapi::ApiRenderEngine_getRenderGeometryNodeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetRenderGeometryNode(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_getRenderCameraNode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_getRenderCameraNode() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_getRenderCameraNode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getRenderCameraNode(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getRenderCameraNodeRequest* /*request*/, ::octaneapi::ApiRenderEngine_getRenderCameraNodeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetRenderCameraNode(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_setRenderRegion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_setRenderRegion() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_setRenderRegion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setRenderRegion(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setRenderRegionRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsetRenderRegion(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_getRenderRegion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_getRenderRegion() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_getRenderRegion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getRenderRegion(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getRenderRegionRequest* /*request*/, ::octaneapi::ApiRenderEngine_getRenderRegionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetRenderRegion(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_setAsyncTonemapParams : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_setAsyncTonemapParams() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_setAsyncTonemapParams() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setAsyncTonemapParams(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setAsyncTonemapParamsRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsetAsyncTonemapParams(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_setAsyncTonemapParams1 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_setAsyncTonemapParams1() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_setAsyncTonemapParams1() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setAsyncTonemapParams1(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setAsyncTonemapParams1Request* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsetAsyncTonemapParams1(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_asyncTonemapBufferType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_asyncTonemapBufferType() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_asyncTonemapBufferType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status asyncTonemapBufferType(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_asyncTonemapBufferTypeRequest* /*request*/, ::octaneapi::ApiRenderEngine_asyncTonemapBufferTypeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestasyncTonemapBufferType(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_asyncTonemapCryptomatteFalseColor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_asyncTonemapCryptomatteFalseColor() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_asyncTonemapCryptomatteFalseColor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status asyncTonemapCryptomatteFalseColor(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_asyncTonemapCryptomatteFalseColorRequest* /*request*/, ::octaneapi::ApiRenderEngine_asyncTonemapCryptomatteFalseColorResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestasyncTonemapCryptomatteFalseColor(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_asyncTonemapOutputColorSpaceInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_asyncTonemapOutputColorSpaceInfo() {
      ::grpc::Service::MarkMethodRaw(10);
    }
    ~WithRawMethod_asyncTonemapOutputColorSpaceInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status asyncTonemapOutputColorSpaceInfo(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_asyncTonemapOutputColorSpaceInfoRequest* /*request*/, ::octaneapi::ApiRenderEngine_asyncTonemapOutputColorSpaceInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestasyncTonemapOutputColorSpaceInfo(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_asyncTonemapColorSpace : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_asyncTonemapColorSpace() {
      ::grpc::Service::MarkMethodRaw(11);
    }
    ~WithRawMethod_asyncTonemapColorSpace() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status asyncTonemapColorSpace(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_asyncTonemapColorSpaceRequest* /*request*/, ::octaneapi::ApiRenderEngine_asyncTonemapColorSpaceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestasyncTonemapColorSpace(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_asyncTonemapPremultipliedAlphaType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_asyncTonemapPremultipliedAlphaType() {
      ::grpc::Service::MarkMethodRaw(12);
    }
    ~WithRawMethod_asyncTonemapPremultipliedAlphaType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status asyncTonemapPremultipliedAlphaType(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_asyncTonemapPremultipliedAlphaTypeRequest* /*request*/, ::octaneapi::ApiRenderEngine_asyncTonemapPremultipliedAlphaTypeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestasyncTonemapPremultipliedAlphaType(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_setAsyncTonemapRenderPasses : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_setAsyncTonemapRenderPasses() {
      ::grpc::Service::MarkMethodRaw(13);
    }
    ~WithRawMethod_setAsyncTonemapRenderPasses() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setAsyncTonemapRenderPasses(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setAsyncTonemapRenderPassesRequest* /*request*/, ::octaneapi::ApiRenderEngine_setAsyncTonemapRenderPassesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsetAsyncTonemapRenderPasses(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_asyncTonemapRenderPasses : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_asyncTonemapRenderPasses() {
      ::grpc::Service::MarkMethodRaw(14);
    }
    ~WithRawMethod_asyncTonemapRenderPasses() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status asyncTonemapRenderPasses(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_asyncTonemapRenderPassesRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestasyncTonemapRenderPasses(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_getEnabledAovs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_getEnabledAovs() {
      ::grpc::Service::MarkMethodRaw(15);
    }
    ~WithRawMethod_getEnabledAovs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getEnabledAovs(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getEnabledAovsRequest* /*request*/, ::octaneapi::ApiRenderEngine_getEnabledAovsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetEnabledAovs(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_freeTonemapPasses : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_freeTonemapPasses() {
      ::grpc::Service::MarkMethodRaw(16);
    }
    ~WithRawMethod_freeTonemapPasses() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status freeTonemapPasses(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_freeTonemapPassesRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestfreeTonemapPasses(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_displayRenderPassId : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_displayRenderPassId() {
      ::grpc::Service::MarkMethodRaw(17);
    }
    ~WithRawMethod_displayRenderPassId() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status displayRenderPassId(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_displayRenderPassIdRequest* /*request*/, ::octaneapi::ApiRenderEngine_displayRenderPassIdResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestdisplayRenderPassId(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_setSubSampleMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_setSubSampleMode() {
      ::grpc::Service::MarkMethodRaw(18);
    }
    ~WithRawMethod_setSubSampleMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setSubSampleMode(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setSubSampleModeRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsetSubSampleMode(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_getSubSampleMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_getSubSampleMode() {
      ::grpc::Service::MarkMethodRaw(19);
    }
    ~WithRawMethod_getSubSampleMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getSubSampleMode(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getSubSampleModeRequest* /*request*/, ::octaneapi::ApiRenderEngine_getSubSampleModeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetSubSampleMode(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(19, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_setClayMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_setClayMode() {
      ::grpc::Service::MarkMethodRaw(20);
    }
    ~WithRawMethod_setClayMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setClayMode(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setClayModeRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsetClayMode(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(20, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_clayMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_clayMode() {
      ::grpc::Service::MarkMethodRaw(21);
    }
    ~WithRawMethod_clayMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status clayMode(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_clayModeRequest* /*request*/, ::octaneapi::ApiRenderEngine_clayModeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestclayMode(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(21, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_fps : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_fps() {
      ::grpc::Service::MarkMethodRaw(22);
    }
    ~WithRawMethod_fps() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status fps(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_fpsRequest* /*request*/, ::octaneapi::ApiRenderEngine_fpsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestfps(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(22, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_setFps : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_setFps() {
      ::grpc::Service::MarkMethodRaw(23);
    }
    ~WithRawMethod_setFps() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setFps(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setFpsRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsetFps(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(23, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_isCompiling : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_isCompiling() {
      ::grpc::Service::MarkMethodRaw(24);
    }
    ~WithRawMethod_isCompiling() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isCompiling(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_isCompilingRequest* /*request*/, ::octaneapi::ApiRenderEngine_isCompilingResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestisCompiling(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(24, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_isCompressingTextures : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_isCompressingTextures() {
      ::grpc::Service::MarkMethodRaw(25);
    }
    ~WithRawMethod_isCompressingTextures() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isCompressingTextures(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_isCompressingTexturesRequest* /*request*/, ::octaneapi::ApiRenderEngine_isCompressingTexturesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestisCompressingTextures(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(25, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_hasPendingRenderData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_hasPendingRenderData() {
      ::grpc::Service::MarkMethodRaw(26);
    }
    ~WithRawMethod_hasPendingRenderData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status hasPendingRenderData(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_hasPendingRenderDataRequest* /*request*/, ::octaneapi::ApiRenderEngine_hasPendingRenderDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequesthasPendingRenderData(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(26, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_getCurrentChangeLevel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_getCurrentChangeLevel() {
      ::grpc::Service::MarkMethodRaw(27);
    }
    ~WithRawMethod_getCurrentChangeLevel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getCurrentChangeLevel(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getCurrentChangeLevelRequest* /*request*/, ::octaneapi::ApiRenderEngine_getCurrentChangeLevelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetCurrentChangeLevel(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(27, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_getRenderImageChangeLevel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_getRenderImageChangeLevel() {
      ::grpc::Service::MarkMethodRaw(28);
    }
    ~WithRawMethod_getRenderImageChangeLevel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getRenderImageChangeLevel(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getRenderImageChangeLevelRequest* /*request*/, ::octaneapi::ApiRenderEngine_getRenderImageChangeLevelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetRenderImageChangeLevel(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(28, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_getRenderRestartedChangeLevel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_getRenderRestartedChangeLevel() {
      ::grpc::Service::MarkMethodRaw(29);
    }
    ~WithRawMethod_getRenderRestartedChangeLevel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getRenderRestartedChangeLevel(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getRenderRestartedChangeLevelRequest* /*request*/, ::octaneapi::ApiRenderEngine_getRenderRestartedChangeLevelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetRenderRestartedChangeLevel(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(29, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_setAsyncUpdateCallback : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_setAsyncUpdateCallback() {
      ::grpc::Service::MarkMethodRaw(30);
    }
    ~WithRawMethod_setAsyncUpdateCallback() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setAsyncUpdateCallback(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setAsyncUpdateCallbackRequest* /*request*/, ::octaneapi::ApiRenderEngine_setAsyncUpdateCallbackResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsetAsyncUpdateCallback(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(30, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_updatesAreAsync : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_updatesAreAsync() {
      ::grpc::Service::MarkMethodRaw(31);
    }
    ~WithRawMethod_updatesAreAsync() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status updatesAreAsync(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_updatesAreAsyncRequest* /*request*/, ::octaneapi::ApiRenderEngine_updatesAreAsyncResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestupdatesAreAsync(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(31, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_isImageReady : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_isImageReady() {
      ::grpc::Service::MarkMethodRaw(32);
    }
    ~WithRawMethod_isImageReady() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isImageReady(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_isImageReadyRequest* /*request*/, ::octaneapi::ApiRenderEngine_isImageReadyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestisImageReady(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(32, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_resetImageReady : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_resetImageReady() {
      ::grpc::Service::MarkMethodRaw(33);
    }
    ~WithRawMethod_resetImageReady() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status resetImageReady(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_resetImageReadyRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestresetImageReady(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(33, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_isRenderFailure : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_isRenderFailure() {
      ::grpc::Service::MarkMethodRaw(34);
    }
    ~WithRawMethod_isRenderFailure() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isRenderFailure(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_isRenderFailureRequest* /*request*/, ::octaneapi::ApiRenderEngine_isRenderFailureResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestisRenderFailure(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(34, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_resetRenderFailure : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_resetRenderFailure() {
      ::grpc::Service::MarkMethodRaw(35);
    }
    ~WithRawMethod_resetRenderFailure() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status resetRenderFailure(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_resetRenderFailureRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestresetRenderFailure(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(35, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_setOnTileBlendedCallback : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_setOnTileBlendedCallback() {
      ::grpc::Service::MarkMethodRaw(36);
    }
    ~WithRawMethod_setOnTileBlendedCallback() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setOnTileBlendedCallback(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setOnTileBlendedCallbackRequest* /*request*/, ::octaneapi::ApiRenderEngine_setOnTileBlendedCallbackResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsetOnTileBlendedCallback(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(36, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_setOnNewStatisticsCallback : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_setOnNewStatisticsCallback() {
      ::grpc::Service::MarkMethodRaw(37);
    }
    ~WithRawMethod_setOnNewStatisticsCallback() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setOnNewStatisticsCallback(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setOnNewStatisticsCallbackRequest* /*request*/, ::octaneapi::ApiRenderEngine_setOnNewStatisticsCallbackResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsetOnNewStatisticsCallback(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(37, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_setOnNewImageCallback : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_setOnNewImageCallback() {
      ::grpc::Service::MarkMethodRaw(38);
    }
    ~WithRawMethod_setOnNewImageCallback() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setOnNewImageCallback(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setOnNewImageCallbackRequest* /*request*/, ::octaneapi::ApiRenderEngine_setOnNewImageCallbackResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsetOnNewImageCallback(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(38, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_setOnOcioErrorCallback : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_setOnOcioErrorCallback() {
      ::grpc::Service::MarkMethodRaw(39);
    }
    ~WithRawMethod_setOnOcioErrorCallback() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setOnOcioErrorCallback(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setOnOcioErrorCallbackRequest* /*request*/, ::octaneapi::ApiRenderEngine_setOnOcioErrorCallbackResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsetOnOcioErrorCallback(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(39, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_setOnRenderFailureCallback : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_setOnRenderFailureCallback() {
      ::grpc::Service::MarkMethodRaw(40);
    }
    ~WithRawMethod_setOnRenderFailureCallback() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setOnRenderFailureCallback(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setOnRenderFailureCallbackRequest* /*request*/, ::octaneapi::ApiRenderEngine_setOnRenderFailureCallbackResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsetOnRenderFailureCallback(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(40, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_setForceCallbacksInRenderThreads : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_setForceCallbacksInRenderThreads() {
      ::grpc::Service::MarkMethodRaw(41);
    }
    ~WithRawMethod_setForceCallbacksInRenderThreads() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setForceCallbacksInRenderThreads(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setForceCallbacksInRenderThreadsRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsetForceCallbacksInRenderThreads(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(41, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_grabRenderResult : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_grabRenderResult() {
      ::grpc::Service::MarkMethodRaw(42);
    }
    ~WithRawMethod_grabRenderResult() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status grabRenderResult(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_grabRenderResultRequest* /*request*/, ::octaneapi::ApiRenderEngine_grabRenderResultResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgrabRenderResult(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(42, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_releaseRenderResult : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_releaseRenderResult() {
      ::grpc::Service::MarkMethodRaw(43);
    }
    ~WithRawMethod_releaseRenderResult() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status releaseRenderResult(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_releaseRenderResultRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestreleaseRenderResult(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(43, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_synchronousTonemap : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_synchronousTonemap() {
      ::grpc::Service::MarkMethodRaw(44);
    }
    ~WithRawMethod_synchronousTonemap() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status synchronousTonemap(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_synchronousTonemapRequest* /*request*/, ::octaneapi::ApiRenderEngine_synchronousTonemapResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsynchronousTonemap(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(44, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_synchronousTonemap1 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_synchronousTonemap1() {
      ::grpc::Service::MarkMethodRaw(45);
    }
    ~WithRawMethod_synchronousTonemap1() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status synchronousTonemap1(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_synchronousTonemap1Request* /*request*/, ::octaneapi::ApiRenderEngine_synchronousTonemap1Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsynchronousTonemap1(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(45, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_synchronousTonemapAllRenderPasses : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_synchronousTonemapAllRenderPasses() {
      ::grpc::Service::MarkMethodRaw(46);
    }
    ~WithRawMethod_synchronousTonemapAllRenderPasses() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status synchronousTonemapAllRenderPasses(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPassesRequest* /*request*/, ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPassesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsynchronousTonemapAllRenderPasses(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(46, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_synchronousTonemapAllRenderPasses1 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_synchronousTonemapAllRenderPasses1() {
      ::grpc::Service::MarkMethodRaw(47);
    }
    ~WithRawMethod_synchronousTonemapAllRenderPasses1() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status synchronousTonemapAllRenderPasses1(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPasses1Request* /*request*/, ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPasses1Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsynchronousTonemapAllRenderPasses1(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(47, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_getRenderStatistics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_getRenderStatistics() {
      ::grpc::Service::MarkMethodRaw(48);
    }
    ~WithRawMethod_getRenderStatistics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getRenderStatistics(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getRenderStatisticsRequest* /*request*/, ::octaneapi::ApiRenderEngine_getRenderStatisticsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetRenderStatistics(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(48, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_getRenderResultStatistics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_getRenderResultStatistics() {
      ::grpc::Service::MarkMethodRaw(49);
    }
    ~WithRawMethod_getRenderResultStatistics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getRenderResultStatistics(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getRenderResultStatisticsRequest* /*request*/, ::octaneapi::ApiRenderEngine_getRenderResultStatisticsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetRenderResultStatistics(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(49, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_saveImage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_saveImage() {
      ::grpc::Service::MarkMethodRaw(50);
    }
    ~WithRawMethod_saveImage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status saveImage(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_saveImageRequest* /*request*/, ::octaneapi::ApiRenderEngine_saveImageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsaveImage(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(50, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_saveImage1 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_saveImage1() {
      ::grpc::Service::MarkMethodRaw(51);
    }
    ~WithRawMethod_saveImage1() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status saveImage1(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_saveImage1Request* /*request*/, ::octaneapi::ApiRenderEngine_saveImage1Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsaveImage1(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(51, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_saveImage2 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_saveImage2() {
      ::grpc::Service::MarkMethodRaw(52);
    }
    ~WithRawMethod_saveImage2() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status saveImage2(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_saveImage2Request* /*request*/, ::octaneapi::ApiRenderEngine_saveImage2Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsaveImage2(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(52, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_saveRenderPasses : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_saveRenderPasses() {
      ::grpc::Service::MarkMethodRaw(53);
    }
    ~WithRawMethod_saveRenderPasses() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status saveRenderPasses(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_saveRenderPassesRequest* /*request*/, ::octaneapi::ApiRenderEngine_saveRenderPassesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsaveRenderPasses(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(53, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_saveRenderPasses1 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_saveRenderPasses1() {
      ::grpc::Service::MarkMethodRaw(54);
    }
    ~WithRawMethod_saveRenderPasses1() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status saveRenderPasses1(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_saveRenderPasses1Request* /*request*/, ::octaneapi::ApiRenderEngine_saveRenderPasses1Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsaveRenderPasses1(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(54, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_saveRenderPasses2 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_saveRenderPasses2() {
      ::grpc::Service::MarkMethodRaw(55);
    }
    ~WithRawMethod_saveRenderPasses2() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status saveRenderPasses2(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_saveRenderPasses2Request* /*request*/, ::octaneapi::ApiRenderEngine_saveRenderPasses2Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsaveRenderPasses2(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(55, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_saveRenderPassesMultiExr : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_saveRenderPassesMultiExr() {
      ::grpc::Service::MarkMethodRaw(56);
    }
    ~WithRawMethod_saveRenderPassesMultiExr() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status saveRenderPassesMultiExr(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExrRequest* /*request*/, ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExrResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsaveRenderPassesMultiExr(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(56, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_saveRenderPassesMultiExr1 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_saveRenderPassesMultiExr1() {
      ::grpc::Service::MarkMethodRaw(57);
    }
    ~WithRawMethod_saveRenderPassesMultiExr1() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status saveRenderPassesMultiExr1(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExr1Request* /*request*/, ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExr1Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsaveRenderPassesMultiExr1(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(57, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_saveRenderPassesDeepExr : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_saveRenderPassesDeepExr() {
      ::grpc::Service::MarkMethodRaw(58);
    }
    ~WithRawMethod_saveRenderPassesDeepExr() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status saveRenderPassesDeepExr(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_saveRenderPassesDeepExrRequest* /*request*/, ::octaneapi::ApiRenderEngine_saveRenderPassesDeepExrResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsaveRenderPassesDeepExr(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(58, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_deepImageEnabled : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_deepImageEnabled() {
      ::grpc::Service::MarkMethodRaw(59);
    }
    ~WithRawMethod_deepImageEnabled() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status deepImageEnabled(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_deepImageEnabledRequest* /*request*/, ::octaneapi::ApiRenderEngine_deepImageEnabledResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestdeepImageEnabled(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(59, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_deepImageEnabled1 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_deepImageEnabled1() {
      ::grpc::Service::MarkMethodRaw(60);
    }
    ~WithRawMethod_deepImageEnabled1() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status deepImageEnabled1(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_deepImageEnabled1Request* /*request*/, ::octaneapi::ApiRenderEngine_deepImageEnabled1Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestdeepImageEnabled1(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(60, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_deepPassesEnabled : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_deepPassesEnabled() {
      ::grpc::Service::MarkMethodRaw(61);
    }
    ~WithRawMethod_deepPassesEnabled() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status deepPassesEnabled(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_deepPassesEnabledRequest* /*request*/, ::octaneapi::ApiRenderEngine_deepPassesEnabledResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestdeepPassesEnabled(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(61, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_canSaveDeepImage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_canSaveDeepImage() {
      ::grpc::Service::MarkMethodRaw(62);
    }
    ~WithRawMethod_canSaveDeepImage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status canSaveDeepImage(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_canSaveDeepImageRequest* /*request*/, ::octaneapi::ApiRenderEngine_canSaveDeepImageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestcanSaveDeepImage(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(62, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_saveDeepImage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_saveDeepImage() {
      ::grpc::Service::MarkMethodRaw(63);
    }
    ~WithRawMethod_saveDeepImage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status saveDeepImage(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_saveDeepImageRequest* /*request*/, ::octaneapi::ApiRenderEngine_saveDeepImageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsaveDeepImage(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(63, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_saveRenderState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_saveRenderState() {
      ::grpc::Service::MarkMethodRaw(64);
    }
    ~WithRawMethod_saveRenderState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status saveRenderState(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_saveRenderStateRequest* /*request*/, ::octaneapi::ApiRenderEngine_saveRenderStateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsaveRenderState(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(64, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_loadRenderState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_loadRenderState() {
      ::grpc::Service::MarkMethodRaw(65);
    }
    ~WithRawMethod_loadRenderState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status loadRenderState(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_loadRenderStateRequest* /*request*/, ::octaneapi::ApiRenderEngine_loadRenderStateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestloadRenderState(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(65, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_previewMaterial : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_previewMaterial() {
      ::grpc::Service::MarkMethodRaw(66);
    }
    ~WithRawMethod_previewMaterial() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status previewMaterial(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_previewMaterialRequest* /*request*/, ::octaneapi::ApiRenderEngine_previewMaterialResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestpreviewMaterial(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(66, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_previewMaterialHdr : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_previewMaterialHdr() {
      ::grpc::Service::MarkMethodRaw(67);
    }
    ~WithRawMethod_previewMaterialHdr() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status previewMaterialHdr(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_previewMaterialHdrRequest* /*request*/, ::octaneapi::ApiRenderEngine_previewMaterialHdrResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestpreviewMaterialHdr(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(67, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_previewMaterial1 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_previewMaterial1() {
      ::grpc::Service::MarkMethodRaw(68);
    }
    ~WithRawMethod_previewMaterial1() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status previewMaterial1(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_previewMaterial1Request* /*request*/, ::octaneapi::ApiRenderEngine_previewMaterial1Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestpreviewMaterial1(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(68, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_getMemoryUsage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_getMemoryUsage() {
      ::grpc::Service::MarkMethodRaw(69);
    }
    ~WithRawMethod_getMemoryUsage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getMemoryUsage(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getMemoryUsageRequest* /*request*/, ::octaneapi::ApiRenderEngine_getMemoryUsageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetMemoryUsage(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(69, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_getResourceStatistics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_getResourceStatistics() {
      ::grpc::Service::MarkMethodRaw(70);
    }
    ~WithRawMethod_getResourceStatistics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getResourceStatistics(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getResourceStatisticsRequest* /*request*/, ::octaneapi::ApiRenderEngine_getResourceStatisticsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetResourceStatistics(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(70, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_getGeometryStatistics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_getGeometryStatistics() {
      ::grpc::Service::MarkMethodRaw(71);
    }
    ~WithRawMethod_getGeometryStatistics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getGeometryStatistics(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getGeometryStatisticsRequest* /*request*/, ::octaneapi::ApiRenderEngine_getGeometryStatisticsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetGeometryStatistics(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(71, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_getTexturesStatistics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_getTexturesStatistics() {
      ::grpc::Service::MarkMethodRaw(72);
    }
    ~WithRawMethod_getTexturesStatistics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getTexturesStatistics(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getTexturesStatisticsRequest* /*request*/, ::octaneapi::ApiRenderEngine_getTexturesStatisticsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetTexturesStatistics(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(72, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_getSceneBounds : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_getSceneBounds() {
      ::grpc::Service::MarkMethodRaw(73);
    }
    ~WithRawMethod_getSceneBounds() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getSceneBounds(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getSceneBoundsRequest* /*request*/, ::octaneapi::ApiRenderEngine_getSceneBoundsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetSceneBounds(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(73, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_getDeviceCount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_getDeviceCount() {
      ::grpc::Service::MarkMethodRaw(74);
    }
    ~WithRawMethod_getDeviceCount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getDeviceCount(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getDeviceCountRequest* /*request*/, ::octaneapi::ApiRenderEngine_getDeviceCountResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetDeviceCount(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(74, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_getDeviceComputeModel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_getDeviceComputeModel() {
      ::grpc::Service::MarkMethodRaw(75);
    }
    ~WithRawMethod_getDeviceComputeModel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getDeviceComputeModel(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getDeviceComputeModelRequest* /*request*/, ::octaneapi::ApiRenderEngine_getDeviceComputeModelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetDeviceComputeModel(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(75, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_getDeviceName : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_getDeviceName() {
      ::grpc::Service::MarkMethodRaw(76);
    }
    ~WithRawMethod_getDeviceName() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getDeviceName(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getDeviceNameRequest* /*request*/, ::octaneapi::ApiRenderEngine_getDeviceNameResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetDeviceName(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(76, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_isSupportedDevice : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_isSupportedDevice() {
      ::grpc::Service::MarkMethodRaw(77);
    }
    ~WithRawMethod_isSupportedDevice() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isSupportedDevice(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_isSupportedDeviceRequest* /*request*/, ::octaneapi::ApiRenderEngine_isSupportedDeviceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestisSupportedDevice(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(77, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_deviceCanRender : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_deviceCanRender() {
      ::grpc::Service::MarkMethodRaw(78);
    }
    ~WithRawMethod_deviceCanRender() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status deviceCanRender(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_deviceCanRenderRequest* /*request*/, ::octaneapi::ApiRenderEngine_deviceCanRenderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestdeviceCanRender(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(78, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_deviceCanDenoise : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_deviceCanDenoise() {
      ::grpc::Service::MarkMethodRaw(79);
    }
    ~WithRawMethod_deviceCanDenoise() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status deviceCanDenoise(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_deviceCanDenoiseRequest* /*request*/, ::octaneapi::ApiRenderEngine_deviceCanDenoiseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestdeviceCanDenoise(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(79, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_deviceSupportsHardwareRayTracing : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_deviceSupportsHardwareRayTracing() {
      ::grpc::Service::MarkMethodRaw(80);
    }
    ~WithRawMethod_deviceSupportsHardwareRayTracing() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status deviceSupportsHardwareRayTracing(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_deviceSupportsHardwareRayTracingRequest* /*request*/, ::octaneapi::ApiRenderEngine_deviceSupportsHardwareRayTracingResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestdeviceSupportsHardwareRayTracing(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(80, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_deviceSharedSurfaceInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_deviceSharedSurfaceInfo() {
      ::grpc::Service::MarkMethodRaw(81);
    }
    ~WithRawMethod_deviceSharedSurfaceInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status deviceSharedSurfaceInfo(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_deviceSharedSurfaceInfoRequest* /*request*/, ::octaneapi::ApiRenderEngine_deviceSharedSurfaceInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestdeviceSharedSurfaceInfo(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(81, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_getAvailablePeerToPeerPairs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_getAvailablePeerToPeerPairs() {
      ::grpc::Service::MarkMethodRaw(82);
    }
    ~WithRawMethod_getAvailablePeerToPeerPairs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getAvailablePeerToPeerPairs(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getAvailablePeerToPeerPairsRequest* /*request*/, ::octaneapi::ApiRenderEngine_getAvailablePeerToPeerPairsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetAvailablePeerToPeerPairs(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(82, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_setDevicesActivity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_setDevicesActivity() {
      ::grpc::Service::MarkMethodRaw(83);
    }
    ~WithRawMethod_setDevicesActivity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setDevicesActivity(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setDevicesActivityRequest* /*request*/, ::octaneapi::ApiRenderEngine_setDevicesActivityResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsetDevicesActivity(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(83, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_isDeviceUsedForRendering : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_isDeviceUsedForRendering() {
      ::grpc::Service::MarkMethodRaw(84);
    }
    ~WithRawMethod_isDeviceUsedForRendering() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isDeviceUsedForRendering(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_isDeviceUsedForRenderingRequest* /*request*/, ::octaneapi::ApiRenderEngine_isDeviceUsedForRenderingResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestisDeviceUsedForRendering(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(84, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_deviceUsesPriority : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_deviceUsesPriority() {
      ::grpc::Service::MarkMethodRaw(85);
    }
    ~WithRawMethod_deviceUsesPriority() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status deviceUsesPriority(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_deviceUsesPriorityRequest* /*request*/, ::octaneapi::ApiRenderEngine_deviceUsesPriorityResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestdeviceUsesPriority(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(85, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_deviceUsesHardwareRayTracing : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_deviceUsesHardwareRayTracing() {
      ::grpc::Service::MarkMethodRaw(86);
    }
    ~WithRawMethod_deviceUsesHardwareRayTracing() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status deviceUsesHardwareRayTracing(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_deviceUsesHardwareRayTracingRequest* /*request*/, ::octaneapi::ApiRenderEngine_deviceUsesHardwareRayTracingResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestdeviceUsesHardwareRayTracing(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(86, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_imageDeviceIndex : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_imageDeviceIndex() {
      ::grpc::Service::MarkMethodRaw(87);
    }
    ~WithRawMethod_imageDeviceIndex() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status imageDeviceIndex(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_imageDeviceIndexRequest* /*request*/, ::octaneapi::ApiRenderEngine_imageDeviceIndexResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestimageDeviceIndex(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(87, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_isDeviceUsedForDenoising : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_isDeviceUsedForDenoising() {
      ::grpc::Service::MarkMethodRaw(88);
    }
    ~WithRawMethod_isDeviceUsedForDenoising() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isDeviceUsedForDenoising(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_isDeviceUsedForDenoisingRequest* /*request*/, ::octaneapi::ApiRenderEngine_isDeviceUsedForDenoisingResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestisDeviceUsedForDenoising(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(88, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_renderPriority : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_renderPriority() {
      ::grpc::Service::MarkMethodRaw(89);
    }
    ~WithRawMethod_renderPriority() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status renderPriority(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_renderPriorityRequest* /*request*/, ::octaneapi::ApiRenderEngine_renderPriorityResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestrenderPriority(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(89, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_setRenderPriority : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_setRenderPriority() {
      ::grpc::Service::MarkMethodRaw(90);
    }
    ~WithRawMethod_setRenderPriority() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setRenderPriority(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setRenderPriorityRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsetRenderPriority(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(90, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_currentPeerToPeerGroups : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_currentPeerToPeerGroups() {
      ::grpc::Service::MarkMethodRaw(91);
    }
    ~WithRawMethod_currentPeerToPeerGroups() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status currentPeerToPeerGroups(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_currentPeerToPeerGroupsRequest* /*request*/, ::octaneapi::ApiRenderEngine_currentPeerToPeerGroupsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestcurrentPeerToPeerGroups(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(91, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_hardwareRayTracingEnabled : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_hardwareRayTracingEnabled() {
      ::grpc::Service::MarkMethodRaw(92);
    }
    ~WithRawMethod_hardwareRayTracingEnabled() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status hardwareRayTracingEnabled(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_hardwareRayTracingEnabledRequest* /*request*/, ::octaneapi::ApiRenderEngine_hardwareRayTracingEnabledResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequesthardwareRayTracingEnabled(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(92, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_openDeviceSettings : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_openDeviceSettings() {
      ::grpc::Service::MarkMethodRaw(93);
    }
    ~WithRawMethod_openDeviceSettings() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status openDeviceSettings(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_openDeviceSettingsRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestopenDeviceSettings(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(93, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_renderDeviceState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_renderDeviceState() {
      ::grpc::Service::MarkMethodRaw(94);
    }
    ~WithRawMethod_renderDeviceState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status renderDeviceState(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_renderDeviceStateRequest* /*request*/, ::octaneapi::ApiRenderEngine_renderDeviceStateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestrenderDeviceState(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(94, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_renderDeviceErrorCode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_renderDeviceErrorCode() {
      ::grpc::Service::MarkMethodRaw(95);
    }
    ~WithRawMethod_renderDeviceErrorCode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status renderDeviceErrorCode(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_renderDeviceErrorCodeRequest* /*request*/, ::octaneapi::ApiRenderEngine_renderDeviceErrorCodeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestrenderDeviceErrorCode(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(95, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_errorcodeToString : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_errorcodeToString() {
      ::grpc::Service::MarkMethodRaw(96);
    }
    ~WithRawMethod_errorcodeToString() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status errorcodeToString(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_errorcodeToStringRequest* /*request*/, ::octaneapi::ApiRenderEngine_errorcodeToStringResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequesterrorcodeToString(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(96, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_renderDeviceErrorMessage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_renderDeviceErrorMessage() {
      ::grpc::Service::MarkMethodRaw(97);
    }
    ~WithRawMethod_renderDeviceErrorMessage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status renderDeviceErrorMessage(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_renderDeviceErrorMessageRequest* /*request*/, ::octaneapi::ApiRenderEngine_renderDeviceErrorMessageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestrenderDeviceErrorMessage(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(97, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_saveRenderDeviceConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_saveRenderDeviceConfig() {
      ::grpc::Service::MarkMethodRaw(98);
    }
    ~WithRawMethod_saveRenderDeviceConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status saveRenderDeviceConfig(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_saveRenderDeviceConfigRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsaveRenderDeviceConfig(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(98, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_outOfCoreEnabled : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_outOfCoreEnabled() {
      ::grpc::Service::MarkMethodRaw(99);
    }
    ~WithRawMethod_outOfCoreEnabled() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status outOfCoreEnabled(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_outOfCoreEnabledRequest* /*request*/, ::octaneapi::ApiRenderEngine_outOfCoreEnabledResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestoutOfCoreEnabled(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(99, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_enableOutOfCore : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_enableOutOfCore() {
      ::grpc::Service::MarkMethodRaw(100);
    }
    ~WithRawMethod_enableOutOfCore() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status enableOutOfCore(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_enableOutOfCoreRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestenableOutOfCore(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(100, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_disableOutOfCore : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_disableOutOfCore() {
      ::grpc::Service::MarkMethodRaw(101);
    }
    ~WithRawMethod_disableOutOfCore() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status disableOutOfCore(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_disableOutOfCoreRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestdisableOutOfCore(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(101, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_getOutOfCoreMemoryUsage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_getOutOfCoreMemoryUsage() {
      ::grpc::Service::MarkMethodRaw(102);
    }
    ~WithRawMethod_getOutOfCoreMemoryUsage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getOutOfCoreMemoryUsage(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getOutOfCoreMemoryUsageRequest* /*request*/, ::octaneapi::ApiRenderEngine_getOutOfCoreMemoryUsageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetOutOfCoreMemoryUsage(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(102, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_setGpuHeadroom : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_setGpuHeadroom() {
      ::grpc::Service::MarkMethodRaw(103);
    }
    ~WithRawMethod_setGpuHeadroom() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setGpuHeadroom(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setGpuHeadroomRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsetGpuHeadroom(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(103, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_getGpuHeadroom : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_getGpuHeadroom() {
      ::grpc::Service::MarkMethodRaw(104);
    }
    ~WithRawMethod_getGpuHeadroom() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getGpuHeadroom(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getGpuHeadroomRequest* /*request*/, ::octaneapi::ApiRenderEngine_getGpuHeadroomResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetGpuHeadroom(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(104, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_setCoreLimit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_setCoreLimit() {
      ::grpc::Service::MarkMethodRaw(105);
    }
    ~WithRawMethod_setCoreLimit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setCoreLimit(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setCoreLimitRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsetCoreLimit(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(105, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_disableCoreLimit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_disableCoreLimit() {
      ::grpc::Service::MarkMethodRaw(106);
    }
    ~WithRawMethod_disableCoreLimit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status disableCoreLimit(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_disableCoreLimitRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestdisableCoreLimit(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(106, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_registerInputSharedSurface : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_registerInputSharedSurface() {
      ::grpc::Service::MarkMethodRaw(107);
    }
    ~WithRawMethod_registerInputSharedSurface() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status registerInputSharedSurface(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_registerInputSharedSurfaceRequest* /*request*/, ::octaneapi::ApiRenderEngine_registerInputSharedSurfaceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestregisterInputSharedSurface(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(107, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_unregisterInputSharedSurface : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_unregisterInputSharedSurface() {
      ::grpc::Service::MarkMethodRaw(108);
    }
    ~WithRawMethod_unregisterInputSharedSurface() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status unregisterInputSharedSurface(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_unregisterInputSharedSurfaceRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestunregisterInputSharedSurface(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(108, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_triggerAsyncTonemap : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_triggerAsyncTonemap() {
      ::grpc::Service::MarkMethodRaw(109);
    }
    ~WithRawMethod_triggerAsyncTonemap() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status triggerAsyncTonemap(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_triggerAsyncTonemapRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequesttriggerAsyncTonemap(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(109, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_setSharedSurfaceOutputType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_setSharedSurfaceOutputType() {
      ::grpc::Service::MarkMethodRaw(110);
    }
    ~WithRawMethod_setSharedSurfaceOutputType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setSharedSurfaceOutputType(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setSharedSurfaceOutputTypeRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsetSharedSurfaceOutputType(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(110, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_getSharedSurfaceOutputType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_getSharedSurfaceOutputType() {
      ::grpc::Service::MarkMethodRaw(111);
    }
    ~WithRawMethod_getSharedSurfaceOutputType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getSharedSurfaceOutputType(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getSharedSurfaceOutputTypeRequest* /*request*/, ::octaneapi::ApiRenderEngine_getSharedSurfaceOutputTypeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetSharedSurfaceOutputType(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(111, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_getRealTime : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_getRealTime() {
      ::grpc::Service::MarkMethodRaw(112);
    }
    ~WithRawMethod_getRealTime() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getRealTime(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getRealTimeRequest* /*request*/, ::octaneapi::ApiRenderEngine_getRealTimeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetRealTime(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(112, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_pauseRendering : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_pauseRendering() {
      ::grpc::Service::MarkMethodRaw(113);
    }
    ~WithRawMethod_pauseRendering() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status pauseRendering(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_pauseRenderingRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestpauseRendering(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(113, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_continueRendering : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_continueRendering() {
      ::grpc::Service::MarkMethodRaw(114);
    }
    ~WithRawMethod_continueRendering() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status continueRendering(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_continueRenderingRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestcontinueRendering(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(114, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_isRenderingPaused : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_isRenderingPaused() {
      ::grpc::Service::MarkMethodRaw(115);
    }
    ~WithRawMethod_isRenderingPaused() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isRenderingPaused(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_isRenderingPausedRequest* /*request*/, ::octaneapi::ApiRenderEngine_isRenderingPausedResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestisRenderingPaused(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(115, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_restartRendering : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_restartRendering() {
      ::grpc::Service::MarkMethodRaw(116);
    }
    ~WithRawMethod_restartRendering() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status restartRendering(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_restartRenderingRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestrestartRendering(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(116, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_stopRendering : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_stopRendering() {
      ::grpc::Service::MarkMethodRaw(117);
    }
    ~WithRawMethod_stopRendering() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status stopRendering(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_stopRenderingRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequeststopRendering(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(117, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_pick : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_pick() {
      ::grpc::Service::MarkMethodRaw(118);
    }
    ~WithRawMethod_pick() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status pick(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_pickRequest* /*request*/, ::octaneapi::ApiRenderEngine_pickResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestpick(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(118, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_pickWhitePoint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_pickWhitePoint() {
      ::grpc::Service::MarkMethodRaw(119);
    }
    ~WithRawMethod_pickWhitePoint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status pickWhitePoint(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_pickWhitePointRequest* /*request*/, ::octaneapi::ApiRenderEngine_pickWhitePointResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestpickWhitePoint(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(119, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_pickImagerWhitePoint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_pickImagerWhitePoint() {
      ::grpc::Service::MarkMethodRaw(120);
    }
    ~WithRawMethod_pickImagerWhitePoint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status pickImagerWhitePoint(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_pickImagerWhitePointRequest* /*request*/, ::octaneapi::ApiRenderEngine_pickImagerWhitePointResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestpickImagerWhitePoint(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(120, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_isOutputAovWhitePointPickable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_isOutputAovWhitePointPickable() {
      ::grpc::Service::MarkMethodRaw(121);
    }
    ~WithRawMethod_isOutputAovWhitePointPickable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isOutputAovWhitePointPickable(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_isOutputAovWhitePointPickableRequest* /*request*/, ::octaneapi::ApiRenderEngine_isOutputAovWhitePointPickableResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestisOutputAovWhitePointPickable(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(121, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_pickOutputAovWhitePoint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_pickOutputAovWhitePoint() {
      ::grpc::Service::MarkMethodRaw(122);
    }
    ~WithRawMethod_pickOutputAovWhitePoint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status pickOutputAovWhitePoint(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_pickOutputAovWhitePointRequest* /*request*/, ::octaneapi::ApiRenderEngine_pickOutputAovWhitePointResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestpickOutputAovWhitePoint(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(122, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_pickCryptomatteMatte : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_pickCryptomatteMatte() {
      ::grpc::Service::MarkMethodRaw(123);
    }
    ~WithRawMethod_pickCryptomatteMatte() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status pickCryptomatteMatte(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_pickCryptomatteMatteRequest* /*request*/, ::octaneapi::ApiRenderEngine_pickCryptomatteMatteResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestpickCryptomatteMatte(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(123, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_modifyCryptomatteMatteSelection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_modifyCryptomatteMatteSelection() {
      ::grpc::Service::MarkMethodRaw(124);
    }
    ~WithRawMethod_modifyCryptomatteMatteSelection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status modifyCryptomatteMatteSelection(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_modifyCryptomatteMatteSelectionRequest* /*request*/, ::octaneapi::ApiRenderEngine_modifyCryptomatteMatteSelectionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestmodifyCryptomatteMatteSelection(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(124, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_toString : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_toString() {
      ::grpc::Service::MarkMethodRaw(125);
    }
    ~WithRawMethod_toString() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status toString(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_toStringRequest* /*request*/, ::octaneapi::ApiRenderEngine_toStringResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequesttoString(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(125, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_getDevicePciIds : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_getDevicePciIds() {
      ::grpc::Service::MarkMethodRaw(126);
    }
    ~WithRawMethod_getDevicePciIds() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getDevicePciIds(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getDevicePciIdsRequest* /*request*/, ::octaneapi::ApiRenderEngine_getDevicePciIdsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetDevicePciIds(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(126, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_setRenderTargetNode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_setRenderTargetNode() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->setRenderTargetNode(context, request, response); }));
    }
    ~WithRawCallbackMethod_setRenderTargetNode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setRenderTargetNode(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setRenderTargetNodeRequest* /*request*/, ::octaneapi::ApiRenderEngine_setRenderTargetNodeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* setRenderTargetNode(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_getRenderTargetNode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_getRenderTargetNode() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->getRenderTargetNode(context, request, response); }));
    }
    ~WithRawCallbackMethod_getRenderTargetNode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getRenderTargetNode(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getRenderTargetNodeRequest* /*request*/, ::octaneapi::ApiRenderEngine_getRenderTargetNodeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getRenderTargetNode(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_getRenderGeometryNode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_getRenderGeometryNode() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->getRenderGeometryNode(context, request, response); }));
    }
    ~WithRawCallbackMethod_getRenderGeometryNode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getRenderGeometryNode(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getRenderGeometryNodeRequest* /*request*/, ::octaneapi::ApiRenderEngine_getRenderGeometryNodeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getRenderGeometryNode(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_getRenderCameraNode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_getRenderCameraNode() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->getRenderCameraNode(context, request, response); }));
    }
    ~WithRawCallbackMethod_getRenderCameraNode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getRenderCameraNode(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getRenderCameraNodeRequest* /*request*/, ::octaneapi::ApiRenderEngine_getRenderCameraNodeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getRenderCameraNode(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_setRenderRegion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_setRenderRegion() {
      ::grpc::Service::MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->setRenderRegion(context, request, response); }));
    }
    ~WithRawCallbackMethod_setRenderRegion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setRenderRegion(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setRenderRegionRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* setRenderRegion(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_getRenderRegion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_getRenderRegion() {
      ::grpc::Service::MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->getRenderRegion(context, request, response); }));
    }
    ~WithRawCallbackMethod_getRenderRegion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getRenderRegion(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getRenderRegionRequest* /*request*/, ::octaneapi::ApiRenderEngine_getRenderRegionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getRenderRegion(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_setAsyncTonemapParams : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_setAsyncTonemapParams() {
      ::grpc::Service::MarkMethodRawCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->setAsyncTonemapParams(context, request, response); }));
    }
    ~WithRawCallbackMethod_setAsyncTonemapParams() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setAsyncTonemapParams(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setAsyncTonemapParamsRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* setAsyncTonemapParams(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_setAsyncTonemapParams1 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_setAsyncTonemapParams1() {
      ::grpc::Service::MarkMethodRawCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->setAsyncTonemapParams1(context, request, response); }));
    }
    ~WithRawCallbackMethod_setAsyncTonemapParams1() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setAsyncTonemapParams1(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setAsyncTonemapParams1Request* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* setAsyncTonemapParams1(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_asyncTonemapBufferType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_asyncTonemapBufferType() {
      ::grpc::Service::MarkMethodRawCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->asyncTonemapBufferType(context, request, response); }));
    }
    ~WithRawCallbackMethod_asyncTonemapBufferType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status asyncTonemapBufferType(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_asyncTonemapBufferTypeRequest* /*request*/, ::octaneapi::ApiRenderEngine_asyncTonemapBufferTypeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* asyncTonemapBufferType(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_asyncTonemapCryptomatteFalseColor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_asyncTonemapCryptomatteFalseColor() {
      ::grpc::Service::MarkMethodRawCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->asyncTonemapCryptomatteFalseColor(context, request, response); }));
    }
    ~WithRawCallbackMethod_asyncTonemapCryptomatteFalseColor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status asyncTonemapCryptomatteFalseColor(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_asyncTonemapCryptomatteFalseColorRequest* /*request*/, ::octaneapi::ApiRenderEngine_asyncTonemapCryptomatteFalseColorResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* asyncTonemapCryptomatteFalseColor(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_asyncTonemapOutputColorSpaceInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_asyncTonemapOutputColorSpaceInfo() {
      ::grpc::Service::MarkMethodRawCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->asyncTonemapOutputColorSpaceInfo(context, request, response); }));
    }
    ~WithRawCallbackMethod_asyncTonemapOutputColorSpaceInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status asyncTonemapOutputColorSpaceInfo(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_asyncTonemapOutputColorSpaceInfoRequest* /*request*/, ::octaneapi::ApiRenderEngine_asyncTonemapOutputColorSpaceInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* asyncTonemapOutputColorSpaceInfo(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_asyncTonemapColorSpace : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_asyncTonemapColorSpace() {
      ::grpc::Service::MarkMethodRawCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->asyncTonemapColorSpace(context, request, response); }));
    }
    ~WithRawCallbackMethod_asyncTonemapColorSpace() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status asyncTonemapColorSpace(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_asyncTonemapColorSpaceRequest* /*request*/, ::octaneapi::ApiRenderEngine_asyncTonemapColorSpaceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* asyncTonemapColorSpace(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_asyncTonemapPremultipliedAlphaType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_asyncTonemapPremultipliedAlphaType() {
      ::grpc::Service::MarkMethodRawCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->asyncTonemapPremultipliedAlphaType(context, request, response); }));
    }
    ~WithRawCallbackMethod_asyncTonemapPremultipliedAlphaType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status asyncTonemapPremultipliedAlphaType(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_asyncTonemapPremultipliedAlphaTypeRequest* /*request*/, ::octaneapi::ApiRenderEngine_asyncTonemapPremultipliedAlphaTypeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* asyncTonemapPremultipliedAlphaType(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_setAsyncTonemapRenderPasses : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_setAsyncTonemapRenderPasses() {
      ::grpc::Service::MarkMethodRawCallback(13,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->setAsyncTonemapRenderPasses(context, request, response); }));
    }
    ~WithRawCallbackMethod_setAsyncTonemapRenderPasses() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setAsyncTonemapRenderPasses(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setAsyncTonemapRenderPassesRequest* /*request*/, ::octaneapi::ApiRenderEngine_setAsyncTonemapRenderPassesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* setAsyncTonemapRenderPasses(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_asyncTonemapRenderPasses : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_asyncTonemapRenderPasses() {
      ::grpc::Service::MarkMethodRawCallback(14,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->asyncTonemapRenderPasses(context, request, response); }));
    }
    ~WithRawCallbackMethod_asyncTonemapRenderPasses() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status asyncTonemapRenderPasses(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_asyncTonemapRenderPassesRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* asyncTonemapRenderPasses(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_getEnabledAovs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_getEnabledAovs() {
      ::grpc::Service::MarkMethodRawCallback(15,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->getEnabledAovs(context, request, response); }));
    }
    ~WithRawCallbackMethod_getEnabledAovs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getEnabledAovs(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getEnabledAovsRequest* /*request*/, ::octaneapi::ApiRenderEngine_getEnabledAovsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getEnabledAovs(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_freeTonemapPasses : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_freeTonemapPasses() {
      ::grpc::Service::MarkMethodRawCallback(16,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->freeTonemapPasses(context, request, response); }));
    }
    ~WithRawCallbackMethod_freeTonemapPasses() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status freeTonemapPasses(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_freeTonemapPassesRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* freeTonemapPasses(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_displayRenderPassId : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_displayRenderPassId() {
      ::grpc::Service::MarkMethodRawCallback(17,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->displayRenderPassId(context, request, response); }));
    }
    ~WithRawCallbackMethod_displayRenderPassId() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status displayRenderPassId(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_displayRenderPassIdRequest* /*request*/, ::octaneapi::ApiRenderEngine_displayRenderPassIdResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* displayRenderPassId(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_setSubSampleMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_setSubSampleMode() {
      ::grpc::Service::MarkMethodRawCallback(18,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->setSubSampleMode(context, request, response); }));
    }
    ~WithRawCallbackMethod_setSubSampleMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setSubSampleMode(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setSubSampleModeRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* setSubSampleMode(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_getSubSampleMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_getSubSampleMode() {
      ::grpc::Service::MarkMethodRawCallback(19,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->getSubSampleMode(context, request, response); }));
    }
    ~WithRawCallbackMethod_getSubSampleMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getSubSampleMode(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getSubSampleModeRequest* /*request*/, ::octaneapi::ApiRenderEngine_getSubSampleModeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getSubSampleMode(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_setClayMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_setClayMode() {
      ::grpc::Service::MarkMethodRawCallback(20,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->setClayMode(context, request, response); }));
    }
    ~WithRawCallbackMethod_setClayMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setClayMode(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setClayModeRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* setClayMode(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_clayMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_clayMode() {
      ::grpc::Service::MarkMethodRawCallback(21,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->clayMode(context, request, response); }));
    }
    ~WithRawCallbackMethod_clayMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status clayMode(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_clayModeRequest* /*request*/, ::octaneapi::ApiRenderEngine_clayModeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* clayMode(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_fps : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_fps() {
      ::grpc::Service::MarkMethodRawCallback(22,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->fps(context, request, response); }));
    }
    ~WithRawCallbackMethod_fps() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status fps(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_fpsRequest* /*request*/, ::octaneapi::ApiRenderEngine_fpsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* fps(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_setFps : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_setFps() {
      ::grpc::Service::MarkMethodRawCallback(23,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->setFps(context, request, response); }));
    }
    ~WithRawCallbackMethod_setFps() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setFps(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setFpsRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* setFps(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_isCompiling : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_isCompiling() {
      ::grpc::Service::MarkMethodRawCallback(24,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->isCompiling(context, request, response); }));
    }
    ~WithRawCallbackMethod_isCompiling() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isCompiling(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_isCompilingRequest* /*request*/, ::octaneapi::ApiRenderEngine_isCompilingResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* isCompiling(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_isCompressingTextures : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_isCompressingTextures() {
      ::grpc::Service::MarkMethodRawCallback(25,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->isCompressingTextures(context, request, response); }));
    }
    ~WithRawCallbackMethod_isCompressingTextures() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isCompressingTextures(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_isCompressingTexturesRequest* /*request*/, ::octaneapi::ApiRenderEngine_isCompressingTexturesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* isCompressingTextures(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_hasPendingRenderData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_hasPendingRenderData() {
      ::grpc::Service::MarkMethodRawCallback(26,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->hasPendingRenderData(context, request, response); }));
    }
    ~WithRawCallbackMethod_hasPendingRenderData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status hasPendingRenderData(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_hasPendingRenderDataRequest* /*request*/, ::octaneapi::ApiRenderEngine_hasPendingRenderDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* hasPendingRenderData(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_getCurrentChangeLevel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_getCurrentChangeLevel() {
      ::grpc::Service::MarkMethodRawCallback(27,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->getCurrentChangeLevel(context, request, response); }));
    }
    ~WithRawCallbackMethod_getCurrentChangeLevel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getCurrentChangeLevel(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getCurrentChangeLevelRequest* /*request*/, ::octaneapi::ApiRenderEngine_getCurrentChangeLevelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getCurrentChangeLevel(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_getRenderImageChangeLevel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_getRenderImageChangeLevel() {
      ::grpc::Service::MarkMethodRawCallback(28,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->getRenderImageChangeLevel(context, request, response); }));
    }
    ~WithRawCallbackMethod_getRenderImageChangeLevel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getRenderImageChangeLevel(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getRenderImageChangeLevelRequest* /*request*/, ::octaneapi::ApiRenderEngine_getRenderImageChangeLevelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getRenderImageChangeLevel(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_getRenderRestartedChangeLevel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_getRenderRestartedChangeLevel() {
      ::grpc::Service::MarkMethodRawCallback(29,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->getRenderRestartedChangeLevel(context, request, response); }));
    }
    ~WithRawCallbackMethod_getRenderRestartedChangeLevel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getRenderRestartedChangeLevel(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getRenderRestartedChangeLevelRequest* /*request*/, ::octaneapi::ApiRenderEngine_getRenderRestartedChangeLevelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getRenderRestartedChangeLevel(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_setAsyncUpdateCallback : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_setAsyncUpdateCallback() {
      ::grpc::Service::MarkMethodRawCallback(30,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->setAsyncUpdateCallback(context, request, response); }));
    }
    ~WithRawCallbackMethod_setAsyncUpdateCallback() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setAsyncUpdateCallback(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setAsyncUpdateCallbackRequest* /*request*/, ::octaneapi::ApiRenderEngine_setAsyncUpdateCallbackResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* setAsyncUpdateCallback(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_updatesAreAsync : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_updatesAreAsync() {
      ::grpc::Service::MarkMethodRawCallback(31,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->updatesAreAsync(context, request, response); }));
    }
    ~WithRawCallbackMethod_updatesAreAsync() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status updatesAreAsync(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_updatesAreAsyncRequest* /*request*/, ::octaneapi::ApiRenderEngine_updatesAreAsyncResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* updatesAreAsync(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_isImageReady : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_isImageReady() {
      ::grpc::Service::MarkMethodRawCallback(32,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->isImageReady(context, request, response); }));
    }
    ~WithRawCallbackMethod_isImageReady() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isImageReady(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_isImageReadyRequest* /*request*/, ::octaneapi::ApiRenderEngine_isImageReadyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* isImageReady(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_resetImageReady : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_resetImageReady() {
      ::grpc::Service::MarkMethodRawCallback(33,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->resetImageReady(context, request, response); }));
    }
    ~WithRawCallbackMethod_resetImageReady() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status resetImageReady(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_resetImageReadyRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* resetImageReady(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_isRenderFailure : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_isRenderFailure() {
      ::grpc::Service::MarkMethodRawCallback(34,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->isRenderFailure(context, request, response); }));
    }
    ~WithRawCallbackMethod_isRenderFailure() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isRenderFailure(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_isRenderFailureRequest* /*request*/, ::octaneapi::ApiRenderEngine_isRenderFailureResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* isRenderFailure(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_resetRenderFailure : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_resetRenderFailure() {
      ::grpc::Service::MarkMethodRawCallback(35,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->resetRenderFailure(context, request, response); }));
    }
    ~WithRawCallbackMethod_resetRenderFailure() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status resetRenderFailure(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_resetRenderFailureRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* resetRenderFailure(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_setOnTileBlendedCallback : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_setOnTileBlendedCallback() {
      ::grpc::Service::MarkMethodRawCallback(36,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->setOnTileBlendedCallback(context, request, response); }));
    }
    ~WithRawCallbackMethod_setOnTileBlendedCallback() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setOnTileBlendedCallback(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setOnTileBlendedCallbackRequest* /*request*/, ::octaneapi::ApiRenderEngine_setOnTileBlendedCallbackResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* setOnTileBlendedCallback(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_setOnNewStatisticsCallback : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_setOnNewStatisticsCallback() {
      ::grpc::Service::MarkMethodRawCallback(37,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->setOnNewStatisticsCallback(context, request, response); }));
    }
    ~WithRawCallbackMethod_setOnNewStatisticsCallback() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setOnNewStatisticsCallback(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setOnNewStatisticsCallbackRequest* /*request*/, ::octaneapi::ApiRenderEngine_setOnNewStatisticsCallbackResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* setOnNewStatisticsCallback(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_setOnNewImageCallback : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_setOnNewImageCallback() {
      ::grpc::Service::MarkMethodRawCallback(38,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->setOnNewImageCallback(context, request, response); }));
    }
    ~WithRawCallbackMethod_setOnNewImageCallback() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setOnNewImageCallback(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setOnNewImageCallbackRequest* /*request*/, ::octaneapi::ApiRenderEngine_setOnNewImageCallbackResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* setOnNewImageCallback(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_setOnOcioErrorCallback : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_setOnOcioErrorCallback() {
      ::grpc::Service::MarkMethodRawCallback(39,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->setOnOcioErrorCallback(context, request, response); }));
    }
    ~WithRawCallbackMethod_setOnOcioErrorCallback() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setOnOcioErrorCallback(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setOnOcioErrorCallbackRequest* /*request*/, ::octaneapi::ApiRenderEngine_setOnOcioErrorCallbackResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* setOnOcioErrorCallback(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_setOnRenderFailureCallback : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_setOnRenderFailureCallback() {
      ::grpc::Service::MarkMethodRawCallback(40,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->setOnRenderFailureCallback(context, request, response); }));
    }
    ~WithRawCallbackMethod_setOnRenderFailureCallback() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setOnRenderFailureCallback(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setOnRenderFailureCallbackRequest* /*request*/, ::octaneapi::ApiRenderEngine_setOnRenderFailureCallbackResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* setOnRenderFailureCallback(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_setForceCallbacksInRenderThreads : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_setForceCallbacksInRenderThreads() {
      ::grpc::Service::MarkMethodRawCallback(41,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->setForceCallbacksInRenderThreads(context, request, response); }));
    }
    ~WithRawCallbackMethod_setForceCallbacksInRenderThreads() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setForceCallbacksInRenderThreads(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setForceCallbacksInRenderThreadsRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* setForceCallbacksInRenderThreads(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_grabRenderResult : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_grabRenderResult() {
      ::grpc::Service::MarkMethodRawCallback(42,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->grabRenderResult(context, request, response); }));
    }
    ~WithRawCallbackMethod_grabRenderResult() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status grabRenderResult(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_grabRenderResultRequest* /*request*/, ::octaneapi::ApiRenderEngine_grabRenderResultResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* grabRenderResult(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_releaseRenderResult : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_releaseRenderResult() {
      ::grpc::Service::MarkMethodRawCallback(43,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->releaseRenderResult(context, request, response); }));
    }
    ~WithRawCallbackMethod_releaseRenderResult() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status releaseRenderResult(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_releaseRenderResultRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* releaseRenderResult(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_synchronousTonemap : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_synchronousTonemap() {
      ::grpc::Service::MarkMethodRawCallback(44,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->synchronousTonemap(context, request, response); }));
    }
    ~WithRawCallbackMethod_synchronousTonemap() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status synchronousTonemap(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_synchronousTonemapRequest* /*request*/, ::octaneapi::ApiRenderEngine_synchronousTonemapResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* synchronousTonemap(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_synchronousTonemap1 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_synchronousTonemap1() {
      ::grpc::Service::MarkMethodRawCallback(45,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->synchronousTonemap1(context, request, response); }));
    }
    ~WithRawCallbackMethod_synchronousTonemap1() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status synchronousTonemap1(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_synchronousTonemap1Request* /*request*/, ::octaneapi::ApiRenderEngine_synchronousTonemap1Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* synchronousTonemap1(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_synchronousTonemapAllRenderPasses : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_synchronousTonemapAllRenderPasses() {
      ::grpc::Service::MarkMethodRawCallback(46,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->synchronousTonemapAllRenderPasses(context, request, response); }));
    }
    ~WithRawCallbackMethod_synchronousTonemapAllRenderPasses() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status synchronousTonemapAllRenderPasses(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPassesRequest* /*request*/, ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPassesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* synchronousTonemapAllRenderPasses(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_synchronousTonemapAllRenderPasses1 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_synchronousTonemapAllRenderPasses1() {
      ::grpc::Service::MarkMethodRawCallback(47,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->synchronousTonemapAllRenderPasses1(context, request, response); }));
    }
    ~WithRawCallbackMethod_synchronousTonemapAllRenderPasses1() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status synchronousTonemapAllRenderPasses1(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPasses1Request* /*request*/, ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPasses1Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* synchronousTonemapAllRenderPasses1(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_getRenderStatistics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_getRenderStatistics() {
      ::grpc::Service::MarkMethodRawCallback(48,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->getRenderStatistics(context, request, response); }));
    }
    ~WithRawCallbackMethod_getRenderStatistics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getRenderStatistics(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getRenderStatisticsRequest* /*request*/, ::octaneapi::ApiRenderEngine_getRenderStatisticsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getRenderStatistics(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_getRenderResultStatistics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_getRenderResultStatistics() {
      ::grpc::Service::MarkMethodRawCallback(49,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->getRenderResultStatistics(context, request, response); }));
    }
    ~WithRawCallbackMethod_getRenderResultStatistics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getRenderResultStatistics(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getRenderResultStatisticsRequest* /*request*/, ::octaneapi::ApiRenderEngine_getRenderResultStatisticsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getRenderResultStatistics(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_saveImage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_saveImage() {
      ::grpc::Service::MarkMethodRawCallback(50,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->saveImage(context, request, response); }));
    }
    ~WithRawCallbackMethod_saveImage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status saveImage(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_saveImageRequest* /*request*/, ::octaneapi::ApiRenderEngine_saveImageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* saveImage(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_saveImage1 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_saveImage1() {
      ::grpc::Service::MarkMethodRawCallback(51,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->saveImage1(context, request, response); }));
    }
    ~WithRawCallbackMethod_saveImage1() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status saveImage1(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_saveImage1Request* /*request*/, ::octaneapi::ApiRenderEngine_saveImage1Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* saveImage1(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_saveImage2 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_saveImage2() {
      ::grpc::Service::MarkMethodRawCallback(52,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->saveImage2(context, request, response); }));
    }
    ~WithRawCallbackMethod_saveImage2() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status saveImage2(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_saveImage2Request* /*request*/, ::octaneapi::ApiRenderEngine_saveImage2Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* saveImage2(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_saveRenderPasses : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_saveRenderPasses() {
      ::grpc::Service::MarkMethodRawCallback(53,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->saveRenderPasses(context, request, response); }));
    }
    ~WithRawCallbackMethod_saveRenderPasses() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status saveRenderPasses(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_saveRenderPassesRequest* /*request*/, ::octaneapi::ApiRenderEngine_saveRenderPassesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* saveRenderPasses(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_saveRenderPasses1 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_saveRenderPasses1() {
      ::grpc::Service::MarkMethodRawCallback(54,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->saveRenderPasses1(context, request, response); }));
    }
    ~WithRawCallbackMethod_saveRenderPasses1() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status saveRenderPasses1(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_saveRenderPasses1Request* /*request*/, ::octaneapi::ApiRenderEngine_saveRenderPasses1Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* saveRenderPasses1(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_saveRenderPasses2 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_saveRenderPasses2() {
      ::grpc::Service::MarkMethodRawCallback(55,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->saveRenderPasses2(context, request, response); }));
    }
    ~WithRawCallbackMethod_saveRenderPasses2() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status saveRenderPasses2(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_saveRenderPasses2Request* /*request*/, ::octaneapi::ApiRenderEngine_saveRenderPasses2Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* saveRenderPasses2(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_saveRenderPassesMultiExr : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_saveRenderPassesMultiExr() {
      ::grpc::Service::MarkMethodRawCallback(56,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->saveRenderPassesMultiExr(context, request, response); }));
    }
    ~WithRawCallbackMethod_saveRenderPassesMultiExr() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status saveRenderPassesMultiExr(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExrRequest* /*request*/, ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExrResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* saveRenderPassesMultiExr(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_saveRenderPassesMultiExr1 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_saveRenderPassesMultiExr1() {
      ::grpc::Service::MarkMethodRawCallback(57,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->saveRenderPassesMultiExr1(context, request, response); }));
    }
    ~WithRawCallbackMethod_saveRenderPassesMultiExr1() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status saveRenderPassesMultiExr1(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExr1Request* /*request*/, ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExr1Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* saveRenderPassesMultiExr1(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_saveRenderPassesDeepExr : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_saveRenderPassesDeepExr() {
      ::grpc::Service::MarkMethodRawCallback(58,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->saveRenderPassesDeepExr(context, request, response); }));
    }
    ~WithRawCallbackMethod_saveRenderPassesDeepExr() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status saveRenderPassesDeepExr(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_saveRenderPassesDeepExrRequest* /*request*/, ::octaneapi::ApiRenderEngine_saveRenderPassesDeepExrResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* saveRenderPassesDeepExr(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_deepImageEnabled : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_deepImageEnabled() {
      ::grpc::Service::MarkMethodRawCallback(59,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->deepImageEnabled(context, request, response); }));
    }
    ~WithRawCallbackMethod_deepImageEnabled() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status deepImageEnabled(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_deepImageEnabledRequest* /*request*/, ::octaneapi::ApiRenderEngine_deepImageEnabledResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* deepImageEnabled(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_deepImageEnabled1 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_deepImageEnabled1() {
      ::grpc::Service::MarkMethodRawCallback(60,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->deepImageEnabled1(context, request, response); }));
    }
    ~WithRawCallbackMethod_deepImageEnabled1() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status deepImageEnabled1(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_deepImageEnabled1Request* /*request*/, ::octaneapi::ApiRenderEngine_deepImageEnabled1Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* deepImageEnabled1(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_deepPassesEnabled : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_deepPassesEnabled() {
      ::grpc::Service::MarkMethodRawCallback(61,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->deepPassesEnabled(context, request, response); }));
    }
    ~WithRawCallbackMethod_deepPassesEnabled() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status deepPassesEnabled(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_deepPassesEnabledRequest* /*request*/, ::octaneapi::ApiRenderEngine_deepPassesEnabledResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* deepPassesEnabled(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_canSaveDeepImage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_canSaveDeepImage() {
      ::grpc::Service::MarkMethodRawCallback(62,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->canSaveDeepImage(context, request, response); }));
    }
    ~WithRawCallbackMethod_canSaveDeepImage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status canSaveDeepImage(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_canSaveDeepImageRequest* /*request*/, ::octaneapi::ApiRenderEngine_canSaveDeepImageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* canSaveDeepImage(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_saveDeepImage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_saveDeepImage() {
      ::grpc::Service::MarkMethodRawCallback(63,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->saveDeepImage(context, request, response); }));
    }
    ~WithRawCallbackMethod_saveDeepImage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status saveDeepImage(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_saveDeepImageRequest* /*request*/, ::octaneapi::ApiRenderEngine_saveDeepImageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* saveDeepImage(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_saveRenderState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_saveRenderState() {
      ::grpc::Service::MarkMethodRawCallback(64,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->saveRenderState(context, request, response); }));
    }
    ~WithRawCallbackMethod_saveRenderState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status saveRenderState(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_saveRenderStateRequest* /*request*/, ::octaneapi::ApiRenderEngine_saveRenderStateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* saveRenderState(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_loadRenderState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_loadRenderState() {
      ::grpc::Service::MarkMethodRawCallback(65,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->loadRenderState(context, request, response); }));
    }
    ~WithRawCallbackMethod_loadRenderState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status loadRenderState(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_loadRenderStateRequest* /*request*/, ::octaneapi::ApiRenderEngine_loadRenderStateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* loadRenderState(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_previewMaterial : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_previewMaterial() {
      ::grpc::Service::MarkMethodRawCallback(66,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->previewMaterial(context, request, response); }));
    }
    ~WithRawCallbackMethod_previewMaterial() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status previewMaterial(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_previewMaterialRequest* /*request*/, ::octaneapi::ApiRenderEngine_previewMaterialResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* previewMaterial(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_previewMaterialHdr : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_previewMaterialHdr() {
      ::grpc::Service::MarkMethodRawCallback(67,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->previewMaterialHdr(context, request, response); }));
    }
    ~WithRawCallbackMethod_previewMaterialHdr() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status previewMaterialHdr(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_previewMaterialHdrRequest* /*request*/, ::octaneapi::ApiRenderEngine_previewMaterialHdrResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* previewMaterialHdr(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_previewMaterial1 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_previewMaterial1() {
      ::grpc::Service::MarkMethodRawCallback(68,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->previewMaterial1(context, request, response); }));
    }
    ~WithRawCallbackMethod_previewMaterial1() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status previewMaterial1(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_previewMaterial1Request* /*request*/, ::octaneapi::ApiRenderEngine_previewMaterial1Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* previewMaterial1(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_getMemoryUsage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_getMemoryUsage() {
      ::grpc::Service::MarkMethodRawCallback(69,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->getMemoryUsage(context, request, response); }));
    }
    ~WithRawCallbackMethod_getMemoryUsage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getMemoryUsage(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getMemoryUsageRequest* /*request*/, ::octaneapi::ApiRenderEngine_getMemoryUsageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getMemoryUsage(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_getResourceStatistics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_getResourceStatistics() {
      ::grpc::Service::MarkMethodRawCallback(70,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->getResourceStatistics(context, request, response); }));
    }
    ~WithRawCallbackMethod_getResourceStatistics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getResourceStatistics(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getResourceStatisticsRequest* /*request*/, ::octaneapi::ApiRenderEngine_getResourceStatisticsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getResourceStatistics(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_getGeometryStatistics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_getGeometryStatistics() {
      ::grpc::Service::MarkMethodRawCallback(71,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->getGeometryStatistics(context, request, response); }));
    }
    ~WithRawCallbackMethod_getGeometryStatistics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getGeometryStatistics(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getGeometryStatisticsRequest* /*request*/, ::octaneapi::ApiRenderEngine_getGeometryStatisticsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getGeometryStatistics(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_getTexturesStatistics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_getTexturesStatistics() {
      ::grpc::Service::MarkMethodRawCallback(72,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->getTexturesStatistics(context, request, response); }));
    }
    ~WithRawCallbackMethod_getTexturesStatistics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getTexturesStatistics(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getTexturesStatisticsRequest* /*request*/, ::octaneapi::ApiRenderEngine_getTexturesStatisticsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getTexturesStatistics(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_getSceneBounds : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_getSceneBounds() {
      ::grpc::Service::MarkMethodRawCallback(73,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->getSceneBounds(context, request, response); }));
    }
    ~WithRawCallbackMethod_getSceneBounds() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getSceneBounds(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getSceneBoundsRequest* /*request*/, ::octaneapi::ApiRenderEngine_getSceneBoundsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getSceneBounds(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_getDeviceCount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_getDeviceCount() {
      ::grpc::Service::MarkMethodRawCallback(74,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->getDeviceCount(context, request, response); }));
    }
    ~WithRawCallbackMethod_getDeviceCount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getDeviceCount(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getDeviceCountRequest* /*request*/, ::octaneapi::ApiRenderEngine_getDeviceCountResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getDeviceCount(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_getDeviceComputeModel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_getDeviceComputeModel() {
      ::grpc::Service::MarkMethodRawCallback(75,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->getDeviceComputeModel(context, request, response); }));
    }
    ~WithRawCallbackMethod_getDeviceComputeModel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getDeviceComputeModel(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getDeviceComputeModelRequest* /*request*/, ::octaneapi::ApiRenderEngine_getDeviceComputeModelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getDeviceComputeModel(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_getDeviceName : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_getDeviceName() {
      ::grpc::Service::MarkMethodRawCallback(76,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->getDeviceName(context, request, response); }));
    }
    ~WithRawCallbackMethod_getDeviceName() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getDeviceName(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getDeviceNameRequest* /*request*/, ::octaneapi::ApiRenderEngine_getDeviceNameResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getDeviceName(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_isSupportedDevice : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_isSupportedDevice() {
      ::grpc::Service::MarkMethodRawCallback(77,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->isSupportedDevice(context, request, response); }));
    }
    ~WithRawCallbackMethod_isSupportedDevice() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isSupportedDevice(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_isSupportedDeviceRequest* /*request*/, ::octaneapi::ApiRenderEngine_isSupportedDeviceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* isSupportedDevice(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_deviceCanRender : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_deviceCanRender() {
      ::grpc::Service::MarkMethodRawCallback(78,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->deviceCanRender(context, request, response); }));
    }
    ~WithRawCallbackMethod_deviceCanRender() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status deviceCanRender(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_deviceCanRenderRequest* /*request*/, ::octaneapi::ApiRenderEngine_deviceCanRenderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* deviceCanRender(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_deviceCanDenoise : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_deviceCanDenoise() {
      ::grpc::Service::MarkMethodRawCallback(79,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->deviceCanDenoise(context, request, response); }));
    }
    ~WithRawCallbackMethod_deviceCanDenoise() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status deviceCanDenoise(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_deviceCanDenoiseRequest* /*request*/, ::octaneapi::ApiRenderEngine_deviceCanDenoiseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* deviceCanDenoise(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_deviceSupportsHardwareRayTracing : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_deviceSupportsHardwareRayTracing() {
      ::grpc::Service::MarkMethodRawCallback(80,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->deviceSupportsHardwareRayTracing(context, request, response); }));
    }
    ~WithRawCallbackMethod_deviceSupportsHardwareRayTracing() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status deviceSupportsHardwareRayTracing(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_deviceSupportsHardwareRayTracingRequest* /*request*/, ::octaneapi::ApiRenderEngine_deviceSupportsHardwareRayTracingResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* deviceSupportsHardwareRayTracing(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_deviceSharedSurfaceInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_deviceSharedSurfaceInfo() {
      ::grpc::Service::MarkMethodRawCallback(81,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->deviceSharedSurfaceInfo(context, request, response); }));
    }
    ~WithRawCallbackMethod_deviceSharedSurfaceInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status deviceSharedSurfaceInfo(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_deviceSharedSurfaceInfoRequest* /*request*/, ::octaneapi::ApiRenderEngine_deviceSharedSurfaceInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* deviceSharedSurfaceInfo(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_getAvailablePeerToPeerPairs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_getAvailablePeerToPeerPairs() {
      ::grpc::Service::MarkMethodRawCallback(82,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->getAvailablePeerToPeerPairs(context, request, response); }));
    }
    ~WithRawCallbackMethod_getAvailablePeerToPeerPairs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getAvailablePeerToPeerPairs(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getAvailablePeerToPeerPairsRequest* /*request*/, ::octaneapi::ApiRenderEngine_getAvailablePeerToPeerPairsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getAvailablePeerToPeerPairs(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_setDevicesActivity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_setDevicesActivity() {
      ::grpc::Service::MarkMethodRawCallback(83,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->setDevicesActivity(context, request, response); }));
    }
    ~WithRawCallbackMethod_setDevicesActivity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setDevicesActivity(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setDevicesActivityRequest* /*request*/, ::octaneapi::ApiRenderEngine_setDevicesActivityResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* setDevicesActivity(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_isDeviceUsedForRendering : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_isDeviceUsedForRendering() {
      ::grpc::Service::MarkMethodRawCallback(84,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->isDeviceUsedForRendering(context, request, response); }));
    }
    ~WithRawCallbackMethod_isDeviceUsedForRendering() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isDeviceUsedForRendering(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_isDeviceUsedForRenderingRequest* /*request*/, ::octaneapi::ApiRenderEngine_isDeviceUsedForRenderingResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* isDeviceUsedForRendering(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_deviceUsesPriority : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_deviceUsesPriority() {
      ::grpc::Service::MarkMethodRawCallback(85,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->deviceUsesPriority(context, request, response); }));
    }
    ~WithRawCallbackMethod_deviceUsesPriority() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status deviceUsesPriority(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_deviceUsesPriorityRequest* /*request*/, ::octaneapi::ApiRenderEngine_deviceUsesPriorityResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* deviceUsesPriority(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_deviceUsesHardwareRayTracing : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_deviceUsesHardwareRayTracing() {
      ::grpc::Service::MarkMethodRawCallback(86,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->deviceUsesHardwareRayTracing(context, request, response); }));
    }
    ~WithRawCallbackMethod_deviceUsesHardwareRayTracing() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status deviceUsesHardwareRayTracing(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_deviceUsesHardwareRayTracingRequest* /*request*/, ::octaneapi::ApiRenderEngine_deviceUsesHardwareRayTracingResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* deviceUsesHardwareRayTracing(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_imageDeviceIndex : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_imageDeviceIndex() {
      ::grpc::Service::MarkMethodRawCallback(87,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->imageDeviceIndex(context, request, response); }));
    }
    ~WithRawCallbackMethod_imageDeviceIndex() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status imageDeviceIndex(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_imageDeviceIndexRequest* /*request*/, ::octaneapi::ApiRenderEngine_imageDeviceIndexResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* imageDeviceIndex(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_isDeviceUsedForDenoising : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_isDeviceUsedForDenoising() {
      ::grpc::Service::MarkMethodRawCallback(88,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->isDeviceUsedForDenoising(context, request, response); }));
    }
    ~WithRawCallbackMethod_isDeviceUsedForDenoising() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isDeviceUsedForDenoising(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_isDeviceUsedForDenoisingRequest* /*request*/, ::octaneapi::ApiRenderEngine_isDeviceUsedForDenoisingResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* isDeviceUsedForDenoising(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_renderPriority : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_renderPriority() {
      ::grpc::Service::MarkMethodRawCallback(89,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->renderPriority(context, request, response); }));
    }
    ~WithRawCallbackMethod_renderPriority() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status renderPriority(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_renderPriorityRequest* /*request*/, ::octaneapi::ApiRenderEngine_renderPriorityResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* renderPriority(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_setRenderPriority : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_setRenderPriority() {
      ::grpc::Service::MarkMethodRawCallback(90,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->setRenderPriority(context, request, response); }));
    }
    ~WithRawCallbackMethod_setRenderPriority() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setRenderPriority(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setRenderPriorityRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* setRenderPriority(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_currentPeerToPeerGroups : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_currentPeerToPeerGroups() {
      ::grpc::Service::MarkMethodRawCallback(91,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->currentPeerToPeerGroups(context, request, response); }));
    }
    ~WithRawCallbackMethod_currentPeerToPeerGroups() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status currentPeerToPeerGroups(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_currentPeerToPeerGroupsRequest* /*request*/, ::octaneapi::ApiRenderEngine_currentPeerToPeerGroupsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* currentPeerToPeerGroups(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_hardwareRayTracingEnabled : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_hardwareRayTracingEnabled() {
      ::grpc::Service::MarkMethodRawCallback(92,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->hardwareRayTracingEnabled(context, request, response); }));
    }
    ~WithRawCallbackMethod_hardwareRayTracingEnabled() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status hardwareRayTracingEnabled(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_hardwareRayTracingEnabledRequest* /*request*/, ::octaneapi::ApiRenderEngine_hardwareRayTracingEnabledResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* hardwareRayTracingEnabled(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_openDeviceSettings : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_openDeviceSettings() {
      ::grpc::Service::MarkMethodRawCallback(93,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->openDeviceSettings(context, request, response); }));
    }
    ~WithRawCallbackMethod_openDeviceSettings() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status openDeviceSettings(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_openDeviceSettingsRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* openDeviceSettings(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_renderDeviceState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_renderDeviceState() {
      ::grpc::Service::MarkMethodRawCallback(94,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->renderDeviceState(context, request, response); }));
    }
    ~WithRawCallbackMethod_renderDeviceState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status renderDeviceState(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_renderDeviceStateRequest* /*request*/, ::octaneapi::ApiRenderEngine_renderDeviceStateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* renderDeviceState(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_renderDeviceErrorCode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_renderDeviceErrorCode() {
      ::grpc::Service::MarkMethodRawCallback(95,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->renderDeviceErrorCode(context, request, response); }));
    }
    ~WithRawCallbackMethod_renderDeviceErrorCode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status renderDeviceErrorCode(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_renderDeviceErrorCodeRequest* /*request*/, ::octaneapi::ApiRenderEngine_renderDeviceErrorCodeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* renderDeviceErrorCode(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_errorcodeToString : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_errorcodeToString() {
      ::grpc::Service::MarkMethodRawCallback(96,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->errorcodeToString(context, request, response); }));
    }
    ~WithRawCallbackMethod_errorcodeToString() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status errorcodeToString(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_errorcodeToStringRequest* /*request*/, ::octaneapi::ApiRenderEngine_errorcodeToStringResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* errorcodeToString(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_renderDeviceErrorMessage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_renderDeviceErrorMessage() {
      ::grpc::Service::MarkMethodRawCallback(97,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->renderDeviceErrorMessage(context, request, response); }));
    }
    ~WithRawCallbackMethod_renderDeviceErrorMessage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status renderDeviceErrorMessage(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_renderDeviceErrorMessageRequest* /*request*/, ::octaneapi::ApiRenderEngine_renderDeviceErrorMessageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* renderDeviceErrorMessage(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_saveRenderDeviceConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_saveRenderDeviceConfig() {
      ::grpc::Service::MarkMethodRawCallback(98,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->saveRenderDeviceConfig(context, request, response); }));
    }
    ~WithRawCallbackMethod_saveRenderDeviceConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status saveRenderDeviceConfig(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_saveRenderDeviceConfigRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* saveRenderDeviceConfig(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_outOfCoreEnabled : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_outOfCoreEnabled() {
      ::grpc::Service::MarkMethodRawCallback(99,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->outOfCoreEnabled(context, request, response); }));
    }
    ~WithRawCallbackMethod_outOfCoreEnabled() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status outOfCoreEnabled(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_outOfCoreEnabledRequest* /*request*/, ::octaneapi::ApiRenderEngine_outOfCoreEnabledResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* outOfCoreEnabled(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_enableOutOfCore : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_enableOutOfCore() {
      ::grpc::Service::MarkMethodRawCallback(100,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->enableOutOfCore(context, request, response); }));
    }
    ~WithRawCallbackMethod_enableOutOfCore() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status enableOutOfCore(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_enableOutOfCoreRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* enableOutOfCore(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_disableOutOfCore : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_disableOutOfCore() {
      ::grpc::Service::MarkMethodRawCallback(101,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->disableOutOfCore(context, request, response); }));
    }
    ~WithRawCallbackMethod_disableOutOfCore() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status disableOutOfCore(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_disableOutOfCoreRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* disableOutOfCore(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_getOutOfCoreMemoryUsage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_getOutOfCoreMemoryUsage() {
      ::grpc::Service::MarkMethodRawCallback(102,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->getOutOfCoreMemoryUsage(context, request, response); }));
    }
    ~WithRawCallbackMethod_getOutOfCoreMemoryUsage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getOutOfCoreMemoryUsage(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getOutOfCoreMemoryUsageRequest* /*request*/, ::octaneapi::ApiRenderEngine_getOutOfCoreMemoryUsageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getOutOfCoreMemoryUsage(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_setGpuHeadroom : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_setGpuHeadroom() {
      ::grpc::Service::MarkMethodRawCallback(103,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->setGpuHeadroom(context, request, response); }));
    }
    ~WithRawCallbackMethod_setGpuHeadroom() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setGpuHeadroom(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setGpuHeadroomRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* setGpuHeadroom(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_getGpuHeadroom : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_getGpuHeadroom() {
      ::grpc::Service::MarkMethodRawCallback(104,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->getGpuHeadroom(context, request, response); }));
    }
    ~WithRawCallbackMethod_getGpuHeadroom() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getGpuHeadroom(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getGpuHeadroomRequest* /*request*/, ::octaneapi::ApiRenderEngine_getGpuHeadroomResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getGpuHeadroom(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_setCoreLimit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_setCoreLimit() {
      ::grpc::Service::MarkMethodRawCallback(105,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->setCoreLimit(context, request, response); }));
    }
    ~WithRawCallbackMethod_setCoreLimit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setCoreLimit(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setCoreLimitRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* setCoreLimit(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_disableCoreLimit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_disableCoreLimit() {
      ::grpc::Service::MarkMethodRawCallback(106,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->disableCoreLimit(context, request, response); }));
    }
    ~WithRawCallbackMethod_disableCoreLimit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status disableCoreLimit(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_disableCoreLimitRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* disableCoreLimit(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_registerInputSharedSurface : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_registerInputSharedSurface() {
      ::grpc::Service::MarkMethodRawCallback(107,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->registerInputSharedSurface(context, request, response); }));
    }
    ~WithRawCallbackMethod_registerInputSharedSurface() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status registerInputSharedSurface(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_registerInputSharedSurfaceRequest* /*request*/, ::octaneapi::ApiRenderEngine_registerInputSharedSurfaceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* registerInputSharedSurface(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_unregisterInputSharedSurface : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_unregisterInputSharedSurface() {
      ::grpc::Service::MarkMethodRawCallback(108,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->unregisterInputSharedSurface(context, request, response); }));
    }
    ~WithRawCallbackMethod_unregisterInputSharedSurface() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status unregisterInputSharedSurface(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_unregisterInputSharedSurfaceRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* unregisterInputSharedSurface(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_triggerAsyncTonemap : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_triggerAsyncTonemap() {
      ::grpc::Service::MarkMethodRawCallback(109,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->triggerAsyncTonemap(context, request, response); }));
    }
    ~WithRawCallbackMethod_triggerAsyncTonemap() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status triggerAsyncTonemap(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_triggerAsyncTonemapRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* triggerAsyncTonemap(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_setSharedSurfaceOutputType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_setSharedSurfaceOutputType() {
      ::grpc::Service::MarkMethodRawCallback(110,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->setSharedSurfaceOutputType(context, request, response); }));
    }
    ~WithRawCallbackMethod_setSharedSurfaceOutputType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setSharedSurfaceOutputType(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setSharedSurfaceOutputTypeRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* setSharedSurfaceOutputType(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_getSharedSurfaceOutputType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_getSharedSurfaceOutputType() {
      ::grpc::Service::MarkMethodRawCallback(111,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->getSharedSurfaceOutputType(context, request, response); }));
    }
    ~WithRawCallbackMethod_getSharedSurfaceOutputType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getSharedSurfaceOutputType(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getSharedSurfaceOutputTypeRequest* /*request*/, ::octaneapi::ApiRenderEngine_getSharedSurfaceOutputTypeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getSharedSurfaceOutputType(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_getRealTime : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_getRealTime() {
      ::grpc::Service::MarkMethodRawCallback(112,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->getRealTime(context, request, response); }));
    }
    ~WithRawCallbackMethod_getRealTime() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getRealTime(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getRealTimeRequest* /*request*/, ::octaneapi::ApiRenderEngine_getRealTimeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getRealTime(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_pauseRendering : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_pauseRendering() {
      ::grpc::Service::MarkMethodRawCallback(113,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->pauseRendering(context, request, response); }));
    }
    ~WithRawCallbackMethod_pauseRendering() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status pauseRendering(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_pauseRenderingRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* pauseRendering(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_continueRendering : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_continueRendering() {
      ::grpc::Service::MarkMethodRawCallback(114,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->continueRendering(context, request, response); }));
    }
    ~WithRawCallbackMethod_continueRendering() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status continueRendering(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_continueRenderingRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* continueRendering(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_isRenderingPaused : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_isRenderingPaused() {
      ::grpc::Service::MarkMethodRawCallback(115,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->isRenderingPaused(context, request, response); }));
    }
    ~WithRawCallbackMethod_isRenderingPaused() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isRenderingPaused(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_isRenderingPausedRequest* /*request*/, ::octaneapi::ApiRenderEngine_isRenderingPausedResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* isRenderingPaused(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_restartRendering : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_restartRendering() {
      ::grpc::Service::MarkMethodRawCallback(116,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->restartRendering(context, request, response); }));
    }
    ~WithRawCallbackMethod_restartRendering() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status restartRendering(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_restartRenderingRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* restartRendering(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_stopRendering : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_stopRendering() {
      ::grpc::Service::MarkMethodRawCallback(117,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->stopRendering(context, request, response); }));
    }
    ~WithRawCallbackMethod_stopRendering() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status stopRendering(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_stopRenderingRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* stopRendering(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_pick : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_pick() {
      ::grpc::Service::MarkMethodRawCallback(118,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->pick(context, request, response); }));
    }
    ~WithRawCallbackMethod_pick() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status pick(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_pickRequest* /*request*/, ::octaneapi::ApiRenderEngine_pickResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* pick(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_pickWhitePoint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_pickWhitePoint() {
      ::grpc::Service::MarkMethodRawCallback(119,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->pickWhitePoint(context, request, response); }));
    }
    ~WithRawCallbackMethod_pickWhitePoint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status pickWhitePoint(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_pickWhitePointRequest* /*request*/, ::octaneapi::ApiRenderEngine_pickWhitePointResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* pickWhitePoint(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_pickImagerWhitePoint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_pickImagerWhitePoint() {
      ::grpc::Service::MarkMethodRawCallback(120,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->pickImagerWhitePoint(context, request, response); }));
    }
    ~WithRawCallbackMethod_pickImagerWhitePoint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status pickImagerWhitePoint(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_pickImagerWhitePointRequest* /*request*/, ::octaneapi::ApiRenderEngine_pickImagerWhitePointResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* pickImagerWhitePoint(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_isOutputAovWhitePointPickable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_isOutputAovWhitePointPickable() {
      ::grpc::Service::MarkMethodRawCallback(121,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->isOutputAovWhitePointPickable(context, request, response); }));
    }
    ~WithRawCallbackMethod_isOutputAovWhitePointPickable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isOutputAovWhitePointPickable(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_isOutputAovWhitePointPickableRequest* /*request*/, ::octaneapi::ApiRenderEngine_isOutputAovWhitePointPickableResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* isOutputAovWhitePointPickable(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_pickOutputAovWhitePoint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_pickOutputAovWhitePoint() {
      ::grpc::Service::MarkMethodRawCallback(122,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->pickOutputAovWhitePoint(context, request, response); }));
    }
    ~WithRawCallbackMethod_pickOutputAovWhitePoint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status pickOutputAovWhitePoint(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_pickOutputAovWhitePointRequest* /*request*/, ::octaneapi::ApiRenderEngine_pickOutputAovWhitePointResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* pickOutputAovWhitePoint(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_pickCryptomatteMatte : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_pickCryptomatteMatte() {
      ::grpc::Service::MarkMethodRawCallback(123,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->pickCryptomatteMatte(context, request, response); }));
    }
    ~WithRawCallbackMethod_pickCryptomatteMatte() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status pickCryptomatteMatte(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_pickCryptomatteMatteRequest* /*request*/, ::octaneapi::ApiRenderEngine_pickCryptomatteMatteResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* pickCryptomatteMatte(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_modifyCryptomatteMatteSelection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_modifyCryptomatteMatteSelection() {
      ::grpc::Service::MarkMethodRawCallback(124,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->modifyCryptomatteMatteSelection(context, request, response); }));
    }
    ~WithRawCallbackMethod_modifyCryptomatteMatteSelection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status modifyCryptomatteMatteSelection(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_modifyCryptomatteMatteSelectionRequest* /*request*/, ::octaneapi::ApiRenderEngine_modifyCryptomatteMatteSelectionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* modifyCryptomatteMatteSelection(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_toString : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_toString() {
      ::grpc::Service::MarkMethodRawCallback(125,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->toString(context, request, response); }));
    }
    ~WithRawCallbackMethod_toString() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status toString(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_toStringRequest* /*request*/, ::octaneapi::ApiRenderEngine_toStringResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* toString(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_getDevicePciIds : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_getDevicePciIds() {
      ::grpc::Service::MarkMethodRawCallback(126,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->getDevicePciIds(context, request, response); }));
    }
    ~WithRawCallbackMethod_getDevicePciIds() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getDevicePciIds(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getDevicePciIdsRequest* /*request*/, ::octaneapi::ApiRenderEngine_getDevicePciIdsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getDevicePciIds(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_setRenderTargetNode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_setRenderTargetNode() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_setRenderTargetNodeRequest, ::octaneapi::ApiRenderEngine_setRenderTargetNodeResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_setRenderTargetNodeRequest, ::octaneapi::ApiRenderEngine_setRenderTargetNodeResponse>* streamer) {
                       return this->StreamedsetRenderTargetNode(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_setRenderTargetNode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status setRenderTargetNode(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setRenderTargetNodeRequest* /*request*/, ::octaneapi::ApiRenderEngine_setRenderTargetNodeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedsetRenderTargetNode(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_setRenderTargetNodeRequest,::octaneapi::ApiRenderEngine_setRenderTargetNodeResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_getRenderTargetNode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_getRenderTargetNode() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_getRenderTargetNodeRequest, ::octaneapi::ApiRenderEngine_getRenderTargetNodeResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_getRenderTargetNodeRequest, ::octaneapi::ApiRenderEngine_getRenderTargetNodeResponse>* streamer) {
                       return this->StreamedgetRenderTargetNode(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_getRenderTargetNode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status getRenderTargetNode(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getRenderTargetNodeRequest* /*request*/, ::octaneapi::ApiRenderEngine_getRenderTargetNodeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedgetRenderTargetNode(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_getRenderTargetNodeRequest,::octaneapi::ApiRenderEngine_getRenderTargetNodeResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_getRenderGeometryNode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_getRenderGeometryNode() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_getRenderGeometryNodeRequest, ::octaneapi::ApiRenderEngine_getRenderGeometryNodeResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_getRenderGeometryNodeRequest, ::octaneapi::ApiRenderEngine_getRenderGeometryNodeResponse>* streamer) {
                       return this->StreamedgetRenderGeometryNode(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_getRenderGeometryNode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status getRenderGeometryNode(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getRenderGeometryNodeRequest* /*request*/, ::octaneapi::ApiRenderEngine_getRenderGeometryNodeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedgetRenderGeometryNode(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_getRenderGeometryNodeRequest,::octaneapi::ApiRenderEngine_getRenderGeometryNodeResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_getRenderCameraNode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_getRenderCameraNode() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_getRenderCameraNodeRequest, ::octaneapi::ApiRenderEngine_getRenderCameraNodeResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_getRenderCameraNodeRequest, ::octaneapi::ApiRenderEngine_getRenderCameraNodeResponse>* streamer) {
                       return this->StreamedgetRenderCameraNode(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_getRenderCameraNode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status getRenderCameraNode(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getRenderCameraNodeRequest* /*request*/, ::octaneapi::ApiRenderEngine_getRenderCameraNodeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedgetRenderCameraNode(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_getRenderCameraNodeRequest,::octaneapi::ApiRenderEngine_getRenderCameraNodeResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_setRenderRegion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_setRenderRegion() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_setRenderRegionRequest, ::google::protobuf::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_setRenderRegionRequest, ::google::protobuf::Empty>* streamer) {
                       return this->StreamedsetRenderRegion(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_setRenderRegion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status setRenderRegion(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setRenderRegionRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedsetRenderRegion(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_setRenderRegionRequest,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_getRenderRegion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_getRenderRegion() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_getRenderRegionRequest, ::octaneapi::ApiRenderEngine_getRenderRegionResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_getRenderRegionRequest, ::octaneapi::ApiRenderEngine_getRenderRegionResponse>* streamer) {
                       return this->StreamedgetRenderRegion(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_getRenderRegion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status getRenderRegion(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getRenderRegionRequest* /*request*/, ::octaneapi::ApiRenderEngine_getRenderRegionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedgetRenderRegion(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_getRenderRegionRequest,::octaneapi::ApiRenderEngine_getRenderRegionResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_setAsyncTonemapParams : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_setAsyncTonemapParams() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_setAsyncTonemapParamsRequest, ::google::protobuf::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_setAsyncTonemapParamsRequest, ::google::protobuf::Empty>* streamer) {
                       return this->StreamedsetAsyncTonemapParams(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_setAsyncTonemapParams() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status setAsyncTonemapParams(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setAsyncTonemapParamsRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedsetAsyncTonemapParams(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_setAsyncTonemapParamsRequest,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_setAsyncTonemapParams1 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_setAsyncTonemapParams1() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_setAsyncTonemapParams1Request, ::google::protobuf::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_setAsyncTonemapParams1Request, ::google::protobuf::Empty>* streamer) {
                       return this->StreamedsetAsyncTonemapParams1(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_setAsyncTonemapParams1() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status setAsyncTonemapParams1(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setAsyncTonemapParams1Request* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedsetAsyncTonemapParams1(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_setAsyncTonemapParams1Request,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_asyncTonemapBufferType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_asyncTonemapBufferType() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_asyncTonemapBufferTypeRequest, ::octaneapi::ApiRenderEngine_asyncTonemapBufferTypeResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_asyncTonemapBufferTypeRequest, ::octaneapi::ApiRenderEngine_asyncTonemapBufferTypeResponse>* streamer) {
                       return this->StreamedasyncTonemapBufferType(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_asyncTonemapBufferType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status asyncTonemapBufferType(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_asyncTonemapBufferTypeRequest* /*request*/, ::octaneapi::ApiRenderEngine_asyncTonemapBufferTypeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedasyncTonemapBufferType(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_asyncTonemapBufferTypeRequest,::octaneapi::ApiRenderEngine_asyncTonemapBufferTypeResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_asyncTonemapCryptomatteFalseColor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_asyncTonemapCryptomatteFalseColor() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_asyncTonemapCryptomatteFalseColorRequest, ::octaneapi::ApiRenderEngine_asyncTonemapCryptomatteFalseColorResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_asyncTonemapCryptomatteFalseColorRequest, ::octaneapi::ApiRenderEngine_asyncTonemapCryptomatteFalseColorResponse>* streamer) {
                       return this->StreamedasyncTonemapCryptomatteFalseColor(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_asyncTonemapCryptomatteFalseColor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status asyncTonemapCryptomatteFalseColor(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_asyncTonemapCryptomatteFalseColorRequest* /*request*/, ::octaneapi::ApiRenderEngine_asyncTonemapCryptomatteFalseColorResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedasyncTonemapCryptomatteFalseColor(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_asyncTonemapCryptomatteFalseColorRequest,::octaneapi::ApiRenderEngine_asyncTonemapCryptomatteFalseColorResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_asyncTonemapOutputColorSpaceInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_asyncTonemapOutputColorSpaceInfo() {
      ::grpc::Service::MarkMethodStreamed(10,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_asyncTonemapOutputColorSpaceInfoRequest, ::octaneapi::ApiRenderEngine_asyncTonemapOutputColorSpaceInfoResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_asyncTonemapOutputColorSpaceInfoRequest, ::octaneapi::ApiRenderEngine_asyncTonemapOutputColorSpaceInfoResponse>* streamer) {
                       return this->StreamedasyncTonemapOutputColorSpaceInfo(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_asyncTonemapOutputColorSpaceInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status asyncTonemapOutputColorSpaceInfo(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_asyncTonemapOutputColorSpaceInfoRequest* /*request*/, ::octaneapi::ApiRenderEngine_asyncTonemapOutputColorSpaceInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedasyncTonemapOutputColorSpaceInfo(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_asyncTonemapOutputColorSpaceInfoRequest,::octaneapi::ApiRenderEngine_asyncTonemapOutputColorSpaceInfoResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_asyncTonemapColorSpace : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_asyncTonemapColorSpace() {
      ::grpc::Service::MarkMethodStreamed(11,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_asyncTonemapColorSpaceRequest, ::octaneapi::ApiRenderEngine_asyncTonemapColorSpaceResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_asyncTonemapColorSpaceRequest, ::octaneapi::ApiRenderEngine_asyncTonemapColorSpaceResponse>* streamer) {
                       return this->StreamedasyncTonemapColorSpace(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_asyncTonemapColorSpace() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status asyncTonemapColorSpace(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_asyncTonemapColorSpaceRequest* /*request*/, ::octaneapi::ApiRenderEngine_asyncTonemapColorSpaceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedasyncTonemapColorSpace(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_asyncTonemapColorSpaceRequest,::octaneapi::ApiRenderEngine_asyncTonemapColorSpaceResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_asyncTonemapPremultipliedAlphaType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_asyncTonemapPremultipliedAlphaType() {
      ::grpc::Service::MarkMethodStreamed(12,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_asyncTonemapPremultipliedAlphaTypeRequest, ::octaneapi::ApiRenderEngine_asyncTonemapPremultipliedAlphaTypeResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_asyncTonemapPremultipliedAlphaTypeRequest, ::octaneapi::ApiRenderEngine_asyncTonemapPremultipliedAlphaTypeResponse>* streamer) {
                       return this->StreamedasyncTonemapPremultipliedAlphaType(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_asyncTonemapPremultipliedAlphaType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status asyncTonemapPremultipliedAlphaType(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_asyncTonemapPremultipliedAlphaTypeRequest* /*request*/, ::octaneapi::ApiRenderEngine_asyncTonemapPremultipliedAlphaTypeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedasyncTonemapPremultipliedAlphaType(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_asyncTonemapPremultipliedAlphaTypeRequest,::octaneapi::ApiRenderEngine_asyncTonemapPremultipliedAlphaTypeResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_setAsyncTonemapRenderPasses : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_setAsyncTonemapRenderPasses() {
      ::grpc::Service::MarkMethodStreamed(13,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_setAsyncTonemapRenderPassesRequest, ::octaneapi::ApiRenderEngine_setAsyncTonemapRenderPassesResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_setAsyncTonemapRenderPassesRequest, ::octaneapi::ApiRenderEngine_setAsyncTonemapRenderPassesResponse>* streamer) {
                       return this->StreamedsetAsyncTonemapRenderPasses(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_setAsyncTonemapRenderPasses() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status setAsyncTonemapRenderPasses(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setAsyncTonemapRenderPassesRequest* /*request*/, ::octaneapi::ApiRenderEngine_setAsyncTonemapRenderPassesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedsetAsyncTonemapRenderPasses(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_setAsyncTonemapRenderPassesRequest,::octaneapi::ApiRenderEngine_setAsyncTonemapRenderPassesResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_asyncTonemapRenderPasses : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_asyncTonemapRenderPasses() {
      ::grpc::Service::MarkMethodStreamed(14,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_asyncTonemapRenderPassesRequest, ::google::protobuf::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_asyncTonemapRenderPassesRequest, ::google::protobuf::Empty>* streamer) {
                       return this->StreamedasyncTonemapRenderPasses(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_asyncTonemapRenderPasses() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status asyncTonemapRenderPasses(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_asyncTonemapRenderPassesRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedasyncTonemapRenderPasses(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_asyncTonemapRenderPassesRequest,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_getEnabledAovs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_getEnabledAovs() {
      ::grpc::Service::MarkMethodStreamed(15,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_getEnabledAovsRequest, ::octaneapi::ApiRenderEngine_getEnabledAovsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_getEnabledAovsRequest, ::octaneapi::ApiRenderEngine_getEnabledAovsResponse>* streamer) {
                       return this->StreamedgetEnabledAovs(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_getEnabledAovs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status getEnabledAovs(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getEnabledAovsRequest* /*request*/, ::octaneapi::ApiRenderEngine_getEnabledAovsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedgetEnabledAovs(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_getEnabledAovsRequest,::octaneapi::ApiRenderEngine_getEnabledAovsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_freeTonemapPasses : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_freeTonemapPasses() {
      ::grpc::Service::MarkMethodStreamed(16,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_freeTonemapPassesRequest, ::google::protobuf::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_freeTonemapPassesRequest, ::google::protobuf::Empty>* streamer) {
                       return this->StreamedfreeTonemapPasses(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_freeTonemapPasses() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status freeTonemapPasses(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_freeTonemapPassesRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedfreeTonemapPasses(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_freeTonemapPassesRequest,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_displayRenderPassId : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_displayRenderPassId() {
      ::grpc::Service::MarkMethodStreamed(17,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_displayRenderPassIdRequest, ::octaneapi::ApiRenderEngine_displayRenderPassIdResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_displayRenderPassIdRequest, ::octaneapi::ApiRenderEngine_displayRenderPassIdResponse>* streamer) {
                       return this->StreameddisplayRenderPassId(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_displayRenderPassId() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status displayRenderPassId(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_displayRenderPassIdRequest* /*request*/, ::octaneapi::ApiRenderEngine_displayRenderPassIdResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreameddisplayRenderPassId(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_displayRenderPassIdRequest,::octaneapi::ApiRenderEngine_displayRenderPassIdResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_setSubSampleMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_setSubSampleMode() {
      ::grpc::Service::MarkMethodStreamed(18,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_setSubSampleModeRequest, ::google::protobuf::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_setSubSampleModeRequest, ::google::protobuf::Empty>* streamer) {
                       return this->StreamedsetSubSampleMode(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_setSubSampleMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status setSubSampleMode(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setSubSampleModeRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedsetSubSampleMode(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_setSubSampleModeRequest,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_getSubSampleMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_getSubSampleMode() {
      ::grpc::Service::MarkMethodStreamed(19,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_getSubSampleModeRequest, ::octaneapi::ApiRenderEngine_getSubSampleModeResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_getSubSampleModeRequest, ::octaneapi::ApiRenderEngine_getSubSampleModeResponse>* streamer) {
                       return this->StreamedgetSubSampleMode(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_getSubSampleMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status getSubSampleMode(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getSubSampleModeRequest* /*request*/, ::octaneapi::ApiRenderEngine_getSubSampleModeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedgetSubSampleMode(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_getSubSampleModeRequest,::octaneapi::ApiRenderEngine_getSubSampleModeResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_setClayMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_setClayMode() {
      ::grpc::Service::MarkMethodStreamed(20,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_setClayModeRequest, ::google::protobuf::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_setClayModeRequest, ::google::protobuf::Empty>* streamer) {
                       return this->StreamedsetClayMode(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_setClayMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status setClayMode(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setClayModeRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedsetClayMode(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_setClayModeRequest,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_clayMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_clayMode() {
      ::grpc::Service::MarkMethodStreamed(21,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_clayModeRequest, ::octaneapi::ApiRenderEngine_clayModeResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_clayModeRequest, ::octaneapi::ApiRenderEngine_clayModeResponse>* streamer) {
                       return this->StreamedclayMode(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_clayMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status clayMode(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_clayModeRequest* /*request*/, ::octaneapi::ApiRenderEngine_clayModeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedclayMode(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_clayModeRequest,::octaneapi::ApiRenderEngine_clayModeResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_fps : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_fps() {
      ::grpc::Service::MarkMethodStreamed(22,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_fpsRequest, ::octaneapi::ApiRenderEngine_fpsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_fpsRequest, ::octaneapi::ApiRenderEngine_fpsResponse>* streamer) {
                       return this->Streamedfps(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_fps() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status fps(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_fpsRequest* /*request*/, ::octaneapi::ApiRenderEngine_fpsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedfps(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_fpsRequest,::octaneapi::ApiRenderEngine_fpsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_setFps : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_setFps() {
      ::grpc::Service::MarkMethodStreamed(23,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_setFpsRequest, ::google::protobuf::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_setFpsRequest, ::google::protobuf::Empty>* streamer) {
                       return this->StreamedsetFps(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_setFps() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status setFps(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setFpsRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedsetFps(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_setFpsRequest,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_isCompiling : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_isCompiling() {
      ::grpc::Service::MarkMethodStreamed(24,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_isCompilingRequest, ::octaneapi::ApiRenderEngine_isCompilingResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_isCompilingRequest, ::octaneapi::ApiRenderEngine_isCompilingResponse>* streamer) {
                       return this->StreamedisCompiling(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_isCompiling() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status isCompiling(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_isCompilingRequest* /*request*/, ::octaneapi::ApiRenderEngine_isCompilingResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedisCompiling(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_isCompilingRequest,::octaneapi::ApiRenderEngine_isCompilingResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_isCompressingTextures : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_isCompressingTextures() {
      ::grpc::Service::MarkMethodStreamed(25,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_isCompressingTexturesRequest, ::octaneapi::ApiRenderEngine_isCompressingTexturesResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_isCompressingTexturesRequest, ::octaneapi::ApiRenderEngine_isCompressingTexturesResponse>* streamer) {
                       return this->StreamedisCompressingTextures(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_isCompressingTextures() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status isCompressingTextures(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_isCompressingTexturesRequest* /*request*/, ::octaneapi::ApiRenderEngine_isCompressingTexturesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedisCompressingTextures(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_isCompressingTexturesRequest,::octaneapi::ApiRenderEngine_isCompressingTexturesResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_hasPendingRenderData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_hasPendingRenderData() {
      ::grpc::Service::MarkMethodStreamed(26,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_hasPendingRenderDataRequest, ::octaneapi::ApiRenderEngine_hasPendingRenderDataResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_hasPendingRenderDataRequest, ::octaneapi::ApiRenderEngine_hasPendingRenderDataResponse>* streamer) {
                       return this->StreamedhasPendingRenderData(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_hasPendingRenderData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status hasPendingRenderData(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_hasPendingRenderDataRequest* /*request*/, ::octaneapi::ApiRenderEngine_hasPendingRenderDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedhasPendingRenderData(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_hasPendingRenderDataRequest,::octaneapi::ApiRenderEngine_hasPendingRenderDataResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_getCurrentChangeLevel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_getCurrentChangeLevel() {
      ::grpc::Service::MarkMethodStreamed(27,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_getCurrentChangeLevelRequest, ::octaneapi::ApiRenderEngine_getCurrentChangeLevelResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_getCurrentChangeLevelRequest, ::octaneapi::ApiRenderEngine_getCurrentChangeLevelResponse>* streamer) {
                       return this->StreamedgetCurrentChangeLevel(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_getCurrentChangeLevel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status getCurrentChangeLevel(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getCurrentChangeLevelRequest* /*request*/, ::octaneapi::ApiRenderEngine_getCurrentChangeLevelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedgetCurrentChangeLevel(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_getCurrentChangeLevelRequest,::octaneapi::ApiRenderEngine_getCurrentChangeLevelResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_getRenderImageChangeLevel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_getRenderImageChangeLevel() {
      ::grpc::Service::MarkMethodStreamed(28,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_getRenderImageChangeLevelRequest, ::octaneapi::ApiRenderEngine_getRenderImageChangeLevelResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_getRenderImageChangeLevelRequest, ::octaneapi::ApiRenderEngine_getRenderImageChangeLevelResponse>* streamer) {
                       return this->StreamedgetRenderImageChangeLevel(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_getRenderImageChangeLevel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status getRenderImageChangeLevel(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getRenderImageChangeLevelRequest* /*request*/, ::octaneapi::ApiRenderEngine_getRenderImageChangeLevelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedgetRenderImageChangeLevel(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_getRenderImageChangeLevelRequest,::octaneapi::ApiRenderEngine_getRenderImageChangeLevelResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_getRenderRestartedChangeLevel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_getRenderRestartedChangeLevel() {
      ::grpc::Service::MarkMethodStreamed(29,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_getRenderRestartedChangeLevelRequest, ::octaneapi::ApiRenderEngine_getRenderRestartedChangeLevelResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_getRenderRestartedChangeLevelRequest, ::octaneapi::ApiRenderEngine_getRenderRestartedChangeLevelResponse>* streamer) {
                       return this->StreamedgetRenderRestartedChangeLevel(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_getRenderRestartedChangeLevel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status getRenderRestartedChangeLevel(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getRenderRestartedChangeLevelRequest* /*request*/, ::octaneapi::ApiRenderEngine_getRenderRestartedChangeLevelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedgetRenderRestartedChangeLevel(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_getRenderRestartedChangeLevelRequest,::octaneapi::ApiRenderEngine_getRenderRestartedChangeLevelResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_setAsyncUpdateCallback : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_setAsyncUpdateCallback() {
      ::grpc::Service::MarkMethodStreamed(30,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_setAsyncUpdateCallbackRequest, ::octaneapi::ApiRenderEngine_setAsyncUpdateCallbackResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_setAsyncUpdateCallbackRequest, ::octaneapi::ApiRenderEngine_setAsyncUpdateCallbackResponse>* streamer) {
                       return this->StreamedsetAsyncUpdateCallback(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_setAsyncUpdateCallback() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status setAsyncUpdateCallback(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setAsyncUpdateCallbackRequest* /*request*/, ::octaneapi::ApiRenderEngine_setAsyncUpdateCallbackResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedsetAsyncUpdateCallback(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_setAsyncUpdateCallbackRequest,::octaneapi::ApiRenderEngine_setAsyncUpdateCallbackResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_updatesAreAsync : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_updatesAreAsync() {
      ::grpc::Service::MarkMethodStreamed(31,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_updatesAreAsyncRequest, ::octaneapi::ApiRenderEngine_updatesAreAsyncResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_updatesAreAsyncRequest, ::octaneapi::ApiRenderEngine_updatesAreAsyncResponse>* streamer) {
                       return this->StreamedupdatesAreAsync(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_updatesAreAsync() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status updatesAreAsync(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_updatesAreAsyncRequest* /*request*/, ::octaneapi::ApiRenderEngine_updatesAreAsyncResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedupdatesAreAsync(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_updatesAreAsyncRequest,::octaneapi::ApiRenderEngine_updatesAreAsyncResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_isImageReady : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_isImageReady() {
      ::grpc::Service::MarkMethodStreamed(32,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_isImageReadyRequest, ::octaneapi::ApiRenderEngine_isImageReadyResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_isImageReadyRequest, ::octaneapi::ApiRenderEngine_isImageReadyResponse>* streamer) {
                       return this->StreamedisImageReady(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_isImageReady() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status isImageReady(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_isImageReadyRequest* /*request*/, ::octaneapi::ApiRenderEngine_isImageReadyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedisImageReady(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_isImageReadyRequest,::octaneapi::ApiRenderEngine_isImageReadyResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_resetImageReady : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_resetImageReady() {
      ::grpc::Service::MarkMethodStreamed(33,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_resetImageReadyRequest, ::google::protobuf::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_resetImageReadyRequest, ::google::protobuf::Empty>* streamer) {
                       return this->StreamedresetImageReady(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_resetImageReady() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status resetImageReady(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_resetImageReadyRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedresetImageReady(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_resetImageReadyRequest,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_isRenderFailure : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_isRenderFailure() {
      ::grpc::Service::MarkMethodStreamed(34,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_isRenderFailureRequest, ::octaneapi::ApiRenderEngine_isRenderFailureResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_isRenderFailureRequest, ::octaneapi::ApiRenderEngine_isRenderFailureResponse>* streamer) {
                       return this->StreamedisRenderFailure(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_isRenderFailure() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status isRenderFailure(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_isRenderFailureRequest* /*request*/, ::octaneapi::ApiRenderEngine_isRenderFailureResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedisRenderFailure(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_isRenderFailureRequest,::octaneapi::ApiRenderEngine_isRenderFailureResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_resetRenderFailure : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_resetRenderFailure() {
      ::grpc::Service::MarkMethodStreamed(35,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_resetRenderFailureRequest, ::google::protobuf::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_resetRenderFailureRequest, ::google::protobuf::Empty>* streamer) {
                       return this->StreamedresetRenderFailure(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_resetRenderFailure() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status resetRenderFailure(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_resetRenderFailureRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedresetRenderFailure(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_resetRenderFailureRequest,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_setOnTileBlendedCallback : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_setOnTileBlendedCallback() {
      ::grpc::Service::MarkMethodStreamed(36,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_setOnTileBlendedCallbackRequest, ::octaneapi::ApiRenderEngine_setOnTileBlendedCallbackResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_setOnTileBlendedCallbackRequest, ::octaneapi::ApiRenderEngine_setOnTileBlendedCallbackResponse>* streamer) {
                       return this->StreamedsetOnTileBlendedCallback(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_setOnTileBlendedCallback() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status setOnTileBlendedCallback(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setOnTileBlendedCallbackRequest* /*request*/, ::octaneapi::ApiRenderEngine_setOnTileBlendedCallbackResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedsetOnTileBlendedCallback(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_setOnTileBlendedCallbackRequest,::octaneapi::ApiRenderEngine_setOnTileBlendedCallbackResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_setOnNewStatisticsCallback : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_setOnNewStatisticsCallback() {
      ::grpc::Service::MarkMethodStreamed(37,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_setOnNewStatisticsCallbackRequest, ::octaneapi::ApiRenderEngine_setOnNewStatisticsCallbackResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_setOnNewStatisticsCallbackRequest, ::octaneapi::ApiRenderEngine_setOnNewStatisticsCallbackResponse>* streamer) {
                       return this->StreamedsetOnNewStatisticsCallback(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_setOnNewStatisticsCallback() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status setOnNewStatisticsCallback(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setOnNewStatisticsCallbackRequest* /*request*/, ::octaneapi::ApiRenderEngine_setOnNewStatisticsCallbackResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedsetOnNewStatisticsCallback(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_setOnNewStatisticsCallbackRequest,::octaneapi::ApiRenderEngine_setOnNewStatisticsCallbackResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_setOnNewImageCallback : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_setOnNewImageCallback() {
      ::grpc::Service::MarkMethodStreamed(38,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_setOnNewImageCallbackRequest, ::octaneapi::ApiRenderEngine_setOnNewImageCallbackResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_setOnNewImageCallbackRequest, ::octaneapi::ApiRenderEngine_setOnNewImageCallbackResponse>* streamer) {
                       return this->StreamedsetOnNewImageCallback(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_setOnNewImageCallback() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status setOnNewImageCallback(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setOnNewImageCallbackRequest* /*request*/, ::octaneapi::ApiRenderEngine_setOnNewImageCallbackResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedsetOnNewImageCallback(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_setOnNewImageCallbackRequest,::octaneapi::ApiRenderEngine_setOnNewImageCallbackResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_setOnOcioErrorCallback : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_setOnOcioErrorCallback() {
      ::grpc::Service::MarkMethodStreamed(39,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_setOnOcioErrorCallbackRequest, ::octaneapi::ApiRenderEngine_setOnOcioErrorCallbackResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_setOnOcioErrorCallbackRequest, ::octaneapi::ApiRenderEngine_setOnOcioErrorCallbackResponse>* streamer) {
                       return this->StreamedsetOnOcioErrorCallback(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_setOnOcioErrorCallback() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status setOnOcioErrorCallback(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setOnOcioErrorCallbackRequest* /*request*/, ::octaneapi::ApiRenderEngine_setOnOcioErrorCallbackResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedsetOnOcioErrorCallback(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_setOnOcioErrorCallbackRequest,::octaneapi::ApiRenderEngine_setOnOcioErrorCallbackResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_setOnRenderFailureCallback : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_setOnRenderFailureCallback() {
      ::grpc::Service::MarkMethodStreamed(40,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_setOnRenderFailureCallbackRequest, ::octaneapi::ApiRenderEngine_setOnRenderFailureCallbackResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_setOnRenderFailureCallbackRequest, ::octaneapi::ApiRenderEngine_setOnRenderFailureCallbackResponse>* streamer) {
                       return this->StreamedsetOnRenderFailureCallback(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_setOnRenderFailureCallback() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status setOnRenderFailureCallback(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setOnRenderFailureCallbackRequest* /*request*/, ::octaneapi::ApiRenderEngine_setOnRenderFailureCallbackResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedsetOnRenderFailureCallback(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_setOnRenderFailureCallbackRequest,::octaneapi::ApiRenderEngine_setOnRenderFailureCallbackResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_setForceCallbacksInRenderThreads : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_setForceCallbacksInRenderThreads() {
      ::grpc::Service::MarkMethodStreamed(41,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_setForceCallbacksInRenderThreadsRequest, ::google::protobuf::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_setForceCallbacksInRenderThreadsRequest, ::google::protobuf::Empty>* streamer) {
                       return this->StreamedsetForceCallbacksInRenderThreads(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_setForceCallbacksInRenderThreads() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status setForceCallbacksInRenderThreads(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setForceCallbacksInRenderThreadsRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedsetForceCallbacksInRenderThreads(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_setForceCallbacksInRenderThreadsRequest,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_grabRenderResult : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_grabRenderResult() {
      ::grpc::Service::MarkMethodStreamed(42,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_grabRenderResultRequest, ::octaneapi::ApiRenderEngine_grabRenderResultResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_grabRenderResultRequest, ::octaneapi::ApiRenderEngine_grabRenderResultResponse>* streamer) {
                       return this->StreamedgrabRenderResult(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_grabRenderResult() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status grabRenderResult(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_grabRenderResultRequest* /*request*/, ::octaneapi::ApiRenderEngine_grabRenderResultResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedgrabRenderResult(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_grabRenderResultRequest,::octaneapi::ApiRenderEngine_grabRenderResultResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_releaseRenderResult : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_releaseRenderResult() {
      ::grpc::Service::MarkMethodStreamed(43,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_releaseRenderResultRequest, ::google::protobuf::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_releaseRenderResultRequest, ::google::protobuf::Empty>* streamer) {
                       return this->StreamedreleaseRenderResult(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_releaseRenderResult() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status releaseRenderResult(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_releaseRenderResultRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedreleaseRenderResult(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_releaseRenderResultRequest,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_synchronousTonemap : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_synchronousTonemap() {
      ::grpc::Service::MarkMethodStreamed(44,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_synchronousTonemapRequest, ::octaneapi::ApiRenderEngine_synchronousTonemapResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_synchronousTonemapRequest, ::octaneapi::ApiRenderEngine_synchronousTonemapResponse>* streamer) {
                       return this->StreamedsynchronousTonemap(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_synchronousTonemap() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status synchronousTonemap(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_synchronousTonemapRequest* /*request*/, ::octaneapi::ApiRenderEngine_synchronousTonemapResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedsynchronousTonemap(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_synchronousTonemapRequest,::octaneapi::ApiRenderEngine_synchronousTonemapResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_synchronousTonemap1 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_synchronousTonemap1() {
      ::grpc::Service::MarkMethodStreamed(45,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_synchronousTonemap1Request, ::octaneapi::ApiRenderEngine_synchronousTonemap1Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_synchronousTonemap1Request, ::octaneapi::ApiRenderEngine_synchronousTonemap1Response>* streamer) {
                       return this->StreamedsynchronousTonemap1(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_synchronousTonemap1() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status synchronousTonemap1(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_synchronousTonemap1Request* /*request*/, ::octaneapi::ApiRenderEngine_synchronousTonemap1Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedsynchronousTonemap1(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_synchronousTonemap1Request,::octaneapi::ApiRenderEngine_synchronousTonemap1Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_synchronousTonemapAllRenderPasses : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_synchronousTonemapAllRenderPasses() {
      ::grpc::Service::MarkMethodStreamed(46,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPassesRequest, ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPassesResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPassesRequest, ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPassesResponse>* streamer) {
                       return this->StreamedsynchronousTonemapAllRenderPasses(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_synchronousTonemapAllRenderPasses() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status synchronousTonemapAllRenderPasses(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPassesRequest* /*request*/, ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPassesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedsynchronousTonemapAllRenderPasses(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPassesRequest,::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPassesResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_synchronousTonemapAllRenderPasses1 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_synchronousTonemapAllRenderPasses1() {
      ::grpc::Service::MarkMethodStreamed(47,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPasses1Request, ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPasses1Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPasses1Request, ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPasses1Response>* streamer) {
                       return this->StreamedsynchronousTonemapAllRenderPasses1(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_synchronousTonemapAllRenderPasses1() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status synchronousTonemapAllRenderPasses1(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPasses1Request* /*request*/, ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPasses1Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedsynchronousTonemapAllRenderPasses1(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPasses1Request,::octaneapi::ApiRenderEngine_synchronousTonemapAllRenderPasses1Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_getRenderStatistics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_getRenderStatistics() {
      ::grpc::Service::MarkMethodStreamed(48,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_getRenderStatisticsRequest, ::octaneapi::ApiRenderEngine_getRenderStatisticsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_getRenderStatisticsRequest, ::octaneapi::ApiRenderEngine_getRenderStatisticsResponse>* streamer) {
                       return this->StreamedgetRenderStatistics(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_getRenderStatistics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status getRenderStatistics(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getRenderStatisticsRequest* /*request*/, ::octaneapi::ApiRenderEngine_getRenderStatisticsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedgetRenderStatistics(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_getRenderStatisticsRequest,::octaneapi::ApiRenderEngine_getRenderStatisticsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_getRenderResultStatistics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_getRenderResultStatistics() {
      ::grpc::Service::MarkMethodStreamed(49,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_getRenderResultStatisticsRequest, ::octaneapi::ApiRenderEngine_getRenderResultStatisticsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_getRenderResultStatisticsRequest, ::octaneapi::ApiRenderEngine_getRenderResultStatisticsResponse>* streamer) {
                       return this->StreamedgetRenderResultStatistics(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_getRenderResultStatistics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status getRenderResultStatistics(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getRenderResultStatisticsRequest* /*request*/, ::octaneapi::ApiRenderEngine_getRenderResultStatisticsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedgetRenderResultStatistics(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_getRenderResultStatisticsRequest,::octaneapi::ApiRenderEngine_getRenderResultStatisticsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_saveImage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_saveImage() {
      ::grpc::Service::MarkMethodStreamed(50,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_saveImageRequest, ::octaneapi::ApiRenderEngine_saveImageResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_saveImageRequest, ::octaneapi::ApiRenderEngine_saveImageResponse>* streamer) {
                       return this->StreamedsaveImage(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_saveImage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status saveImage(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_saveImageRequest* /*request*/, ::octaneapi::ApiRenderEngine_saveImageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedsaveImage(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_saveImageRequest,::octaneapi::ApiRenderEngine_saveImageResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_saveImage1 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_saveImage1() {
      ::grpc::Service::MarkMethodStreamed(51,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_saveImage1Request, ::octaneapi::ApiRenderEngine_saveImage1Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_saveImage1Request, ::octaneapi::ApiRenderEngine_saveImage1Response>* streamer) {
                       return this->StreamedsaveImage1(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_saveImage1() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status saveImage1(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_saveImage1Request* /*request*/, ::octaneapi::ApiRenderEngine_saveImage1Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedsaveImage1(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_saveImage1Request,::octaneapi::ApiRenderEngine_saveImage1Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_saveImage2 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_saveImage2() {
      ::grpc::Service::MarkMethodStreamed(52,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_saveImage2Request, ::octaneapi::ApiRenderEngine_saveImage2Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_saveImage2Request, ::octaneapi::ApiRenderEngine_saveImage2Response>* streamer) {
                       return this->StreamedsaveImage2(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_saveImage2() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status saveImage2(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_saveImage2Request* /*request*/, ::octaneapi::ApiRenderEngine_saveImage2Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedsaveImage2(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_saveImage2Request,::octaneapi::ApiRenderEngine_saveImage2Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_saveRenderPasses : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_saveRenderPasses() {
      ::grpc::Service::MarkMethodStreamed(53,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_saveRenderPassesRequest, ::octaneapi::ApiRenderEngine_saveRenderPassesResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_saveRenderPassesRequest, ::octaneapi::ApiRenderEngine_saveRenderPassesResponse>* streamer) {
                       return this->StreamedsaveRenderPasses(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_saveRenderPasses() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status saveRenderPasses(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_saveRenderPassesRequest* /*request*/, ::octaneapi::ApiRenderEngine_saveRenderPassesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedsaveRenderPasses(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_saveRenderPassesRequest,::octaneapi::ApiRenderEngine_saveRenderPassesResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_saveRenderPasses1 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_saveRenderPasses1() {
      ::grpc::Service::MarkMethodStreamed(54,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_saveRenderPasses1Request, ::octaneapi::ApiRenderEngine_saveRenderPasses1Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_saveRenderPasses1Request, ::octaneapi::ApiRenderEngine_saveRenderPasses1Response>* streamer) {
                       return this->StreamedsaveRenderPasses1(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_saveRenderPasses1() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status saveRenderPasses1(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_saveRenderPasses1Request* /*request*/, ::octaneapi::ApiRenderEngine_saveRenderPasses1Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedsaveRenderPasses1(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_saveRenderPasses1Request,::octaneapi::ApiRenderEngine_saveRenderPasses1Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_saveRenderPasses2 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_saveRenderPasses2() {
      ::grpc::Service::MarkMethodStreamed(55,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_saveRenderPasses2Request, ::octaneapi::ApiRenderEngine_saveRenderPasses2Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_saveRenderPasses2Request, ::octaneapi::ApiRenderEngine_saveRenderPasses2Response>* streamer) {
                       return this->StreamedsaveRenderPasses2(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_saveRenderPasses2() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status saveRenderPasses2(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_saveRenderPasses2Request* /*request*/, ::octaneapi::ApiRenderEngine_saveRenderPasses2Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedsaveRenderPasses2(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_saveRenderPasses2Request,::octaneapi::ApiRenderEngine_saveRenderPasses2Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_saveRenderPassesMultiExr : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_saveRenderPassesMultiExr() {
      ::grpc::Service::MarkMethodStreamed(56,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExrRequest, ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExrResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExrRequest, ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExrResponse>* streamer) {
                       return this->StreamedsaveRenderPassesMultiExr(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_saveRenderPassesMultiExr() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status saveRenderPassesMultiExr(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExrRequest* /*request*/, ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExrResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedsaveRenderPassesMultiExr(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExrRequest,::octaneapi::ApiRenderEngine_saveRenderPassesMultiExrResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_saveRenderPassesMultiExr1 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_saveRenderPassesMultiExr1() {
      ::grpc::Service::MarkMethodStreamed(57,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExr1Request, ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExr1Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExr1Request, ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExr1Response>* streamer) {
                       return this->StreamedsaveRenderPassesMultiExr1(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_saveRenderPassesMultiExr1() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status saveRenderPassesMultiExr1(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExr1Request* /*request*/, ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExr1Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedsaveRenderPassesMultiExr1(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_saveRenderPassesMultiExr1Request,::octaneapi::ApiRenderEngine_saveRenderPassesMultiExr1Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_saveRenderPassesDeepExr : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_saveRenderPassesDeepExr() {
      ::grpc::Service::MarkMethodStreamed(58,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_saveRenderPassesDeepExrRequest, ::octaneapi::ApiRenderEngine_saveRenderPassesDeepExrResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_saveRenderPassesDeepExrRequest, ::octaneapi::ApiRenderEngine_saveRenderPassesDeepExrResponse>* streamer) {
                       return this->StreamedsaveRenderPassesDeepExr(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_saveRenderPassesDeepExr() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status saveRenderPassesDeepExr(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_saveRenderPassesDeepExrRequest* /*request*/, ::octaneapi::ApiRenderEngine_saveRenderPassesDeepExrResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedsaveRenderPassesDeepExr(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_saveRenderPassesDeepExrRequest,::octaneapi::ApiRenderEngine_saveRenderPassesDeepExrResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_deepImageEnabled : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_deepImageEnabled() {
      ::grpc::Service::MarkMethodStreamed(59,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_deepImageEnabledRequest, ::octaneapi::ApiRenderEngine_deepImageEnabledResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_deepImageEnabledRequest, ::octaneapi::ApiRenderEngine_deepImageEnabledResponse>* streamer) {
                       return this->StreameddeepImageEnabled(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_deepImageEnabled() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status deepImageEnabled(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_deepImageEnabledRequest* /*request*/, ::octaneapi::ApiRenderEngine_deepImageEnabledResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreameddeepImageEnabled(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_deepImageEnabledRequest,::octaneapi::ApiRenderEngine_deepImageEnabledResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_deepImageEnabled1 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_deepImageEnabled1() {
      ::grpc::Service::MarkMethodStreamed(60,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_deepImageEnabled1Request, ::octaneapi::ApiRenderEngine_deepImageEnabled1Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_deepImageEnabled1Request, ::octaneapi::ApiRenderEngine_deepImageEnabled1Response>* streamer) {
                       return this->StreameddeepImageEnabled1(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_deepImageEnabled1() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status deepImageEnabled1(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_deepImageEnabled1Request* /*request*/, ::octaneapi::ApiRenderEngine_deepImageEnabled1Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreameddeepImageEnabled1(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_deepImageEnabled1Request,::octaneapi::ApiRenderEngine_deepImageEnabled1Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_deepPassesEnabled : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_deepPassesEnabled() {
      ::grpc::Service::MarkMethodStreamed(61,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_deepPassesEnabledRequest, ::octaneapi::ApiRenderEngine_deepPassesEnabledResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_deepPassesEnabledRequest, ::octaneapi::ApiRenderEngine_deepPassesEnabledResponse>* streamer) {
                       return this->StreameddeepPassesEnabled(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_deepPassesEnabled() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status deepPassesEnabled(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_deepPassesEnabledRequest* /*request*/, ::octaneapi::ApiRenderEngine_deepPassesEnabledResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreameddeepPassesEnabled(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_deepPassesEnabledRequest,::octaneapi::ApiRenderEngine_deepPassesEnabledResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_canSaveDeepImage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_canSaveDeepImage() {
      ::grpc::Service::MarkMethodStreamed(62,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_canSaveDeepImageRequest, ::octaneapi::ApiRenderEngine_canSaveDeepImageResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_canSaveDeepImageRequest, ::octaneapi::ApiRenderEngine_canSaveDeepImageResponse>* streamer) {
                       return this->StreamedcanSaveDeepImage(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_canSaveDeepImage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status canSaveDeepImage(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_canSaveDeepImageRequest* /*request*/, ::octaneapi::ApiRenderEngine_canSaveDeepImageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedcanSaveDeepImage(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_canSaveDeepImageRequest,::octaneapi::ApiRenderEngine_canSaveDeepImageResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_saveDeepImage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_saveDeepImage() {
      ::grpc::Service::MarkMethodStreamed(63,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_saveDeepImageRequest, ::octaneapi::ApiRenderEngine_saveDeepImageResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_saveDeepImageRequest, ::octaneapi::ApiRenderEngine_saveDeepImageResponse>* streamer) {
                       return this->StreamedsaveDeepImage(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_saveDeepImage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status saveDeepImage(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_saveDeepImageRequest* /*request*/, ::octaneapi::ApiRenderEngine_saveDeepImageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedsaveDeepImage(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_saveDeepImageRequest,::octaneapi::ApiRenderEngine_saveDeepImageResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_saveRenderState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_saveRenderState() {
      ::grpc::Service::MarkMethodStreamed(64,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_saveRenderStateRequest, ::octaneapi::ApiRenderEngine_saveRenderStateResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_saveRenderStateRequest, ::octaneapi::ApiRenderEngine_saveRenderStateResponse>* streamer) {
                       return this->StreamedsaveRenderState(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_saveRenderState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status saveRenderState(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_saveRenderStateRequest* /*request*/, ::octaneapi::ApiRenderEngine_saveRenderStateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedsaveRenderState(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_saveRenderStateRequest,::octaneapi::ApiRenderEngine_saveRenderStateResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_loadRenderState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_loadRenderState() {
      ::grpc::Service::MarkMethodStreamed(65,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_loadRenderStateRequest, ::octaneapi::ApiRenderEngine_loadRenderStateResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_loadRenderStateRequest, ::octaneapi::ApiRenderEngine_loadRenderStateResponse>* streamer) {
                       return this->StreamedloadRenderState(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_loadRenderState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status loadRenderState(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_loadRenderStateRequest* /*request*/, ::octaneapi::ApiRenderEngine_loadRenderStateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedloadRenderState(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_loadRenderStateRequest,::octaneapi::ApiRenderEngine_loadRenderStateResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_previewMaterial : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_previewMaterial() {
      ::grpc::Service::MarkMethodStreamed(66,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_previewMaterialRequest, ::octaneapi::ApiRenderEngine_previewMaterialResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_previewMaterialRequest, ::octaneapi::ApiRenderEngine_previewMaterialResponse>* streamer) {
                       return this->StreamedpreviewMaterial(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_previewMaterial() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status previewMaterial(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_previewMaterialRequest* /*request*/, ::octaneapi::ApiRenderEngine_previewMaterialResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedpreviewMaterial(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_previewMaterialRequest,::octaneapi::ApiRenderEngine_previewMaterialResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_previewMaterialHdr : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_previewMaterialHdr() {
      ::grpc::Service::MarkMethodStreamed(67,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_previewMaterialHdrRequest, ::octaneapi::ApiRenderEngine_previewMaterialHdrResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_previewMaterialHdrRequest, ::octaneapi::ApiRenderEngine_previewMaterialHdrResponse>* streamer) {
                       return this->StreamedpreviewMaterialHdr(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_previewMaterialHdr() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status previewMaterialHdr(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_previewMaterialHdrRequest* /*request*/, ::octaneapi::ApiRenderEngine_previewMaterialHdrResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedpreviewMaterialHdr(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_previewMaterialHdrRequest,::octaneapi::ApiRenderEngine_previewMaterialHdrResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_previewMaterial1 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_previewMaterial1() {
      ::grpc::Service::MarkMethodStreamed(68,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_previewMaterial1Request, ::octaneapi::ApiRenderEngine_previewMaterial1Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_previewMaterial1Request, ::octaneapi::ApiRenderEngine_previewMaterial1Response>* streamer) {
                       return this->StreamedpreviewMaterial1(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_previewMaterial1() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status previewMaterial1(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_previewMaterial1Request* /*request*/, ::octaneapi::ApiRenderEngine_previewMaterial1Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedpreviewMaterial1(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_previewMaterial1Request,::octaneapi::ApiRenderEngine_previewMaterial1Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_getMemoryUsage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_getMemoryUsage() {
      ::grpc::Service::MarkMethodStreamed(69,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_getMemoryUsageRequest, ::octaneapi::ApiRenderEngine_getMemoryUsageResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_getMemoryUsageRequest, ::octaneapi::ApiRenderEngine_getMemoryUsageResponse>* streamer) {
                       return this->StreamedgetMemoryUsage(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_getMemoryUsage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status getMemoryUsage(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getMemoryUsageRequest* /*request*/, ::octaneapi::ApiRenderEngine_getMemoryUsageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedgetMemoryUsage(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_getMemoryUsageRequest,::octaneapi::ApiRenderEngine_getMemoryUsageResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_getResourceStatistics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_getResourceStatistics() {
      ::grpc::Service::MarkMethodStreamed(70,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_getResourceStatisticsRequest, ::octaneapi::ApiRenderEngine_getResourceStatisticsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_getResourceStatisticsRequest, ::octaneapi::ApiRenderEngine_getResourceStatisticsResponse>* streamer) {
                       return this->StreamedgetResourceStatistics(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_getResourceStatistics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status getResourceStatistics(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getResourceStatisticsRequest* /*request*/, ::octaneapi::ApiRenderEngine_getResourceStatisticsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedgetResourceStatistics(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_getResourceStatisticsRequest,::octaneapi::ApiRenderEngine_getResourceStatisticsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_getGeometryStatistics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_getGeometryStatistics() {
      ::grpc::Service::MarkMethodStreamed(71,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_getGeometryStatisticsRequest, ::octaneapi::ApiRenderEngine_getGeometryStatisticsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_getGeometryStatisticsRequest, ::octaneapi::ApiRenderEngine_getGeometryStatisticsResponse>* streamer) {
                       return this->StreamedgetGeometryStatistics(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_getGeometryStatistics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status getGeometryStatistics(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getGeometryStatisticsRequest* /*request*/, ::octaneapi::ApiRenderEngine_getGeometryStatisticsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedgetGeometryStatistics(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_getGeometryStatisticsRequest,::octaneapi::ApiRenderEngine_getGeometryStatisticsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_getTexturesStatistics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_getTexturesStatistics() {
      ::grpc::Service::MarkMethodStreamed(72,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_getTexturesStatisticsRequest, ::octaneapi::ApiRenderEngine_getTexturesStatisticsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_getTexturesStatisticsRequest, ::octaneapi::ApiRenderEngine_getTexturesStatisticsResponse>* streamer) {
                       return this->StreamedgetTexturesStatistics(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_getTexturesStatistics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status getTexturesStatistics(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getTexturesStatisticsRequest* /*request*/, ::octaneapi::ApiRenderEngine_getTexturesStatisticsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedgetTexturesStatistics(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_getTexturesStatisticsRequest,::octaneapi::ApiRenderEngine_getTexturesStatisticsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_getSceneBounds : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_getSceneBounds() {
      ::grpc::Service::MarkMethodStreamed(73,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_getSceneBoundsRequest, ::octaneapi::ApiRenderEngine_getSceneBoundsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_getSceneBoundsRequest, ::octaneapi::ApiRenderEngine_getSceneBoundsResponse>* streamer) {
                       return this->StreamedgetSceneBounds(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_getSceneBounds() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status getSceneBounds(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getSceneBoundsRequest* /*request*/, ::octaneapi::ApiRenderEngine_getSceneBoundsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedgetSceneBounds(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_getSceneBoundsRequest,::octaneapi::ApiRenderEngine_getSceneBoundsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_getDeviceCount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_getDeviceCount() {
      ::grpc::Service::MarkMethodStreamed(74,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_getDeviceCountRequest, ::octaneapi::ApiRenderEngine_getDeviceCountResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_getDeviceCountRequest, ::octaneapi::ApiRenderEngine_getDeviceCountResponse>* streamer) {
                       return this->StreamedgetDeviceCount(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_getDeviceCount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status getDeviceCount(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getDeviceCountRequest* /*request*/, ::octaneapi::ApiRenderEngine_getDeviceCountResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedgetDeviceCount(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_getDeviceCountRequest,::octaneapi::ApiRenderEngine_getDeviceCountResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_getDeviceComputeModel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_getDeviceComputeModel() {
      ::grpc::Service::MarkMethodStreamed(75,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_getDeviceComputeModelRequest, ::octaneapi::ApiRenderEngine_getDeviceComputeModelResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_getDeviceComputeModelRequest, ::octaneapi::ApiRenderEngine_getDeviceComputeModelResponse>* streamer) {
                       return this->StreamedgetDeviceComputeModel(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_getDeviceComputeModel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status getDeviceComputeModel(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getDeviceComputeModelRequest* /*request*/, ::octaneapi::ApiRenderEngine_getDeviceComputeModelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedgetDeviceComputeModel(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_getDeviceComputeModelRequest,::octaneapi::ApiRenderEngine_getDeviceComputeModelResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_getDeviceName : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_getDeviceName() {
      ::grpc::Service::MarkMethodStreamed(76,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_getDeviceNameRequest, ::octaneapi::ApiRenderEngine_getDeviceNameResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_getDeviceNameRequest, ::octaneapi::ApiRenderEngine_getDeviceNameResponse>* streamer) {
                       return this->StreamedgetDeviceName(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_getDeviceName() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status getDeviceName(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getDeviceNameRequest* /*request*/, ::octaneapi::ApiRenderEngine_getDeviceNameResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedgetDeviceName(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_getDeviceNameRequest,::octaneapi::ApiRenderEngine_getDeviceNameResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_isSupportedDevice : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_isSupportedDevice() {
      ::grpc::Service::MarkMethodStreamed(77,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_isSupportedDeviceRequest, ::octaneapi::ApiRenderEngine_isSupportedDeviceResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_isSupportedDeviceRequest, ::octaneapi::ApiRenderEngine_isSupportedDeviceResponse>* streamer) {
                       return this->StreamedisSupportedDevice(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_isSupportedDevice() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status isSupportedDevice(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_isSupportedDeviceRequest* /*request*/, ::octaneapi::ApiRenderEngine_isSupportedDeviceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedisSupportedDevice(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_isSupportedDeviceRequest,::octaneapi::ApiRenderEngine_isSupportedDeviceResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_deviceCanRender : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_deviceCanRender() {
      ::grpc::Service::MarkMethodStreamed(78,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_deviceCanRenderRequest, ::octaneapi::ApiRenderEngine_deviceCanRenderResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_deviceCanRenderRequest, ::octaneapi::ApiRenderEngine_deviceCanRenderResponse>* streamer) {
                       return this->StreameddeviceCanRender(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_deviceCanRender() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status deviceCanRender(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_deviceCanRenderRequest* /*request*/, ::octaneapi::ApiRenderEngine_deviceCanRenderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreameddeviceCanRender(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_deviceCanRenderRequest,::octaneapi::ApiRenderEngine_deviceCanRenderResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_deviceCanDenoise : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_deviceCanDenoise() {
      ::grpc::Service::MarkMethodStreamed(79,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_deviceCanDenoiseRequest, ::octaneapi::ApiRenderEngine_deviceCanDenoiseResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_deviceCanDenoiseRequest, ::octaneapi::ApiRenderEngine_deviceCanDenoiseResponse>* streamer) {
                       return this->StreameddeviceCanDenoise(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_deviceCanDenoise() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status deviceCanDenoise(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_deviceCanDenoiseRequest* /*request*/, ::octaneapi::ApiRenderEngine_deviceCanDenoiseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreameddeviceCanDenoise(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_deviceCanDenoiseRequest,::octaneapi::ApiRenderEngine_deviceCanDenoiseResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_deviceSupportsHardwareRayTracing : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_deviceSupportsHardwareRayTracing() {
      ::grpc::Service::MarkMethodStreamed(80,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_deviceSupportsHardwareRayTracingRequest, ::octaneapi::ApiRenderEngine_deviceSupportsHardwareRayTracingResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_deviceSupportsHardwareRayTracingRequest, ::octaneapi::ApiRenderEngine_deviceSupportsHardwareRayTracingResponse>* streamer) {
                       return this->StreameddeviceSupportsHardwareRayTracing(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_deviceSupportsHardwareRayTracing() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status deviceSupportsHardwareRayTracing(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_deviceSupportsHardwareRayTracingRequest* /*request*/, ::octaneapi::ApiRenderEngine_deviceSupportsHardwareRayTracingResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreameddeviceSupportsHardwareRayTracing(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_deviceSupportsHardwareRayTracingRequest,::octaneapi::ApiRenderEngine_deviceSupportsHardwareRayTracingResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_deviceSharedSurfaceInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_deviceSharedSurfaceInfo() {
      ::grpc::Service::MarkMethodStreamed(81,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_deviceSharedSurfaceInfoRequest, ::octaneapi::ApiRenderEngine_deviceSharedSurfaceInfoResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_deviceSharedSurfaceInfoRequest, ::octaneapi::ApiRenderEngine_deviceSharedSurfaceInfoResponse>* streamer) {
                       return this->StreameddeviceSharedSurfaceInfo(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_deviceSharedSurfaceInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status deviceSharedSurfaceInfo(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_deviceSharedSurfaceInfoRequest* /*request*/, ::octaneapi::ApiRenderEngine_deviceSharedSurfaceInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreameddeviceSharedSurfaceInfo(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_deviceSharedSurfaceInfoRequest,::octaneapi::ApiRenderEngine_deviceSharedSurfaceInfoResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_getAvailablePeerToPeerPairs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_getAvailablePeerToPeerPairs() {
      ::grpc::Service::MarkMethodStreamed(82,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_getAvailablePeerToPeerPairsRequest, ::octaneapi::ApiRenderEngine_getAvailablePeerToPeerPairsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_getAvailablePeerToPeerPairsRequest, ::octaneapi::ApiRenderEngine_getAvailablePeerToPeerPairsResponse>* streamer) {
                       return this->StreamedgetAvailablePeerToPeerPairs(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_getAvailablePeerToPeerPairs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status getAvailablePeerToPeerPairs(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getAvailablePeerToPeerPairsRequest* /*request*/, ::octaneapi::ApiRenderEngine_getAvailablePeerToPeerPairsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedgetAvailablePeerToPeerPairs(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_getAvailablePeerToPeerPairsRequest,::octaneapi::ApiRenderEngine_getAvailablePeerToPeerPairsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_setDevicesActivity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_setDevicesActivity() {
      ::grpc::Service::MarkMethodStreamed(83,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_setDevicesActivityRequest, ::octaneapi::ApiRenderEngine_setDevicesActivityResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_setDevicesActivityRequest, ::octaneapi::ApiRenderEngine_setDevicesActivityResponse>* streamer) {
                       return this->StreamedsetDevicesActivity(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_setDevicesActivity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status setDevicesActivity(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setDevicesActivityRequest* /*request*/, ::octaneapi::ApiRenderEngine_setDevicesActivityResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedsetDevicesActivity(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_setDevicesActivityRequest,::octaneapi::ApiRenderEngine_setDevicesActivityResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_isDeviceUsedForRendering : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_isDeviceUsedForRendering() {
      ::grpc::Service::MarkMethodStreamed(84,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_isDeviceUsedForRenderingRequest, ::octaneapi::ApiRenderEngine_isDeviceUsedForRenderingResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_isDeviceUsedForRenderingRequest, ::octaneapi::ApiRenderEngine_isDeviceUsedForRenderingResponse>* streamer) {
                       return this->StreamedisDeviceUsedForRendering(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_isDeviceUsedForRendering() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status isDeviceUsedForRendering(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_isDeviceUsedForRenderingRequest* /*request*/, ::octaneapi::ApiRenderEngine_isDeviceUsedForRenderingResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedisDeviceUsedForRendering(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_isDeviceUsedForRenderingRequest,::octaneapi::ApiRenderEngine_isDeviceUsedForRenderingResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_deviceUsesPriority : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_deviceUsesPriority() {
      ::grpc::Service::MarkMethodStreamed(85,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_deviceUsesPriorityRequest, ::octaneapi::ApiRenderEngine_deviceUsesPriorityResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_deviceUsesPriorityRequest, ::octaneapi::ApiRenderEngine_deviceUsesPriorityResponse>* streamer) {
                       return this->StreameddeviceUsesPriority(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_deviceUsesPriority() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status deviceUsesPriority(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_deviceUsesPriorityRequest* /*request*/, ::octaneapi::ApiRenderEngine_deviceUsesPriorityResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreameddeviceUsesPriority(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_deviceUsesPriorityRequest,::octaneapi::ApiRenderEngine_deviceUsesPriorityResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_deviceUsesHardwareRayTracing : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_deviceUsesHardwareRayTracing() {
      ::grpc::Service::MarkMethodStreamed(86,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_deviceUsesHardwareRayTracingRequest, ::octaneapi::ApiRenderEngine_deviceUsesHardwareRayTracingResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_deviceUsesHardwareRayTracingRequest, ::octaneapi::ApiRenderEngine_deviceUsesHardwareRayTracingResponse>* streamer) {
                       return this->StreameddeviceUsesHardwareRayTracing(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_deviceUsesHardwareRayTracing() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status deviceUsesHardwareRayTracing(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_deviceUsesHardwareRayTracingRequest* /*request*/, ::octaneapi::ApiRenderEngine_deviceUsesHardwareRayTracingResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreameddeviceUsesHardwareRayTracing(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_deviceUsesHardwareRayTracingRequest,::octaneapi::ApiRenderEngine_deviceUsesHardwareRayTracingResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_imageDeviceIndex : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_imageDeviceIndex() {
      ::grpc::Service::MarkMethodStreamed(87,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_imageDeviceIndexRequest, ::octaneapi::ApiRenderEngine_imageDeviceIndexResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_imageDeviceIndexRequest, ::octaneapi::ApiRenderEngine_imageDeviceIndexResponse>* streamer) {
                       return this->StreamedimageDeviceIndex(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_imageDeviceIndex() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status imageDeviceIndex(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_imageDeviceIndexRequest* /*request*/, ::octaneapi::ApiRenderEngine_imageDeviceIndexResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedimageDeviceIndex(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_imageDeviceIndexRequest,::octaneapi::ApiRenderEngine_imageDeviceIndexResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_isDeviceUsedForDenoising : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_isDeviceUsedForDenoising() {
      ::grpc::Service::MarkMethodStreamed(88,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_isDeviceUsedForDenoisingRequest, ::octaneapi::ApiRenderEngine_isDeviceUsedForDenoisingResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_isDeviceUsedForDenoisingRequest, ::octaneapi::ApiRenderEngine_isDeviceUsedForDenoisingResponse>* streamer) {
                       return this->StreamedisDeviceUsedForDenoising(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_isDeviceUsedForDenoising() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status isDeviceUsedForDenoising(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_isDeviceUsedForDenoisingRequest* /*request*/, ::octaneapi::ApiRenderEngine_isDeviceUsedForDenoisingResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedisDeviceUsedForDenoising(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_isDeviceUsedForDenoisingRequest,::octaneapi::ApiRenderEngine_isDeviceUsedForDenoisingResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_renderPriority : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_renderPriority() {
      ::grpc::Service::MarkMethodStreamed(89,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_renderPriorityRequest, ::octaneapi::ApiRenderEngine_renderPriorityResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_renderPriorityRequest, ::octaneapi::ApiRenderEngine_renderPriorityResponse>* streamer) {
                       return this->StreamedrenderPriority(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_renderPriority() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status renderPriority(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_renderPriorityRequest* /*request*/, ::octaneapi::ApiRenderEngine_renderPriorityResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedrenderPriority(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_renderPriorityRequest,::octaneapi::ApiRenderEngine_renderPriorityResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_setRenderPriority : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_setRenderPriority() {
      ::grpc::Service::MarkMethodStreamed(90,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_setRenderPriorityRequest, ::google::protobuf::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_setRenderPriorityRequest, ::google::protobuf::Empty>* streamer) {
                       return this->StreamedsetRenderPriority(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_setRenderPriority() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status setRenderPriority(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setRenderPriorityRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedsetRenderPriority(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_setRenderPriorityRequest,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_currentPeerToPeerGroups : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_currentPeerToPeerGroups() {
      ::grpc::Service::MarkMethodStreamed(91,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_currentPeerToPeerGroupsRequest, ::octaneapi::ApiRenderEngine_currentPeerToPeerGroupsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_currentPeerToPeerGroupsRequest, ::octaneapi::ApiRenderEngine_currentPeerToPeerGroupsResponse>* streamer) {
                       return this->StreamedcurrentPeerToPeerGroups(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_currentPeerToPeerGroups() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status currentPeerToPeerGroups(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_currentPeerToPeerGroupsRequest* /*request*/, ::octaneapi::ApiRenderEngine_currentPeerToPeerGroupsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedcurrentPeerToPeerGroups(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_currentPeerToPeerGroupsRequest,::octaneapi::ApiRenderEngine_currentPeerToPeerGroupsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_hardwareRayTracingEnabled : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_hardwareRayTracingEnabled() {
      ::grpc::Service::MarkMethodStreamed(92,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_hardwareRayTracingEnabledRequest, ::octaneapi::ApiRenderEngine_hardwareRayTracingEnabledResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_hardwareRayTracingEnabledRequest, ::octaneapi::ApiRenderEngine_hardwareRayTracingEnabledResponse>* streamer) {
                       return this->StreamedhardwareRayTracingEnabled(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_hardwareRayTracingEnabled() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status hardwareRayTracingEnabled(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_hardwareRayTracingEnabledRequest* /*request*/, ::octaneapi::ApiRenderEngine_hardwareRayTracingEnabledResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedhardwareRayTracingEnabled(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_hardwareRayTracingEnabledRequest,::octaneapi::ApiRenderEngine_hardwareRayTracingEnabledResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_openDeviceSettings : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_openDeviceSettings() {
      ::grpc::Service::MarkMethodStreamed(93,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_openDeviceSettingsRequest, ::google::protobuf::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_openDeviceSettingsRequest, ::google::protobuf::Empty>* streamer) {
                       return this->StreamedopenDeviceSettings(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_openDeviceSettings() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status openDeviceSettings(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_openDeviceSettingsRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedopenDeviceSettings(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_openDeviceSettingsRequest,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_renderDeviceState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_renderDeviceState() {
      ::grpc::Service::MarkMethodStreamed(94,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_renderDeviceStateRequest, ::octaneapi::ApiRenderEngine_renderDeviceStateResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_renderDeviceStateRequest, ::octaneapi::ApiRenderEngine_renderDeviceStateResponse>* streamer) {
                       return this->StreamedrenderDeviceState(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_renderDeviceState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status renderDeviceState(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_renderDeviceStateRequest* /*request*/, ::octaneapi::ApiRenderEngine_renderDeviceStateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedrenderDeviceState(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_renderDeviceStateRequest,::octaneapi::ApiRenderEngine_renderDeviceStateResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_renderDeviceErrorCode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_renderDeviceErrorCode() {
      ::grpc::Service::MarkMethodStreamed(95,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_renderDeviceErrorCodeRequest, ::octaneapi::ApiRenderEngine_renderDeviceErrorCodeResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_renderDeviceErrorCodeRequest, ::octaneapi::ApiRenderEngine_renderDeviceErrorCodeResponse>* streamer) {
                       return this->StreamedrenderDeviceErrorCode(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_renderDeviceErrorCode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status renderDeviceErrorCode(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_renderDeviceErrorCodeRequest* /*request*/, ::octaneapi::ApiRenderEngine_renderDeviceErrorCodeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedrenderDeviceErrorCode(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_renderDeviceErrorCodeRequest,::octaneapi::ApiRenderEngine_renderDeviceErrorCodeResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_errorcodeToString : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_errorcodeToString() {
      ::grpc::Service::MarkMethodStreamed(96,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_errorcodeToStringRequest, ::octaneapi::ApiRenderEngine_errorcodeToStringResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_errorcodeToStringRequest, ::octaneapi::ApiRenderEngine_errorcodeToStringResponse>* streamer) {
                       return this->StreamederrorcodeToString(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_errorcodeToString() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status errorcodeToString(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_errorcodeToStringRequest* /*request*/, ::octaneapi::ApiRenderEngine_errorcodeToStringResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamederrorcodeToString(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_errorcodeToStringRequest,::octaneapi::ApiRenderEngine_errorcodeToStringResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_renderDeviceErrorMessage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_renderDeviceErrorMessage() {
      ::grpc::Service::MarkMethodStreamed(97,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_renderDeviceErrorMessageRequest, ::octaneapi::ApiRenderEngine_renderDeviceErrorMessageResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_renderDeviceErrorMessageRequest, ::octaneapi::ApiRenderEngine_renderDeviceErrorMessageResponse>* streamer) {
                       return this->StreamedrenderDeviceErrorMessage(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_renderDeviceErrorMessage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status renderDeviceErrorMessage(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_renderDeviceErrorMessageRequest* /*request*/, ::octaneapi::ApiRenderEngine_renderDeviceErrorMessageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedrenderDeviceErrorMessage(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_renderDeviceErrorMessageRequest,::octaneapi::ApiRenderEngine_renderDeviceErrorMessageResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_saveRenderDeviceConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_saveRenderDeviceConfig() {
      ::grpc::Service::MarkMethodStreamed(98,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_saveRenderDeviceConfigRequest, ::google::protobuf::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_saveRenderDeviceConfigRequest, ::google::protobuf::Empty>* streamer) {
                       return this->StreamedsaveRenderDeviceConfig(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_saveRenderDeviceConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status saveRenderDeviceConfig(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_saveRenderDeviceConfigRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedsaveRenderDeviceConfig(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_saveRenderDeviceConfigRequest,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_outOfCoreEnabled : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_outOfCoreEnabled() {
      ::grpc::Service::MarkMethodStreamed(99,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_outOfCoreEnabledRequest, ::octaneapi::ApiRenderEngine_outOfCoreEnabledResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_outOfCoreEnabledRequest, ::octaneapi::ApiRenderEngine_outOfCoreEnabledResponse>* streamer) {
                       return this->StreamedoutOfCoreEnabled(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_outOfCoreEnabled() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status outOfCoreEnabled(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_outOfCoreEnabledRequest* /*request*/, ::octaneapi::ApiRenderEngine_outOfCoreEnabledResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedoutOfCoreEnabled(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_outOfCoreEnabledRequest,::octaneapi::ApiRenderEngine_outOfCoreEnabledResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_enableOutOfCore : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_enableOutOfCore() {
      ::grpc::Service::MarkMethodStreamed(100,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_enableOutOfCoreRequest, ::google::protobuf::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_enableOutOfCoreRequest, ::google::protobuf::Empty>* streamer) {
                       return this->StreamedenableOutOfCore(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_enableOutOfCore() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status enableOutOfCore(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_enableOutOfCoreRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedenableOutOfCore(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_enableOutOfCoreRequest,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_disableOutOfCore : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_disableOutOfCore() {
      ::grpc::Service::MarkMethodStreamed(101,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_disableOutOfCoreRequest, ::google::protobuf::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_disableOutOfCoreRequest, ::google::protobuf::Empty>* streamer) {
                       return this->StreameddisableOutOfCore(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_disableOutOfCore() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status disableOutOfCore(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_disableOutOfCoreRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreameddisableOutOfCore(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_disableOutOfCoreRequest,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_getOutOfCoreMemoryUsage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_getOutOfCoreMemoryUsage() {
      ::grpc::Service::MarkMethodStreamed(102,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_getOutOfCoreMemoryUsageRequest, ::octaneapi::ApiRenderEngine_getOutOfCoreMemoryUsageResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_getOutOfCoreMemoryUsageRequest, ::octaneapi::ApiRenderEngine_getOutOfCoreMemoryUsageResponse>* streamer) {
                       return this->StreamedgetOutOfCoreMemoryUsage(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_getOutOfCoreMemoryUsage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status getOutOfCoreMemoryUsage(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getOutOfCoreMemoryUsageRequest* /*request*/, ::octaneapi::ApiRenderEngine_getOutOfCoreMemoryUsageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedgetOutOfCoreMemoryUsage(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_getOutOfCoreMemoryUsageRequest,::octaneapi::ApiRenderEngine_getOutOfCoreMemoryUsageResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_setGpuHeadroom : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_setGpuHeadroom() {
      ::grpc::Service::MarkMethodStreamed(103,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_setGpuHeadroomRequest, ::google::protobuf::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_setGpuHeadroomRequest, ::google::protobuf::Empty>* streamer) {
                       return this->StreamedsetGpuHeadroom(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_setGpuHeadroom() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status setGpuHeadroom(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setGpuHeadroomRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedsetGpuHeadroom(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_setGpuHeadroomRequest,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_getGpuHeadroom : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_getGpuHeadroom() {
      ::grpc::Service::MarkMethodStreamed(104,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_getGpuHeadroomRequest, ::octaneapi::ApiRenderEngine_getGpuHeadroomResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_getGpuHeadroomRequest, ::octaneapi::ApiRenderEngine_getGpuHeadroomResponse>* streamer) {
                       return this->StreamedgetGpuHeadroom(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_getGpuHeadroom() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status getGpuHeadroom(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getGpuHeadroomRequest* /*request*/, ::octaneapi::ApiRenderEngine_getGpuHeadroomResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedgetGpuHeadroom(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_getGpuHeadroomRequest,::octaneapi::ApiRenderEngine_getGpuHeadroomResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_setCoreLimit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_setCoreLimit() {
      ::grpc::Service::MarkMethodStreamed(105,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_setCoreLimitRequest, ::google::protobuf::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_setCoreLimitRequest, ::google::protobuf::Empty>* streamer) {
                       return this->StreamedsetCoreLimit(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_setCoreLimit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status setCoreLimit(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setCoreLimitRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedsetCoreLimit(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_setCoreLimitRequest,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_disableCoreLimit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_disableCoreLimit() {
      ::grpc::Service::MarkMethodStreamed(106,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_disableCoreLimitRequest, ::google::protobuf::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_disableCoreLimitRequest, ::google::protobuf::Empty>* streamer) {
                       return this->StreameddisableCoreLimit(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_disableCoreLimit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status disableCoreLimit(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_disableCoreLimitRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreameddisableCoreLimit(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_disableCoreLimitRequest,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_registerInputSharedSurface : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_registerInputSharedSurface() {
      ::grpc::Service::MarkMethodStreamed(107,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_registerInputSharedSurfaceRequest, ::octaneapi::ApiRenderEngine_registerInputSharedSurfaceResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_registerInputSharedSurfaceRequest, ::octaneapi::ApiRenderEngine_registerInputSharedSurfaceResponse>* streamer) {
                       return this->StreamedregisterInputSharedSurface(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_registerInputSharedSurface() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status registerInputSharedSurface(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_registerInputSharedSurfaceRequest* /*request*/, ::octaneapi::ApiRenderEngine_registerInputSharedSurfaceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedregisterInputSharedSurface(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_registerInputSharedSurfaceRequest,::octaneapi::ApiRenderEngine_registerInputSharedSurfaceResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_unregisterInputSharedSurface : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_unregisterInputSharedSurface() {
      ::grpc::Service::MarkMethodStreamed(108,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_unregisterInputSharedSurfaceRequest, ::google::protobuf::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_unregisterInputSharedSurfaceRequest, ::google::protobuf::Empty>* streamer) {
                       return this->StreamedunregisterInputSharedSurface(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_unregisterInputSharedSurface() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status unregisterInputSharedSurface(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_unregisterInputSharedSurfaceRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedunregisterInputSharedSurface(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_unregisterInputSharedSurfaceRequest,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_triggerAsyncTonemap : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_triggerAsyncTonemap() {
      ::grpc::Service::MarkMethodStreamed(109,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_triggerAsyncTonemapRequest, ::google::protobuf::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_triggerAsyncTonemapRequest, ::google::protobuf::Empty>* streamer) {
                       return this->StreamedtriggerAsyncTonemap(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_triggerAsyncTonemap() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status triggerAsyncTonemap(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_triggerAsyncTonemapRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedtriggerAsyncTonemap(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_triggerAsyncTonemapRequest,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_setSharedSurfaceOutputType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_setSharedSurfaceOutputType() {
      ::grpc::Service::MarkMethodStreamed(110,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_setSharedSurfaceOutputTypeRequest, ::google::protobuf::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_setSharedSurfaceOutputTypeRequest, ::google::protobuf::Empty>* streamer) {
                       return this->StreamedsetSharedSurfaceOutputType(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_setSharedSurfaceOutputType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status setSharedSurfaceOutputType(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_setSharedSurfaceOutputTypeRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedsetSharedSurfaceOutputType(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_setSharedSurfaceOutputTypeRequest,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_getSharedSurfaceOutputType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_getSharedSurfaceOutputType() {
      ::grpc::Service::MarkMethodStreamed(111,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_getSharedSurfaceOutputTypeRequest, ::octaneapi::ApiRenderEngine_getSharedSurfaceOutputTypeResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_getSharedSurfaceOutputTypeRequest, ::octaneapi::ApiRenderEngine_getSharedSurfaceOutputTypeResponse>* streamer) {
                       return this->StreamedgetSharedSurfaceOutputType(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_getSharedSurfaceOutputType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status getSharedSurfaceOutputType(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getSharedSurfaceOutputTypeRequest* /*request*/, ::octaneapi::ApiRenderEngine_getSharedSurfaceOutputTypeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedgetSharedSurfaceOutputType(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_getSharedSurfaceOutputTypeRequest,::octaneapi::ApiRenderEngine_getSharedSurfaceOutputTypeResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_getRealTime : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_getRealTime() {
      ::grpc::Service::MarkMethodStreamed(112,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_getRealTimeRequest, ::octaneapi::ApiRenderEngine_getRealTimeResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_getRealTimeRequest, ::octaneapi::ApiRenderEngine_getRealTimeResponse>* streamer) {
                       return this->StreamedgetRealTime(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_getRealTime() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status getRealTime(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getRealTimeRequest* /*request*/, ::octaneapi::ApiRenderEngine_getRealTimeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedgetRealTime(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_getRealTimeRequest,::octaneapi::ApiRenderEngine_getRealTimeResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_pauseRendering : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_pauseRendering() {
      ::grpc::Service::MarkMethodStreamed(113,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_pauseRenderingRequest, ::google::protobuf::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_pauseRenderingRequest, ::google::protobuf::Empty>* streamer) {
                       return this->StreamedpauseRendering(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_pauseRendering() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status pauseRendering(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_pauseRenderingRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedpauseRendering(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_pauseRenderingRequest,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_continueRendering : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_continueRendering() {
      ::grpc::Service::MarkMethodStreamed(114,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_continueRenderingRequest, ::google::protobuf::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_continueRenderingRequest, ::google::protobuf::Empty>* streamer) {
                       return this->StreamedcontinueRendering(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_continueRendering() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status continueRendering(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_continueRenderingRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedcontinueRendering(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_continueRenderingRequest,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_isRenderingPaused : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_isRenderingPaused() {
      ::grpc::Service::MarkMethodStreamed(115,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_isRenderingPausedRequest, ::octaneapi::ApiRenderEngine_isRenderingPausedResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_isRenderingPausedRequest, ::octaneapi::ApiRenderEngine_isRenderingPausedResponse>* streamer) {
                       return this->StreamedisRenderingPaused(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_isRenderingPaused() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status isRenderingPaused(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_isRenderingPausedRequest* /*request*/, ::octaneapi::ApiRenderEngine_isRenderingPausedResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedisRenderingPaused(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_isRenderingPausedRequest,::octaneapi::ApiRenderEngine_isRenderingPausedResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_restartRendering : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_restartRendering() {
      ::grpc::Service::MarkMethodStreamed(116,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_restartRenderingRequest, ::google::protobuf::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_restartRenderingRequest, ::google::protobuf::Empty>* streamer) {
                       return this->StreamedrestartRendering(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_restartRendering() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status restartRendering(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_restartRenderingRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedrestartRendering(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_restartRenderingRequest,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_stopRendering : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_stopRendering() {
      ::grpc::Service::MarkMethodStreamed(117,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_stopRenderingRequest, ::google::protobuf::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_stopRenderingRequest, ::google::protobuf::Empty>* streamer) {
                       return this->StreamedstopRendering(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_stopRendering() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status stopRendering(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_stopRenderingRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedstopRendering(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_stopRenderingRequest,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_pick : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_pick() {
      ::grpc::Service::MarkMethodStreamed(118,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_pickRequest, ::octaneapi::ApiRenderEngine_pickResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_pickRequest, ::octaneapi::ApiRenderEngine_pickResponse>* streamer) {
                       return this->Streamedpick(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_pick() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status pick(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_pickRequest* /*request*/, ::octaneapi::ApiRenderEngine_pickResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedpick(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_pickRequest,::octaneapi::ApiRenderEngine_pickResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_pickWhitePoint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_pickWhitePoint() {
      ::grpc::Service::MarkMethodStreamed(119,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_pickWhitePointRequest, ::octaneapi::ApiRenderEngine_pickWhitePointResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_pickWhitePointRequest, ::octaneapi::ApiRenderEngine_pickWhitePointResponse>* streamer) {
                       return this->StreamedpickWhitePoint(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_pickWhitePoint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status pickWhitePoint(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_pickWhitePointRequest* /*request*/, ::octaneapi::ApiRenderEngine_pickWhitePointResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedpickWhitePoint(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_pickWhitePointRequest,::octaneapi::ApiRenderEngine_pickWhitePointResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_pickImagerWhitePoint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_pickImagerWhitePoint() {
      ::grpc::Service::MarkMethodStreamed(120,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_pickImagerWhitePointRequest, ::octaneapi::ApiRenderEngine_pickImagerWhitePointResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_pickImagerWhitePointRequest, ::octaneapi::ApiRenderEngine_pickImagerWhitePointResponse>* streamer) {
                       return this->StreamedpickImagerWhitePoint(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_pickImagerWhitePoint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status pickImagerWhitePoint(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_pickImagerWhitePointRequest* /*request*/, ::octaneapi::ApiRenderEngine_pickImagerWhitePointResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedpickImagerWhitePoint(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_pickImagerWhitePointRequest,::octaneapi::ApiRenderEngine_pickImagerWhitePointResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_isOutputAovWhitePointPickable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_isOutputAovWhitePointPickable() {
      ::grpc::Service::MarkMethodStreamed(121,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_isOutputAovWhitePointPickableRequest, ::octaneapi::ApiRenderEngine_isOutputAovWhitePointPickableResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_isOutputAovWhitePointPickableRequest, ::octaneapi::ApiRenderEngine_isOutputAovWhitePointPickableResponse>* streamer) {
                       return this->StreamedisOutputAovWhitePointPickable(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_isOutputAovWhitePointPickable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status isOutputAovWhitePointPickable(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_isOutputAovWhitePointPickableRequest* /*request*/, ::octaneapi::ApiRenderEngine_isOutputAovWhitePointPickableResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedisOutputAovWhitePointPickable(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_isOutputAovWhitePointPickableRequest,::octaneapi::ApiRenderEngine_isOutputAovWhitePointPickableResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_pickOutputAovWhitePoint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_pickOutputAovWhitePoint() {
      ::grpc::Service::MarkMethodStreamed(122,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_pickOutputAovWhitePointRequest, ::octaneapi::ApiRenderEngine_pickOutputAovWhitePointResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_pickOutputAovWhitePointRequest, ::octaneapi::ApiRenderEngine_pickOutputAovWhitePointResponse>* streamer) {
                       return this->StreamedpickOutputAovWhitePoint(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_pickOutputAovWhitePoint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status pickOutputAovWhitePoint(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_pickOutputAovWhitePointRequest* /*request*/, ::octaneapi::ApiRenderEngine_pickOutputAovWhitePointResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedpickOutputAovWhitePoint(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_pickOutputAovWhitePointRequest,::octaneapi::ApiRenderEngine_pickOutputAovWhitePointResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_pickCryptomatteMatte : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_pickCryptomatteMatte() {
      ::grpc::Service::MarkMethodStreamed(123,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_pickCryptomatteMatteRequest, ::octaneapi::ApiRenderEngine_pickCryptomatteMatteResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_pickCryptomatteMatteRequest, ::octaneapi::ApiRenderEngine_pickCryptomatteMatteResponse>* streamer) {
                       return this->StreamedpickCryptomatteMatte(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_pickCryptomatteMatte() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status pickCryptomatteMatte(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_pickCryptomatteMatteRequest* /*request*/, ::octaneapi::ApiRenderEngine_pickCryptomatteMatteResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedpickCryptomatteMatte(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_pickCryptomatteMatteRequest,::octaneapi::ApiRenderEngine_pickCryptomatteMatteResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_modifyCryptomatteMatteSelection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_modifyCryptomatteMatteSelection() {
      ::grpc::Service::MarkMethodStreamed(124,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_modifyCryptomatteMatteSelectionRequest, ::octaneapi::ApiRenderEngine_modifyCryptomatteMatteSelectionResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_modifyCryptomatteMatteSelectionRequest, ::octaneapi::ApiRenderEngine_modifyCryptomatteMatteSelectionResponse>* streamer) {
                       return this->StreamedmodifyCryptomatteMatteSelection(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_modifyCryptomatteMatteSelection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status modifyCryptomatteMatteSelection(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_modifyCryptomatteMatteSelectionRequest* /*request*/, ::octaneapi::ApiRenderEngine_modifyCryptomatteMatteSelectionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedmodifyCryptomatteMatteSelection(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_modifyCryptomatteMatteSelectionRequest,::octaneapi::ApiRenderEngine_modifyCryptomatteMatteSelectionResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_toString : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_toString() {
      ::grpc::Service::MarkMethodStreamed(125,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_toStringRequest, ::octaneapi::ApiRenderEngine_toStringResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_toStringRequest, ::octaneapi::ApiRenderEngine_toStringResponse>* streamer) {
                       return this->StreamedtoString(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_toString() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status toString(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_toStringRequest* /*request*/, ::octaneapi::ApiRenderEngine_toStringResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedtoString(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_toStringRequest,::octaneapi::ApiRenderEngine_toStringResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_getDevicePciIds : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_getDevicePciIds() {
      ::grpc::Service::MarkMethodStreamed(126,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderEngine_getDevicePciIdsRequest, ::octaneapi::ApiRenderEngine_getDevicePciIdsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderEngine_getDevicePciIdsRequest, ::octaneapi::ApiRenderEngine_getDevicePciIdsResponse>* streamer) {
                       return this->StreamedgetDevicePciIds(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_getDevicePciIds() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status getDevicePciIds(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderEngine_getDevicePciIdsRequest* /*request*/, ::octaneapi::ApiRenderEngine_getDevicePciIdsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedgetDevicePciIds(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderEngine_getDevicePciIdsRequest,::octaneapi::ApiRenderEngine_getDevicePciIdsResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_setRenderTargetNode<WithStreamedUnaryMethod_getRenderTargetNode<WithStreamedUnaryMethod_getRenderGeometryNode<WithStreamedUnaryMethod_getRenderCameraNode<WithStreamedUnaryMethod_setRenderRegion<WithStreamedUnaryMethod_getRenderRegion<WithStreamedUnaryMethod_setAsyncTonemapParams<WithStreamedUnaryMethod_setAsyncTonemapParams1<WithStreamedUnaryMethod_asyncTonemapBufferType<WithStreamedUnaryMethod_asyncTonemapCryptomatteFalseColor<WithStreamedUnaryMethod_asyncTonemapOutputColorSpaceInfo<WithStreamedUnaryMethod_asyncTonemapColorSpace<WithStreamedUnaryMethod_asyncTonemapPremultipliedAlphaType<WithStreamedUnaryMethod_setAsyncTonemapRenderPasses<WithStreamedUnaryMethod_asyncTonemapRenderPasses<WithStreamedUnaryMethod_getEnabledAovs<WithStreamedUnaryMethod_freeTonemapPasses<WithStreamedUnaryMethod_displayRenderPassId<WithStreamedUnaryMethod_setSubSampleMode<WithStreamedUnaryMethod_getSubSampleMode<WithStreamedUnaryMethod_setClayMode<WithStreamedUnaryMethod_clayMode<WithStreamedUnaryMethod_fps<WithStreamedUnaryMethod_setFps<WithStreamedUnaryMethod_isCompiling<WithStreamedUnaryMethod_isCompressingTextures<WithStreamedUnaryMethod_hasPendingRenderData<WithStreamedUnaryMethod_getCurrentChangeLevel<WithStreamedUnaryMethod_getRenderImageChangeLevel<WithStreamedUnaryMethod_getRenderRestartedChangeLevel<WithStreamedUnaryMethod_setAsyncUpdateCallback<WithStreamedUnaryMethod_updatesAreAsync<WithStreamedUnaryMethod_isImageReady<WithStreamedUnaryMethod_resetImageReady<WithStreamedUnaryMethod_isRenderFailure<WithStreamedUnaryMethod_resetRenderFailure<WithStreamedUnaryMethod_setOnTileBlendedCallback<WithStreamedUnaryMethod_setOnNewStatisticsCallback<WithStreamedUnaryMethod_setOnNewImageCallback<WithStreamedUnaryMethod_setOnOcioErrorCallback<WithStreamedUnaryMethod_setOnRenderFailureCallback<WithStreamedUnaryMethod_setForceCallbacksInRenderThreads<WithStreamedUnaryMethod_grabRenderResult<WithStreamedUnaryMethod_releaseRenderResult<WithStreamedUnaryMethod_synchronousTonemap<WithStreamedUnaryMethod_synchronousTonemap1<WithStreamedUnaryMethod_synchronousTonemapAllRenderPasses<WithStreamedUnaryMethod_synchronousTonemapAllRenderPasses1<WithStreamedUnaryMethod_getRenderStatistics<WithStreamedUnaryMethod_getRenderResultStatistics<WithStreamedUnaryMethod_saveImage<WithStreamedUnaryMethod_saveImage1<WithStreamedUnaryMethod_saveImage2<WithStreamedUnaryMethod_saveRenderPasses<WithStreamedUnaryMethod_saveRenderPasses1<WithStreamedUnaryMethod_saveRenderPasses2<WithStreamedUnaryMethod_saveRenderPassesMultiExr<WithStreamedUnaryMethod_saveRenderPassesMultiExr1<WithStreamedUnaryMethod_saveRenderPassesDeepExr<WithStreamedUnaryMethod_deepImageEnabled<WithStreamedUnaryMethod_deepImageEnabled1<WithStreamedUnaryMethod_deepPassesEnabled<WithStreamedUnaryMethod_canSaveDeepImage<WithStreamedUnaryMethod_saveDeepImage<WithStreamedUnaryMethod_saveRenderState<WithStreamedUnaryMethod_loadRenderState<WithStreamedUnaryMethod_previewMaterial<WithStreamedUnaryMethod_previewMaterialHdr<WithStreamedUnaryMethod_previewMaterial1<WithStreamedUnaryMethod_getMemoryUsage<WithStreamedUnaryMethod_getResourceStatistics<WithStreamedUnaryMethod_getGeometryStatistics<WithStreamedUnaryMethod_getTexturesStatistics<WithStreamedUnaryMethod_getSceneBounds<WithStreamedUnaryMethod_getDeviceCount<WithStreamedUnaryMethod_getDeviceComputeModel<WithStreamedUnaryMethod_getDeviceName<WithStreamedUnaryMethod_isSupportedDevice<WithStreamedUnaryMethod_deviceCanRender<WithStreamedUnaryMethod_deviceCanDenoise<WithStreamedUnaryMethod_deviceSupportsHardwareRayTracing<WithStreamedUnaryMethod_deviceSharedSurfaceInfo<WithStreamedUnaryMethod_getAvailablePeerToPeerPairs<WithStreamedUnaryMethod_setDevicesActivity<WithStreamedUnaryMethod_isDeviceUsedForRendering<WithStreamedUnaryMethod_deviceUsesPriority<WithStreamedUnaryMethod_deviceUsesHardwareRayTracing<WithStreamedUnaryMethod_imageDeviceIndex<WithStreamedUnaryMethod_isDeviceUsedForDenoising<WithStreamedUnaryMethod_renderPriority<WithStreamedUnaryMethod_setRenderPriority<WithStreamedUnaryMethod_currentPeerToPeerGroups<WithStreamedUnaryMethod_hardwareRayTracingEnabled<WithStreamedUnaryMethod_openDeviceSettings<WithStreamedUnaryMethod_renderDeviceState<WithStreamedUnaryMethod_renderDeviceErrorCode<WithStreamedUnaryMethod_errorcodeToString<WithStreamedUnaryMethod_renderDeviceErrorMessage<WithStreamedUnaryMethod_saveRenderDeviceConfig<WithStreamedUnaryMethod_outOfCoreEnabled<WithStreamedUnaryMethod_enableOutOfCore<WithStreamedUnaryMethod_disableOutOfCore<WithStreamedUnaryMethod_getOutOfCoreMemoryUsage<WithStreamedUnaryMethod_setGpuHeadroom<WithStreamedUnaryMethod_getGpuHeadroom<WithStreamedUnaryMethod_setCoreLimit<WithStreamedUnaryMethod_disableCoreLimit<WithStreamedUnaryMethod_registerInputSharedSurface<WithStreamedUnaryMethod_unregisterInputSharedSurface<WithStreamedUnaryMethod_triggerAsyncTonemap<WithStreamedUnaryMethod_setSharedSurfaceOutputType<WithStreamedUnaryMethod_getSharedSurfaceOutputType<WithStreamedUnaryMethod_getRealTime<WithStreamedUnaryMethod_pauseRendering<WithStreamedUnaryMethod_continueRendering<WithStreamedUnaryMethod_isRenderingPaused<WithStreamedUnaryMethod_restartRendering<WithStreamedUnaryMethod_stopRendering<WithStreamedUnaryMethod_pick<WithStreamedUnaryMethod_pickWhitePoint<WithStreamedUnaryMethod_pickImagerWhitePoint<WithStreamedUnaryMethod_isOutputAovWhitePointPickable<WithStreamedUnaryMethod_pickOutputAovWhitePoint<WithStreamedUnaryMethod_pickCryptomatteMatte<WithStreamedUnaryMethod_modifyCryptomatteMatteSelection<WithStreamedUnaryMethod_toString<WithStreamedUnaryMethod_getDevicePciIds<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_setRenderTargetNode<WithStreamedUnaryMethod_getRenderTargetNode<WithStreamedUnaryMethod_getRenderGeometryNode<WithStreamedUnaryMethod_getRenderCameraNode<WithStreamedUnaryMethod_setRenderRegion<WithStreamedUnaryMethod_getRenderRegion<WithStreamedUnaryMethod_setAsyncTonemapParams<WithStreamedUnaryMethod_setAsyncTonemapParams1<WithStreamedUnaryMethod_asyncTonemapBufferType<WithStreamedUnaryMethod_asyncTonemapCryptomatteFalseColor<WithStreamedUnaryMethod_asyncTonemapOutputColorSpaceInfo<WithStreamedUnaryMethod_asyncTonemapColorSpace<WithStreamedUnaryMethod_asyncTonemapPremultipliedAlphaType<WithStreamedUnaryMethod_setAsyncTonemapRenderPasses<WithStreamedUnaryMethod_asyncTonemapRenderPasses<WithStreamedUnaryMethod_getEnabledAovs<WithStreamedUnaryMethod_freeTonemapPasses<WithStreamedUnaryMethod_displayRenderPassId<WithStreamedUnaryMethod_setSubSampleMode<WithStreamedUnaryMethod_getSubSampleMode<WithStreamedUnaryMethod_setClayMode<WithStreamedUnaryMethod_clayMode<WithStreamedUnaryMethod_fps<WithStreamedUnaryMethod_setFps<WithStreamedUnaryMethod_isCompiling<WithStreamedUnaryMethod_isCompressingTextures<WithStreamedUnaryMethod_hasPendingRenderData<WithStreamedUnaryMethod_getCurrentChangeLevel<WithStreamedUnaryMethod_getRenderImageChangeLevel<WithStreamedUnaryMethod_getRenderRestartedChangeLevel<WithStreamedUnaryMethod_setAsyncUpdateCallback<WithStreamedUnaryMethod_updatesAreAsync<WithStreamedUnaryMethod_isImageReady<WithStreamedUnaryMethod_resetImageReady<WithStreamedUnaryMethod_isRenderFailure<WithStreamedUnaryMethod_resetRenderFailure<WithStreamedUnaryMethod_setOnTileBlendedCallback<WithStreamedUnaryMethod_setOnNewStatisticsCallback<WithStreamedUnaryMethod_setOnNewImageCallback<WithStreamedUnaryMethod_setOnOcioErrorCallback<WithStreamedUnaryMethod_setOnRenderFailureCallback<WithStreamedUnaryMethod_setForceCallbacksInRenderThreads<WithStreamedUnaryMethod_grabRenderResult<WithStreamedUnaryMethod_releaseRenderResult<WithStreamedUnaryMethod_synchronousTonemap<WithStreamedUnaryMethod_synchronousTonemap1<WithStreamedUnaryMethod_synchronousTonemapAllRenderPasses<WithStreamedUnaryMethod_synchronousTonemapAllRenderPasses1<WithStreamedUnaryMethod_getRenderStatistics<WithStreamedUnaryMethod_getRenderResultStatistics<WithStreamedUnaryMethod_saveImage<WithStreamedUnaryMethod_saveImage1<WithStreamedUnaryMethod_saveImage2<WithStreamedUnaryMethod_saveRenderPasses<WithStreamedUnaryMethod_saveRenderPasses1<WithStreamedUnaryMethod_saveRenderPasses2<WithStreamedUnaryMethod_saveRenderPassesMultiExr<WithStreamedUnaryMethod_saveRenderPassesMultiExr1<WithStreamedUnaryMethod_saveRenderPassesDeepExr<WithStreamedUnaryMethod_deepImageEnabled<WithStreamedUnaryMethod_deepImageEnabled1<WithStreamedUnaryMethod_deepPassesEnabled<WithStreamedUnaryMethod_canSaveDeepImage<WithStreamedUnaryMethod_saveDeepImage<WithStreamedUnaryMethod_saveRenderState<WithStreamedUnaryMethod_loadRenderState<WithStreamedUnaryMethod_previewMaterial<WithStreamedUnaryMethod_previewMaterialHdr<WithStreamedUnaryMethod_previewMaterial1<WithStreamedUnaryMethod_getMemoryUsage<WithStreamedUnaryMethod_getResourceStatistics<WithStreamedUnaryMethod_getGeometryStatistics<WithStreamedUnaryMethod_getTexturesStatistics<WithStreamedUnaryMethod_getSceneBounds<WithStreamedUnaryMethod_getDeviceCount<WithStreamedUnaryMethod_getDeviceComputeModel<WithStreamedUnaryMethod_getDeviceName<WithStreamedUnaryMethod_isSupportedDevice<WithStreamedUnaryMethod_deviceCanRender<WithStreamedUnaryMethod_deviceCanDenoise<WithStreamedUnaryMethod_deviceSupportsHardwareRayTracing<WithStreamedUnaryMethod_deviceSharedSurfaceInfo<WithStreamedUnaryMethod_getAvailablePeerToPeerPairs<WithStreamedUnaryMethod_setDevicesActivity<WithStreamedUnaryMethod_isDeviceUsedForRendering<WithStreamedUnaryMethod_deviceUsesPriority<WithStreamedUnaryMethod_deviceUsesHardwareRayTracing<WithStreamedUnaryMethod_imageDeviceIndex<WithStreamedUnaryMethod_isDeviceUsedForDenoising<WithStreamedUnaryMethod_renderPriority<WithStreamedUnaryMethod_setRenderPriority<WithStreamedUnaryMethod_currentPeerToPeerGroups<WithStreamedUnaryMethod_hardwareRayTracingEnabled<WithStreamedUnaryMethod_openDeviceSettings<WithStreamedUnaryMethod_renderDeviceState<WithStreamedUnaryMethod_renderDeviceErrorCode<WithStreamedUnaryMethod_errorcodeToString<WithStreamedUnaryMethod_renderDeviceErrorMessage<WithStreamedUnaryMethod_saveRenderDeviceConfig<WithStreamedUnaryMethod_outOfCoreEnabled<WithStreamedUnaryMethod_enableOutOfCore<WithStreamedUnaryMethod_disableOutOfCore<WithStreamedUnaryMethod_getOutOfCoreMemoryUsage<WithStreamedUnaryMethod_setGpuHeadroom<WithStreamedUnaryMethod_getGpuHeadroom<WithStreamedUnaryMethod_setCoreLimit<WithStreamedUnaryMethod_disableCoreLimit<WithStreamedUnaryMethod_registerInputSharedSurface<WithStreamedUnaryMethod_unregisterInputSharedSurface<WithStreamedUnaryMethod_triggerAsyncTonemap<WithStreamedUnaryMethod_setSharedSurfaceOutputType<WithStreamedUnaryMethod_getSharedSurfaceOutputType<WithStreamedUnaryMethod_getRealTime<WithStreamedUnaryMethod_pauseRendering<WithStreamedUnaryMethod_continueRendering<WithStreamedUnaryMethod_isRenderingPaused<WithStreamedUnaryMethod_restartRendering<WithStreamedUnaryMethod_stopRendering<WithStreamedUnaryMethod_pick<WithStreamedUnaryMethod_pickWhitePoint<WithStreamedUnaryMethod_pickImagerWhitePoint<WithStreamedUnaryMethod_isOutputAovWhitePointPickable<WithStreamedUnaryMethod_pickOutputAovWhitePoint<WithStreamedUnaryMethod_pickCryptomatteMatte<WithStreamedUnaryMethod_modifyCryptomatteMatteSelection<WithStreamedUnaryMethod_toString<WithStreamedUnaryMethod_getDevicePciIds<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > StreamedService;
};

// GRPC interface definition for class 'ApiRenderEngine_PickIntersection' from 'apirender.h'
//
// GRPC interface definition for class 'ApiRenderImage' from 'apirender.h'
class ApiRenderImageService final {
 public:
  static constexpr char const* service_full_name() {
    return "octaneapi.ApiRenderImageService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // / Little convenience function to check if this buffer is empty
    virtual ::grpc::Status isEmpty(::grpc::ClientContext* context, const ::octaneapi::ApiRenderImage_isEmptyRequest& request, ::octaneapi::ApiRenderImage_isEmptyResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderImage_isEmptyResponse>> AsyncisEmpty(::grpc::ClientContext* context, const ::octaneapi::ApiRenderImage_isEmptyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderImage_isEmptyResponse>>(AsyncisEmptyRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderImage_isEmptyResponse>> PrepareAsyncisEmpty(::grpc::ClientContext* context, const ::octaneapi::ApiRenderImage_isEmptyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderImage_isEmptyResponse>>(PrepareAsyncisEmptyRaw(context, request, cq));
    }
    // / Little convenience function to check if a render result is LDR (1 byte per channel) or HDR
    // / (2 or 4 bytes per channel)
    virtual ::grpc::Status isHdr(::grpc::ClientContext* context, const ::octaneapi::ApiRenderImage_isHdrRequest& request, ::octaneapi::ApiRenderImage_isHdrResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderImage_isHdrResponse>> AsyncisHdr(::grpc::ClientContext* context, const ::octaneapi::ApiRenderImage_isHdrRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderImage_isHdrResponse>>(AsyncisHdrRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderImage_isHdrResponse>> PrepareAsyncisHdr(::grpc::ClientContext* context, const ::octaneapi::ApiRenderImage_isHdrRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderImage_isHdrResponse>>(PrepareAsyncisHdrRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      // / Little convenience function to check if this buffer is empty
      virtual void isEmpty(::grpc::ClientContext* context, const ::octaneapi::ApiRenderImage_isEmptyRequest* request, ::octaneapi::ApiRenderImage_isEmptyResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void isEmpty(::grpc::ClientContext* context, const ::octaneapi::ApiRenderImage_isEmptyRequest* request, ::octaneapi::ApiRenderImage_isEmptyResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Little convenience function to check if a render result is LDR (1 byte per channel) or HDR
      // / (2 or 4 bytes per channel)
      virtual void isHdr(::grpc::ClientContext* context, const ::octaneapi::ApiRenderImage_isHdrRequest* request, ::octaneapi::ApiRenderImage_isHdrResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void isHdr(::grpc::ClientContext* context, const ::octaneapi::ApiRenderImage_isHdrRequest* request, ::octaneapi::ApiRenderImage_isHdrResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderImage_isEmptyResponse>* AsyncisEmptyRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderImage_isEmptyRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderImage_isEmptyResponse>* PrepareAsyncisEmptyRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderImage_isEmptyRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderImage_isHdrResponse>* AsyncisHdrRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderImage_isHdrRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::ApiRenderImage_isHdrResponse>* PrepareAsyncisHdrRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderImage_isHdrRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status isEmpty(::grpc::ClientContext* context, const ::octaneapi::ApiRenderImage_isEmptyRequest& request, ::octaneapi::ApiRenderImage_isEmptyResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderImage_isEmptyResponse>> AsyncisEmpty(::grpc::ClientContext* context, const ::octaneapi::ApiRenderImage_isEmptyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderImage_isEmptyResponse>>(AsyncisEmptyRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderImage_isEmptyResponse>> PrepareAsyncisEmpty(::grpc::ClientContext* context, const ::octaneapi::ApiRenderImage_isEmptyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderImage_isEmptyResponse>>(PrepareAsyncisEmptyRaw(context, request, cq));
    }
    ::grpc::Status isHdr(::grpc::ClientContext* context, const ::octaneapi::ApiRenderImage_isHdrRequest& request, ::octaneapi::ApiRenderImage_isHdrResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderImage_isHdrResponse>> AsyncisHdr(::grpc::ClientContext* context, const ::octaneapi::ApiRenderImage_isHdrRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderImage_isHdrResponse>>(AsyncisHdrRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderImage_isHdrResponse>> PrepareAsyncisHdr(::grpc::ClientContext* context, const ::octaneapi::ApiRenderImage_isHdrRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderImage_isHdrResponse>>(PrepareAsyncisHdrRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void isEmpty(::grpc::ClientContext* context, const ::octaneapi::ApiRenderImage_isEmptyRequest* request, ::octaneapi::ApiRenderImage_isEmptyResponse* response, std::function<void(::grpc::Status)>) override;
      void isEmpty(::grpc::ClientContext* context, const ::octaneapi::ApiRenderImage_isEmptyRequest* request, ::octaneapi::ApiRenderImage_isEmptyResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void isHdr(::grpc::ClientContext* context, const ::octaneapi::ApiRenderImage_isHdrRequest* request, ::octaneapi::ApiRenderImage_isHdrResponse* response, std::function<void(::grpc::Status)>) override;
      void isHdr(::grpc::ClientContext* context, const ::octaneapi::ApiRenderImage_isHdrRequest* request, ::octaneapi::ApiRenderImage_isHdrResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderImage_isEmptyResponse>* AsyncisEmptyRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderImage_isEmptyRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderImage_isEmptyResponse>* PrepareAsyncisEmptyRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderImage_isEmptyRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderImage_isHdrResponse>* AsyncisHdrRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderImage_isHdrRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::ApiRenderImage_isHdrResponse>* PrepareAsyncisHdrRaw(::grpc::ClientContext* context, const ::octaneapi::ApiRenderImage_isHdrRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_isEmpty_;
    const ::grpc::internal::RpcMethod rpcmethod_isHdr_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // / Little convenience function to check if this buffer is empty
    virtual ::grpc::Status isEmpty(::grpc::ServerContext* context, const ::octaneapi::ApiRenderImage_isEmptyRequest* request, ::octaneapi::ApiRenderImage_isEmptyResponse* response);
    // / Little convenience function to check if a render result is LDR (1 byte per channel) or HDR
    // / (2 or 4 bytes per channel)
    virtual ::grpc::Status isHdr(::grpc::ServerContext* context, const ::octaneapi::ApiRenderImage_isHdrRequest* request, ::octaneapi::ApiRenderImage_isHdrResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_isEmpty : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_isEmpty() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_isEmpty() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isEmpty(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderImage_isEmptyRequest* /*request*/, ::octaneapi::ApiRenderImage_isEmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestisEmpty(::grpc::ServerContext* context, ::octaneapi::ApiRenderImage_isEmptyRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiRenderImage_isEmptyResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_isHdr : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_isHdr() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_isHdr() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isHdr(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderImage_isHdrRequest* /*request*/, ::octaneapi::ApiRenderImage_isHdrResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestisHdr(::grpc::ServerContext* context, ::octaneapi::ApiRenderImage_isHdrRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::ApiRenderImage_isHdrResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_isEmpty<WithAsyncMethod_isHdr<Service > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_isEmpty : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_isEmpty() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderImage_isEmptyRequest, ::octaneapi::ApiRenderImage_isEmptyResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderImage_isEmptyRequest* request, ::octaneapi::ApiRenderImage_isEmptyResponse* response) { return this->isEmpty(context, request, response); }));}
    void SetMessageAllocatorFor_isEmpty(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderImage_isEmptyRequest, ::octaneapi::ApiRenderImage_isEmptyResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderImage_isEmptyRequest, ::octaneapi::ApiRenderImage_isEmptyResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_isEmpty() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isEmpty(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderImage_isEmptyRequest* /*request*/, ::octaneapi::ApiRenderImage_isEmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* isEmpty(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderImage_isEmptyRequest* /*request*/, ::octaneapi::ApiRenderImage_isEmptyResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_isHdr : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_isHdr() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderImage_isHdrRequest, ::octaneapi::ApiRenderImage_isHdrResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::ApiRenderImage_isHdrRequest* request, ::octaneapi::ApiRenderImage_isHdrResponse* response) { return this->isHdr(context, request, response); }));}
    void SetMessageAllocatorFor_isHdr(
        ::grpc::MessageAllocator< ::octaneapi::ApiRenderImage_isHdrRequest, ::octaneapi::ApiRenderImage_isHdrResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::ApiRenderImage_isHdrRequest, ::octaneapi::ApiRenderImage_isHdrResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_isHdr() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isHdr(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderImage_isHdrRequest* /*request*/, ::octaneapi::ApiRenderImage_isHdrResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* isHdr(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::ApiRenderImage_isHdrRequest* /*request*/, ::octaneapi::ApiRenderImage_isHdrResponse* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_isEmpty<WithCallbackMethod_isHdr<Service > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_isEmpty : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_isEmpty() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_isEmpty() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isEmpty(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderImage_isEmptyRequest* /*request*/, ::octaneapi::ApiRenderImage_isEmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_isHdr : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_isHdr() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_isHdr() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isHdr(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderImage_isHdrRequest* /*request*/, ::octaneapi::ApiRenderImage_isHdrResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_isEmpty : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_isEmpty() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_isEmpty() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isEmpty(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderImage_isEmptyRequest* /*request*/, ::octaneapi::ApiRenderImage_isEmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestisEmpty(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_isHdr : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_isHdr() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_isHdr() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isHdr(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderImage_isHdrRequest* /*request*/, ::octaneapi::ApiRenderImage_isHdrResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestisHdr(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_isEmpty : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_isEmpty() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->isEmpty(context, request, response); }));
    }
    ~WithRawCallbackMethod_isEmpty() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isEmpty(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderImage_isEmptyRequest* /*request*/, ::octaneapi::ApiRenderImage_isEmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* isEmpty(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_isHdr : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_isHdr() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->isHdr(context, request, response); }));
    }
    ~WithRawCallbackMethod_isHdr() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isHdr(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderImage_isHdrRequest* /*request*/, ::octaneapi::ApiRenderImage_isHdrResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* isHdr(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_isEmpty : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_isEmpty() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderImage_isEmptyRequest, ::octaneapi::ApiRenderImage_isEmptyResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderImage_isEmptyRequest, ::octaneapi::ApiRenderImage_isEmptyResponse>* streamer) {
                       return this->StreamedisEmpty(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_isEmpty() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status isEmpty(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderImage_isEmptyRequest* /*request*/, ::octaneapi::ApiRenderImage_isEmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedisEmpty(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderImage_isEmptyRequest,::octaneapi::ApiRenderImage_isEmptyResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_isHdr : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_isHdr() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::ApiRenderImage_isHdrRequest, ::octaneapi::ApiRenderImage_isHdrResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::ApiRenderImage_isHdrRequest, ::octaneapi::ApiRenderImage_isHdrResponse>* streamer) {
                       return this->StreamedisHdr(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_isHdr() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status isHdr(::grpc::ServerContext* /*context*/, const ::octaneapi::ApiRenderImage_isHdrRequest* /*request*/, ::octaneapi::ApiRenderImage_isHdrResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedisHdr(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::ApiRenderImage_isHdrRequest,::octaneapi::ApiRenderImage_isHdrResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_isEmpty<WithStreamedUnaryMethod_isHdr<Service > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_isEmpty<WithStreamedUnaryMethod_isHdr<Service > > StreamedService;
};

}  // namespace octaneapi


#include <grpcpp/ports_undef.inc>
#endif  // GRPC_apirender_2eproto__INCLUDED
