// Copyright (C) 2026 OTOY NZ Ltd.

// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: octaneenums.proto
// Protobuf C++ Version: 6.31.1

#ifndef octaneenums_2eproto_2epb_2eh
#define octaneenums_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 6031001
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_octaneenums_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_octaneenums_2eproto {
  static const ::uint32_t offsets[];
};
extern "C" {
extern const ::google::protobuf::internal::DescriptorTable descriptor_table_octaneenums_2eproto;
}  // extern "C"
namespace octaneapi {
enum ActivationResult : int;
extern const uint32_t ActivationResult_internal_data_[];
enum AnalyticLightType : int;
extern const uint32_t AnalyticLightType_internal_data_[];
enum AnimationTimeTransformType : int;
extern const uint32_t AnimationTimeTransformType_internal_data_[];
enum AnimationType : int;
extern const uint32_t AnimationType_internal_data_[];
enum AsPixelGroupMode : int;
extern const uint32_t AsPixelGroupMode_internal_data_[];
enum BakingTextureType : int;
extern const uint32_t BakingTextureType_internal_data_[];
enum BinaryOperation : int;
extern const uint32_t BinaryOperation_internal_data_[];
enum BlendMode : int;
extern const uint32_t BlendMode_internal_data_[];
enum BlendRegionMask : int;
extern const uint32_t BlendRegionMask_internal_data_[];
enum BorderMode : int;
extern const uint32_t BorderMode_internal_data_[];
enum BrdfModel : int;
extern const uint32_t BrdfModel_internal_data_[];
enum BxDFDiffuseModel : int;
extern const uint32_t BxDFDiffuseModel_internal_data_[];
enum BxDFSheenModel : int;
extern const uint32_t BxDFSheenModel_internal_data_[];
enum BxDFSpecularModel : int;
extern const uint32_t BxDFSpecularModel_internal_data_[];
enum BxDFTranmissionType : int;
extern const uint32_t BxDFTranmissionType_internal_data_[];
enum BxDFUniversalModel : int;
extern const uint32_t BxDFUniversalModel_internal_data_[];
enum CacheStatus : int;
extern const uint32_t CacheStatus_internal_data_[];
enum ChangeEventType : int;
extern const uint32_t ChangeEventType_internal_data_[];
enum ChannelGroups : int;
extern const uint32_t ChannelGroups_internal_data_[];
enum ChannelMapping : int;
extern const uint32_t ChannelMapping_internal_data_[];
enum Cinema4dNoiseType : int;
extern const uint32_t Cinema4dNoiseType_internal_data_[];
enum ClayMode : int;
extern const uint32_t ClayMode_internal_data_[];
enum ColorChannelType : int;
extern const uint32_t ColorChannelType_internal_data_[];
enum ColorPickerSpace : int;
extern const uint32_t ColorPickerSpace_internal_data_[];
enum ColorSpaceConversion : int;
extern const uint32_t ColorSpaceConversion_internal_data_[];
enum ColorSpaceCurveType : int;
extern const uint32_t ColorSpaceCurveType_internal_data_[];
enum ComparisonOperation : int;
extern const uint32_t ComparisonOperation_internal_data_[];
enum CompilationResult : int;
extern const uint32_t CompilationResult_internal_data_[];
enum ComponentPickerOperation : int;
extern const uint32_t ComponentPickerOperation_internal_data_[];
enum CompositeAlphaOperation : int;
extern const uint32_t CompositeAlphaOperation_internal_data_[];
enum CompositeOperation : int;
extern const uint32_t CompositeOperation_internal_data_[];
enum CoordinateAxis : int;
extern const uint32_t CoordinateAxis_internal_data_[];
enum CoordinateSystem : int;
extern const uint32_t CoordinateSystem_internal_data_[];
enum CryptomatteType : int;
extern const uint32_t CryptomatteType_internal_data_[];
enum CurvatureModes : int;
extern const uint32_t CurvatureModes_internal_data_[];
enum CustomAov : int;
extern const uint32_t CustomAov_internal_data_[];
enum CustomAovChannel : int;
extern const uint32_t CustomAovChannel_internal_data_[];
enum CustomAovSecondaryRayVisibility : int;
extern const uint32_t CustomAovSecondaryRayVisibility_internal_data_[];
enum CustomCurveMode : int;
extern const uint32_t CustomCurveMode_internal_data_[];
enum DaylightModel : int;
extern const uint32_t DaylightModel_internal_data_[];
enum DecalTextureIndex : int;
extern const uint32_t DecalTextureIndex_internal_data_[];
enum DenoiserQuality : int;
extern const uint32_t DenoiserQuality_internal_data_[];
enum DenoiserType : int;
extern const uint32_t DenoiserType_internal_data_[];
enum DirectLightMode : int;
extern const uint32_t DirectLightMode_internal_data_[];
enum DispersionModel : int;
extern const uint32_t DispersionModel_internal_data_[];
enum DisplacementDirection : int;
extern const uint32_t DisplacementDirection_internal_data_[];
enum DisplacementLod : int;
extern const uint32_t DisplacementLod_internal_data_[];
enum DisplacementMapType : int;
extern const uint32_t DisplacementMapType_internal_data_[];
enum DisplacementQuality : int;
extern const uint32_t DisplacementQuality_internal_data_[];
enum DisplacementTextureAxes : int;
extern const uint32_t DisplacementTextureAxes_internal_data_[];
enum DisplacementTextureSpace : int;
extern const uint32_t DisplacementTextureSpace_internal_data_[];
enum DistanceMode : int;
extern const uint32_t DistanceMode_internal_data_[];
enum ExpandContractRgbMode : int;
extern const uint32_t ExpandContractRgbMode_internal_data_[];
enum ExportState : int;
extern const uint32_t ExportState_internal_data_[];
enum ExrCompressionType : int;
extern const uint32_t ExrCompressionType_internal_data_[];
enum FaceCullingMode : int;
extern const uint32_t FaceCullingMode_internal_data_[];
enum FalloffTextureMode : int;
extern const uint32_t FalloffTextureMode_internal_data_[];
enum FilterType : int;
extern const uint32_t FilterType_internal_data_[];
enum FractalNoiseMode : int;
extern const uint32_t FractalNoiseMode_internal_data_[];
enum GaussianSplatClipMode : int;
extern const uint32_t GaussianSplatClipMode_internal_data_[];
enum GaussianSplatLightingMode : int;
extern const uint32_t GaussianSplatLightingMode_internal_data_[];
enum GeometryExportFormat : int;
extern const uint32_t GeometryExportFormat_internal_data_[];
enum GeometryImportObjectLayers : int;
extern const uint32_t GeometryImportObjectLayers_internal_data_[];
enum GeometryImportScale : int;
extern const uint32_t GeometryImportScale_internal_data_[];
enum GlobalLightIdMaskAction : int;
extern const uint32_t GlobalLightIdMaskAction_internal_data_[];
enum GlobalTexAvo : int;
extern const uint32_t GlobalTexAvo_internal_data_[];
enum GradientGeneratorType : int;
extern const uint32_t GradientGeneratorType_internal_data_[];
enum GradientInterpColorSpace : int;
extern const uint32_t GradientInterpColorSpace_internal_data_[];
enum GradientInterpType : int;
extern const uint32_t GradientInterpType_internal_data_[];
enum HairInterpolationType : int;
extern const uint32_t HairInterpolationType_internal_data_[];
enum HairMaterialBaseColorMode : int;
extern const uint32_t HairMaterialBaseColorMode_internal_data_[];
enum IesPhotometryMode : int;
extern const uint32_t IesPhotometryMode_internal_data_[];
enum ImageChannelType : int;
extern const uint32_t ImageChannelType_internal_data_[];
enum ImageColorType : int;
extern const uint32_t ImageColorType_internal_data_[];
enum ImageFilterType : int;
extern const uint32_t ImageFilterType_internal_data_[];
enum ImageMaskSource : int;
extern const uint32_t ImageMaskSource_internal_data_[];
enum ImageSaveFormat : int;
extern const uint32_t ImageSaveFormat_internal_data_[];
enum ImageType : int;
extern const uint32_t ImageType_internal_data_[];
enum ImportRestAttributesMode : int;
extern const uint32_t ImportRestAttributesMode_internal_data_[];
enum InfoChannelSamplingMode : int;
extern const uint32_t InfoChannelSamplingMode_internal_data_[];
enum InfoChannelType : int;
extern const uint32_t InfoChannelType_internal_data_[];
enum InputAction : int;
extern const uint32_t InputAction_internal_data_[];
enum InterpolationType : int;
extern const uint32_t InterpolationType_internal_data_[];
enum ItemDbOrigin : int;
extern const uint32_t ItemDbOrigin_internal_data_[];
enum LightAov : int;
extern const uint32_t LightAov_internal_data_[];
enum LightPassMask : int;
extern const uint32_t LightPassMask_internal_data_[];
enum LightSampler : int;
extern const uint32_t LightSampler_internal_data_[];
enum LiveDbThumbnailView : int;
extern const uint32_t LiveDbThumbnailView_internal_data_[];
enum LogicalOperator : int;
extern const uint32_t LogicalOperator_internal_data_[];
enum LuaScriptType : int;
extern const uint32_t LuaScriptType_internal_data_[];
enum MemoryLocation : int;
extern const uint32_t MemoryLocation_internal_data_[];
enum MetallicReflectionMode : int;
extern const uint32_t MetallicReflectionMode_internal_data_[];
enum ModuleType : int;
extern const uint32_t ModuleType_internal_data_[];
enum MoireMosaicShape : int;
extern const uint32_t MoireMosaicShape_internal_data_[];
enum MovableInputFormat : int;
extern const uint32_t MovableInputFormat_internal_data_[];
enum NamedColorSpace : int;
extern const uint32_t NamedColorSpace_internal_data_[];
enum NoiseType : int;
extern const uint32_t NoiseType_internal_data_[];
enum NoiseTypeOsl : int;
extern const uint32_t NoiseTypeOsl_internal_data_[];
enum NormalType : int;
extern const uint32_t NormalType_internal_data_[];
enum ObjImportColorSpace : int;
extern const uint32_t ObjImportColorSpace_internal_data_[];
enum ObjectIncludeMode : int;
extern const uint32_t ObjectIncludeMode_internal_data_[];
enum OctaneLiveCategory : int;
extern const uint32_t OctaneLiveCategory_internal_data_[];
enum PanoramicCameraMode : int;
extern const uint32_t PanoramicCameraMode_internal_data_[];
enum PhotonTypes : int;
extern const uint32_t PhotonTypes_internal_data_[];
enum PositionType : int;
extern const uint32_t PositionType_internal_data_[];
enum PrePassType : int;
extern const uint32_t PrePassType_internal_data_[];
enum PreferencesTabId : int;
extern const uint32_t PreferencesTabId_internal_data_[];
enum PremultipliedAlphaType : int;
extern const uint32_t PremultipliedAlphaType_internal_data_[];
enum PreviewType : int;
extern const uint32_t PreviewType_internal_data_[];
enum PrimitiveType : int;
extern const uint32_t PrimitiveType_internal_data_[];
enum ProceduralEffectType : int;
extern const uint32_t ProceduralEffectType_internal_data_[];
enum ReferenceAABBDisplay : int;
extern const uint32_t ReferenceAABBDisplay_internal_data_[];
enum RenderDeviceState : int;
extern const uint32_t RenderDeviceState_internal_data_[];
enum RenderError : int;
extern const uint32_t RenderError_internal_data_[];
enum RenderJobAction : int;
extern const uint32_t RenderJobAction_internal_data_[];
enum RenderJobStatus : int;
extern const uint32_t RenderJobStatus_internal_data_[];
enum RenderLayerMode : int;
extern const uint32_t RenderLayerMode_internal_data_[];
enum RenderPassGroupId : int;
extern const uint32_t RenderPassGroupId_internal_data_[];
enum RenderPassId : int;
extern const uint32_t RenderPassId_internal_data_[];
enum RenderState : int;
extern const uint32_t RenderState_internal_data_[];
enum ResourceCategory : int;
extern const uint32_t ResourceCategory_internal_data_[];
enum ResponseCurveId : int;
extern const uint32_t ResponseCurveId_internal_data_[];
enum RoundEdgesMode : int;
extern const uint32_t RoundEdgesMode_internal_data_[];
enum RoundingMode : int;
extern const uint32_t RoundingMode_internal_data_[];
enum SamplerType : int;
extern const uint32_t SamplerType_internal_data_[];
enum ScatterSurfaceHairMode : int;
extern const uint32_t ScatterSurfaceHairMode_internal_data_[];
enum ScatterSurfaceOrientationPriority : int;
extern const uint32_t ScatterSurfaceOrientationPriority_internal_data_[];
enum ScatterSurfaceParticleMode : int;
extern const uint32_t ScatterSurfaceParticleMode_internal_data_[];
enum ScatterSurfacePolygonMode : int;
extern const uint32_t ScatterSurfacePolygonMode_internal_data_[];
enum ScatterSurfaceReferenceType : int;
extern const uint32_t ScatterSurfaceReferenceType_internal_data_[];
enum ScatterSurfaceSelectionMode : int;
extern const uint32_t ScatterSurfaceSelectionMode_internal_data_[];
enum ScatterSurfaceTransformType : int;
extern const uint32_t ScatterSurfaceTransformType_internal_data_[];
enum ScatterVolumeOrientationPriority : int;
extern const uint32_t ScatterVolumeOrientationPriority_internal_data_[];
enum ScatterVolumeReferenceType : int;
extern const uint32_t ScatterVolumeReferenceType_internal_data_[];
enum ScatterVolumeSelectionMode : int;
extern const uint32_t ScatterVolumeSelectionMode_internal_data_[];
enum ScatterVolumeShape : int;
extern const uint32_t ScatterVolumeShape_internal_data_[];
enum ScatterVolumeTransformType : int;
extern const uint32_t ScatterVolumeTransformType_internal_data_[];
enum ScriptExecuteType : int;
extern const uint32_t ScriptExecuteType_internal_data_[];
enum SharedSurfaceType : int;
extern const uint32_t SharedSurfaceType_internal_data_[];
enum ShutterIntervalAlignment : int;
extern const uint32_t ShutterIntervalAlignment_internal_data_[];
enum SimulatedLens : int;
extern const uint32_t SimulatedLens_internal_data_[];
enum SpotlightOrientation : int;
extern const uint32_t SpotlightOrientation_internal_data_[];
enum StereoMode : int;
extern const uint32_t StereoMode_internal_data_[];
enum StereoOutput : int;
extern const uint32_t StereoOutput_internal_data_[];
enum SubDivFVarInterpolateBoundary : int;
extern const uint32_t SubDivFVarInterpolateBoundary_internal_data_[];
enum SubDivInterpolateBoundary : int;
extern const uint32_t SubDivInterpolateBoundary_internal_data_[];
enum SubDivSchemeType : int;
extern const uint32_t SubDivSchemeType_internal_data_[];
enum SubSampleMode : int;
extern const uint32_t SubSampleMode_internal_data_[];
enum TexelType : int;
extern const uint32_t TexelType_internal_data_[];
enum TextureNodeTypeMode : int;
extern const uint32_t TextureNodeTypeMode_internal_data_[];
enum TexturePinValueTypeMode : int;
extern const uint32_t TexturePinValueTypeMode_internal_data_[];
enum TextureValueType : int;
extern const uint32_t TextureValueType_internal_data_[];
enum TiffCompressionType : int;
extern const uint32_t TiffCompressionType_internal_data_[];
enum TilePatternType : int;
extern const uint32_t TilePatternType_internal_data_[];
enum TimeEventType : int;
extern const uint32_t TimeEventType_internal_data_[];
enum TonemapBufferType : int;
extern const uint32_t TonemapBufferType_internal_data_[];
enum TonemapOrder : int;
extern const uint32_t TonemapOrder_internal_data_[];
enum ToonLightMode : int;
extern const uint32_t ToonLightMode_internal_data_[];
enum TraceSetBounceType : int;
extern const uint32_t TraceSetBounceType_internal_data_[];
enum TraceSetFutureHits : int;
extern const uint32_t TraceSetFutureHits_internal_data_[];
enum UIOperationsFlag : int;
extern const uint32_t UIOperationsFlag_internal_data_[];
enum UnaryOperation : int;
extern const uint32_t UnaryOperation_internal_data_[];
enum UnblendExtractMode : int;
extern const uint32_t UnblendExtractMode_internal_data_[];
enum UnblendOutputColorRange : int;
extern const uint32_t UnblendOutputColorRange_internal_data_[];
enum UniversalCamApertureShape : int;
extern const uint32_t UniversalCamApertureShape_internal_data_[];
enum UniversalCamCubemapLayout : int;
extern const uint32_t UniversalCamCubemapLayout_internal_data_[];
enum UniversalCamFisheyeProjection : int;
extern const uint32_t UniversalCamFisheyeProjection_internal_data_[];
enum UniversalCamFisheyeType : int;
extern const uint32_t UniversalCamFisheyeType_internal_data_[];
enum UniversalCamMode : int;
extern const uint32_t UniversalCamMode_internal_data_[];
enum UpSampleMode : int;
extern const uint32_t UpSampleMode_internal_data_[];
enum UpSampleSourcePercentage : int;
extern const uint32_t UpSampleSourcePercentage_internal_data_[];
enum UpSamplerType : int;
extern const uint32_t UpSamplerType_internal_data_[];
enum UsdDisplayPurpose : int;
extern const uint32_t UsdDisplayPurpose_internal_data_[];
enum VdbGridIds : int;
extern const uint32_t VdbGridIds_internal_data_[];
enum VectronCircleType : int;
extern const uint32_t VectronCircleType_internal_data_[];
enum VectronEdgeType : int;
extern const uint32_t VectronEdgeType_internal_data_[];
enum VirtualTexturingMode : int;
extern const uint32_t VirtualTexturingMode_internal_data_[];
enum VolumeEmissionType : int;
extern const uint32_t VolumeEmissionType_internal_data_[];
enum VolumeInterpolationType : int;
extern const uint32_t VolumeInterpolationType_internal_data_[];
enum VolumeSampling : int;
extern const uint32_t VolumeSampling_internal_data_[];
enum WCoordinateBorderMode : int;
extern const uint32_t WCoordinateBorderMode_internal_data_[];
enum Waveform : int;
extern const uint32_t Waveform_internal_data_[];
enum WhiteLightSpectrum : int;
extern const uint32_t WhiteLightSpectrum_internal_data_[];
enum WindingOrder : int;
extern const uint32_t WindingOrder_internal_data_[];
class ApiArrayImageTypeT;
struct ApiArrayImageTypeTDefaultTypeInternal;
extern ApiArrayImageTypeTDefaultTypeInternal _ApiArrayImageTypeT_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ApiArrayImageTypeT_class_data_;
class ApiArrayRenderPassId;
struct ApiArrayRenderPassIdDefaultTypeInternal;
extern ApiArrayRenderPassIdDefaultTypeInternal _ApiArrayRenderPassId_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ApiArrayRenderPassId_class_data_;
}  // namespace octaneapi
namespace google {
namespace protobuf {
template <>
internal::EnumTraitsT<::octaneapi::ActivationResult_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::ActivationResult>;
template <>
internal::EnumTraitsT<::octaneapi::AnalyticLightType_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::AnalyticLightType>;
template <>
internal::EnumTraitsT<::octaneapi::AnimationTimeTransformType_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::AnimationTimeTransformType>;
template <>
internal::EnumTraitsT<::octaneapi::AnimationType_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::AnimationType>;
template <>
internal::EnumTraitsT<::octaneapi::AsPixelGroupMode_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::AsPixelGroupMode>;
template <>
internal::EnumTraitsT<::octaneapi::BakingTextureType_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::BakingTextureType>;
template <>
internal::EnumTraitsT<::octaneapi::BinaryOperation_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::BinaryOperation>;
template <>
internal::EnumTraitsT<::octaneapi::BlendMode_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::BlendMode>;
template <>
internal::EnumTraitsT<::octaneapi::BlendRegionMask_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::BlendRegionMask>;
template <>
internal::EnumTraitsT<::octaneapi::BorderMode_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::BorderMode>;
template <>
internal::EnumTraitsT<::octaneapi::BrdfModel_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::BrdfModel>;
template <>
internal::EnumTraitsT<::octaneapi::BxDFDiffuseModel_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::BxDFDiffuseModel>;
template <>
internal::EnumTraitsT<::octaneapi::BxDFSheenModel_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::BxDFSheenModel>;
template <>
internal::EnumTraitsT<::octaneapi::BxDFSpecularModel_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::BxDFSpecularModel>;
template <>
internal::EnumTraitsT<::octaneapi::BxDFTranmissionType_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::BxDFTranmissionType>;
template <>
internal::EnumTraitsT<::octaneapi::BxDFUniversalModel_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::BxDFUniversalModel>;
template <>
internal::EnumTraitsT<::octaneapi::CacheStatus_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::CacheStatus>;
template <>
internal::EnumTraitsT<::octaneapi::ChangeEventType_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::ChangeEventType>;
template <>
internal::EnumTraitsT<::octaneapi::ChannelGroups_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::ChannelGroups>;
template <>
internal::EnumTraitsT<::octaneapi::ChannelMapping_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::ChannelMapping>;
template <>
internal::EnumTraitsT<::octaneapi::Cinema4dNoiseType_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::Cinema4dNoiseType>;
template <>
internal::EnumTraitsT<::octaneapi::ClayMode_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::ClayMode>;
template <>
internal::EnumTraitsT<::octaneapi::ColorChannelType_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::ColorChannelType>;
template <>
internal::EnumTraitsT<::octaneapi::ColorPickerSpace_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::ColorPickerSpace>;
template <>
internal::EnumTraitsT<::octaneapi::ColorSpaceConversion_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::ColorSpaceConversion>;
template <>
internal::EnumTraitsT<::octaneapi::ColorSpaceCurveType_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::ColorSpaceCurveType>;
template <>
internal::EnumTraitsT<::octaneapi::ComparisonOperation_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::ComparisonOperation>;
template <>
internal::EnumTraitsT<::octaneapi::CompilationResult_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::CompilationResult>;
template <>
internal::EnumTraitsT<::octaneapi::ComponentPickerOperation_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::ComponentPickerOperation>;
template <>
internal::EnumTraitsT<::octaneapi::CompositeAlphaOperation_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::CompositeAlphaOperation>;
template <>
internal::EnumTraitsT<::octaneapi::CompositeOperation_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::CompositeOperation>;
template <>
internal::EnumTraitsT<::octaneapi::CoordinateAxis_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::CoordinateAxis>;
template <>
internal::EnumTraitsT<::octaneapi::CoordinateSystem_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::CoordinateSystem>;
template <>
internal::EnumTraitsT<::octaneapi::CryptomatteType_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::CryptomatteType>;
template <>
internal::EnumTraitsT<::octaneapi::CurvatureModes_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::CurvatureModes>;
template <>
internal::EnumTraitsT<::octaneapi::CustomAov_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::CustomAov>;
template <>
internal::EnumTraitsT<::octaneapi::CustomAovChannel_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::CustomAovChannel>;
template <>
internal::EnumTraitsT<::octaneapi::CustomAovSecondaryRayVisibility_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::CustomAovSecondaryRayVisibility>;
template <>
internal::EnumTraitsT<::octaneapi::CustomCurveMode_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::CustomCurveMode>;
template <>
internal::EnumTraitsT<::octaneapi::DaylightModel_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::DaylightModel>;
template <>
internal::EnumTraitsT<::octaneapi::DecalTextureIndex_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::DecalTextureIndex>;
template <>
internal::EnumTraitsT<::octaneapi::DenoiserQuality_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::DenoiserQuality>;
template <>
internal::EnumTraitsT<::octaneapi::DenoiserType_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::DenoiserType>;
template <>
internal::EnumTraitsT<::octaneapi::DirectLightMode_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::DirectLightMode>;
template <>
internal::EnumTraitsT<::octaneapi::DispersionModel_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::DispersionModel>;
template <>
internal::EnumTraitsT<::octaneapi::DisplacementDirection_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::DisplacementDirection>;
template <>
internal::EnumTraitsT<::octaneapi::DisplacementLod_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::DisplacementLod>;
template <>
internal::EnumTraitsT<::octaneapi::DisplacementMapType_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::DisplacementMapType>;
template <>
internal::EnumTraitsT<::octaneapi::DisplacementQuality_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::DisplacementQuality>;
template <>
internal::EnumTraitsT<::octaneapi::DisplacementTextureAxes_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::DisplacementTextureAxes>;
template <>
internal::EnumTraitsT<::octaneapi::DisplacementTextureSpace_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::DisplacementTextureSpace>;
template <>
internal::EnumTraitsT<::octaneapi::DistanceMode_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::DistanceMode>;
template <>
internal::EnumTraitsT<::octaneapi::ExpandContractRgbMode_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::ExpandContractRgbMode>;
template <>
internal::EnumTraitsT<::octaneapi::ExportState_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::ExportState>;
template <>
internal::EnumTraitsT<::octaneapi::ExrCompressionType_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::ExrCompressionType>;
template <>
internal::EnumTraitsT<::octaneapi::FaceCullingMode_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::FaceCullingMode>;
template <>
internal::EnumTraitsT<::octaneapi::FalloffTextureMode_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::FalloffTextureMode>;
template <>
internal::EnumTraitsT<::octaneapi::FilterType_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::FilterType>;
template <>
internal::EnumTraitsT<::octaneapi::FractalNoiseMode_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::FractalNoiseMode>;
template <>
internal::EnumTraitsT<::octaneapi::GaussianSplatClipMode_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::GaussianSplatClipMode>;
template <>
internal::EnumTraitsT<::octaneapi::GaussianSplatLightingMode_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::GaussianSplatLightingMode>;
template <>
internal::EnumTraitsT<::octaneapi::GeometryExportFormat_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::GeometryExportFormat>;
template <>
internal::EnumTraitsT<::octaneapi::GeometryImportObjectLayers_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::GeometryImportObjectLayers>;
template <>
internal::EnumTraitsT<::octaneapi::GeometryImportScale_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::GeometryImportScale>;
template <>
internal::EnumTraitsT<::octaneapi::GlobalLightIdMaskAction_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::GlobalLightIdMaskAction>;
template <>
internal::EnumTraitsT<::octaneapi::GlobalTexAvo_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::GlobalTexAvo>;
template <>
internal::EnumTraitsT<::octaneapi::GradientGeneratorType_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::GradientGeneratorType>;
template <>
internal::EnumTraitsT<::octaneapi::GradientInterpColorSpace_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::GradientInterpColorSpace>;
template <>
internal::EnumTraitsT<::octaneapi::GradientInterpType_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::GradientInterpType>;
template <>
internal::EnumTraitsT<::octaneapi::HairInterpolationType_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::HairInterpolationType>;
template <>
internal::EnumTraitsT<::octaneapi::HairMaterialBaseColorMode_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::HairMaterialBaseColorMode>;
template <>
internal::EnumTraitsT<::octaneapi::IesPhotometryMode_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::IesPhotometryMode>;
template <>
internal::EnumTraitsT<::octaneapi::ImageChannelType_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::ImageChannelType>;
template <>
internal::EnumTraitsT<::octaneapi::ImageColorType_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::ImageColorType>;
template <>
internal::EnumTraitsT<::octaneapi::ImageFilterType_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::ImageFilterType>;
template <>
internal::EnumTraitsT<::octaneapi::ImageMaskSource_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::ImageMaskSource>;
template <>
internal::EnumTraitsT<::octaneapi::ImageSaveFormat_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::ImageSaveFormat>;
template <>
internal::EnumTraitsT<::octaneapi::ImageType_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::ImageType>;
template <>
internal::EnumTraitsT<::octaneapi::ImportRestAttributesMode_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::ImportRestAttributesMode>;
template <>
internal::EnumTraitsT<::octaneapi::InfoChannelSamplingMode_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::InfoChannelSamplingMode>;
template <>
internal::EnumTraitsT<::octaneapi::InfoChannelType_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::InfoChannelType>;
template <>
internal::EnumTraitsT<::octaneapi::InputAction_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::InputAction>;
template <>
internal::EnumTraitsT<::octaneapi::InterpolationType_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::InterpolationType>;
template <>
internal::EnumTraitsT<::octaneapi::ItemDbOrigin_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::ItemDbOrigin>;
template <>
internal::EnumTraitsT<::octaneapi::LightAov_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::LightAov>;
template <>
internal::EnumTraitsT<::octaneapi::LightPassMask_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::LightPassMask>;
template <>
internal::EnumTraitsT<::octaneapi::LightSampler_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::LightSampler>;
template <>
internal::EnumTraitsT<::octaneapi::LiveDbThumbnailView_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::LiveDbThumbnailView>;
template <>
internal::EnumTraitsT<::octaneapi::LogicalOperator_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::LogicalOperator>;
template <>
internal::EnumTraitsT<::octaneapi::LuaScriptType_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::LuaScriptType>;
template <>
internal::EnumTraitsT<::octaneapi::MemoryLocation_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::MemoryLocation>;
template <>
internal::EnumTraitsT<::octaneapi::MetallicReflectionMode_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::MetallicReflectionMode>;
template <>
internal::EnumTraitsT<::octaneapi::ModuleType_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::ModuleType>;
template <>
internal::EnumTraitsT<::octaneapi::MoireMosaicShape_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::MoireMosaicShape>;
template <>
internal::EnumTraitsT<::octaneapi::MovableInputFormat_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::MovableInputFormat>;
template <>
internal::EnumTraitsT<::octaneapi::NamedColorSpace_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::NamedColorSpace>;
template <>
internal::EnumTraitsT<::octaneapi::NoiseType_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::NoiseType>;
template <>
internal::EnumTraitsT<::octaneapi::NoiseTypeOsl_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::NoiseTypeOsl>;
template <>
internal::EnumTraitsT<::octaneapi::NormalType_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::NormalType>;
template <>
internal::EnumTraitsT<::octaneapi::ObjImportColorSpace_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::ObjImportColorSpace>;
template <>
internal::EnumTraitsT<::octaneapi::ObjectIncludeMode_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::ObjectIncludeMode>;
template <>
internal::EnumTraitsT<::octaneapi::OctaneLiveCategory_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::OctaneLiveCategory>;
template <>
internal::EnumTraitsT<::octaneapi::PanoramicCameraMode_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::PanoramicCameraMode>;
template <>
internal::EnumTraitsT<::octaneapi::PhotonTypes_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::PhotonTypes>;
template <>
internal::EnumTraitsT<::octaneapi::PositionType_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::PositionType>;
template <>
internal::EnumTraitsT<::octaneapi::PrePassType_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::PrePassType>;
template <>
internal::EnumTraitsT<::octaneapi::PreferencesTabId_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::PreferencesTabId>;
template <>
internal::EnumTraitsT<::octaneapi::PremultipliedAlphaType_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::PremultipliedAlphaType>;
template <>
internal::EnumTraitsT<::octaneapi::PreviewType_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::PreviewType>;
template <>
internal::EnumTraitsT<::octaneapi::PrimitiveType_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::PrimitiveType>;
template <>
internal::EnumTraitsT<::octaneapi::ProceduralEffectType_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::ProceduralEffectType>;
template <>
internal::EnumTraitsT<::octaneapi::ReferenceAABBDisplay_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::ReferenceAABBDisplay>;
template <>
internal::EnumTraitsT<::octaneapi::RenderDeviceState_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::RenderDeviceState>;
template <>
internal::EnumTraitsT<::octaneapi::RenderError_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::RenderError>;
template <>
internal::EnumTraitsT<::octaneapi::RenderJobAction_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::RenderJobAction>;
template <>
internal::EnumTraitsT<::octaneapi::RenderJobStatus_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::RenderJobStatus>;
template <>
internal::EnumTraitsT<::octaneapi::RenderLayerMode_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::RenderLayerMode>;
template <>
internal::EnumTraitsT<::octaneapi::RenderPassGroupId_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::RenderPassGroupId>;
template <>
internal::EnumTraitsT<::octaneapi::RenderPassId_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::RenderPassId>;
template <>
internal::EnumTraitsT<::octaneapi::RenderState_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::RenderState>;
template <>
internal::EnumTraitsT<::octaneapi::ResourceCategory_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::ResourceCategory>;
template <>
internal::EnumTraitsT<::octaneapi::ResponseCurveId_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::ResponseCurveId>;
template <>
internal::EnumTraitsT<::octaneapi::RoundEdgesMode_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::RoundEdgesMode>;
template <>
internal::EnumTraitsT<::octaneapi::RoundingMode_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::RoundingMode>;
template <>
internal::EnumTraitsT<::octaneapi::SamplerType_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::SamplerType>;
template <>
internal::EnumTraitsT<::octaneapi::ScatterSurfaceHairMode_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::ScatterSurfaceHairMode>;
template <>
internal::EnumTraitsT<::octaneapi::ScatterSurfaceOrientationPriority_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::ScatterSurfaceOrientationPriority>;
template <>
internal::EnumTraitsT<::octaneapi::ScatterSurfaceParticleMode_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::ScatterSurfaceParticleMode>;
template <>
internal::EnumTraitsT<::octaneapi::ScatterSurfacePolygonMode_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::ScatterSurfacePolygonMode>;
template <>
internal::EnumTraitsT<::octaneapi::ScatterSurfaceReferenceType_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::ScatterSurfaceReferenceType>;
template <>
internal::EnumTraitsT<::octaneapi::ScatterSurfaceSelectionMode_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::ScatterSurfaceSelectionMode>;
template <>
internal::EnumTraitsT<::octaneapi::ScatterSurfaceTransformType_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::ScatterSurfaceTransformType>;
template <>
internal::EnumTraitsT<::octaneapi::ScatterVolumeOrientationPriority_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::ScatterVolumeOrientationPriority>;
template <>
internal::EnumTraitsT<::octaneapi::ScatterVolumeReferenceType_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::ScatterVolumeReferenceType>;
template <>
internal::EnumTraitsT<::octaneapi::ScatterVolumeSelectionMode_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::ScatterVolumeSelectionMode>;
template <>
internal::EnumTraitsT<::octaneapi::ScatterVolumeShape_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::ScatterVolumeShape>;
template <>
internal::EnumTraitsT<::octaneapi::ScatterVolumeTransformType_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::ScatterVolumeTransformType>;
template <>
internal::EnumTraitsT<::octaneapi::ScriptExecuteType_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::ScriptExecuteType>;
template <>
internal::EnumTraitsT<::octaneapi::SharedSurfaceType_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::SharedSurfaceType>;
template <>
internal::EnumTraitsT<::octaneapi::ShutterIntervalAlignment_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::ShutterIntervalAlignment>;
template <>
internal::EnumTraitsT<::octaneapi::SimulatedLens_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::SimulatedLens>;
template <>
internal::EnumTraitsT<::octaneapi::SpotlightOrientation_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::SpotlightOrientation>;
template <>
internal::EnumTraitsT<::octaneapi::StereoMode_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::StereoMode>;
template <>
internal::EnumTraitsT<::octaneapi::StereoOutput_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::StereoOutput>;
template <>
internal::EnumTraitsT<::octaneapi::SubDivFVarInterpolateBoundary_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::SubDivFVarInterpolateBoundary>;
template <>
internal::EnumTraitsT<::octaneapi::SubDivInterpolateBoundary_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::SubDivInterpolateBoundary>;
template <>
internal::EnumTraitsT<::octaneapi::SubDivSchemeType_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::SubDivSchemeType>;
template <>
internal::EnumTraitsT<::octaneapi::SubSampleMode_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::SubSampleMode>;
template <>
internal::EnumTraitsT<::octaneapi::TexelType_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::TexelType>;
template <>
internal::EnumTraitsT<::octaneapi::TextureNodeTypeMode_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::TextureNodeTypeMode>;
template <>
internal::EnumTraitsT<::octaneapi::TexturePinValueTypeMode_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::TexturePinValueTypeMode>;
template <>
internal::EnumTraitsT<::octaneapi::TextureValueType_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::TextureValueType>;
template <>
internal::EnumTraitsT<::octaneapi::TiffCompressionType_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::TiffCompressionType>;
template <>
internal::EnumTraitsT<::octaneapi::TilePatternType_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::TilePatternType>;
template <>
internal::EnumTraitsT<::octaneapi::TimeEventType_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::TimeEventType>;
template <>
internal::EnumTraitsT<::octaneapi::TonemapBufferType_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::TonemapBufferType>;
template <>
internal::EnumTraitsT<::octaneapi::TonemapOrder_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::TonemapOrder>;
template <>
internal::EnumTraitsT<::octaneapi::ToonLightMode_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::ToonLightMode>;
template <>
internal::EnumTraitsT<::octaneapi::TraceSetBounceType_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::TraceSetBounceType>;
template <>
internal::EnumTraitsT<::octaneapi::TraceSetFutureHits_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::TraceSetFutureHits>;
template <>
internal::EnumTraitsT<::octaneapi::UIOperationsFlag_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::UIOperationsFlag>;
template <>
internal::EnumTraitsT<::octaneapi::UnaryOperation_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::UnaryOperation>;
template <>
internal::EnumTraitsT<::octaneapi::UnblendExtractMode_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::UnblendExtractMode>;
template <>
internal::EnumTraitsT<::octaneapi::UnblendOutputColorRange_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::UnblendOutputColorRange>;
template <>
internal::EnumTraitsT<::octaneapi::UniversalCamApertureShape_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::UniversalCamApertureShape>;
template <>
internal::EnumTraitsT<::octaneapi::UniversalCamCubemapLayout_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::UniversalCamCubemapLayout>;
template <>
internal::EnumTraitsT<::octaneapi::UniversalCamFisheyeProjection_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::UniversalCamFisheyeProjection>;
template <>
internal::EnumTraitsT<::octaneapi::UniversalCamFisheyeType_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::UniversalCamFisheyeType>;
template <>
internal::EnumTraitsT<::octaneapi::UniversalCamMode_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::UniversalCamMode>;
template <>
internal::EnumTraitsT<::octaneapi::UpSampleMode_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::UpSampleMode>;
template <>
internal::EnumTraitsT<::octaneapi::UpSampleSourcePercentage_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::UpSampleSourcePercentage>;
template <>
internal::EnumTraitsT<::octaneapi::UpSamplerType_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::UpSamplerType>;
template <>
internal::EnumTraitsT<::octaneapi::UsdDisplayPurpose_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::UsdDisplayPurpose>;
template <>
internal::EnumTraitsT<::octaneapi::VdbGridIds_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::VdbGridIds>;
template <>
internal::EnumTraitsT<::octaneapi::VectronCircleType_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::VectronCircleType>;
template <>
internal::EnumTraitsT<::octaneapi::VectronEdgeType_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::VectronEdgeType>;
template <>
internal::EnumTraitsT<::octaneapi::VirtualTexturingMode_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::VirtualTexturingMode>;
template <>
internal::EnumTraitsT<::octaneapi::VolumeEmissionType_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::VolumeEmissionType>;
template <>
internal::EnumTraitsT<::octaneapi::VolumeInterpolationType_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::VolumeInterpolationType>;
template <>
internal::EnumTraitsT<::octaneapi::VolumeSampling_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::VolumeSampling>;
template <>
internal::EnumTraitsT<::octaneapi::WCoordinateBorderMode_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::WCoordinateBorderMode>;
template <>
internal::EnumTraitsT<::octaneapi::Waveform_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::Waveform>;
template <>
internal::EnumTraitsT<::octaneapi::WhiteLightSpectrum_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::WhiteLightSpectrum>;
template <>
internal::EnumTraitsT<::octaneapi::WindingOrder_internal_data_>
    internal::EnumTraitsImpl::value<::octaneapi::WindingOrder>;
}  // namespace protobuf
}  // namespace google

namespace octaneapi {
enum ActivationResult : int {
  ACTIVATION_OK = 0,
  ACTIVATION_STANDALONE_LICENSE_INVALID = 1,
  ACTIVATION_PLUGIN_LICENSE_INVALID = 2,
  ACTIVATION_CONNECTION_FAILED = 3,
  ACTIVATION_LOCK_ACQUIRE_FAILED = 4,
  ACTIVATION_CANCELLED = 5,
  ActivationResult_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  ActivationResult_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t ActivationResult_internal_data_[];
inline constexpr ActivationResult ActivationResult_MIN =
    static_cast<ActivationResult>(0);
inline constexpr ActivationResult ActivationResult_MAX =
    static_cast<ActivationResult>(5);
inline bool ActivationResult_IsValid(int value) {
  return 0 <= value && value <= 5;
}
inline constexpr int ActivationResult_ARRAYSIZE = 5 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL ActivationResult_descriptor();
template <typename T>
const ::std::string& ActivationResult_Name(T value) {
  static_assert(::std::is_same<T, ActivationResult>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to ActivationResult_Name().");
  return ActivationResult_Name(static_cast<ActivationResult>(value));
}
template <>
inline const ::std::string& ActivationResult_Name(ActivationResult value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ActivationResult_descriptor, 0, 5>(
      static_cast<int>(value));
}
inline bool ActivationResult_Parse(
    ::absl::string_view name, ActivationResult* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<ActivationResult>(ActivationResult_descriptor(), name,
                                           value);
}
enum AnimationTimeTransformType : int {
  AnimationTimeTransformType_UNSPECIFIED = 0,
  ANIMATION_TIME_TRANSFORM_LINEAR = 1,
  AnimationTimeTransformType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  AnimationTimeTransformType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t AnimationTimeTransformType_internal_data_[];
inline constexpr AnimationTimeTransformType AnimationTimeTransformType_MIN =
    static_cast<AnimationTimeTransformType>(0);
inline constexpr AnimationTimeTransformType AnimationTimeTransformType_MAX =
    static_cast<AnimationTimeTransformType>(1);
inline bool AnimationTimeTransformType_IsValid(int value) {
  return 0 <= value && value <= 1;
}
inline constexpr int AnimationTimeTransformType_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL AnimationTimeTransformType_descriptor();
template <typename T>
const ::std::string& AnimationTimeTransformType_Name(T value) {
  static_assert(::std::is_same<T, AnimationTimeTransformType>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to AnimationTimeTransformType_Name().");
  return AnimationTimeTransformType_Name(static_cast<AnimationTimeTransformType>(value));
}
template <>
inline const ::std::string& AnimationTimeTransformType_Name(AnimationTimeTransformType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<AnimationTimeTransformType_descriptor, 0, 1>(
      static_cast<int>(value));
}
inline bool AnimationTimeTransformType_Parse(
    ::absl::string_view name, AnimationTimeTransformType* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<AnimationTimeTransformType>(AnimationTimeTransformType_descriptor(), name,
                                           value);
}
enum AsPixelGroupMode : int {
  AsPixelGroupMode_UNSPECIFIED = 0,
  AS_PIXEL_GROUP_NONE = 1,
  AS_PIXEL_GROUP_2X2 = 2,
  AS_PIXEL_GROUP_4X4 = 4,
  AsPixelGroupMode_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  AsPixelGroupMode_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t AsPixelGroupMode_internal_data_[];
inline constexpr AsPixelGroupMode AsPixelGroupMode_MIN =
    static_cast<AsPixelGroupMode>(0);
inline constexpr AsPixelGroupMode AsPixelGroupMode_MAX =
    static_cast<AsPixelGroupMode>(4);
inline bool AsPixelGroupMode_IsValid(int value) {
  return 0 <= value && value <= 4 && ((23u >> value) & 1) != 0;
}
inline constexpr int AsPixelGroupMode_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL AsPixelGroupMode_descriptor();
template <typename T>
const ::std::string& AsPixelGroupMode_Name(T value) {
  static_assert(::std::is_same<T, AsPixelGroupMode>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to AsPixelGroupMode_Name().");
  return AsPixelGroupMode_Name(static_cast<AsPixelGroupMode>(value));
}
template <>
inline const ::std::string& AsPixelGroupMode_Name(AsPixelGroupMode value) {
  return ::google::protobuf::internal::NameOfDenseEnum<AsPixelGroupMode_descriptor, 0, 4>(
      static_cast<int>(value));
}
inline bool AsPixelGroupMode_Parse(
    ::absl::string_view name, AsPixelGroupMode* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<AsPixelGroupMode>(AsPixelGroupMode_descriptor(), name,
                                           value);
}
enum AnalyticLightType : int {
  ANALYTIC_LIGHT_QUAD = 0,
  ANALYTIC_LIGHT_DISK = 1,
  ANALYTIC_LIGHT_DIRECTIONAL = 2,
  ANALYTIC_LIGHT_SPHERE = 3,
  ANALYTIC_LIGHT_TUBE = 4,
  AnalyticLightType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  AnalyticLightType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t AnalyticLightType_internal_data_[];
inline constexpr AnalyticLightType AnalyticLightType_MIN =
    static_cast<AnalyticLightType>(0);
inline constexpr AnalyticLightType AnalyticLightType_MAX =
    static_cast<AnalyticLightType>(4);
inline bool AnalyticLightType_IsValid(int value) {
  return 0 <= value && value <= 4;
}
inline constexpr int AnalyticLightType_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL AnalyticLightType_descriptor();
template <typename T>
const ::std::string& AnalyticLightType_Name(T value) {
  static_assert(::std::is_same<T, AnalyticLightType>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to AnalyticLightType_Name().");
  return AnalyticLightType_Name(static_cast<AnalyticLightType>(value));
}
template <>
inline const ::std::string& AnalyticLightType_Name(AnalyticLightType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<AnalyticLightType_descriptor, 0, 4>(
      static_cast<int>(value));
}
inline bool AnalyticLightType_Parse(
    ::absl::string_view name, AnalyticLightType* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<AnalyticLightType>(AnalyticLightType_descriptor(), name,
                                           value);
}
enum AnimationType : int {
  AnimationType_UNSPECIFIED = 0,
  ANIMATION_LOOP = 1,
  ANIMATION_PINGPONG = 2,
  ANIMATION_ONCE = 3,
  AnimationType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  AnimationType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t AnimationType_internal_data_[];
inline constexpr AnimationType AnimationType_MIN =
    static_cast<AnimationType>(0);
inline constexpr AnimationType AnimationType_MAX =
    static_cast<AnimationType>(3);
inline bool AnimationType_IsValid(int value) {
  return 0 <= value && value <= 3;
}
inline constexpr int AnimationType_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL AnimationType_descriptor();
template <typename T>
const ::std::string& AnimationType_Name(T value) {
  static_assert(::std::is_same<T, AnimationType>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to AnimationType_Name().");
  return AnimationType_Name(static_cast<AnimationType>(value));
}
template <>
inline const ::std::string& AnimationType_Name(AnimationType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<AnimationType_descriptor, 0, 3>(
      static_cast<int>(value));
}
inline bool AnimationType_Parse(
    ::absl::string_view name, AnimationType* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<AnimationType>(AnimationType_descriptor(), name,
                                           value);
}
enum BakingTextureType : int {
  BAKING_TEXTURE_TYPE_LDR = 0,
  BAKING_TEXTURE_TYPE_HDR = 2,
  BakingTextureType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  BakingTextureType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t BakingTextureType_internal_data_[];
inline constexpr BakingTextureType BakingTextureType_MIN =
    static_cast<BakingTextureType>(0);
inline constexpr BakingTextureType BakingTextureType_MAX =
    static_cast<BakingTextureType>(2);
inline bool BakingTextureType_IsValid(int value) {
  return 0 <= value && value <= 2 && ((5u >> value) & 1) != 0;
}
inline constexpr int BakingTextureType_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL BakingTextureType_descriptor();
template <typename T>
const ::std::string& BakingTextureType_Name(T value) {
  static_assert(::std::is_same<T, BakingTextureType>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to BakingTextureType_Name().");
  return BakingTextureType_Name(static_cast<BakingTextureType>(value));
}
template <>
inline const ::std::string& BakingTextureType_Name(BakingTextureType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<BakingTextureType_descriptor, 0, 2>(
      static_cast<int>(value));
}
inline bool BakingTextureType_Parse(
    ::absl::string_view name, BakingTextureType* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<BakingTextureType>(BakingTextureType_descriptor(), name,
                                           value);
}
enum BinaryOperation : int {
  BINARY_OP_ADD = 0,
  BINARY_OP_ATAN2 = 1,
  BINARY_OP_CROSS = 2,
  BINARY_OP_DIVIDE = 3,
  BINARY_OP_DOT = 4,
  BINARY_OP_FMOD = 5,
  BINARY_OP_LOG_BASE = 6,
  BINARY_OP_MAX = 7,
  BINARY_OP_MIN = 8,
  BINARY_OP_MOD = 9,
  BINARY_OP_MULTIPLY = 10,
  BINARY_OP_POW = 11,
  BINARY_OP_SUBTRACT = 12,
  BinaryOperation_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  BinaryOperation_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t BinaryOperation_internal_data_[];
inline constexpr BinaryOperation BinaryOperation_MIN =
    static_cast<BinaryOperation>(0);
inline constexpr BinaryOperation BinaryOperation_MAX =
    static_cast<BinaryOperation>(12);
inline bool BinaryOperation_IsValid(int value) {
  return 0 <= value && value <= 12;
}
inline constexpr int BinaryOperation_ARRAYSIZE = 12 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL BinaryOperation_descriptor();
template <typename T>
const ::std::string& BinaryOperation_Name(T value) {
  static_assert(::std::is_same<T, BinaryOperation>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to BinaryOperation_Name().");
  return BinaryOperation_Name(static_cast<BinaryOperation>(value));
}
template <>
inline const ::std::string& BinaryOperation_Name(BinaryOperation value) {
  return ::google::protobuf::internal::NameOfDenseEnum<BinaryOperation_descriptor, 0, 12>(
      static_cast<int>(value));
}
inline bool BinaryOperation_Parse(
    ::absl::string_view name, BinaryOperation* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<BinaryOperation>(BinaryOperation_descriptor(), name,
                                           value);
}
enum BorderMode : int {
  BORDER_MODE_WRAP = 0,
  BORDER_MODE_BLACK = 1,
  BORDER_MODE_WHITE = 2,
  BORDER_MODE_CLAMP = 3,
  BORDER_MODE_MIRROR = 4,
  BorderMode_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  BorderMode_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t BorderMode_internal_data_[];
inline constexpr BorderMode BorderMode_MIN =
    static_cast<BorderMode>(0);
inline constexpr BorderMode BorderMode_MAX =
    static_cast<BorderMode>(4);
inline bool BorderMode_IsValid(int value) {
  return 0 <= value && value <= 4;
}
inline constexpr int BorderMode_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL BorderMode_descriptor();
template <typename T>
const ::std::string& BorderMode_Name(T value) {
  static_assert(::std::is_same<T, BorderMode>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to BorderMode_Name().");
  return BorderMode_Name(static_cast<BorderMode>(value));
}
template <>
inline const ::std::string& BorderMode_Name(BorderMode value) {
  return ::google::protobuf::internal::NameOfDenseEnum<BorderMode_descriptor, 0, 4>(
      static_cast<int>(value));
}
inline bool BorderMode_Parse(
    ::absl::string_view name, BorderMode* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<BorderMode>(BorderMode_descriptor(), name,
                                           value);
}
enum BlendRegionMask : int {
  BLEND_REGION_MASK_NOTHING = 0,
  BLEND_REGION_MASK_BACKGROUND_ONLY = 1,
  BLEND_REGION_MASK_FOREGROUND_ONLY = 2,
  BLEND_REGION_MASK_XOR = 3,
  BLEND_REGION_MASK_INTERSECTION = 4,
  BLEND_REGION_MASK_BACKGROUND_AND_INTERSECTION = 5,
  BLEND_REGION_MASK_FOREGROUND_AND_INTERSECTION = 6,
  BLEND_REGION_MASK_ALL = 7,
  BlendRegionMask_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  BlendRegionMask_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t BlendRegionMask_internal_data_[];
inline constexpr BlendRegionMask BlendRegionMask_MIN =
    static_cast<BlendRegionMask>(0);
inline constexpr BlendRegionMask BlendRegionMask_MAX =
    static_cast<BlendRegionMask>(7);
inline bool BlendRegionMask_IsValid(int value) {
  return 0 <= value && value <= 7;
}
inline constexpr int BlendRegionMask_ARRAYSIZE = 7 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL BlendRegionMask_descriptor();
template <typename T>
const ::std::string& BlendRegionMask_Name(T value) {
  static_assert(::std::is_same<T, BlendRegionMask>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to BlendRegionMask_Name().");
  return BlendRegionMask_Name(static_cast<BlendRegionMask>(value));
}
template <>
inline const ::std::string& BlendRegionMask_Name(BlendRegionMask value) {
  return ::google::protobuf::internal::NameOfDenseEnum<BlendRegionMask_descriptor, 0, 7>(
      static_cast<int>(value));
}
inline bool BlendRegionMask_Parse(
    ::absl::string_view name, BlendRegionMask* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<BlendRegionMask>(BlendRegionMask_descriptor(), name,
                                           value);
}
enum ComponentPickerOperation : int {
  COMPONENT_PICKER_X = 0,
  COMPONENT_PICKER_Y = 1,
  COMPONENT_PICKER_Z = 2,
  COMPONENT_PICKER_MAX = 3,
  COMPONENT_PICKER_MED = 4,
  COMPONENT_PICKER_MIN = 5,
  ComponentPickerOperation_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  ComponentPickerOperation_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t ComponentPickerOperation_internal_data_[];
inline constexpr ComponentPickerOperation ComponentPickerOperation_MIN =
    static_cast<ComponentPickerOperation>(0);
inline constexpr ComponentPickerOperation ComponentPickerOperation_MAX =
    static_cast<ComponentPickerOperation>(5);
inline bool ComponentPickerOperation_IsValid(int value) {
  return 0 <= value && value <= 5;
}
inline constexpr int ComponentPickerOperation_ARRAYSIZE = 5 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL ComponentPickerOperation_descriptor();
template <typename T>
const ::std::string& ComponentPickerOperation_Name(T value) {
  static_assert(::std::is_same<T, ComponentPickerOperation>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to ComponentPickerOperation_Name().");
  return ComponentPickerOperation_Name(static_cast<ComponentPickerOperation>(value));
}
template <>
inline const ::std::string& ComponentPickerOperation_Name(ComponentPickerOperation value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ComponentPickerOperation_descriptor, 0, 5>(
      static_cast<int>(value));
}
inline bool ComponentPickerOperation_Parse(
    ::absl::string_view name, ComponentPickerOperation* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<ComponentPickerOperation>(ComponentPickerOperation_descriptor(), name,
                                           value);
}
enum CompositeOperation : int {
  COMPOSITE_OPERATION_SRC = 0,
  COMPOSITE_OPERATION_SRC_OVER = 1,
  COMPOSITE_OPERATION_SRC_OVER_CONJOINT = 2,
  COMPOSITE_OPERATION_SRC_OVER_DISJOINT = 3,
  COMPOSITE_OPERATION_SRC_IN = 4,
  COMPOSITE_OPERATION_SRC_OUT = 5,
  COMPOSITE_OPERATION_SRC_ATOP = 6,
  COMPOSITE_OPERATION_DST = 7,
  COMPOSITE_OPERATION_DST_OVER = 8,
  COMPOSITE_OPERATION_DST_IN = 9,
  COMPOSITE_OPERATION_DST_OUT = 10,
  COMPOSITE_OPERATION_DST_ATOP = 11,
  COMPOSITE_OPERATION_CLEAR = 12,
  COMPOSITE_OPERATION_XOR = 13,
  COMPOSITE_OPERATION_DISSOLVE = 14,
  COMPOSITE_OPERATION_PLUS = 15,
  COMPOSITE_OPERATION_MATTE = 16,
  CompositeOperation_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  CompositeOperation_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t CompositeOperation_internal_data_[];
inline constexpr CompositeOperation CompositeOperation_MIN =
    static_cast<CompositeOperation>(0);
inline constexpr CompositeOperation CompositeOperation_MAX =
    static_cast<CompositeOperation>(16);
inline bool CompositeOperation_IsValid(int value) {
  return 0 <= value && value <= 16;
}
inline constexpr int CompositeOperation_ARRAYSIZE = 16 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL CompositeOperation_descriptor();
template <typename T>
const ::std::string& CompositeOperation_Name(T value) {
  static_assert(::std::is_same<T, CompositeOperation>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to CompositeOperation_Name().");
  return CompositeOperation_Name(static_cast<CompositeOperation>(value));
}
template <>
inline const ::std::string& CompositeOperation_Name(CompositeOperation value) {
  return ::google::protobuf::internal::NameOfDenseEnum<CompositeOperation_descriptor, 0, 16>(
      static_cast<int>(value));
}
inline bool CompositeOperation_Parse(
    ::absl::string_view name, CompositeOperation* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<CompositeOperation>(CompositeOperation_descriptor(), name,
                                           value);
}
enum BlendMode : int {
  BLEND_MODE_ADD = 0,
  BLEND_MODE_AVERAGE = 1,
  BLEND_MODE_COLOR_BURN = 2,
  BLEND_MODE_COLOR_DODGE = 3,
  BLEND_MODE_DARKEN = 4,
  BLEND_MODE_DIFFERENCE = 5,
  BLEND_MODE_EXCLUDE = 6,
  BLEND_MODE_GLOW = 7,
  BLEND_MODE_HARD_LIGHT = 8,
  BLEND_MODE_HARD_MIX = 9,
  BLEND_MODE_LIGHTEN = 10,
  BLEND_MODE_LINEAR_BURN = 11,
  BLEND_MODE_LINEAR_DODGE = 12,
  BLEND_MODE_LINEAR_LIGHT = 13,
  BLEND_MODE_MULTIPLY = 14,
  BLEND_MODE_NEGATE = 15,
  BLEND_MODE_NORMAL = 16,
  BLEND_MODE_OVERLAY = 17,
  BLEND_MODE_PHOENIX = 18,
  BLEND_MODE_PIN_LIGHT = 19,
  BLEND_MODE_REFLECT = 20,
  BLEND_MODE_SCREEN = 21,
  BLEND_MODE_SOFT_LIGHT = 22,
  BLEND_MODE_SUBTRACT = 23,
  BLEND_MODE_VIVID_LIGHT = 24,
  BLEND_MODE_GEOMETRIC = 25,
  BLEND_MODE_HYPOTENUSE = 26,
  BLEND_MODE_SPOTLIGHT = 27,
  BLEND_MODE_SPOTLIGHT_BLEND = 28,
  BLEND_MODE_SUBTRACT_INVERSE = 29,
  BLEND_MODE_DIVIDE = 30,
  BLEND_MODE_DIVIDE_INVERSE = 31,
  BLEND_MODE_HUE = 32,
  BLEND_MODE_SATURATION = 33,
  BLEND_MODE_COLOR = 34,
  BLEND_MODE_LUMINOSITY = 35,
  BLEND_MODE_DARKER_COLOR = 36,
  BLEND_MODE_LIGHTER_COLOR = 37,
  BLEND_MODE_DARKER_COLOR_LUMINANCE = 38,
  BLEND_MODE_LIGHTER_COLOR_LUMINANCE = 39,
  BLEND_MODE_VALUE = 40,
  BLEND_MODE_CHROMATICITY = 41,
  BLEND_MODE_RED = 42,
  BLEND_MODE_GREEN = 43,
  BLEND_MODE_BLUE = 44,
  BLEND_MODE_FREEZE = 45,
  BLEND_MODE_LEVR = 46,
  BLEND_MODE_HEAT = 47,
  BLEND_MODE_GRAIN_EXTRACT = 48,
  BLEND_MODE_GRAIN_MERGE = 49,
  BLEND_MODE_STAMP = 50,
  BLEND_MODE_REORIENTED_NORMAL = 51,
  BLEND_MODE_RATIO = 52,
  BLEND_MODE_COMPOSITE_OFFSET = 1000,
  BLEND_MODE_SRC = 1000,
  BLEND_MODE_SRC_OVER = 1001,
  BLEND_MODE_SRC_OVER_CONJOINT = 1002,
  BLEND_MODE_SRC_OVER_DISJOINT = 1003,
  BLEND_MODE_SRC_IN = 1004,
  BLEND_MODE_SRC_OUT = 1005,
  BLEND_MODE_SRC_ATOP = 1006,
  BLEND_MODE_DST = 1007,
  BLEND_MODE_DST_OVER = 1008,
  BLEND_MODE_DST_IN = 1009,
  BLEND_MODE_DST_OUT = 1010,
  BLEND_MODE_DST_ATOP = 1011,
  BLEND_MODE_CLEAR = 1012,
  BLEND_MODE_XOR = 1013,
  BLEND_MODE_DISSOLVE = 1014,
  BLEND_MODE_PLUS = 1015,
  BLEND_MODE_MATTE = 1016,
  BLEND_MODE_SDR_OFFSET = 2000,
  BLEND_MODE_REVERSE_OFFSET = 4000,
  BlendMode_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  BlendMode_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t BlendMode_internal_data_[];
inline constexpr BlendMode BlendMode_MIN =
    static_cast<BlendMode>(0);
inline constexpr BlendMode BlendMode_MAX =
    static_cast<BlendMode>(4000);
inline bool BlendMode_IsValid(int value) {
  return ::google::protobuf::internal::ValidateEnum(value, BlendMode_internal_data_);
}
inline constexpr int BlendMode_ARRAYSIZE = 4000 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL BlendMode_descriptor();
template <typename T>
const ::std::string& BlendMode_Name(T value) {
  static_assert(::std::is_same<T, BlendMode>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to BlendMode_Name().");
  return ::google::protobuf::internal::NameOfEnum(BlendMode_descriptor(), value);
}
inline bool BlendMode_Parse(
    ::absl::string_view name, BlendMode* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<BlendMode>(BlendMode_descriptor(), name,
                                           value);
}
enum BrdfModel : int {
  BRDF_OCTANE = 0,
  BRDF_BECKMANN = 1,
  BRDF_GGX = 2,
  BRDF_WARD = 3,
  BrdfModel_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  BrdfModel_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t BrdfModel_internal_data_[];
inline constexpr BrdfModel BrdfModel_MIN =
    static_cast<BrdfModel>(0);
inline constexpr BrdfModel BrdfModel_MAX =
    static_cast<BrdfModel>(3);
inline bool BrdfModel_IsValid(int value) {
  return 0 <= value && value <= 3;
}
inline constexpr int BrdfModel_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL BrdfModel_descriptor();
template <typename T>
const ::std::string& BrdfModel_Name(T value) {
  static_assert(::std::is_same<T, BrdfModel>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to BrdfModel_Name().");
  return BrdfModel_Name(static_cast<BrdfModel>(value));
}
template <>
inline const ::std::string& BrdfModel_Name(BrdfModel value) {
  return ::google::protobuf::internal::NameOfDenseEnum<BrdfModel_descriptor, 0, 3>(
      static_cast<int>(value));
}
inline bool BrdfModel_Parse(
    ::absl::string_view name, BrdfModel* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<BrdfModel>(BrdfModel_descriptor(), name,
                                           value);
}
enum BxDFDiffuseModel : int {
  BxDF_DIFFUSE_OCTANE = 0,
  BxDF_DIFFUSE_LAMBERTIAN = 1,
  BxDF_DIFFUSE_OREN_NAYAR = 2,
  BxDF_DIFFUSE_EON = 3,
  BxDFDiffuseModel_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  BxDFDiffuseModel_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t BxDFDiffuseModel_internal_data_[];
inline constexpr BxDFDiffuseModel BxDFDiffuseModel_MIN =
    static_cast<BxDFDiffuseModel>(0);
inline constexpr BxDFDiffuseModel BxDFDiffuseModel_MAX =
    static_cast<BxDFDiffuseModel>(3);
inline bool BxDFDiffuseModel_IsValid(int value) {
  return 0 <= value && value <= 3;
}
inline constexpr int BxDFDiffuseModel_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL BxDFDiffuseModel_descriptor();
template <typename T>
const ::std::string& BxDFDiffuseModel_Name(T value) {
  static_assert(::std::is_same<T, BxDFDiffuseModel>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to BxDFDiffuseModel_Name().");
  return BxDFDiffuseModel_Name(static_cast<BxDFDiffuseModel>(value));
}
template <>
inline const ::std::string& BxDFDiffuseModel_Name(BxDFDiffuseModel value) {
  return ::google::protobuf::internal::NameOfDenseEnum<BxDFDiffuseModel_descriptor, 0, 3>(
      static_cast<int>(value));
}
inline bool BxDFDiffuseModel_Parse(
    ::absl::string_view name, BxDFDiffuseModel* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<BxDFDiffuseModel>(BxDFDiffuseModel_descriptor(), name,
                                           value);
}
enum BxDFSpecularModel : int {
  BxDF_SPECULAR_OCTANE = 0,
  BxDF_SPECULAR_BECKMANN = 1,
  BxDF_SPECULAR_GGX = 2,
  BxDF_SPECULAR_WARD = 3,
  BxDF_SPECULAR_ENERGY_PRESERVED_GGX = 6,
  BxDF_SPECULAR_STD = 7,
  BxDFSpecularModel_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  BxDFSpecularModel_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t BxDFSpecularModel_internal_data_[];
inline constexpr BxDFSpecularModel BxDFSpecularModel_MIN =
    static_cast<BxDFSpecularModel>(0);
inline constexpr BxDFSpecularModel BxDFSpecularModel_MAX =
    static_cast<BxDFSpecularModel>(7);
inline bool BxDFSpecularModel_IsValid(int value) {
  return 0 <= value && value <= 7 && ((207u >> value) & 1) != 0;
}
inline constexpr int BxDFSpecularModel_ARRAYSIZE = 7 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL BxDFSpecularModel_descriptor();
template <typename T>
const ::std::string& BxDFSpecularModel_Name(T value) {
  static_assert(::std::is_same<T, BxDFSpecularModel>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to BxDFSpecularModel_Name().");
  return BxDFSpecularModel_Name(static_cast<BxDFSpecularModel>(value));
}
template <>
inline const ::std::string& BxDFSpecularModel_Name(BxDFSpecularModel value) {
  return ::google::protobuf::internal::NameOfDenseEnum<BxDFSpecularModel_descriptor, 0, 7>(
      static_cast<int>(value));
}
inline bool BxDFSpecularModel_Parse(
    ::absl::string_view name, BxDFSpecularModel* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<BxDFSpecularModel>(BxDFSpecularModel_descriptor(), name,
                                           value);
}
enum BxDFSheenModel : int {
  BxDFSheenModel_UNSPECIFIED = 0,
  BxDF_SHEEN = 10,
  BxDF_FUZZ = 19,
  BxDFSheenModel_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  BxDFSheenModel_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t BxDFSheenModel_internal_data_[];
inline constexpr BxDFSheenModel BxDFSheenModel_MIN =
    static_cast<BxDFSheenModel>(0);
inline constexpr BxDFSheenModel BxDFSheenModel_MAX =
    static_cast<BxDFSheenModel>(19);
inline bool BxDFSheenModel_IsValid(int value) {
  return 0 <= value && value <= 19 && ((525313u >> value) & 1) != 0;
}
inline constexpr int BxDFSheenModel_ARRAYSIZE = 19 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL BxDFSheenModel_descriptor();
template <typename T>
const ::std::string& BxDFSheenModel_Name(T value) {
  static_assert(::std::is_same<T, BxDFSheenModel>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to BxDFSheenModel_Name().");
  return ::google::protobuf::internal::NameOfEnum(BxDFSheenModel_descriptor(), value);
}
inline bool BxDFSheenModel_Parse(
    ::absl::string_view name, BxDFSheenModel* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<BxDFSheenModel>(BxDFSheenModel_descriptor(), name,
                                           value);
}
enum BxDFTranmissionType : int {
  BxDF_TRANSMISSION_TYPE_SPECULAR = 0,
  BxDF_TRANSMISSION_TYPE_DIFFUSE = 1,
  BxDF_TRANSMISSION_TYPE_THINWALL = 2,
  BxDF_TRANSMISSION_TYPE_THINWALL_DIFFUSE = 3,
  BxDFTranmissionType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  BxDFTranmissionType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t BxDFTranmissionType_internal_data_[];
inline constexpr BxDFTranmissionType BxDFTranmissionType_MIN =
    static_cast<BxDFTranmissionType>(0);
inline constexpr BxDFTranmissionType BxDFTranmissionType_MAX =
    static_cast<BxDFTranmissionType>(3);
inline bool BxDFTranmissionType_IsValid(int value) {
  return 0 <= value && value <= 3;
}
inline constexpr int BxDFTranmissionType_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL BxDFTranmissionType_descriptor();
template <typename T>
const ::std::string& BxDFTranmissionType_Name(T value) {
  static_assert(::std::is_same<T, BxDFTranmissionType>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to BxDFTranmissionType_Name().");
  return BxDFTranmissionType_Name(static_cast<BxDFTranmissionType>(value));
}
template <>
inline const ::std::string& BxDFTranmissionType_Name(BxDFTranmissionType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<BxDFTranmissionType_descriptor, 0, 3>(
      static_cast<int>(value));
}
inline bool BxDFTranmissionType_Parse(
    ::absl::string_view name, BxDFTranmissionType* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<BxDFTranmissionType>(BxDFTranmissionType_descriptor(), name,
                                           value);
}
enum BxDFUniversalModel : int {
  BxDF_UNIVERSAL_OCTANE = 0,
  BxDF_UNIVERSAL_BECKMANN = 1,
  BxDF_UNIVERSAL_GGX = 2,
  BxDF_UNIVERSAL_WARD = 3,
  BxDF_UNIVERSAL_LAMBERTIAN = 5,
  BxDF_UNIVERSAL_ENERGY_PRESERVED_GGX = 6,
  BxDF_UNIVERSAL_STD = 7,
  BxDFUniversalModel_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  BxDFUniversalModel_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t BxDFUniversalModel_internal_data_[];
inline constexpr BxDFUniversalModel BxDFUniversalModel_MIN =
    static_cast<BxDFUniversalModel>(0);
inline constexpr BxDFUniversalModel BxDFUniversalModel_MAX =
    static_cast<BxDFUniversalModel>(7);
inline bool BxDFUniversalModel_IsValid(int value) {
  return 0 <= value && value <= 7 && ((239u >> value) & 1) != 0;
}
inline constexpr int BxDFUniversalModel_ARRAYSIZE = 7 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL BxDFUniversalModel_descriptor();
template <typename T>
const ::std::string& BxDFUniversalModel_Name(T value) {
  static_assert(::std::is_same<T, BxDFUniversalModel>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to BxDFUniversalModel_Name().");
  return BxDFUniversalModel_Name(static_cast<BxDFUniversalModel>(value));
}
template <>
inline const ::std::string& BxDFUniversalModel_Name(BxDFUniversalModel value) {
  return ::google::protobuf::internal::NameOfDenseEnum<BxDFUniversalModel_descriptor, 0, 7>(
      static_cast<int>(value));
}
inline bool BxDFUniversalModel_Parse(
    ::absl::string_view name, BxDFUniversalModel* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<BxDFUniversalModel>(BxDFUniversalModel_descriptor(), name,
                                           value);
}
enum ChangeEventType : int {
  ChangeEventType_UNSPECIFIED = 0,
  ITEM_ADDED = 1,
  ITEM_DELETE = 2,
  CONNECTION_CHANGED = 4,
  DESTINATION_ADDED = 8,
  PINS_CHANGED = 16,
  ITEM_VALUE_CHANGED = 32,
  ITEM_INPUT_CHANGED = 64,
  ITEM_NAME_CHANGED = 128,
  ITEM_MOVED = 256,
  LINKER_ORDER_CHANGED = 512,
  ITEM_UI_OPERATION_FLAG_CHANGED = 1024,
  TIME_TRANSFORM_CHANGED = 2048,
  ChangeEventType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  ChangeEventType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t ChangeEventType_internal_data_[];
inline constexpr ChangeEventType ChangeEventType_MIN =
    static_cast<ChangeEventType>(0);
inline constexpr ChangeEventType ChangeEventType_MAX =
    static_cast<ChangeEventType>(2048);
inline bool ChangeEventType_IsValid(int value) {
  return ::google::protobuf::internal::ValidateEnum(value, ChangeEventType_internal_data_);
}
inline constexpr int ChangeEventType_ARRAYSIZE = 2048 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL ChangeEventType_descriptor();
template <typename T>
const ::std::string& ChangeEventType_Name(T value) {
  static_assert(::std::is_same<T, ChangeEventType>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to ChangeEventType_Name().");
  return ::google::protobuf::internal::NameOfEnum(ChangeEventType_descriptor(), value);
}
inline bool ChangeEventType_Parse(
    ::absl::string_view name, ChangeEventType* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<ChangeEventType>(ChangeEventType_descriptor(), name,
                                           value);
}
enum ChannelGroups : int {
  CHANNEL_GROUP_RGBA = 0,
  CHANNEL_GROUP_RGB = 1,
  CHANNEL_GROUP_ALPHA = 2,
  ChannelGroups_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  ChannelGroups_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t ChannelGroups_internal_data_[];
inline constexpr ChannelGroups ChannelGroups_MIN =
    static_cast<ChannelGroups>(0);
inline constexpr ChannelGroups ChannelGroups_MAX =
    static_cast<ChannelGroups>(2);
inline bool ChannelGroups_IsValid(int value) {
  return 0 <= value && value <= 2;
}
inline constexpr int ChannelGroups_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL ChannelGroups_descriptor();
template <typename T>
const ::std::string& ChannelGroups_Name(T value) {
  static_assert(::std::is_same<T, ChannelGroups>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to ChannelGroups_Name().");
  return ChannelGroups_Name(static_cast<ChannelGroups>(value));
}
template <>
inline const ::std::string& ChannelGroups_Name(ChannelGroups value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ChannelGroups_descriptor, 0, 2>(
      static_cast<int>(value));
}
inline bool ChannelGroups_Parse(
    ::absl::string_view name, ChannelGroups* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<ChannelGroups>(ChannelGroups_descriptor(), name,
                                           value);
}
enum ChannelMapping : int {
  CHANNEL_MAPPING_RED = 0,
  CHANNEL_MAPPING_GREEN = 1,
  CHANNEL_MAPPING_BLUE = 2,
  CHANNEL_MAPPING_RED_INVERSE = 3,
  CHANNEL_MAPPING_GREEN_INVERSE = 4,
  CHANNEL_MAPPING_BLUE_INVERSE = 5,
  CHANNEL_MAPPING_LUMINANCE = 6,
  CHANNEL_MAPPING_LUMINANCE_INVERSE = 7,
  CHANNEL_MAPPING_ZERO = 8,
  CHANNEL_MAPPING_ONE = 9,
  ChannelMapping_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  ChannelMapping_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t ChannelMapping_internal_data_[];
inline constexpr ChannelMapping ChannelMapping_MIN =
    static_cast<ChannelMapping>(0);
inline constexpr ChannelMapping ChannelMapping_MAX =
    static_cast<ChannelMapping>(9);
inline bool ChannelMapping_IsValid(int value) {
  return 0 <= value && value <= 9;
}
inline constexpr int ChannelMapping_ARRAYSIZE = 9 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL ChannelMapping_descriptor();
template <typename T>
const ::std::string& ChannelMapping_Name(T value) {
  static_assert(::std::is_same<T, ChannelMapping>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to ChannelMapping_Name().");
  return ChannelMapping_Name(static_cast<ChannelMapping>(value));
}
template <>
inline const ::std::string& ChannelMapping_Name(ChannelMapping value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ChannelMapping_descriptor, 0, 9>(
      static_cast<int>(value));
}
inline bool ChannelMapping_Parse(
    ::absl::string_view name, ChannelMapping* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<ChannelMapping>(ChannelMapping_descriptor(), name,
                                           value);
}
enum Cinema4dNoiseType : int {
  C4D_NOISE_TYPE_BOX_NOISE = 0,
  C4D_NOISE_TYPE_BLIST_TURB = 1,
  C4D_NOISE_TYPE_BUYA = 2,
  C4D_NOISE_TYPE_CELL_NOISE = 3,
  C4D_NOISE_TYPE_CRANAL = 4,
  C4D_NOISE_TYPE_DENTS = 5,
  C4D_NOISE_TYPE_DISPL_TURB = 6,
  C4D_NOISE_TYPE_FBM = 7,
  C4D_NOISE_TYPE_HAMA = 8,
  C4D_NOISE_TYPE_LUKA = 9,
  C4D_NOISE_TYPE_MOD_NOISE = 10,
  C4D_NOISE_TYPE_NAKI = 11,
  C4D_NOISE_TYPE_NOISE = 12,
  C4D_NOISE_TYPE_NUTOUS = 13,
  C4D_NOISE_TYPE_OBER = 14,
  C4D_NOISE_TYPE_PEZO = 15,
  C4D_NOISE_TYPE_POXO = 16,
  C4D_NOISE_TYPE_SEMA = 17,
  C4D_NOISE_TYPE_STUPL = 18,
  C4D_NOISE_TYPE_TURBULENCE = 19,
  C4D_NOISE_TYPE_VL_NOISE = 20,
  C4D_NOISE_TYPE_WAVY_TURB = 21,
  C4D_NOISE_TYPE_CELL_VORONOI = 22,
  C4D_NOISE_TYPE_DISPL_VORONOI = 23,
  C4D_NOISE_TYPE_VORONOI1 = 24,
  C4D_NOISE_TYPE_VORONOI2 = 25,
  C4D_NOISE_TYPE_VORONOI3 = 26,
  C4D_NOISE_TYPE_ZADA = 27,
  C4D_NOISE_TYPE_FIRE = 28,
  C4D_NOISE_TYPE_ELECTRIC = 29,
  C4D_NOISE_TYPE_GASEOUS = 30,
  C4D_NOISE_TYPE_RIDGEDMULTI = 31,
  Cinema4dNoiseType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  Cinema4dNoiseType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t Cinema4dNoiseType_internal_data_[];
inline constexpr Cinema4dNoiseType Cinema4dNoiseType_MIN =
    static_cast<Cinema4dNoiseType>(0);
inline constexpr Cinema4dNoiseType Cinema4dNoiseType_MAX =
    static_cast<Cinema4dNoiseType>(31);
inline bool Cinema4dNoiseType_IsValid(int value) {
  return 0 <= value && value <= 31;
}
inline constexpr int Cinema4dNoiseType_ARRAYSIZE = 31 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL Cinema4dNoiseType_descriptor();
template <typename T>
const ::std::string& Cinema4dNoiseType_Name(T value) {
  static_assert(::std::is_same<T, Cinema4dNoiseType>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to Cinema4dNoiseType_Name().");
  return Cinema4dNoiseType_Name(static_cast<Cinema4dNoiseType>(value));
}
template <>
inline const ::std::string& Cinema4dNoiseType_Name(Cinema4dNoiseType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Cinema4dNoiseType_descriptor, 0, 31>(
      static_cast<int>(value));
}
inline bool Cinema4dNoiseType_Parse(
    ::absl::string_view name, Cinema4dNoiseType* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<Cinema4dNoiseType>(Cinema4dNoiseType_descriptor(), name,
                                           value);
}
enum ClayMode : int {
  CLAY_MODE_NONE = 0,
  CLAY_MODE_GREY = 1,
  CLAY_MODE_COLOR = 2,
  ClayMode_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  ClayMode_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t ClayMode_internal_data_[];
inline constexpr ClayMode ClayMode_MIN =
    static_cast<ClayMode>(0);
inline constexpr ClayMode ClayMode_MAX =
    static_cast<ClayMode>(2);
inline bool ClayMode_IsValid(int value) {
  return 0 <= value && value <= 2;
}
inline constexpr int ClayMode_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL ClayMode_descriptor();
template <typename T>
const ::std::string& ClayMode_Name(T value) {
  static_assert(::std::is_same<T, ClayMode>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to ClayMode_Name().");
  return ClayMode_Name(static_cast<ClayMode>(value));
}
template <>
inline const ::std::string& ClayMode_Name(ClayMode value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ClayMode_descriptor, 0, 2>(
      static_cast<int>(value));
}
inline bool ClayMode_Parse(
    ::absl::string_view name, ClayMode* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<ClayMode>(ClayMode_descriptor(), name,
                                           value);
}
enum ColorChannelType : int {
  COLOR_CHANNEL_R = 0,
  COLOR_CHANNEL_G = 1,
  COLOR_CHANNEL_B = 2,
  ColorChannelType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  ColorChannelType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t ColorChannelType_internal_data_[];
inline constexpr ColorChannelType ColorChannelType_MIN =
    static_cast<ColorChannelType>(0);
inline constexpr ColorChannelType ColorChannelType_MAX =
    static_cast<ColorChannelType>(2);
inline bool ColorChannelType_IsValid(int value) {
  return 0 <= value && value <= 2;
}
inline constexpr int ColorChannelType_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL ColorChannelType_descriptor();
template <typename T>
const ::std::string& ColorChannelType_Name(T value) {
  static_assert(::std::is_same<T, ColorChannelType>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to ColorChannelType_Name().");
  return ColorChannelType_Name(static_cast<ColorChannelType>(value));
}
template <>
inline const ::std::string& ColorChannelType_Name(ColorChannelType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ColorChannelType_descriptor, 0, 2>(
      static_cast<int>(value));
}
inline bool ColorChannelType_Parse(
    ::absl::string_view name, ColorChannelType* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<ColorChannelType>(ColorChannelType_descriptor(), name,
                                           value);
}
enum ColorPickerSpace : int {
  ColorPickerSpace_UNSPECIFIED = 0,
  COLOR_PICKER_SPACE_LINEAR_SRGB = 1,
  COLOR_PICKER_SPACE_SRGB = 2,
  ColorPickerSpace_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  ColorPickerSpace_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t ColorPickerSpace_internal_data_[];
inline constexpr ColorPickerSpace ColorPickerSpace_MIN =
    static_cast<ColorPickerSpace>(0);
inline constexpr ColorPickerSpace ColorPickerSpace_MAX =
    static_cast<ColorPickerSpace>(2);
inline bool ColorPickerSpace_IsValid(int value) {
  return 0 <= value && value <= 2;
}
inline constexpr int ColorPickerSpace_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL ColorPickerSpace_descriptor();
template <typename T>
const ::std::string& ColorPickerSpace_Name(T value) {
  static_assert(::std::is_same<T, ColorPickerSpace>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to ColorPickerSpace_Name().");
  return ColorPickerSpace_Name(static_cast<ColorPickerSpace>(value));
}
template <>
inline const ::std::string& ColorPickerSpace_Name(ColorPickerSpace value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ColorPickerSpace_descriptor, 0, 2>(
      static_cast<int>(value));
}
inline bool ColorPickerSpace_Parse(
    ::absl::string_view name, ColorPickerSpace* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<ColorPickerSpace>(ColorPickerSpace_descriptor(), name,
                                           value);
}
enum ColorSpaceConversion : int {
  COLOR_SPACE_CONVERSION_NONE = 0,
  COLOR_SPACE_CONVERSION_LINEAR_SRGB_TO_HSV = 1,
  COLOR_SPACE_CONVERSION_HSV_TO_LINEAR_SRGB = 2,
  COLOR_SPACE_CONVERSION_LINEAR_SRGB_TO_HSL = 3,
  COLOR_SPACE_CONVERSION_HSL_TO_LINEAR_SRGB = 4,
  COLOR_SPACE_CONVERSION_LINEAR_SRGB_TO_SRGB = 5,
  COLOR_SPACE_CONVERSION_SRGB_TO_LINEAR_SRGB = 6,
  COLOR_SPACE_CONVERSION_LINEAR_SRGB_TO_XY_Y = 7,
  COLOR_SPACE_CONVERSION_XY_Y_TO_LINEAR_SRGB = 8,
  COLOR_SPACE_CONVERSION_LINEAR_SRGB_TO_XYZ = 9,
  COLOR_SPACE_CONVERSION_XYZ_TO_LINEAR_SRGB = 10,
  ColorSpaceConversion_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  ColorSpaceConversion_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t ColorSpaceConversion_internal_data_[];
inline constexpr ColorSpaceConversion ColorSpaceConversion_MIN =
    static_cast<ColorSpaceConversion>(0);
inline constexpr ColorSpaceConversion ColorSpaceConversion_MAX =
    static_cast<ColorSpaceConversion>(10);
inline bool ColorSpaceConversion_IsValid(int value) {
  return 0 <= value && value <= 10;
}
inline constexpr int ColorSpaceConversion_ARRAYSIZE = 10 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL ColorSpaceConversion_descriptor();
template <typename T>
const ::std::string& ColorSpaceConversion_Name(T value) {
  static_assert(::std::is_same<T, ColorSpaceConversion>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to ColorSpaceConversion_Name().");
  return ColorSpaceConversion_Name(static_cast<ColorSpaceConversion>(value));
}
template <>
inline const ::std::string& ColorSpaceConversion_Name(ColorSpaceConversion value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ColorSpaceConversion_descriptor, 0, 10>(
      static_cast<int>(value));
}
inline bool ColorSpaceConversion_Parse(
    ::absl::string_view name, ColorSpaceConversion* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<ColorSpaceConversion>(ColorSpaceConversion_descriptor(), name,
                                           value);
}
enum ColorSpaceCurveType : int {
  COLOR_SPACE_CURVE_TYPE_LINEAR = 0,
  COLOR_SPACE_CURVE_TYPE_UNIFORM = 1,
  COLOR_SPACE_CURVE_TYPE_OTHER = 2,
  ColorSpaceCurveType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  ColorSpaceCurveType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t ColorSpaceCurveType_internal_data_[];
inline constexpr ColorSpaceCurveType ColorSpaceCurveType_MIN =
    static_cast<ColorSpaceCurveType>(0);
inline constexpr ColorSpaceCurveType ColorSpaceCurveType_MAX =
    static_cast<ColorSpaceCurveType>(2);
inline bool ColorSpaceCurveType_IsValid(int value) {
  return 0 <= value && value <= 2;
}
inline constexpr int ColorSpaceCurveType_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL ColorSpaceCurveType_descriptor();
template <typename T>
const ::std::string& ColorSpaceCurveType_Name(T value) {
  static_assert(::std::is_same<T, ColorSpaceCurveType>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to ColorSpaceCurveType_Name().");
  return ColorSpaceCurveType_Name(static_cast<ColorSpaceCurveType>(value));
}
template <>
inline const ::std::string& ColorSpaceCurveType_Name(ColorSpaceCurveType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ColorSpaceCurveType_descriptor, 0, 2>(
      static_cast<int>(value));
}
inline bool ColorSpaceCurveType_Parse(
    ::absl::string_view name, ColorSpaceCurveType* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<ColorSpaceCurveType>(ColorSpaceCurveType_descriptor(), name,
                                           value);
}
enum ComparisonOperation : int {
  COMPARISON_OPERATION_LESS = 0,
  COMPARISON_OPERATION_GREATER = 1,
  COMPARISON_OPERATION_EQUAL = 2,
  COMPARISON_OPERATION_NOT_EQUAL = 3,
  COMPARISON_OPERATION_LESS_OR_EQUAL = 4,
  COMPARISON_OPERATION_GREATER_OR_EQUAL = 5,
  ComparisonOperation_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  ComparisonOperation_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t ComparisonOperation_internal_data_[];
inline constexpr ComparisonOperation ComparisonOperation_MIN =
    static_cast<ComparisonOperation>(0);
inline constexpr ComparisonOperation ComparisonOperation_MAX =
    static_cast<ComparisonOperation>(5);
inline bool ComparisonOperation_IsValid(int value) {
  return 0 <= value && value <= 5;
}
inline constexpr int ComparisonOperation_ARRAYSIZE = 5 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL ComparisonOperation_descriptor();
template <typename T>
const ::std::string& ComparisonOperation_Name(T value) {
  static_assert(::std::is_same<T, ComparisonOperation>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to ComparisonOperation_Name().");
  return ComparisonOperation_Name(static_cast<ComparisonOperation>(value));
}
template <>
inline const ::std::string& ComparisonOperation_Name(ComparisonOperation value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ComparisonOperation_descriptor, 0, 5>(
      static_cast<int>(value));
}
inline bool ComparisonOperation_Parse(
    ::absl::string_view name, ComparisonOperation* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<ComparisonOperation>(ComparisonOperation_descriptor(), name,
                                           value);
}
enum CompilationResult : int {
  COMPILE_NONE = 0,
  COMPILE_SUCCESS = 1,
  COMPILE_FAILED = 2,
  COMPILE_FORCE = 3,
  CompilationResult_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  CompilationResult_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t CompilationResult_internal_data_[];
inline constexpr CompilationResult CompilationResult_MIN =
    static_cast<CompilationResult>(0);
inline constexpr CompilationResult CompilationResult_MAX =
    static_cast<CompilationResult>(3);
inline bool CompilationResult_IsValid(int value) {
  return 0 <= value && value <= 3;
}
inline constexpr int CompilationResult_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL CompilationResult_descriptor();
template <typename T>
const ::std::string& CompilationResult_Name(T value) {
  static_assert(::std::is_same<T, CompilationResult>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to CompilationResult_Name().");
  return CompilationResult_Name(static_cast<CompilationResult>(value));
}
template <>
inline const ::std::string& CompilationResult_Name(CompilationResult value) {
  return ::google::protobuf::internal::NameOfDenseEnum<CompilationResult_descriptor, 0, 3>(
      static_cast<int>(value));
}
inline bool CompilationResult_Parse(
    ::absl::string_view name, CompilationResult* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<CompilationResult>(CompilationResult_descriptor(), name,
                                           value);
}
enum CompositeAlphaOperation : int {
  COMPOSITE_ALPHA_OPERATION_BLEND_MODE = 0,
  COMPOSITE_ALPHA_OPERATION_ALPHA_COMPOSITING = 1,
  COMPOSITE_ALPHA_OPERATION_BACKGROUND = 2,
  COMPOSITE_ALPHA_OPERATION_FOREGROUND = 3,
  COMPOSITE_ALPHA_OPERATION_ONE = 4,
  COMPOSITE_ALPHA_OPERATION_ZERO = 5,
  COMPOSITE_ALPHA_OPERATION_BLEND_MODE_LEGACY = 6,
  CompositeAlphaOperation_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  CompositeAlphaOperation_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t CompositeAlphaOperation_internal_data_[];
inline constexpr CompositeAlphaOperation CompositeAlphaOperation_MIN =
    static_cast<CompositeAlphaOperation>(0);
inline constexpr CompositeAlphaOperation CompositeAlphaOperation_MAX =
    static_cast<CompositeAlphaOperation>(6);
inline bool CompositeAlphaOperation_IsValid(int value) {
  return 0 <= value && value <= 6;
}
inline constexpr int CompositeAlphaOperation_ARRAYSIZE = 6 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL CompositeAlphaOperation_descriptor();
template <typename T>
const ::std::string& CompositeAlphaOperation_Name(T value) {
  static_assert(::std::is_same<T, CompositeAlphaOperation>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to CompositeAlphaOperation_Name().");
  return CompositeAlphaOperation_Name(static_cast<CompositeAlphaOperation>(value));
}
template <>
inline const ::std::string& CompositeAlphaOperation_Name(CompositeAlphaOperation value) {
  return ::google::protobuf::internal::NameOfDenseEnum<CompositeAlphaOperation_descriptor, 0, 6>(
      static_cast<int>(value));
}
inline bool CompositeAlphaOperation_Parse(
    ::absl::string_view name, CompositeAlphaOperation* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<CompositeAlphaOperation>(CompositeAlphaOperation_descriptor(), name,
                                           value);
}
enum CoordinateAxis : int {
  COORDINATE_AXIS_X = 0,
  COORDINATE_AXIS_Y = 1,
  COORDINATE_AXIS_Z = 2,
  CoordinateAxis_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  CoordinateAxis_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t CoordinateAxis_internal_data_[];
inline constexpr CoordinateAxis CoordinateAxis_MIN =
    static_cast<CoordinateAxis>(0);
inline constexpr CoordinateAxis CoordinateAxis_MAX =
    static_cast<CoordinateAxis>(2);
inline bool CoordinateAxis_IsValid(int value) {
  return 0 <= value && value <= 2;
}
inline constexpr int CoordinateAxis_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL CoordinateAxis_descriptor();
template <typename T>
const ::std::string& CoordinateAxis_Name(T value) {
  static_assert(::std::is_same<T, CoordinateAxis>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to CoordinateAxis_Name().");
  return CoordinateAxis_Name(static_cast<CoordinateAxis>(value));
}
template <>
inline const ::std::string& CoordinateAxis_Name(CoordinateAxis value) {
  return ::google::protobuf::internal::NameOfDenseEnum<CoordinateAxis_descriptor, 0, 2>(
      static_cast<int>(value));
}
inline bool CoordinateAxis_Parse(
    ::absl::string_view name, CoordinateAxis* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<CoordinateAxis>(CoordinateAxis_descriptor(), name,
                                           value);
}
enum CoordinateSystem : int {
  COORDINATE_SYSTEM_WORLD = 0,
  COORDINATE_SYSTEM_CAMERA = 1,
  COORDINATE_SYSTEM_OBJECT = 2,
  COORDINATE_SYSTEM_TANGENT = 3,
  CoordinateSystem_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  CoordinateSystem_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t CoordinateSystem_internal_data_[];
inline constexpr CoordinateSystem CoordinateSystem_MIN =
    static_cast<CoordinateSystem>(0);
inline constexpr CoordinateSystem CoordinateSystem_MAX =
    static_cast<CoordinateSystem>(3);
inline bool CoordinateSystem_IsValid(int value) {
  return 0 <= value && value <= 3;
}
inline constexpr int CoordinateSystem_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL CoordinateSystem_descriptor();
template <typename T>
const ::std::string& CoordinateSystem_Name(T value) {
  static_assert(::std::is_same<T, CoordinateSystem>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to CoordinateSystem_Name().");
  return CoordinateSystem_Name(static_cast<CoordinateSystem>(value));
}
template <>
inline const ::std::string& CoordinateSystem_Name(CoordinateSystem value) {
  return ::google::protobuf::internal::NameOfDenseEnum<CoordinateSystem_descriptor, 0, 3>(
      static_cast<int>(value));
}
inline bool CoordinateSystem_Parse(
    ::absl::string_view name, CoordinateSystem* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<CoordinateSystem>(CoordinateSystem_descriptor(), name,
                                           value);
}
enum CryptomatteType : int {
  CRYPTOMATTE_MATERIAL_NODE = 0,
  CRYPTOMATTE_MATERIAL_NODE_NAME = 1,
  CRYPTOMATTE_MATERIAL_PIN_NAME = 2,
  CRYPTOMATTE_OBJECT_NODE = 3,
  CRYPTOMATTE_OBJECT_NODE_NAME = 4,
  CRYPTOMATTE_OBJECT_PIN_NAME = 5,
  CRYPTOMATTE_INSTANCE = 6,
  CRYPTOMATTE_GEOMETRY_NODE_NAME = 7,
  CRYPTOMATTE_RENDER_LAYER = 8,
  CRYPTOMATTE_USER_INSTANCE_ID = 9,
  CryptomatteType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  CryptomatteType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t CryptomatteType_internal_data_[];
inline constexpr CryptomatteType CryptomatteType_MIN =
    static_cast<CryptomatteType>(0);
inline constexpr CryptomatteType CryptomatteType_MAX =
    static_cast<CryptomatteType>(9);
inline bool CryptomatteType_IsValid(int value) {
  return 0 <= value && value <= 9;
}
inline constexpr int CryptomatteType_ARRAYSIZE = 9 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL CryptomatteType_descriptor();
template <typename T>
const ::std::string& CryptomatteType_Name(T value) {
  static_assert(::std::is_same<T, CryptomatteType>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to CryptomatteType_Name().");
  return CryptomatteType_Name(static_cast<CryptomatteType>(value));
}
template <>
inline const ::std::string& CryptomatteType_Name(CryptomatteType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<CryptomatteType_descriptor, 0, 9>(
      static_cast<int>(value));
}
inline bool CryptomatteType_Parse(
    ::absl::string_view name, CryptomatteType* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<CryptomatteType>(CryptomatteType_descriptor(), name,
                                           value);
}
enum CurvatureModes : int {
  CurvatureModes_UNSPECIFIED = 0,
  CURVATURE_MODE_CONCAVITY = 1,
  CURVATURE_MODE_CONVEXITY = 2,
  CURVATURE_MODE_ALL = 3,
  CurvatureModes_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  CurvatureModes_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t CurvatureModes_internal_data_[];
inline constexpr CurvatureModes CurvatureModes_MIN =
    static_cast<CurvatureModes>(0);
inline constexpr CurvatureModes CurvatureModes_MAX =
    static_cast<CurvatureModes>(3);
inline bool CurvatureModes_IsValid(int value) {
  return 0 <= value && value <= 3;
}
inline constexpr int CurvatureModes_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL CurvatureModes_descriptor();
template <typename T>
const ::std::string& CurvatureModes_Name(T value) {
  static_assert(::std::is_same<T, CurvatureModes>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to CurvatureModes_Name().");
  return CurvatureModes_Name(static_cast<CurvatureModes>(value));
}
template <>
inline const ::std::string& CurvatureModes_Name(CurvatureModes value) {
  return ::google::protobuf::internal::NameOfDenseEnum<CurvatureModes_descriptor, 0, 3>(
      static_cast<int>(value));
}
inline bool CurvatureModes_Parse(
    ::absl::string_view name, CurvatureModes* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<CurvatureModes>(CurvatureModes_descriptor(), name,
                                           value);
}
enum CustomAov : int {
  CUSTOM_AOV_1 = 0,
  CUSTOM_AOV_2 = 1,
  CUSTOM_AOV_3 = 2,
  CUSTOM_AOV_4 = 3,
  CUSTOM_AOV_5 = 4,
  CUSTOM_AOV_6 = 5,
  CUSTOM_AOV_7 = 6,
  CUSTOM_AOV_8 = 7,
  CUSTOM_AOV_9 = 8,
  CUSTOM_AOV_10 = 9,
  CUSTOM_AOV_11 = 10,
  CUSTOM_AOV_12 = 11,
  CUSTOM_AOV_13 = 12,
  CUSTOM_AOV_14 = 13,
  CUSTOM_AOV_15 = 14,
  CUSTOM_AOV_16 = 15,
  CUSTOM_AOV_17 = 16,
  CUSTOM_AOV_18 = 17,
  CUSTOM_AOV_19 = 18,
  CUSTOM_AOV_20 = 19,
  CUSTOM_AOV_COUNT = 20,
  INVALID_CUSTOM_AOV = 4096,
  CustomAov_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  CustomAov_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t CustomAov_internal_data_[];
inline constexpr CustomAov CustomAov_MIN =
    static_cast<CustomAov>(0);
inline constexpr CustomAov CustomAov_MAX =
    static_cast<CustomAov>(4096);
inline bool CustomAov_IsValid(int value) {
  return ::google::protobuf::internal::ValidateEnum(value, CustomAov_internal_data_);
}
inline constexpr int CustomAov_ARRAYSIZE = 4096 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL CustomAov_descriptor();
template <typename T>
const ::std::string& CustomAov_Name(T value) {
  static_assert(::std::is_same<T, CustomAov>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to CustomAov_Name().");
  return ::google::protobuf::internal::NameOfEnum(CustomAov_descriptor(), value);
}
inline bool CustomAov_Parse(
    ::absl::string_view name, CustomAov* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<CustomAov>(CustomAov_descriptor(), name,
                                           value);
}
enum CustomAovChannel : int {
  CUSTOM_AOV_CHANNEL_ALL = 0,
  CUSTOM_AOV_CHANNEL_RED = 1,
  CUSTOM_AOV_CHANNEL_GREEN = 2,
  CUSTOM_AOV_CHANNEL_BLUE = 3,
  CustomAovChannel_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  CustomAovChannel_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t CustomAovChannel_internal_data_[];
inline constexpr CustomAovChannel CustomAovChannel_MIN =
    static_cast<CustomAovChannel>(0);
inline constexpr CustomAovChannel CustomAovChannel_MAX =
    static_cast<CustomAovChannel>(3);
inline bool CustomAovChannel_IsValid(int value) {
  return 0 <= value && value <= 3;
}
inline constexpr int CustomAovChannel_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL CustomAovChannel_descriptor();
template <typename T>
const ::std::string& CustomAovChannel_Name(T value) {
  static_assert(::std::is_same<T, CustomAovChannel>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to CustomAovChannel_Name().");
  return CustomAovChannel_Name(static_cast<CustomAovChannel>(value));
}
template <>
inline const ::std::string& CustomAovChannel_Name(CustomAovChannel value) {
  return ::google::protobuf::internal::NameOfDenseEnum<CustomAovChannel_descriptor, 0, 3>(
      static_cast<int>(value));
}
inline bool CustomAovChannel_Parse(
    ::absl::string_view name, CustomAovChannel* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<CustomAovChannel>(CustomAovChannel_descriptor(), name,
                                           value);
}
enum CustomAovSecondaryRayVisibility : int {
  CUSTOM_AOV_PRIMARY_RAYS_ONLY = 0,
  CUSTOM_AOV_ALLOW_REFLECTIONS = 1,
  CUSTOM_AOV_ALLOW_REFRACTIONS = 2,
  CUSTOM_AOV_ALLOW_REFLECTIONS_REFRACTIONS = 3,
  CustomAovSecondaryRayVisibility_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  CustomAovSecondaryRayVisibility_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t CustomAovSecondaryRayVisibility_internal_data_[];
inline constexpr CustomAovSecondaryRayVisibility CustomAovSecondaryRayVisibility_MIN =
    static_cast<CustomAovSecondaryRayVisibility>(0);
inline constexpr CustomAovSecondaryRayVisibility CustomAovSecondaryRayVisibility_MAX =
    static_cast<CustomAovSecondaryRayVisibility>(3);
inline bool CustomAovSecondaryRayVisibility_IsValid(int value) {
  return 0 <= value && value <= 3;
}
inline constexpr int CustomAovSecondaryRayVisibility_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL CustomAovSecondaryRayVisibility_descriptor();
template <typename T>
const ::std::string& CustomAovSecondaryRayVisibility_Name(T value) {
  static_assert(::std::is_same<T, CustomAovSecondaryRayVisibility>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to CustomAovSecondaryRayVisibility_Name().");
  return CustomAovSecondaryRayVisibility_Name(static_cast<CustomAovSecondaryRayVisibility>(value));
}
template <>
inline const ::std::string& CustomAovSecondaryRayVisibility_Name(CustomAovSecondaryRayVisibility value) {
  return ::google::protobuf::internal::NameOfDenseEnum<CustomAovSecondaryRayVisibility_descriptor, 0, 3>(
      static_cast<int>(value));
}
inline bool CustomAovSecondaryRayVisibility_Parse(
    ::absl::string_view name, CustomAovSecondaryRayVisibility* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<CustomAovSecondaryRayVisibility>(CustomAovSecondaryRayVisibility_descriptor(), name,
                                           value);
}
enum CustomCurveMode : int {
  CUSTOM_CURVE_MODE_ALL_CHANNELS = 0,
  CUSTOM_CURVE_MODE_LUMINANCE = 1,
  CUSTOM_CURVE_MODE_MAX_CHANNEL = 2,
  CUSTOM_CURVE_MODE_MAX_CHANNEL_SMOOTH = 3,
  CUSTOM_CURVE_MODE_MAX_AND_MIN_CHANNELS = 4,
  CUSTOM_CURVE_MODE_MAX_AND_MIN_CHANNELS_SMOOTH = 5,
  CustomCurveMode_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  CustomCurveMode_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t CustomCurveMode_internal_data_[];
inline constexpr CustomCurveMode CustomCurveMode_MIN =
    static_cast<CustomCurveMode>(0);
inline constexpr CustomCurveMode CustomCurveMode_MAX =
    static_cast<CustomCurveMode>(5);
inline bool CustomCurveMode_IsValid(int value) {
  return 0 <= value && value <= 5;
}
inline constexpr int CustomCurveMode_ARRAYSIZE = 5 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL CustomCurveMode_descriptor();
template <typename T>
const ::std::string& CustomCurveMode_Name(T value) {
  static_assert(::std::is_same<T, CustomCurveMode>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to CustomCurveMode_Name().");
  return CustomCurveMode_Name(static_cast<CustomCurveMode>(value));
}
template <>
inline const ::std::string& CustomCurveMode_Name(CustomCurveMode value) {
  return ::google::protobuf::internal::NameOfDenseEnum<CustomCurveMode_descriptor, 0, 5>(
      static_cast<int>(value));
}
inline bool CustomCurveMode_Parse(
    ::absl::string_view name, CustomCurveMode* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<CustomCurveMode>(CustomCurveMode_descriptor(), name,
                                           value);
}
enum CacheStatus : int {
  CACHE_NONE = 0,
  CACHE_ERROR = 1,
  CACHE_BUILDING = 2,
  CACHE_FINISHED = 3,
  CacheStatus_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  CacheStatus_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t CacheStatus_internal_data_[];
inline constexpr CacheStatus CacheStatus_MIN =
    static_cast<CacheStatus>(0);
inline constexpr CacheStatus CacheStatus_MAX =
    static_cast<CacheStatus>(3);
inline bool CacheStatus_IsValid(int value) {
  return 0 <= value && value <= 3;
}
inline constexpr int CacheStatus_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL CacheStatus_descriptor();
template <typename T>
const ::std::string& CacheStatus_Name(T value) {
  static_assert(::std::is_same<T, CacheStatus>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to CacheStatus_Name().");
  return CacheStatus_Name(static_cast<CacheStatus>(value));
}
template <>
inline const ::std::string& CacheStatus_Name(CacheStatus value) {
  return ::google::protobuf::internal::NameOfDenseEnum<CacheStatus_descriptor, 0, 3>(
      static_cast<int>(value));
}
inline bool CacheStatus_Parse(
    ::absl::string_view name, CacheStatus* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<CacheStatus>(CacheStatus_descriptor(), name,
                                           value);
}
enum DaylightModel : int {
  DAYLIGHTMODEL_PREETHAM = 0,
  DAYLIGHTMODEL_OCTANE = 1,
  DAYLIGHTMODEL_NISHITA = 2,
  DAYLIGHTMODEL_HOSEK = 3,
  DaylightModel_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  DaylightModel_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t DaylightModel_internal_data_[];
inline constexpr DaylightModel DaylightModel_MIN =
    static_cast<DaylightModel>(0);
inline constexpr DaylightModel DaylightModel_MAX =
    static_cast<DaylightModel>(3);
inline bool DaylightModel_IsValid(int value) {
  return 0 <= value && value <= 3;
}
inline constexpr int DaylightModel_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL DaylightModel_descriptor();
template <typename T>
const ::std::string& DaylightModel_Name(T value) {
  static_assert(::std::is_same<T, DaylightModel>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to DaylightModel_Name().");
  return DaylightModel_Name(static_cast<DaylightModel>(value));
}
template <>
inline const ::std::string& DaylightModel_Name(DaylightModel value) {
  return ::google::protobuf::internal::NameOfDenseEnum<DaylightModel_descriptor, 0, 3>(
      static_cast<int>(value));
}
inline bool DaylightModel_Parse(
    ::absl::string_view name, DaylightModel* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<DaylightModel>(DaylightModel_descriptor(), name,
                                           value);
}
enum DenoiserType : int {
  DENOISER_OCTANE_AI = 0,
  DENOISER_OPEN_IMAGE_DENOISE = 1,
  DenoiserType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  DenoiserType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t DenoiserType_internal_data_[];
inline constexpr DenoiserType DenoiserType_MIN =
    static_cast<DenoiserType>(0);
inline constexpr DenoiserType DenoiserType_MAX =
    static_cast<DenoiserType>(1);
inline bool DenoiserType_IsValid(int value) {
  return 0 <= value && value <= 1;
}
inline constexpr int DenoiserType_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL DenoiserType_descriptor();
template <typename T>
const ::std::string& DenoiserType_Name(T value) {
  static_assert(::std::is_same<T, DenoiserType>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to DenoiserType_Name().");
  return DenoiserType_Name(static_cast<DenoiserType>(value));
}
template <>
inline const ::std::string& DenoiserType_Name(DenoiserType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<DenoiserType_descriptor, 0, 1>(
      static_cast<int>(value));
}
inline bool DenoiserType_Parse(
    ::absl::string_view name, DenoiserType* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<DenoiserType>(DenoiserType_descriptor(), name,
                                           value);
}
enum DenoiserQuality : int {
  DENOISER_QUALITY_FAST = 0,
  DENOISER_QUALITY_BALANCED = 1,
  DENOISER_QUALITY_HIGH = 2,
  DENOISER_QUALITY_DEFAULT = 3,
  DenoiserQuality_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  DenoiserQuality_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t DenoiserQuality_internal_data_[];
inline constexpr DenoiserQuality DenoiserQuality_MIN =
    static_cast<DenoiserQuality>(0);
inline constexpr DenoiserQuality DenoiserQuality_MAX =
    static_cast<DenoiserQuality>(3);
inline bool DenoiserQuality_IsValid(int value) {
  return 0 <= value && value <= 3;
}
inline constexpr int DenoiserQuality_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL DenoiserQuality_descriptor();
template <typename T>
const ::std::string& DenoiserQuality_Name(T value) {
  static_assert(::std::is_same<T, DenoiserQuality>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to DenoiserQuality_Name().");
  return DenoiserQuality_Name(static_cast<DenoiserQuality>(value));
}
template <>
inline const ::std::string& DenoiserQuality_Name(DenoiserQuality value) {
  return ::google::protobuf::internal::NameOfDenseEnum<DenoiserQuality_descriptor, 0, 3>(
      static_cast<int>(value));
}
inline bool DenoiserQuality_Parse(
    ::absl::string_view name, DenoiserQuality* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<DenoiserQuality>(DenoiserQuality_descriptor(), name,
                                           value);
}
enum DecalTextureIndex : int {
  DECAL_TEXTURE_INDEX_NORMAL = 0,
  DECAL_TEXTURE_INDEX_1 = 1,
  DECAL_TEXTURE_INDEX_2 = 2,
  DECAL_TEXTURE_INDEX_3 = 3,
  DECAL_TEXTURE_INDEX_4 = 4,
  DECAL_TEXTURE_INDEX_5 = 5,
  DECAL_TEXTURE_INDEX_6 = 6,
  DECAL_TEXTURE_INDEX_7 = 7,
  DECAL_TEXTURE_INDEX_8 = 8,
  DECAL_TEXTURE_INDEX_9 = 9,
  DecalTextureIndex_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  DecalTextureIndex_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t DecalTextureIndex_internal_data_[];
inline constexpr DecalTextureIndex DecalTextureIndex_MIN =
    static_cast<DecalTextureIndex>(0);
inline constexpr DecalTextureIndex DecalTextureIndex_MAX =
    static_cast<DecalTextureIndex>(9);
inline bool DecalTextureIndex_IsValid(int value) {
  return 0 <= value && value <= 9;
}
inline constexpr int DecalTextureIndex_ARRAYSIZE = 9 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL DecalTextureIndex_descriptor();
template <typename T>
const ::std::string& DecalTextureIndex_Name(T value) {
  static_assert(::std::is_same<T, DecalTextureIndex>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to DecalTextureIndex_Name().");
  return DecalTextureIndex_Name(static_cast<DecalTextureIndex>(value));
}
template <>
inline const ::std::string& DecalTextureIndex_Name(DecalTextureIndex value) {
  return ::google::protobuf::internal::NameOfDenseEnum<DecalTextureIndex_descriptor, 0, 9>(
      static_cast<int>(value));
}
inline bool DecalTextureIndex_Parse(
    ::absl::string_view name, DecalTextureIndex* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<DecalTextureIndex>(DecalTextureIndex_descriptor(), name,
                                           value);
}
enum DirectLightMode : int {
  DL_GI_NONE = 0,
  _DL_GI_AMBIENT = 1,
  _DL_GI_SAMPLE_AMBIENT = 2,
  DL_GI_AMBIENT_OCCLUSION = 3,
  DL_GI_DIFFUSE = 4,
  DirectLightMode_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  DirectLightMode_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t DirectLightMode_internal_data_[];
inline constexpr DirectLightMode DirectLightMode_MIN =
    static_cast<DirectLightMode>(0);
inline constexpr DirectLightMode DirectLightMode_MAX =
    static_cast<DirectLightMode>(4);
inline bool DirectLightMode_IsValid(int value) {
  return 0 <= value && value <= 4;
}
inline constexpr int DirectLightMode_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL DirectLightMode_descriptor();
template <typename T>
const ::std::string& DirectLightMode_Name(T value) {
  static_assert(::std::is_same<T, DirectLightMode>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to DirectLightMode_Name().");
  return DirectLightMode_Name(static_cast<DirectLightMode>(value));
}
template <>
inline const ::std::string& DirectLightMode_Name(DirectLightMode value) {
  return ::google::protobuf::internal::NameOfDenseEnum<DirectLightMode_descriptor, 0, 4>(
      static_cast<int>(value));
}
inline bool DirectLightMode_Parse(
    ::absl::string_view name, DirectLightMode* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<DirectLightMode>(DirectLightMode_descriptor(), name,
                                           value);
}
enum DispersionModel : int {
  DispersionModel_UNSPECIFIED = 0,
  DISPERSION_ABBE = 1,
  DISPERSION_CAUCHY = 2,
  DispersionModel_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  DispersionModel_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t DispersionModel_internal_data_[];
inline constexpr DispersionModel DispersionModel_MIN =
    static_cast<DispersionModel>(0);
inline constexpr DispersionModel DispersionModel_MAX =
    static_cast<DispersionModel>(2);
inline bool DispersionModel_IsValid(int value) {
  return 0 <= value && value <= 2;
}
inline constexpr int DispersionModel_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL DispersionModel_descriptor();
template <typename T>
const ::std::string& DispersionModel_Name(T value) {
  static_assert(::std::is_same<T, DispersionModel>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to DispersionModel_Name().");
  return DispersionModel_Name(static_cast<DispersionModel>(value));
}
template <>
inline const ::std::string& DispersionModel_Name(DispersionModel value) {
  return ::google::protobuf::internal::NameOfDenseEnum<DispersionModel_descriptor, 0, 2>(
      static_cast<int>(value));
}
inline bool DispersionModel_Parse(
    ::absl::string_view name, DispersionModel* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<DispersionModel>(DispersionModel_descriptor(), name,
                                           value);
}
enum DisplacementLod : int {
  DisplacementLod_UNSPECIFIED = 0,
  DISPLACEMENT_LEVEL_256 = 8,
  DISPLACEMENT_LEVEL_512 = 9,
  DISPLACEMENT_LEVEL_1024 = 10,
  DISPLACEMENT_LEVEL_2048 = 11,
  DISPLACEMENT_LEVEL_4096 = 12,
  DISPLACEMENT_LEVEL_8192 = 13,
  DISPLACEMENT_LEVEL_16384 = 14,
  DisplacementLod_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  DisplacementLod_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t DisplacementLod_internal_data_[];
inline constexpr DisplacementLod DisplacementLod_MIN =
    static_cast<DisplacementLod>(0);
inline constexpr DisplacementLod DisplacementLod_MAX =
    static_cast<DisplacementLod>(14);
inline bool DisplacementLod_IsValid(int value) {
  return 0 <= value && value <= 14 && ((32513u >> value) & 1) != 0;
}
inline constexpr int DisplacementLod_ARRAYSIZE = 14 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL DisplacementLod_descriptor();
template <typename T>
const ::std::string& DisplacementLod_Name(T value) {
  static_assert(::std::is_same<T, DisplacementLod>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to DisplacementLod_Name().");
  return DisplacementLod_Name(static_cast<DisplacementLod>(value));
}
template <>
inline const ::std::string& DisplacementLod_Name(DisplacementLod value) {
  return ::google::protobuf::internal::NameOfDenseEnum<DisplacementLod_descriptor, 0, 14>(
      static_cast<int>(value));
}
inline bool DisplacementLod_Parse(
    ::absl::string_view name, DisplacementLod* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<DisplacementLod>(DisplacementLod_descriptor(), name,
                                           value);
}
enum DisplacementQuality : int {
  DISPLACEMENT_QUALITY_NORMAL = 0,
  DISPLACEMENT_QUALITY_HIGH = 1,
  DisplacementQuality_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  DisplacementQuality_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t DisplacementQuality_internal_data_[];
inline constexpr DisplacementQuality DisplacementQuality_MIN =
    static_cast<DisplacementQuality>(0);
inline constexpr DisplacementQuality DisplacementQuality_MAX =
    static_cast<DisplacementQuality>(1);
inline bool DisplacementQuality_IsValid(int value) {
  return 0 <= value && value <= 1;
}
inline constexpr int DisplacementQuality_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL DisplacementQuality_descriptor();
template <typename T>
const ::std::string& DisplacementQuality_Name(T value) {
  static_assert(::std::is_same<T, DisplacementQuality>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to DisplacementQuality_Name().");
  return DisplacementQuality_Name(static_cast<DisplacementQuality>(value));
}
template <>
inline const ::std::string& DisplacementQuality_Name(DisplacementQuality value) {
  return ::google::protobuf::internal::NameOfDenseEnum<DisplacementQuality_descriptor, 0, 1>(
      static_cast<int>(value));
}
inline bool DisplacementQuality_Parse(
    ::absl::string_view name, DisplacementQuality* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<DisplacementQuality>(DisplacementQuality_descriptor(), name,
                                           value);
}
enum DisplacementDirection : int {
  DisplacementDirection_UNSPECIFIED = 0,
  DISPLACEMENT_VERTEX_NORMAL = 1,
  DISPLACEMENT_GEOMETRIC_NORMAL = 2,
  DISPLACEMENT_SMOOTH_NORMAL = 3,
  DisplacementDirection_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  DisplacementDirection_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t DisplacementDirection_internal_data_[];
inline constexpr DisplacementDirection DisplacementDirection_MIN =
    static_cast<DisplacementDirection>(0);
inline constexpr DisplacementDirection DisplacementDirection_MAX =
    static_cast<DisplacementDirection>(3);
inline bool DisplacementDirection_IsValid(int value) {
  return 0 <= value && value <= 3;
}
inline constexpr int DisplacementDirection_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL DisplacementDirection_descriptor();
template <typename T>
const ::std::string& DisplacementDirection_Name(T value) {
  static_assert(::std::is_same<T, DisplacementDirection>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to DisplacementDirection_Name().");
  return DisplacementDirection_Name(static_cast<DisplacementDirection>(value));
}
template <>
inline const ::std::string& DisplacementDirection_Name(DisplacementDirection value) {
  return ::google::protobuf::internal::NameOfDenseEnum<DisplacementDirection_descriptor, 0, 3>(
      static_cast<int>(value));
}
inline bool DisplacementDirection_Parse(
    ::absl::string_view name, DisplacementDirection* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<DisplacementDirection>(DisplacementDirection_descriptor(), name,
                                           value);
}
enum DisplacementTextureSpace : int {
  DISPLACEMENT_TEXTURE_SPACE_OBJECT = 0,
  DISPLACEMENT_TEXTURE_SPACE_TANGENT = 1,
  DisplacementTextureSpace_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  DisplacementTextureSpace_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t DisplacementTextureSpace_internal_data_[];
inline constexpr DisplacementTextureSpace DisplacementTextureSpace_MIN =
    static_cast<DisplacementTextureSpace>(0);
inline constexpr DisplacementTextureSpace DisplacementTextureSpace_MAX =
    static_cast<DisplacementTextureSpace>(1);
inline bool DisplacementTextureSpace_IsValid(int value) {
  return 0 <= value && value <= 1;
}
inline constexpr int DisplacementTextureSpace_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL DisplacementTextureSpace_descriptor();
template <typename T>
const ::std::string& DisplacementTextureSpace_Name(T value) {
  static_assert(::std::is_same<T, DisplacementTextureSpace>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to DisplacementTextureSpace_Name().");
  return DisplacementTextureSpace_Name(static_cast<DisplacementTextureSpace>(value));
}
template <>
inline const ::std::string& DisplacementTextureSpace_Name(DisplacementTextureSpace value) {
  return ::google::protobuf::internal::NameOfDenseEnum<DisplacementTextureSpace_descriptor, 0, 1>(
      static_cast<int>(value));
}
inline bool DisplacementTextureSpace_Parse(
    ::absl::string_view name, DisplacementTextureSpace* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<DisplacementTextureSpace>(DisplacementTextureSpace_descriptor(), name,
                                           value);
}
enum DisplacementMapType : int {
  DISPLACEMENT_MAP_TYPE_VECTOR = 0,
  DISPLACEMENT_MAP_TYPE_HEIGHT = 1,
  DisplacementMapType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  DisplacementMapType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t DisplacementMapType_internal_data_[];
inline constexpr DisplacementMapType DisplacementMapType_MIN =
    static_cast<DisplacementMapType>(0);
inline constexpr DisplacementMapType DisplacementMapType_MAX =
    static_cast<DisplacementMapType>(1);
inline bool DisplacementMapType_IsValid(int value) {
  return 0 <= value && value <= 1;
}
inline constexpr int DisplacementMapType_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL DisplacementMapType_descriptor();
template <typename T>
const ::std::string& DisplacementMapType_Name(T value) {
  static_assert(::std::is_same<T, DisplacementMapType>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to DisplacementMapType_Name().");
  return DisplacementMapType_Name(static_cast<DisplacementMapType>(value));
}
template <>
inline const ::std::string& DisplacementMapType_Name(DisplacementMapType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<DisplacementMapType_descriptor, 0, 1>(
      static_cast<int>(value));
}
inline bool DisplacementMapType_Parse(
    ::absl::string_view name, DisplacementMapType* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<DisplacementMapType>(DisplacementMapType_descriptor(), name,
                                           value);
}
enum DisplacementTextureAxes : int {
  DISPLACEMENT_MAP_AXES_POSITIVE_XYZ = 0,
  DISPLACEMENT_MAP_AXES_POSITIVE_XZY = 1,
  DISPLACEMENT_MAP_AXES_POSITIVE_XY_NEG_Z = 2,
  DisplacementTextureAxes_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  DisplacementTextureAxes_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t DisplacementTextureAxes_internal_data_[];
inline constexpr DisplacementTextureAxes DisplacementTextureAxes_MIN =
    static_cast<DisplacementTextureAxes>(0);
inline constexpr DisplacementTextureAxes DisplacementTextureAxes_MAX =
    static_cast<DisplacementTextureAxes>(2);
inline bool DisplacementTextureAxes_IsValid(int value) {
  return 0 <= value && value <= 2;
}
inline constexpr int DisplacementTextureAxes_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL DisplacementTextureAxes_descriptor();
template <typename T>
const ::std::string& DisplacementTextureAxes_Name(T value) {
  static_assert(::std::is_same<T, DisplacementTextureAxes>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to DisplacementTextureAxes_Name().");
  return DisplacementTextureAxes_Name(static_cast<DisplacementTextureAxes>(value));
}
template <>
inline const ::std::string& DisplacementTextureAxes_Name(DisplacementTextureAxes value) {
  return ::google::protobuf::internal::NameOfDenseEnum<DisplacementTextureAxes_descriptor, 0, 2>(
      static_cast<int>(value));
}
inline bool DisplacementTextureAxes_Parse(
    ::absl::string_view name, DisplacementTextureAxes* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<DisplacementTextureAxes>(DisplacementTextureAxes_descriptor(), name,
                                           value);
}
enum DistanceMode : int {
  DISTANCE_MODE_NORMAL = 0,
  DISTANCE_MODE_OFFSET_X = 1,
  DISTANCE_MODE_OFFSET_Y = 2,
  DISTANCE_MODE_OFFSET_Z = 3,
  DistanceMode_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  DistanceMode_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t DistanceMode_internal_data_[];
inline constexpr DistanceMode DistanceMode_MIN =
    static_cast<DistanceMode>(0);
inline constexpr DistanceMode DistanceMode_MAX =
    static_cast<DistanceMode>(3);
inline bool DistanceMode_IsValid(int value) {
  return 0 <= value && value <= 3;
}
inline constexpr int DistanceMode_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL DistanceMode_descriptor();
template <typename T>
const ::std::string& DistanceMode_Name(T value) {
  static_assert(::std::is_same<T, DistanceMode>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to DistanceMode_Name().");
  return DistanceMode_Name(static_cast<DistanceMode>(value));
}
template <>
inline const ::std::string& DistanceMode_Name(DistanceMode value) {
  return ::google::protobuf::internal::NameOfDenseEnum<DistanceMode_descriptor, 0, 3>(
      static_cast<int>(value));
}
inline bool DistanceMode_Parse(
    ::absl::string_view name, DistanceMode* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<DistanceMode>(DistanceMode_descriptor(), name,
                                           value);
}
enum ExpandContractRgbMode : int {
  EXPAND_CONTRACT_RGB_MODE_COLOR = 0,
  EXPAND_CONTRACT_RGB_MODE_MASKS = 1,
  ExpandContractRgbMode_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  ExpandContractRgbMode_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t ExpandContractRgbMode_internal_data_[];
inline constexpr ExpandContractRgbMode ExpandContractRgbMode_MIN =
    static_cast<ExpandContractRgbMode>(0);
inline constexpr ExpandContractRgbMode ExpandContractRgbMode_MAX =
    static_cast<ExpandContractRgbMode>(1);
inline bool ExpandContractRgbMode_IsValid(int value) {
  return 0 <= value && value <= 1;
}
inline constexpr int ExpandContractRgbMode_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL ExpandContractRgbMode_descriptor();
template <typename T>
const ::std::string& ExpandContractRgbMode_Name(T value) {
  static_assert(::std::is_same<T, ExpandContractRgbMode>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to ExpandContractRgbMode_Name().");
  return ExpandContractRgbMode_Name(static_cast<ExpandContractRgbMode>(value));
}
template <>
inline const ::std::string& ExpandContractRgbMode_Name(ExpandContractRgbMode value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ExpandContractRgbMode_descriptor, 0, 1>(
      static_cast<int>(value));
}
inline bool ExpandContractRgbMode_Parse(
    ::absl::string_view name, ExpandContractRgbMode* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<ExpandContractRgbMode>(ExpandContractRgbMode_descriptor(), name,
                                           value);
}
enum ExportState : int {
  EXPORT_NOT_STARTED = 0,
  EXPORTING = 1,
  EXPORTING_WITH_ERRORS = 2,
  EXPORT_FAILED = 3,
  EXPORT_FINISHED = 4,
  ExportState_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  ExportState_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t ExportState_internal_data_[];
inline constexpr ExportState ExportState_MIN =
    static_cast<ExportState>(0);
inline constexpr ExportState ExportState_MAX =
    static_cast<ExportState>(4);
inline bool ExportState_IsValid(int value) {
  return 0 <= value && value <= 4;
}
inline constexpr int ExportState_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL ExportState_descriptor();
template <typename T>
const ::std::string& ExportState_Name(T value) {
  static_assert(::std::is_same<T, ExportState>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to ExportState_Name().");
  return ExportState_Name(static_cast<ExportState>(value));
}
template <>
inline const ::std::string& ExportState_Name(ExportState value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ExportState_descriptor, 0, 4>(
      static_cast<int>(value));
}
inline bool ExportState_Parse(
    ::absl::string_view name, ExportState* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<ExportState>(ExportState_descriptor(), name,
                                           value);
}
enum ExrCompressionType : int {
  ExrCompressionType_UNSPECIFIED = 0,
  EXR_COMPRESSION_NO_COMPRESSION = 1,
  EXR_COMPRESSION_RLE = 2,
  EXR_COMPRESSION_ZIPS = 3,
  EXR_COMPRESSION_ZIP = 4,
  EXR_COMPRESSION_PIZ = 5,
  EXR_COMPRESSION_PXR24 = 6,
  EXR_COMPRESSION_B44 = 7,
  EXR_COMPRESSION_B44A = 8,
  EXR_COMPRESSION_DWAA = 9,
  EXR_COMPRESSION_DWAB = 10,
  ExrCompressionType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  ExrCompressionType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t ExrCompressionType_internal_data_[];
inline constexpr ExrCompressionType ExrCompressionType_MIN =
    static_cast<ExrCompressionType>(0);
inline constexpr ExrCompressionType ExrCompressionType_MAX =
    static_cast<ExrCompressionType>(10);
inline bool ExrCompressionType_IsValid(int value) {
  return 0 <= value && value <= 10;
}
inline constexpr int ExrCompressionType_ARRAYSIZE = 10 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL ExrCompressionType_descriptor();
template <typename T>
const ::std::string& ExrCompressionType_Name(T value) {
  static_assert(::std::is_same<T, ExrCompressionType>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to ExrCompressionType_Name().");
  return ExrCompressionType_Name(static_cast<ExrCompressionType>(value));
}
template <>
inline const ::std::string& ExrCompressionType_Name(ExrCompressionType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ExrCompressionType_descriptor, 0, 10>(
      static_cast<int>(value));
}
inline bool ExrCompressionType_Parse(
    ::absl::string_view name, ExrCompressionType* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<ExrCompressionType>(ExrCompressionType_descriptor(), name,
                                           value);
}
enum FaceCullingMode : int {
  FACE_CULLING_RENDER_ALL = 0,
  FACE_CULLING_RENDER_BACK = 1,
  FACE_CULLING_RENDER_FRONT = 2,
  FACE_CULLING_RENDER_NONE = 3,
  FaceCullingMode_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  FaceCullingMode_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t FaceCullingMode_internal_data_[];
inline constexpr FaceCullingMode FaceCullingMode_MIN =
    static_cast<FaceCullingMode>(0);
inline constexpr FaceCullingMode FaceCullingMode_MAX =
    static_cast<FaceCullingMode>(3);
inline bool FaceCullingMode_IsValid(int value) {
  return 0 <= value && value <= 3;
}
inline constexpr int FaceCullingMode_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL FaceCullingMode_descriptor();
template <typename T>
const ::std::string& FaceCullingMode_Name(T value) {
  static_assert(::std::is_same<T, FaceCullingMode>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to FaceCullingMode_Name().");
  return FaceCullingMode_Name(static_cast<FaceCullingMode>(value));
}
template <>
inline const ::std::string& FaceCullingMode_Name(FaceCullingMode value) {
  return ::google::protobuf::internal::NameOfDenseEnum<FaceCullingMode_descriptor, 0, 3>(
      static_cast<int>(value));
}
inline bool FaceCullingMode_Parse(
    ::absl::string_view name, FaceCullingMode* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<FaceCullingMode>(FaceCullingMode_descriptor(), name,
                                           value);
}
enum FalloffTextureMode : int {
  FALLOFF_NORMAL_VS_EYE_RAY = 0,
  FALLOFF_NORMAL_VS_VECTOR_90DEG = 1,
  FALLOFF_NORMAL_VS_VECTOR_180DEG = 2,
  FalloffTextureMode_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  FalloffTextureMode_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t FalloffTextureMode_internal_data_[];
inline constexpr FalloffTextureMode FalloffTextureMode_MIN =
    static_cast<FalloffTextureMode>(0);
inline constexpr FalloffTextureMode FalloffTextureMode_MAX =
    static_cast<FalloffTextureMode>(2);
inline bool FalloffTextureMode_IsValid(int value) {
  return 0 <= value && value <= 2;
}
inline constexpr int FalloffTextureMode_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL FalloffTextureMode_descriptor();
template <typename T>
const ::std::string& FalloffTextureMode_Name(T value) {
  static_assert(::std::is_same<T, FalloffTextureMode>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to FalloffTextureMode_Name().");
  return FalloffTextureMode_Name(static_cast<FalloffTextureMode>(value));
}
template <>
inline const ::std::string& FalloffTextureMode_Name(FalloffTextureMode value) {
  return ::google::protobuf::internal::NameOfDenseEnum<FalloffTextureMode_descriptor, 0, 2>(
      static_cast<int>(value));
}
inline bool FalloffTextureMode_Parse(
    ::absl::string_view name, FalloffTextureMode* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<FalloffTextureMode>(FalloffTextureMode_descriptor(), name,
                                           value);
}
enum FilterType : int {
  FILTER_TYPE_NONE = 0,
  FILTER_TYPE_BOX = 1,
  FILTER_TYPE_GAUSSIAN = 2,
  FilterType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  FilterType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t FilterType_internal_data_[];
inline constexpr FilterType FilterType_MIN =
    static_cast<FilterType>(0);
inline constexpr FilterType FilterType_MAX =
    static_cast<FilterType>(2);
inline bool FilterType_IsValid(int value) {
  return 0 <= value && value <= 2;
}
inline constexpr int FilterType_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL FilterType_descriptor();
template <typename T>
const ::std::string& FilterType_Name(T value) {
  static_assert(::std::is_same<T, FilterType>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to FilterType_Name().");
  return FilterType_Name(static_cast<FilterType>(value));
}
template <>
inline const ::std::string& FilterType_Name(FilterType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<FilterType_descriptor, 0, 2>(
      static_cast<int>(value));
}
inline bool FilterType_Parse(
    ::absl::string_view name, FilterType* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<FilterType>(FilterType_descriptor(), name,
                                           value);
}
enum FractalNoiseMode : int {
  FRACTAL_NOISE_MODE_SCALAR = 0,
  FRACTAL_NOISE_MODE_VECTOR = 1,
  FractalNoiseMode_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  FractalNoiseMode_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t FractalNoiseMode_internal_data_[];
inline constexpr FractalNoiseMode FractalNoiseMode_MIN =
    static_cast<FractalNoiseMode>(0);
inline constexpr FractalNoiseMode FractalNoiseMode_MAX =
    static_cast<FractalNoiseMode>(1);
inline bool FractalNoiseMode_IsValid(int value) {
  return 0 <= value && value <= 1;
}
inline constexpr int FractalNoiseMode_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL FractalNoiseMode_descriptor();
template <typename T>
const ::std::string& FractalNoiseMode_Name(T value) {
  static_assert(::std::is_same<T, FractalNoiseMode>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to FractalNoiseMode_Name().");
  return FractalNoiseMode_Name(static_cast<FractalNoiseMode>(value));
}
template <>
inline const ::std::string& FractalNoiseMode_Name(FractalNoiseMode value) {
  return ::google::protobuf::internal::NameOfDenseEnum<FractalNoiseMode_descriptor, 0, 1>(
      static_cast<int>(value));
}
inline bool FractalNoiseMode_Parse(
    ::absl::string_view name, FractalNoiseMode* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<FractalNoiseMode>(FractalNoiseMode_descriptor(), name,
                                           value);
}
enum GaussianSplatClipMode : int {
  GAUSSIAN_SPLAT_CLIP_MODE_NONE = 0,
  GAUSSIAN_SPLAT_CLIP_MODE_BOX = 1,
  GAUSSIAN_SPLAT_CLIP_MODE_ELLIPSOID = 2,
  GaussianSplatClipMode_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  GaussianSplatClipMode_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t GaussianSplatClipMode_internal_data_[];
inline constexpr GaussianSplatClipMode GaussianSplatClipMode_MIN =
    static_cast<GaussianSplatClipMode>(0);
inline constexpr GaussianSplatClipMode GaussianSplatClipMode_MAX =
    static_cast<GaussianSplatClipMode>(2);
inline bool GaussianSplatClipMode_IsValid(int value) {
  return 0 <= value && value <= 2;
}
inline constexpr int GaussianSplatClipMode_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL GaussianSplatClipMode_descriptor();
template <typename T>
const ::std::string& GaussianSplatClipMode_Name(T value) {
  static_assert(::std::is_same<T, GaussianSplatClipMode>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to GaussianSplatClipMode_Name().");
  return GaussianSplatClipMode_Name(static_cast<GaussianSplatClipMode>(value));
}
template <>
inline const ::std::string& GaussianSplatClipMode_Name(GaussianSplatClipMode value) {
  return ::google::protobuf::internal::NameOfDenseEnum<GaussianSplatClipMode_descriptor, 0, 2>(
      static_cast<int>(value));
}
inline bool GaussianSplatClipMode_Parse(
    ::absl::string_view name, GaussianSplatClipMode* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<GaussianSplatClipMode>(GaussianSplatClipMode_descriptor(), name,
                                           value);
}
enum GaussianSplatLightingMode : int {
  GAUSSIAN_SPLAT_LIGHTING_MODE_NONE = 0,
  GAUSSIAN_SPLAT_LIGHTING_MODE_POWER = 1,
  GAUSSIAN_SPLAT_LIGHTING_MODE_POWER_AND_COLOR = 2,
  GaussianSplatLightingMode_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  GaussianSplatLightingMode_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t GaussianSplatLightingMode_internal_data_[];
inline constexpr GaussianSplatLightingMode GaussianSplatLightingMode_MIN =
    static_cast<GaussianSplatLightingMode>(0);
inline constexpr GaussianSplatLightingMode GaussianSplatLightingMode_MAX =
    static_cast<GaussianSplatLightingMode>(2);
inline bool GaussianSplatLightingMode_IsValid(int value) {
  return 0 <= value && value <= 2;
}
inline constexpr int GaussianSplatLightingMode_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL GaussianSplatLightingMode_descriptor();
template <typename T>
const ::std::string& GaussianSplatLightingMode_Name(T value) {
  static_assert(::std::is_same<T, GaussianSplatLightingMode>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to GaussianSplatLightingMode_Name().");
  return GaussianSplatLightingMode_Name(static_cast<GaussianSplatLightingMode>(value));
}
template <>
inline const ::std::string& GaussianSplatLightingMode_Name(GaussianSplatLightingMode value) {
  return ::google::protobuf::internal::NameOfDenseEnum<GaussianSplatLightingMode_descriptor, 0, 2>(
      static_cast<int>(value));
}
inline bool GaussianSplatLightingMode_Parse(
    ::absl::string_view name, GaussianSplatLightingMode* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<GaussianSplatLightingMode>(GaussianSplatLightingMode_descriptor(), name,
                                           value);
}
enum GeometryExportFormat : int {
  GeometryExportFormat_UNSPECIFIED = 0,
  GEOMETRY_FORMAT_ALEMBIC = 1,
  GEOMETRY_FORMAT_FBX = 2,
  GeometryExportFormat_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  GeometryExportFormat_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t GeometryExportFormat_internal_data_[];
inline constexpr GeometryExportFormat GeometryExportFormat_MIN =
    static_cast<GeometryExportFormat>(0);
inline constexpr GeometryExportFormat GeometryExportFormat_MAX =
    static_cast<GeometryExportFormat>(2);
inline bool GeometryExportFormat_IsValid(int value) {
  return 0 <= value && value <= 2;
}
inline constexpr int GeometryExportFormat_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL GeometryExportFormat_descriptor();
template <typename T>
const ::std::string& GeometryExportFormat_Name(T value) {
  static_assert(::std::is_same<T, GeometryExportFormat>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to GeometryExportFormat_Name().");
  return GeometryExportFormat_Name(static_cast<GeometryExportFormat>(value));
}
template <>
inline const ::std::string& GeometryExportFormat_Name(GeometryExportFormat value) {
  return ::google::protobuf::internal::NameOfDenseEnum<GeometryExportFormat_descriptor, 0, 2>(
      static_cast<int>(value));
}
inline bool GeometryExportFormat_Parse(
    ::absl::string_view name, GeometryExportFormat* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<GeometryExportFormat>(GeometryExportFormat_descriptor(), name,
                                           value);
}
enum GeometryImportObjectLayers : int {
  GeometryImportObjectLayers_UNSPECIFIED = 0,
  GEOIMP_HIDE_OBJECT_LAYERS = 1,
  GEOIMP_LOAD_AS_ONE_OBJECT_LAYER = 2,
  GEOIMP_LOAD_ALL_OBJECT_LAYERS = 3,
  GeometryImportObjectLayers_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  GeometryImportObjectLayers_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t GeometryImportObjectLayers_internal_data_[];
inline constexpr GeometryImportObjectLayers GeometryImportObjectLayers_MIN =
    static_cast<GeometryImportObjectLayers>(0);
inline constexpr GeometryImportObjectLayers GeometryImportObjectLayers_MAX =
    static_cast<GeometryImportObjectLayers>(3);
inline bool GeometryImportObjectLayers_IsValid(int value) {
  return 0 <= value && value <= 3;
}
inline constexpr int GeometryImportObjectLayers_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL GeometryImportObjectLayers_descriptor();
template <typename T>
const ::std::string& GeometryImportObjectLayers_Name(T value) {
  static_assert(::std::is_same<T, GeometryImportObjectLayers>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to GeometryImportObjectLayers_Name().");
  return GeometryImportObjectLayers_Name(static_cast<GeometryImportObjectLayers>(value));
}
template <>
inline const ::std::string& GeometryImportObjectLayers_Name(GeometryImportObjectLayers value) {
  return ::google::protobuf::internal::NameOfDenseEnum<GeometryImportObjectLayers_descriptor, 0, 3>(
      static_cast<int>(value));
}
inline bool GeometryImportObjectLayers_Parse(
    ::absl::string_view name, GeometryImportObjectLayers* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<GeometryImportObjectLayers>(GeometryImportObjectLayers_descriptor(), name,
                                           value);
}
enum GeometryImportScale : int {
  GeometryImportScale_UNSPECIFIED = 0,
  GEOIMP_UNIT_MILLIMETERS = 1,
  GEOIMP_UNIT_CENTIMETERS = 2,
  GEOIMP_UNIT_DECIMETERS = 3,
  GEOIMP_UNIT_METERS = 4,
  GEOIMP_UNIT_DECAMETERS = 5,
  GEOIMP_UNIT_HECTOMETERS = 6,
  GEOIMP_UNIT_KILOMETERS = 7,
  GEOIMP_UNIT_INCHES = 8,
  GEOIMP_UNIT_FEET = 9,
  GEOIMP_UNIT_YARDS = 10,
  GEOIMP_UNIT_FURLONGS = 11,
  GEOIMP_UNIT_MILES = 12,
  GEOIMP_UNIT_8FOOT_DAZ = 13,
  GEOIMP_UNIT_86FOOT_POSER = 14,
  GeometryImportScale_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  GeometryImportScale_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t GeometryImportScale_internal_data_[];
inline constexpr GeometryImportScale GeometryImportScale_MIN =
    static_cast<GeometryImportScale>(0);
inline constexpr GeometryImportScale GeometryImportScale_MAX =
    static_cast<GeometryImportScale>(14);
inline bool GeometryImportScale_IsValid(int value) {
  return 0 <= value && value <= 14;
}
inline constexpr int GeometryImportScale_ARRAYSIZE = 14 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL GeometryImportScale_descriptor();
template <typename T>
const ::std::string& GeometryImportScale_Name(T value) {
  static_assert(::std::is_same<T, GeometryImportScale>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to GeometryImportScale_Name().");
  return GeometryImportScale_Name(static_cast<GeometryImportScale>(value));
}
template <>
inline const ::std::string& GeometryImportScale_Name(GeometryImportScale value) {
  return ::google::protobuf::internal::NameOfDenseEnum<GeometryImportScale_descriptor, 0, 14>(
      static_cast<int>(value));
}
inline bool GeometryImportScale_Parse(
    ::absl::string_view name, GeometryImportScale* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<GeometryImportScale>(GeometryImportScale_descriptor(), name,
                                           value);
}
enum GlobalLightIdMaskAction : int {
  GLOBAL_LIGHT_ID_MASK_ACTION_ENABLE = 0,
  GLOBAL_LIGHT_ID_MASK_ACTION_DISABLE = 1,
  GlobalLightIdMaskAction_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  GlobalLightIdMaskAction_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t GlobalLightIdMaskAction_internal_data_[];
inline constexpr GlobalLightIdMaskAction GlobalLightIdMaskAction_MIN =
    static_cast<GlobalLightIdMaskAction>(0);
inline constexpr GlobalLightIdMaskAction GlobalLightIdMaskAction_MAX =
    static_cast<GlobalLightIdMaskAction>(1);
inline bool GlobalLightIdMaskAction_IsValid(int value) {
  return 0 <= value && value <= 1;
}
inline constexpr int GlobalLightIdMaskAction_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL GlobalLightIdMaskAction_descriptor();
template <typename T>
const ::std::string& GlobalLightIdMaskAction_Name(T value) {
  static_assert(::std::is_same<T, GlobalLightIdMaskAction>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to GlobalLightIdMaskAction_Name().");
  return GlobalLightIdMaskAction_Name(static_cast<GlobalLightIdMaskAction>(value));
}
template <>
inline const ::std::string& GlobalLightIdMaskAction_Name(GlobalLightIdMaskAction value) {
  return ::google::protobuf::internal::NameOfDenseEnum<GlobalLightIdMaskAction_descriptor, 0, 1>(
      static_cast<int>(value));
}
inline bool GlobalLightIdMaskAction_Parse(
    ::absl::string_view name, GlobalLightIdMaskAction* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<GlobalLightIdMaskAction>(GlobalLightIdMaskAction_descriptor(), name,
                                           value);
}
enum GlobalTexAvo : int {
  GLOBAL_TEX_AOV_1 = 0,
  GLOBAL_TEX_AOV_2 = 1,
  GLOBAL_TEX_AOV_3 = 2,
  GLOBAL_TEX_AOV_4 = 3,
  GLOBAL_TEX_AOV_5 = 4,
  GLOBAL_TEX_AOV_6 = 5,
  GLOBAL_TEX_AOV_7 = 6,
  GLOBAL_TEX_AOV_8 = 7,
  GLOBAL_TEX_AOV_9 = 8,
  GLOBAL_TEX_AOV_10 = 9,
  GLOBAL_TEX_AOV_11 = 10,
  GLOBAL_TEX_AOV_12 = 11,
  GLOBAL_TEX_AOV_13 = 12,
  GLOBAL_TEX_AOV_14 = 13,
  GLOBAL_TEX_AOV_15 = 14,
  GLOBAL_TEX_AOV_16 = 15,
  GLOBAL_TEX_AOV_17 = 16,
  GLOBAL_TEX_AOV_18 = 17,
  GLOBAL_TEX_AOV_19 = 18,
  GLOBAL_TEX_AOV_20 = 19,
  GLOBAL_TEX_AOV_COUNT = 20,
  GlobalTexAvo_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  GlobalTexAvo_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t GlobalTexAvo_internal_data_[];
inline constexpr GlobalTexAvo GlobalTexAvo_MIN =
    static_cast<GlobalTexAvo>(0);
inline constexpr GlobalTexAvo GlobalTexAvo_MAX =
    static_cast<GlobalTexAvo>(20);
inline bool GlobalTexAvo_IsValid(int value) {
  return 0 <= value && value <= 20;
}
inline constexpr int GlobalTexAvo_ARRAYSIZE = 20 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL GlobalTexAvo_descriptor();
template <typename T>
const ::std::string& GlobalTexAvo_Name(T value) {
  static_assert(::std::is_same<T, GlobalTexAvo>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to GlobalTexAvo_Name().");
  return GlobalTexAvo_Name(static_cast<GlobalTexAvo>(value));
}
template <>
inline const ::std::string& GlobalTexAvo_Name(GlobalTexAvo value) {
  return ::google::protobuf::internal::NameOfDenseEnum<GlobalTexAvo_descriptor, 0, 20>(
      static_cast<int>(value));
}
inline bool GlobalTexAvo_Parse(
    ::absl::string_view name, GlobalTexAvo* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<GlobalTexAvo>(GlobalTexAvo_descriptor(), name,
                                           value);
}
enum GradientGeneratorType : int {
  GRADIENT_GENERATOR_TYPE_LINEAR = 0,
  GRADIENT_GENERATOR_TYPE_RADIAL = 1,
  GRADIENT_GENERATOR_TYPE_ANGULAR = 2,
  GRADIENT_GENERATOR_TYPE_POLYGONAL = 3,
  GRADIENT_GENERATOR_TYPE_SPIRAL = 4,
  GradientGeneratorType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  GradientGeneratorType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t GradientGeneratorType_internal_data_[];
inline constexpr GradientGeneratorType GradientGeneratorType_MIN =
    static_cast<GradientGeneratorType>(0);
inline constexpr GradientGeneratorType GradientGeneratorType_MAX =
    static_cast<GradientGeneratorType>(4);
inline bool GradientGeneratorType_IsValid(int value) {
  return 0 <= value && value <= 4;
}
inline constexpr int GradientGeneratorType_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL GradientGeneratorType_descriptor();
template <typename T>
const ::std::string& GradientGeneratorType_Name(T value) {
  static_assert(::std::is_same<T, GradientGeneratorType>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to GradientGeneratorType_Name().");
  return GradientGeneratorType_Name(static_cast<GradientGeneratorType>(value));
}
template <>
inline const ::std::string& GradientGeneratorType_Name(GradientGeneratorType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<GradientGeneratorType_descriptor, 0, 4>(
      static_cast<int>(value));
}
inline bool GradientGeneratorType_Parse(
    ::absl::string_view name, GradientGeneratorType* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<GradientGeneratorType>(GradientGeneratorType_descriptor(), name,
                                           value);
}
enum GradientInterpColorSpace : int {
  GRADIENT_INTERP_COLOR_SPACE_LINEAR = 0,
  GRADIENT_INTERP_COLOR_SPACE_OKLAB = 1,
  GradientInterpColorSpace_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  GradientInterpColorSpace_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t GradientInterpColorSpace_internal_data_[];
inline constexpr GradientInterpColorSpace GradientInterpColorSpace_MIN =
    static_cast<GradientInterpColorSpace>(0);
inline constexpr GradientInterpColorSpace GradientInterpColorSpace_MAX =
    static_cast<GradientInterpColorSpace>(1);
inline bool GradientInterpColorSpace_IsValid(int value) {
  return 0 <= value && value <= 1;
}
inline constexpr int GradientInterpColorSpace_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL GradientInterpColorSpace_descriptor();
template <typename T>
const ::std::string& GradientInterpColorSpace_Name(T value) {
  static_assert(::std::is_same<T, GradientInterpColorSpace>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to GradientInterpColorSpace_Name().");
  return GradientInterpColorSpace_Name(static_cast<GradientInterpColorSpace>(value));
}
template <>
inline const ::std::string& GradientInterpColorSpace_Name(GradientInterpColorSpace value) {
  return ::google::protobuf::internal::NameOfDenseEnum<GradientInterpColorSpace_descriptor, 0, 1>(
      static_cast<int>(value));
}
inline bool GradientInterpColorSpace_Parse(
    ::absl::string_view name, GradientInterpColorSpace* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<GradientInterpColorSpace>(GradientInterpColorSpace_descriptor(), name,
                                           value);
}
enum GradientInterpType : int {
  GRADIENT_INTERP_NONE = 0,
  GRADIENT_INTERP_CONSTANT = 1,
  GRADIENT_INTERP_LINEAR = 2,
  GRADIENT_INTERP_CUBIC = 3,
  GRADIENT_INTERP_CARDINAL = 4,
  GradientInterpType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  GradientInterpType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t GradientInterpType_internal_data_[];
inline constexpr GradientInterpType GradientInterpType_MIN =
    static_cast<GradientInterpType>(0);
inline constexpr GradientInterpType GradientInterpType_MAX =
    static_cast<GradientInterpType>(4);
inline bool GradientInterpType_IsValid(int value) {
  return 0 <= value && value <= 4;
}
inline constexpr int GradientInterpType_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL GradientInterpType_descriptor();
template <typename T>
const ::std::string& GradientInterpType_Name(T value) {
  static_assert(::std::is_same<T, GradientInterpType>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to GradientInterpType_Name().");
  return GradientInterpType_Name(static_cast<GradientInterpType>(value));
}
template <>
inline const ::std::string& GradientInterpType_Name(GradientInterpType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<GradientInterpType_descriptor, 0, 4>(
      static_cast<int>(value));
}
inline bool GradientInterpType_Parse(
    ::absl::string_view name, GradientInterpType* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<GradientInterpType>(GradientInterpType_descriptor(), name,
                                           value);
}
enum HairInterpolationType : int {
  HAIR_INTERP_LENGTH = 0,
  HAIR_INTERP_DEFAULT = 0,
  HAIR_INTERP_SEGMENTS = 1,
  HairInterpolationType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  HairInterpolationType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t HairInterpolationType_internal_data_[];
inline constexpr HairInterpolationType HairInterpolationType_MIN =
    static_cast<HairInterpolationType>(0);
inline constexpr HairInterpolationType HairInterpolationType_MAX =
    static_cast<HairInterpolationType>(1);
inline bool HairInterpolationType_IsValid(int value) {
  return 0 <= value && value <= 1;
}
inline constexpr int HairInterpolationType_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL HairInterpolationType_descriptor();
template <typename T>
const ::std::string& HairInterpolationType_Name(T value) {
  static_assert(::std::is_same<T, HairInterpolationType>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to HairInterpolationType_Name().");
  return HairInterpolationType_Name(static_cast<HairInterpolationType>(value));
}
template <>
inline const ::std::string& HairInterpolationType_Name(HairInterpolationType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<HairInterpolationType_descriptor, 0, 1>(
      static_cast<int>(value));
}
inline bool HairInterpolationType_Parse(
    ::absl::string_view name, HairInterpolationType* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<HairInterpolationType>(HairInterpolationType_descriptor(), name,
                                           value);
}
enum HairMaterialBaseColorMode : int {
  HAIR_MATERIAL_BASE_COLOR_ALBEDO = 0,
  HAIR_MATERIAL_BASE_COLOR = 0,
  HAIR_MATERIAL_BASE_COLOR_MELANIN_PLUS_PHEOMELANIN = 1,
  HairMaterialBaseColorMode_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  HairMaterialBaseColorMode_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t HairMaterialBaseColorMode_internal_data_[];
inline constexpr HairMaterialBaseColorMode HairMaterialBaseColorMode_MIN =
    static_cast<HairMaterialBaseColorMode>(0);
inline constexpr HairMaterialBaseColorMode HairMaterialBaseColorMode_MAX =
    static_cast<HairMaterialBaseColorMode>(1);
inline bool HairMaterialBaseColorMode_IsValid(int value) {
  return 0 <= value && value <= 1;
}
inline constexpr int HairMaterialBaseColorMode_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL HairMaterialBaseColorMode_descriptor();
template <typename T>
const ::std::string& HairMaterialBaseColorMode_Name(T value) {
  static_assert(::std::is_same<T, HairMaterialBaseColorMode>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to HairMaterialBaseColorMode_Name().");
  return HairMaterialBaseColorMode_Name(static_cast<HairMaterialBaseColorMode>(value));
}
template <>
inline const ::std::string& HairMaterialBaseColorMode_Name(HairMaterialBaseColorMode value) {
  return ::google::protobuf::internal::NameOfDenseEnum<HairMaterialBaseColorMode_descriptor, 0, 1>(
      static_cast<int>(value));
}
inline bool HairMaterialBaseColorMode_Parse(
    ::absl::string_view name, HairMaterialBaseColorMode* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<HairMaterialBaseColorMode>(HairMaterialBaseColorMode_descriptor(), name,
                                           value);
}
enum IesPhotometryMode : int {
  IesPhotometryMode_UNSPECIFIED = 0,
  IES_MAX_1 = 1,
  IES_COMPENSATE_LUMINANCE = 2,
  IES_CANDELA_ABSOLUTE = 3,
  IesPhotometryMode_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  IesPhotometryMode_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t IesPhotometryMode_internal_data_[];
inline constexpr IesPhotometryMode IesPhotometryMode_MIN =
    static_cast<IesPhotometryMode>(0);
inline constexpr IesPhotometryMode IesPhotometryMode_MAX =
    static_cast<IesPhotometryMode>(3);
inline bool IesPhotometryMode_IsValid(int value) {
  return 0 <= value && value <= 3;
}
inline constexpr int IesPhotometryMode_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL IesPhotometryMode_descriptor();
template <typename T>
const ::std::string& IesPhotometryMode_Name(T value) {
  static_assert(::std::is_same<T, IesPhotometryMode>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to IesPhotometryMode_Name().");
  return IesPhotometryMode_Name(static_cast<IesPhotometryMode>(value));
}
template <>
inline const ::std::string& IesPhotometryMode_Name(IesPhotometryMode value) {
  return ::google::protobuf::internal::NameOfDenseEnum<IesPhotometryMode_descriptor, 0, 3>(
      static_cast<int>(value));
}
inline bool IesPhotometryMode_Parse(
    ::absl::string_view name, IesPhotometryMode* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<IesPhotometryMode>(IesPhotometryMode_descriptor(), name,
                                           value);
}
enum ImageChannelType : int {
  IMAGE_CHANNEL_UINT8 = 0,
  IMAGE_CHANNEL_AUTO = -1,
  IMAGE_CHANNEL_FLOAT = 1,
  IMAGE_CHANNEL_HALF = 2,
  IMAGE_CHANNEL_BC1_UNORM = 3,
  IMAGE_CHANNEL_BC3_UNORM = 4,
  IMAGE_CHANNEL_BC4_SNORM = 5,
  IMAGE_CHANNEL_BC4_UNORM = 6,
  IMAGE_CHANNEL_BC6_SF = 7,
  IMAGE_CHANNEL_BC6_UF = 8,
  IMAGE_CHANNEL_BC7_UNORM = 9,
  ImageChannelType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  ImageChannelType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t ImageChannelType_internal_data_[];
inline constexpr ImageChannelType ImageChannelType_MIN =
    static_cast<ImageChannelType>(-1);
inline constexpr ImageChannelType ImageChannelType_MAX =
    static_cast<ImageChannelType>(9);
inline bool ImageChannelType_IsValid(int value) {
  return -1 <= value && value <= 9;
}
inline constexpr int ImageChannelType_ARRAYSIZE = 9 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL ImageChannelType_descriptor();
template <typename T>
const ::std::string& ImageChannelType_Name(T value) {
  static_assert(::std::is_same<T, ImageChannelType>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to ImageChannelType_Name().");
  return ImageChannelType_Name(static_cast<ImageChannelType>(value));
}
template <>
inline const ::std::string& ImageChannelType_Name(ImageChannelType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ImageChannelType_descriptor, -1, 9>(
      static_cast<int>(value));
}
inline bool ImageChannelType_Parse(
    ::absl::string_view name, ImageChannelType* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<ImageChannelType>(ImageChannelType_descriptor(), name,
                                           value);
}
enum ImageColorType : int {
  IMAGE_COLOR_KEEP_SOURCE = 0,
  IMAGE_COLOR_RGBA = 1,
  IMAGE_COLOR_GREYSCALE = 2,
  IMAGE_COLOR_ALPHA = 3,
  ImageColorType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  ImageColorType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t ImageColorType_internal_data_[];
inline constexpr ImageColorType ImageColorType_MIN =
    static_cast<ImageColorType>(0);
inline constexpr ImageColorType ImageColorType_MAX =
    static_cast<ImageColorType>(3);
inline bool ImageColorType_IsValid(int value) {
  return 0 <= value && value <= 3;
}
inline constexpr int ImageColorType_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL ImageColorType_descriptor();
template <typename T>
const ::std::string& ImageColorType_Name(T value) {
  static_assert(::std::is_same<T, ImageColorType>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to ImageColorType_Name().");
  return ImageColorType_Name(static_cast<ImageColorType>(value));
}
template <>
inline const ::std::string& ImageColorType_Name(ImageColorType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ImageColorType_descriptor, 0, 3>(
      static_cast<int>(value));
}
inline bool ImageColorType_Parse(
    ::absl::string_view name, ImageColorType* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<ImageColorType>(ImageColorType_descriptor(), name,
                                           value);
}
enum ImageFilterType : int {
  IMAGE_FILTER_NEAREST_NEIGHBOR = 0,
  IMAGE_FILTER_BILINEAR = 1,
  ImageFilterType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  ImageFilterType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t ImageFilterType_internal_data_[];
inline constexpr ImageFilterType ImageFilterType_MIN =
    static_cast<ImageFilterType>(0);
inline constexpr ImageFilterType ImageFilterType_MAX =
    static_cast<ImageFilterType>(1);
inline bool ImageFilterType_IsValid(int value) {
  return 0 <= value && value <= 1;
}
inline constexpr int ImageFilterType_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL ImageFilterType_descriptor();
template <typename T>
const ::std::string& ImageFilterType_Name(T value) {
  static_assert(::std::is_same<T, ImageFilterType>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to ImageFilterType_Name().");
  return ImageFilterType_Name(static_cast<ImageFilterType>(value));
}
template <>
inline const ::std::string& ImageFilterType_Name(ImageFilterType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ImageFilterType_descriptor, 0, 1>(
      static_cast<int>(value));
}
inline bool ImageFilterType_Parse(
    ::absl::string_view name, ImageFilterType* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<ImageFilterType>(ImageFilterType_descriptor(), name,
                                           value);
}
enum ImageMaskSource : int {
  IMAGE_MASK_SOURCE_R = 0,
  IMAGE_MASK_SOURCE_G = 1,
  IMAGE_MASK_SOURCE_B = 2,
  IMAGE_MASK_SOURCE_A = 3,
  IMAGE_MASK_SOURCE_INVERSE_BIT = 4,
  IMAGE_MASK_SOURCE_INVERSE_R = 4,
  IMAGE_MASK_SOURCE_INVERSE_G = 5,
  IMAGE_MASK_SOURCE_INVERSE_B = 6,
  IMAGE_MASK_SOURCE_INVERSE_A = 7,
  IMAGE_MASK_SOURCE_LUMINANCE = 8,
  IMAGE_MASK_SOURCE_INVERSE_LUMINANCE = 12,
  IMAGE_MASK_SOURCE_NO_MASK = 256,
  ImageMaskSource_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  ImageMaskSource_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t ImageMaskSource_internal_data_[];
inline constexpr ImageMaskSource ImageMaskSource_MIN =
    static_cast<ImageMaskSource>(0);
inline constexpr ImageMaskSource ImageMaskSource_MAX =
    static_cast<ImageMaskSource>(256);
inline bool ImageMaskSource_IsValid(int value) {
  return ::google::protobuf::internal::ValidateEnum(value, ImageMaskSource_internal_data_);
}
inline constexpr int ImageMaskSource_ARRAYSIZE = 256 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL ImageMaskSource_descriptor();
template <typename T>
const ::std::string& ImageMaskSource_Name(T value) {
  static_assert(::std::is_same<T, ImageMaskSource>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to ImageMaskSource_Name().");
  return ::google::protobuf::internal::NameOfEnum(ImageMaskSource_descriptor(), value);
}
inline bool ImageMaskSource_Parse(
    ::absl::string_view name, ImageMaskSource* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<ImageMaskSource>(ImageMaskSource_descriptor(), name,
                                           value);
}
enum ImageSaveFormat : int {
  IMAGE_SAVE_FORMAT_PNG_8 = 0,
  IMAGE_SAVE_FORMAT_PNG_16 = 1,
  IMAGE_SAVE_FORMAT_EXR_16 = 2,
  IMAGE_SAVE_FORMAT_EXR_32 = 3,
  IMAGE_SAVE_FORMAT_TIFF_8 = 4,
  IMAGE_SAVE_FORMAT_TIFF_16 = 5,
  IMAGE_SAVE_FORMAT_JPEG = 6,
  ImageSaveFormat_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  ImageSaveFormat_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t ImageSaveFormat_internal_data_[];
inline constexpr ImageSaveFormat ImageSaveFormat_MIN =
    static_cast<ImageSaveFormat>(0);
inline constexpr ImageSaveFormat ImageSaveFormat_MAX =
    static_cast<ImageSaveFormat>(6);
inline bool ImageSaveFormat_IsValid(int value) {
  return 0 <= value && value <= 6;
}
inline constexpr int ImageSaveFormat_ARRAYSIZE = 6 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL ImageSaveFormat_descriptor();
template <typename T>
const ::std::string& ImageSaveFormat_Name(T value) {
  static_assert(::std::is_same<T, ImageSaveFormat>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to ImageSaveFormat_Name().");
  return ImageSaveFormat_Name(static_cast<ImageSaveFormat>(value));
}
template <>
inline const ::std::string& ImageSaveFormat_Name(ImageSaveFormat value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ImageSaveFormat_descriptor, 0, 6>(
      static_cast<int>(value));
}
inline bool ImageSaveFormat_Parse(
    ::absl::string_view name, ImageSaveFormat* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<ImageSaveFormat>(ImageSaveFormat_descriptor(), name,
                                           value);
}
enum ImageType : int {
  IMAGE_TYPE_LDR_RGBA = 0,
  IMAGE_TYPE_LDR_MONO = 1,
  IMAGE_TYPE_HDR_RGBA = 2,
  IMAGE_TYPE_HDR_MONO = 3,
  IMAGE_TYPE_LDR_MONO_ALPHA = 4,
  IMAGE_TYPE_HDR_MONO_ALPHA = 5,
  IMAGE_TYPE_HALF_RGBA = 6,
  IMAGE_TYPE_HALF_MONO = 7,
  IMAGE_TYPE_HALF_MONO_ALPHA = 8,
  IMAGE_TYPE_BC1_UNORM = 9,
  IMAGE_TYPE_BC3_UNORM = 10,
  IMAGE_TYPE_BC4_SNORM = 11,
  IMAGE_TYPE_BC4_UNORM = 12,
  IMAGE_TYPE_BC6_SHF = 13,
  IMAGE_TYPE_BC6_UHF = 14,
  IMAGE_TYPE_BC7_UNORM = 15,
  ImageType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  ImageType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t ImageType_internal_data_[];
inline constexpr ImageType ImageType_MIN =
    static_cast<ImageType>(0);
inline constexpr ImageType ImageType_MAX =
    static_cast<ImageType>(15);
inline bool ImageType_IsValid(int value) {
  return 0 <= value && value <= 15;
}
inline constexpr int ImageType_ARRAYSIZE = 15 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL ImageType_descriptor();
template <typename T>
const ::std::string& ImageType_Name(T value) {
  static_assert(::std::is_same<T, ImageType>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to ImageType_Name().");
  return ImageType_Name(static_cast<ImageType>(value));
}
template <>
inline const ::std::string& ImageType_Name(ImageType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ImageType_descriptor, 0, 15>(
      static_cast<int>(value));
}
inline bool ImageType_Parse(
    ::absl::string_view name, ImageType* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<ImageType>(ImageType_descriptor(), name,
                                           value);
}
enum ImportRestAttributesMode : int {
  ImportRestAttributesMode_UNSPECIFIED = 0,
  IMPORT_REST_ATTRIBUTES_MODE_DISABLED = 1,
  IMPORT_REST_ATTRIBUTES_MODE_FROM_FILE = 2,
  IMPORT_REST_ATTRIBUTES_MODE_FROM_ANIMATION_TIME = 3,
  IMPORT_REST_ATTRIBUTES_MODE_FROM_BIND_POSE = 4,
  ImportRestAttributesMode_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  ImportRestAttributesMode_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t ImportRestAttributesMode_internal_data_[];
inline constexpr ImportRestAttributesMode ImportRestAttributesMode_MIN =
    static_cast<ImportRestAttributesMode>(0);
inline constexpr ImportRestAttributesMode ImportRestAttributesMode_MAX =
    static_cast<ImportRestAttributesMode>(4);
inline bool ImportRestAttributesMode_IsValid(int value) {
  return 0 <= value && value <= 4;
}
inline constexpr int ImportRestAttributesMode_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL ImportRestAttributesMode_descriptor();
template <typename T>
const ::std::string& ImportRestAttributesMode_Name(T value) {
  static_assert(::std::is_same<T, ImportRestAttributesMode>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to ImportRestAttributesMode_Name().");
  return ImportRestAttributesMode_Name(static_cast<ImportRestAttributesMode>(value));
}
template <>
inline const ::std::string& ImportRestAttributesMode_Name(ImportRestAttributesMode value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ImportRestAttributesMode_descriptor, 0, 4>(
      static_cast<int>(value));
}
inline bool ImportRestAttributesMode_Parse(
    ::absl::string_view name, ImportRestAttributesMode* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<ImportRestAttributesMode>(ImportRestAttributesMode_descriptor(), name,
                                           value);
}
enum InfoChannelType : int {
  IC_TYPE_GEOMETRIC_NORMAL = 0,
  IC_TYPE_SHADING_NORMAL = 1,
  IC_TYPE_POSITION = 2,
  IC_TYPE_Z_DEPTH = 3,
  IC_TYPE_MATERIAL_ID = 4,
  IC_TYPE_UV_COORD = 5,
  IC_TYPE_TANGENT_U = 6,
  IC_TYPE_WIREFRAME = 7,
  IC_TYPE_SMOOTH_NORMAL = 8,
  IC_TYPE_VERTEX_NORMAL = 8,
  IC_TYPE_OBJECT_ID = 9,
  IC_TYPE_AMBIENT_OCCLUSION = 10,
  IC_TYPE_MOTION_VECTOR = 11,
  IC_TYPE_RENDER_LAYER_ID = 12,
  IC_TYPE_RENDER_LAYER_MASK = 13,
  IC_TYPE_LIGHT_PASS_ID = 14,
  IC_TYPE_TANGENT_NORMAL = 15,
  IC_TYPE_OPACITY = 16,
  IC_TYPE_BAKING_GROUP_ID = 17,
  IC_TYPE_ROUGHNESS = 18,
  IC_TYPE_IOR = 19,
  IC_TYPE_DIFFUSE_FILTER = 20,
  IC_TYPE_REFLECTION_FILTER = 21,
  IC_TYPE_REFRACTION_FILTER = 22,
  IC_TYPE_TRANSMISSION_FILTER = 23,
  IC_TYPE_OBJECT_LAYER_COLOR = 24,
  IC_TYPE_GAUSSIAN_SPLAT = 25,
  IC_TYPE_TRACE_CLOCK = 26,
  IC_TYPE_PRIMITIVE_TYPE = 27,
  InfoChannelType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  InfoChannelType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t InfoChannelType_internal_data_[];
inline constexpr InfoChannelType InfoChannelType_MIN =
    static_cast<InfoChannelType>(0);
inline constexpr InfoChannelType InfoChannelType_MAX =
    static_cast<InfoChannelType>(27);
inline bool InfoChannelType_IsValid(int value) {
  return 0 <= value && value <= 27;
}
inline constexpr int InfoChannelType_ARRAYSIZE = 27 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL InfoChannelType_descriptor();
template <typename T>
const ::std::string& InfoChannelType_Name(T value) {
  static_assert(::std::is_same<T, InfoChannelType>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to InfoChannelType_Name().");
  return InfoChannelType_Name(static_cast<InfoChannelType>(value));
}
template <>
inline const ::std::string& InfoChannelType_Name(InfoChannelType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<InfoChannelType_descriptor, 0, 27>(
      static_cast<int>(value));
}
inline bool InfoChannelType_Parse(
    ::absl::string_view name, InfoChannelType* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<InfoChannelType>(InfoChannelType_descriptor(), name,
                                           value);
}
enum InfoChannelSamplingMode : int {
  IC_SAMPLING_MODE_DISTRIBUTED = 0,
  IC_SAMPLING_MODE_PIXEL_FILTERING_ENABLED = 1,
  IC_SAMPLING_MODE_PIXEL_FILTERING_DISABLED = 2,
  InfoChannelSamplingMode_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  InfoChannelSamplingMode_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t InfoChannelSamplingMode_internal_data_[];
inline constexpr InfoChannelSamplingMode InfoChannelSamplingMode_MIN =
    static_cast<InfoChannelSamplingMode>(0);
inline constexpr InfoChannelSamplingMode InfoChannelSamplingMode_MAX =
    static_cast<InfoChannelSamplingMode>(2);
inline bool InfoChannelSamplingMode_IsValid(int value) {
  return 0 <= value && value <= 2;
}
inline constexpr int InfoChannelSamplingMode_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL InfoChannelSamplingMode_descriptor();
template <typename T>
const ::std::string& InfoChannelSamplingMode_Name(T value) {
  static_assert(::std::is_same<T, InfoChannelSamplingMode>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to InfoChannelSamplingMode_Name().");
  return InfoChannelSamplingMode_Name(static_cast<InfoChannelSamplingMode>(value));
}
template <>
inline const ::std::string& InfoChannelSamplingMode_Name(InfoChannelSamplingMode value) {
  return ::google::protobuf::internal::NameOfDenseEnum<InfoChannelSamplingMode_descriptor, 0, 2>(
      static_cast<int>(value));
}
inline bool InfoChannelSamplingMode_Parse(
    ::absl::string_view name, InfoChannelSamplingMode* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<InfoChannelSamplingMode>(InfoChannelSamplingMode_descriptor(), name,
                                           value);
}
enum InputAction : int {
  INPUT_ACTION_NONE = 0,
  INPUT_ACTION_INSERT = 1,
  INPUT_ACTION_DELETE = 2,
  INPUT_ACTION_MOVE_UP = 3,
  INPUT_ACTION_MOVE_DOWN = 4,
  InputAction_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  InputAction_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t InputAction_internal_data_[];
inline constexpr InputAction InputAction_MIN =
    static_cast<InputAction>(0);
inline constexpr InputAction InputAction_MAX =
    static_cast<InputAction>(4);
inline bool InputAction_IsValid(int value) {
  return 0 <= value && value <= 4;
}
inline constexpr int InputAction_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL InputAction_descriptor();
template <typename T>
const ::std::string& InputAction_Name(T value) {
  static_assert(::std::is_same<T, InputAction>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to InputAction_Name().");
  return InputAction_Name(static_cast<InputAction>(value));
}
template <>
inline const ::std::string& InputAction_Name(InputAction value) {
  return ::google::protobuf::internal::NameOfDenseEnum<InputAction_descriptor, 0, 4>(
      static_cast<int>(value));
}
inline bool InputAction_Parse(
    ::absl::string_view name, InputAction* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<InputAction>(InputAction_descriptor(), name,
                                           value);
}
enum InterpolationType : int {
  INTERPOLATION_TYPE_LINEAR = 0,
  INTERPOLATION_TYPE_LINEAR_STEP = 1,
  INTERPOLATION_TYPE_SMOOTH_STEP = 2,
  INTERPOLATION_TYPE_SMOOTHER_STEP = 3,
  INTERPOLATION_TYPE_POSTERIZE = 4,
  InterpolationType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  InterpolationType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t InterpolationType_internal_data_[];
inline constexpr InterpolationType InterpolationType_MIN =
    static_cast<InterpolationType>(0);
inline constexpr InterpolationType InterpolationType_MAX =
    static_cast<InterpolationType>(4);
inline bool InterpolationType_IsValid(int value) {
  return 0 <= value && value <= 4;
}
inline constexpr int InterpolationType_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL InterpolationType_descriptor();
template <typename T>
const ::std::string& InterpolationType_Name(T value) {
  static_assert(::std::is_same<T, InterpolationType>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to InterpolationType_Name().");
  return InterpolationType_Name(static_cast<InterpolationType>(value));
}
template <>
inline const ::std::string& InterpolationType_Name(InterpolationType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<InterpolationType_descriptor, 0, 4>(
      static_cast<int>(value));
}
inline bool InterpolationType_Parse(
    ::absl::string_view name, InterpolationType* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<InterpolationType>(InterpolationType_descriptor(), name,
                                           value);
}
enum ItemDbOrigin : int {
  ORIGIN_LIVEDB = 0,
  ORIGIN_LOCALDB = 1,
  ItemDbOrigin_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  ItemDbOrigin_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t ItemDbOrigin_internal_data_[];
inline constexpr ItemDbOrigin ItemDbOrigin_MIN =
    static_cast<ItemDbOrigin>(0);
inline constexpr ItemDbOrigin ItemDbOrigin_MAX =
    static_cast<ItemDbOrigin>(1);
inline bool ItemDbOrigin_IsValid(int value) {
  return 0 <= value && value <= 1;
}
inline constexpr int ItemDbOrigin_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL ItemDbOrigin_descriptor();
template <typename T>
const ::std::string& ItemDbOrigin_Name(T value) {
  static_assert(::std::is_same<T, ItemDbOrigin>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to ItemDbOrigin_Name().");
  return ItemDbOrigin_Name(static_cast<ItemDbOrigin>(value));
}
template <>
inline const ::std::string& ItemDbOrigin_Name(ItemDbOrigin value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ItemDbOrigin_descriptor, 0, 1>(
      static_cast<int>(value));
}
inline bool ItemDbOrigin_Parse(
    ::absl::string_view name, ItemDbOrigin* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<ItemDbOrigin>(ItemDbOrigin_descriptor(), name,
                                           value);
}
enum LightAov : int {
  LIGHT_AOV_SUN = 0,
  LIGHT_AOV_AMBIENT = 1,
  LIGHT_AOV_1 = 2,
  LIGHT_AOV_2 = 3,
  LIGHT_AOV_3 = 4,
  LIGHT_AOV_4 = 5,
  LIGHT_AOV_5 = 6,
  LIGHT_AOV_6 = 7,
  LIGHT_AOV_7 = 8,
  LIGHT_AOV_8 = 9,
  LIGHT_AOV_9 = 10,
  LIGHT_AOV_10 = 11,
  LIGHT_AOV_11 = 12,
  LIGHT_AOV_12 = 13,
  LIGHT_AOV_13 = 14,
  LIGHT_AOV_14 = 15,
  LIGHT_AOV_15 = 16,
  LIGHT_AOV_16 = 17,
  LIGHT_AOV_17 = 18,
  LIGHT_AOV_18 = 19,
  LIGHT_AOV_19 = 20,
  LIGHT_AOV_20 = 21,
  LightAov_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  LightAov_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t LightAov_internal_data_[];
inline constexpr LightAov LightAov_MIN =
    static_cast<LightAov>(0);
inline constexpr LightAov LightAov_MAX =
    static_cast<LightAov>(21);
inline bool LightAov_IsValid(int value) {
  return 0 <= value && value <= 21;
}
inline constexpr int LightAov_ARRAYSIZE = 21 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL LightAov_descriptor();
template <typename T>
const ::std::string& LightAov_Name(T value) {
  static_assert(::std::is_same<T, LightAov>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to LightAov_Name().");
  return LightAov_Name(static_cast<LightAov>(value));
}
template <>
inline const ::std::string& LightAov_Name(LightAov value) {
  return ::google::protobuf::internal::NameOfDenseEnum<LightAov_descriptor, 0, 21>(
      static_cast<int>(value));
}
inline bool LightAov_Parse(
    ::absl::string_view name, LightAov* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<LightAov>(LightAov_descriptor(), name,
                                           value);
}
enum LightPassMask : int {
  LightPassMask_UNSPECIFIED = 0,
  LIGHT_PASS_MASK_SUN = 1,
  LIGHT_PASS_MASK_ENVIRONMENT = 2,
  LIGHT_PASS_MASK_EMIT_FIRST = 4,
  LIGHT_PASS_MASK_EMIT_LAST = 2097152,
  LIGHT_PASS_MASK_EMIT_ALL = 4194300,
  LIGHT_PASS_MASK_ALL = 4194303,
  LightPassMask_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  LightPassMask_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t LightPassMask_internal_data_[];
inline constexpr LightPassMask LightPassMask_MIN =
    static_cast<LightPassMask>(0);
inline constexpr LightPassMask LightPassMask_MAX =
    static_cast<LightPassMask>(4194303);
inline bool LightPassMask_IsValid(int value) {
  return ::google::protobuf::internal::ValidateEnum(value, LightPassMask_internal_data_);
}
inline constexpr int LightPassMask_ARRAYSIZE = 4194303 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL LightPassMask_descriptor();
template <typename T>
const ::std::string& LightPassMask_Name(T value) {
  static_assert(::std::is_same<T, LightPassMask>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to LightPassMask_Name().");
  return ::google::protobuf::internal::NameOfEnum(LightPassMask_descriptor(), value);
}
inline bool LightPassMask_Parse(
    ::absl::string_view name, LightPassMask* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<LightPassMask>(LightPassMask_descriptor(), name,
                                           value);
}
enum LightSampler : int {
  LIGHT_SAMPLER_POWER = 0,
  LIGHT_SAMPLER_AILIGHT = 1,
  LIGHT_SAMPLER_LIGHTBVH = 2,
  LightSampler_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  LightSampler_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t LightSampler_internal_data_[];
inline constexpr LightSampler LightSampler_MIN =
    static_cast<LightSampler>(0);
inline constexpr LightSampler LightSampler_MAX =
    static_cast<LightSampler>(2);
inline bool LightSampler_IsValid(int value) {
  return 0 <= value && value <= 2;
}
inline constexpr int LightSampler_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL LightSampler_descriptor();
template <typename T>
const ::std::string& LightSampler_Name(T value) {
  static_assert(::std::is_same<T, LightSampler>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to LightSampler_Name().");
  return LightSampler_Name(static_cast<LightSampler>(value));
}
template <>
inline const ::std::string& LightSampler_Name(LightSampler value) {
  return ::google::protobuf::internal::NameOfDenseEnum<LightSampler_descriptor, 0, 2>(
      static_cast<int>(value));
}
inline bool LightSampler_Parse(
    ::absl::string_view name, LightSampler* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<LightSampler>(LightSampler_descriptor(), name,
                                           value);
}
enum LiveDbThumbnailView : int {
  DB_VIEW_FULL = 0,
  DB_VIEW_COMBINED = -1,
  DB_VIEW_CORNER = 1,
  DB_VIEW_BOTTOM = 2,
  DB_VIEW_COUNT = 3,
  LiveDbThumbnailView_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  LiveDbThumbnailView_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t LiveDbThumbnailView_internal_data_[];
inline constexpr LiveDbThumbnailView LiveDbThumbnailView_MIN =
    static_cast<LiveDbThumbnailView>(-1);
inline constexpr LiveDbThumbnailView LiveDbThumbnailView_MAX =
    static_cast<LiveDbThumbnailView>(3);
inline bool LiveDbThumbnailView_IsValid(int value) {
  return -1 <= value && value <= 3;
}
inline constexpr int LiveDbThumbnailView_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL LiveDbThumbnailView_descriptor();
template <typename T>
const ::std::string& LiveDbThumbnailView_Name(T value) {
  static_assert(::std::is_same<T, LiveDbThumbnailView>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to LiveDbThumbnailView_Name().");
  return LiveDbThumbnailView_Name(static_cast<LiveDbThumbnailView>(value));
}
template <>
inline const ::std::string& LiveDbThumbnailView_Name(LiveDbThumbnailView value) {
  return ::google::protobuf::internal::NameOfDenseEnum<LiveDbThumbnailView_descriptor, -1, 3>(
      static_cast<int>(value));
}
inline bool LiveDbThumbnailView_Parse(
    ::absl::string_view name, LiveDbThumbnailView* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<LiveDbThumbnailView>(LiveDbThumbnailView_descriptor(), name,
                                           value);
}
enum LogicalOperator : int {
  LOGICAL_OPERATOR_AND = 0,
  LOGICAL_OPERATOR_OR = 1,
  LOGICAL_OPERATOR_XOR = 2,
  LOGICAL_OPERATOR_NOT = 3,
  LogicalOperator_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  LogicalOperator_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t LogicalOperator_internal_data_[];
inline constexpr LogicalOperator LogicalOperator_MIN =
    static_cast<LogicalOperator>(0);
inline constexpr LogicalOperator LogicalOperator_MAX =
    static_cast<LogicalOperator>(3);
inline bool LogicalOperator_IsValid(int value) {
  return 0 <= value && value <= 3;
}
inline constexpr int LogicalOperator_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL LogicalOperator_descriptor();
template <typename T>
const ::std::string& LogicalOperator_Name(T value) {
  static_assert(::std::is_same<T, LogicalOperator>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to LogicalOperator_Name().");
  return LogicalOperator_Name(static_cast<LogicalOperator>(value));
}
template <>
inline const ::std::string& LogicalOperator_Name(LogicalOperator value) {
  return ::google::protobuf::internal::NameOfDenseEnum<LogicalOperator_descriptor, 0, 3>(
      static_cast<int>(value));
}
inline bool LogicalOperator_Parse(
    ::absl::string_view name, LogicalOperator* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<LogicalOperator>(LogicalOperator_descriptor(), name,
                                           value);
}
enum LuaScriptType : int {
  SCRIPT_TYPE_STANDALONE = 0,
  SCRIPT_TYPE_GRAPH = 1,
  LuaScriptType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  LuaScriptType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t LuaScriptType_internal_data_[];
inline constexpr LuaScriptType LuaScriptType_MIN =
    static_cast<LuaScriptType>(0);
inline constexpr LuaScriptType LuaScriptType_MAX =
    static_cast<LuaScriptType>(1);
inline bool LuaScriptType_IsValid(int value) {
  return 0 <= value && value <= 1;
}
inline constexpr int LuaScriptType_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL LuaScriptType_descriptor();
template <typename T>
const ::std::string& LuaScriptType_Name(T value) {
  static_assert(::std::is_same<T, LuaScriptType>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to LuaScriptType_Name().");
  return LuaScriptType_Name(static_cast<LuaScriptType>(value));
}
template <>
inline const ::std::string& LuaScriptType_Name(LuaScriptType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<LuaScriptType_descriptor, 0, 1>(
      static_cast<int>(value));
}
inline bool LuaScriptType_Parse(
    ::absl::string_view name, LuaScriptType* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<LuaScriptType>(LuaScriptType_descriptor(), name,
                                           value);
}
enum MemoryLocation : int {
  MEMORY_LOCATION_DEVICE = 0,
  MEMORY_LOCATION_OUT_OF_CORE = 1,
  MEMORY_LOCATION_PEER_TO_PEER = 2,
  MemoryLocation_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  MemoryLocation_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t MemoryLocation_internal_data_[];
inline constexpr MemoryLocation MemoryLocation_MIN =
    static_cast<MemoryLocation>(0);
inline constexpr MemoryLocation MemoryLocation_MAX =
    static_cast<MemoryLocation>(2);
inline bool MemoryLocation_IsValid(int value) {
  return 0 <= value && value <= 2;
}
inline constexpr int MemoryLocation_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL MemoryLocation_descriptor();
template <typename T>
const ::std::string& MemoryLocation_Name(T value) {
  static_assert(::std::is_same<T, MemoryLocation>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to MemoryLocation_Name().");
  return MemoryLocation_Name(static_cast<MemoryLocation>(value));
}
template <>
inline const ::std::string& MemoryLocation_Name(MemoryLocation value) {
  return ::google::protobuf::internal::NameOfDenseEnum<MemoryLocation_descriptor, 0, 2>(
      static_cast<int>(value));
}
inline bool MemoryLocation_Parse(
    ::absl::string_view name, MemoryLocation* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<MemoryLocation>(MemoryLocation_descriptor(), name,
                                           value);
}
enum MetallicReflectionMode : int {
  METALLIC_ARTISTIC = 0,
  METALLIC_IOR = 1,
  METALLIC_RGB_IOR = 2,
  METALLIC_ARTISTIC_N_K = 3,
  MetallicReflectionMode_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  MetallicReflectionMode_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t MetallicReflectionMode_internal_data_[];
inline constexpr MetallicReflectionMode MetallicReflectionMode_MIN =
    static_cast<MetallicReflectionMode>(0);
inline constexpr MetallicReflectionMode MetallicReflectionMode_MAX =
    static_cast<MetallicReflectionMode>(3);
inline bool MetallicReflectionMode_IsValid(int value) {
  return 0 <= value && value <= 3;
}
inline constexpr int MetallicReflectionMode_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL MetallicReflectionMode_descriptor();
template <typename T>
const ::std::string& MetallicReflectionMode_Name(T value) {
  static_assert(::std::is_same<T, MetallicReflectionMode>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to MetallicReflectionMode_Name().");
  return MetallicReflectionMode_Name(static_cast<MetallicReflectionMode>(value));
}
template <>
inline const ::std::string& MetallicReflectionMode_Name(MetallicReflectionMode value) {
  return ::google::protobuf::internal::NameOfDenseEnum<MetallicReflectionMode_descriptor, 0, 3>(
      static_cast<int>(value));
}
inline bool MetallicReflectionMode_Parse(
    ::absl::string_view name, MetallicReflectionMode* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<MetallicReflectionMode>(MetallicReflectionMode_descriptor(), name,
                                           value);
}
enum ModuleType : int {
  MODULE_TYPE_INVALID = 0,
  MODULE_TYPE_COMMAND = 1,
  MODULE_TYPE_WORK_PANE = 2,
  MODULE_TYPE_NODE_GRAPH = 3,
  ModuleType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  ModuleType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t ModuleType_internal_data_[];
inline constexpr ModuleType ModuleType_MIN =
    static_cast<ModuleType>(0);
inline constexpr ModuleType ModuleType_MAX =
    static_cast<ModuleType>(3);
inline bool ModuleType_IsValid(int value) {
  return 0 <= value && value <= 3;
}
inline constexpr int ModuleType_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL ModuleType_descriptor();
template <typename T>
const ::std::string& ModuleType_Name(T value) {
  static_assert(::std::is_same<T, ModuleType>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to ModuleType_Name().");
  return ModuleType_Name(static_cast<ModuleType>(value));
}
template <>
inline const ::std::string& ModuleType_Name(ModuleType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ModuleType_descriptor, 0, 3>(
      static_cast<int>(value));
}
inline bool ModuleType_Parse(
    ::absl::string_view name, ModuleType* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<ModuleType>(ModuleType_descriptor(), name,
                                           value);
}
enum MoireMosaicShape : int {
  MOIRE_MOSAIC_SHAPE_RECTANGLE = 0,
  MOIRE_MOSAIC_SHAPE_CIRCLE = 1,
  MOIRE_MOSAIC_SHAPE_RING = 2,
  MOIRE_MOSAIC_SHAPE_FRAME = 3,
  MoireMosaicShape_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  MoireMosaicShape_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t MoireMosaicShape_internal_data_[];
inline constexpr MoireMosaicShape MoireMosaicShape_MIN =
    static_cast<MoireMosaicShape>(0);
inline constexpr MoireMosaicShape MoireMosaicShape_MAX =
    static_cast<MoireMosaicShape>(3);
inline bool MoireMosaicShape_IsValid(int value) {
  return 0 <= value && value <= 3;
}
inline constexpr int MoireMosaicShape_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL MoireMosaicShape_descriptor();
template <typename T>
const ::std::string& MoireMosaicShape_Name(T value) {
  static_assert(::std::is_same<T, MoireMosaicShape>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to MoireMosaicShape_Name().");
  return MoireMosaicShape_Name(static_cast<MoireMosaicShape>(value));
}
template <>
inline const ::std::string& MoireMosaicShape_Name(MoireMosaicShape value) {
  return ::google::protobuf::internal::NameOfDenseEnum<MoireMosaicShape_descriptor, 0, 3>(
      static_cast<int>(value));
}
inline bool MoireMosaicShape_Parse(
    ::absl::string_view name, MoireMosaicShape* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<MoireMosaicShape>(MoireMosaicShape_descriptor(), name,
                                           value);
}
enum MovableInputFormat : int {
  MOVABLE_INPUT_FORMAT_NONE = 0,
  MOVABLE_INPUT_FORMAT_OUTPUT_AOV = 1,
  MOVABLE_INPUT_FORMAT_OUTPUT_AOV_LAYER = 2,
  MOVABLE_INPUT_FORMAT_COMPOSITE_TEXTURE_LAYER = 3,
  MOVABLE_INPUT_FORMAT_COMPOSITE_MATERIAL_INPUT = 4,
  MOVABLE_INPUT_FORMAT_GEOMETRY = 5,
  MOVABLE_INPUT_FORMAT_MATERIAL_LAYER = 6,
  MOVABLE_INPUT_FORMAT_RENDER_PASSES = 7,
  MOVABLE_INPUT_FORMAT_VERTEX_DISPLACEMENT_MIXER_INPUT = 8,
  MOVABLE_INPUT_FORMAT_GRADIENT_TEXTURE_CONTROL_POINT = 9,
  MOVABLE_INPUT_FORMAT_VOLUME_RAMP_CONTROL_POINT = 10,
  MOVABLE_INPUT_FORMAT_TOON_RAMP_CONTROL_POINT = 11,
  MOVABLE_INPUT_FORMAT_RENDER_JOB = 12,
  MOVABLE_INPUT_FORMAT_TRACE_SET_VISIBILITY_RULE = 13,
  MovableInputFormat_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  MovableInputFormat_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t MovableInputFormat_internal_data_[];
inline constexpr MovableInputFormat MovableInputFormat_MIN =
    static_cast<MovableInputFormat>(0);
inline constexpr MovableInputFormat MovableInputFormat_MAX =
    static_cast<MovableInputFormat>(13);
inline bool MovableInputFormat_IsValid(int value) {
  return 0 <= value && value <= 13;
}
inline constexpr int MovableInputFormat_ARRAYSIZE = 13 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL MovableInputFormat_descriptor();
template <typename T>
const ::std::string& MovableInputFormat_Name(T value) {
  static_assert(::std::is_same<T, MovableInputFormat>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to MovableInputFormat_Name().");
  return MovableInputFormat_Name(static_cast<MovableInputFormat>(value));
}
template <>
inline const ::std::string& MovableInputFormat_Name(MovableInputFormat value) {
  return ::google::protobuf::internal::NameOfDenseEnum<MovableInputFormat_descriptor, 0, 13>(
      static_cast<int>(value));
}
inline bool MovableInputFormat_Parse(
    ::absl::string_view name, MovableInputFormat* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<MovableInputFormat>(MovableInputFormat_descriptor(), name,
                                           value);
}
enum NamedColorSpace : int {
  NAMED_COLOR_SPACE_OTHER = 0,
  NAMED_COLOR_SPACE_SRGB = 1,
  NAMED_COLOR_SPACE_LINEAR_SRGB = 2,
  NAMED_COLOR_SPACE_ACES2065_1 = 3,
  NAMED_COLOR_SPACE_ACESCG = 4,
  NAMED_COLOR_SPACE_XYZ_E = 5,
  NAMED_COLOR_SPACE_OCIO = 1000,
  NamedColorSpace_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  NamedColorSpace_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t NamedColorSpace_internal_data_[];
inline constexpr NamedColorSpace NamedColorSpace_MIN =
    static_cast<NamedColorSpace>(0);
inline constexpr NamedColorSpace NamedColorSpace_MAX =
    static_cast<NamedColorSpace>(1000);
inline bool NamedColorSpace_IsValid(int value) {
  return ::google::protobuf::internal::ValidateEnum(value, NamedColorSpace_internal_data_);
}
inline constexpr int NamedColorSpace_ARRAYSIZE = 1000 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL NamedColorSpace_descriptor();
template <typename T>
const ::std::string& NamedColorSpace_Name(T value) {
  static_assert(::std::is_same<T, NamedColorSpace>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to NamedColorSpace_Name().");
  return ::google::protobuf::internal::NameOfEnum(NamedColorSpace_descriptor(), value);
}
inline bool NamedColorSpace_Parse(
    ::absl::string_view name, NamedColorSpace* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<NamedColorSpace>(NamedColorSpace_descriptor(), name,
                                           value);
}
enum NoiseType : int {
  NOISE_TYPE_PERLIN = 0,
  NOISE_TYPE_TURBULENCE = 1,
  NOISE_TYPE_CIRCULAR = 2,
  NOISE_TYPE_CHIPS = 3,
  NOISE_TYPE_VORONOI = 4,
  NoiseType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  NoiseType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t NoiseType_internal_data_[];
inline constexpr NoiseType NoiseType_MIN =
    static_cast<NoiseType>(0);
inline constexpr NoiseType NoiseType_MAX =
    static_cast<NoiseType>(4);
inline bool NoiseType_IsValid(int value) {
  return 0 <= value && value <= 4;
}
inline constexpr int NoiseType_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL NoiseType_descriptor();
template <typename T>
const ::std::string& NoiseType_Name(T value) {
  static_assert(::std::is_same<T, NoiseType>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to NoiseType_Name().");
  return NoiseType_Name(static_cast<NoiseType>(value));
}
template <>
inline const ::std::string& NoiseType_Name(NoiseType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<NoiseType_descriptor, 0, 4>(
      static_cast<int>(value));
}
inline bool NoiseType_Parse(
    ::absl::string_view name, NoiseType* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<NoiseType>(NoiseType_descriptor(), name,
                                           value);
}
enum NoiseTypeOsl : int {
  NOISE_TYPE_OSL_PERLIN = 0,
  NOISE_TYPE_OSL_UPERLIN = 1,
  NOISE_TYPE_OSL_CELL = 2,
  NOISE_TYPE_OSL_HASH = 3,
  NoiseTypeOsl_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  NoiseTypeOsl_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t NoiseTypeOsl_internal_data_[];
inline constexpr NoiseTypeOsl NoiseTypeOsl_MIN =
    static_cast<NoiseTypeOsl>(0);
inline constexpr NoiseTypeOsl NoiseTypeOsl_MAX =
    static_cast<NoiseTypeOsl>(3);
inline bool NoiseTypeOsl_IsValid(int value) {
  return 0 <= value && value <= 3;
}
inline constexpr int NoiseTypeOsl_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL NoiseTypeOsl_descriptor();
template <typename T>
const ::std::string& NoiseTypeOsl_Name(T value) {
  static_assert(::std::is_same<T, NoiseTypeOsl>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to NoiseTypeOsl_Name().");
  return NoiseTypeOsl_Name(static_cast<NoiseTypeOsl>(value));
}
template <>
inline const ::std::string& NoiseTypeOsl_Name(NoiseTypeOsl value) {
  return ::google::protobuf::internal::NameOfDenseEnum<NoiseTypeOsl_descriptor, 0, 3>(
      static_cast<int>(value));
}
inline bool NoiseTypeOsl_Parse(
    ::absl::string_view name, NoiseTypeOsl* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<NoiseTypeOsl>(NoiseTypeOsl_descriptor(), name,
                                           value);
}
enum NormalType : int {
  NORMAL_TYPE_GEOMETRIC = 0,
  NORMAL_TYPE_SMOOTH = 1,
  NORMAL_TYPE_SHADING = 2,
  NormalType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  NormalType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t NormalType_internal_data_[];
inline constexpr NormalType NormalType_MIN =
    static_cast<NormalType>(0);
inline constexpr NormalType NormalType_MAX =
    static_cast<NormalType>(2);
inline bool NormalType_IsValid(int value) {
  return 0 <= value && value <= 2;
}
inline constexpr int NormalType_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL NormalType_descriptor();
template <typename T>
const ::std::string& NormalType_Name(T value) {
  static_assert(::std::is_same<T, NormalType>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to NormalType_Name().");
  return NormalType_Name(static_cast<NormalType>(value));
}
template <>
inline const ::std::string& NormalType_Name(NormalType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<NormalType_descriptor, 0, 2>(
      static_cast<int>(value));
}
inline bool NormalType_Parse(
    ::absl::string_view name, NormalType* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<NormalType>(NormalType_descriptor(), name,
                                           value);
}
enum ObjectIncludeMode : int {
  OBJECT_INCLUDE_ALL = 0,
  OBJECT_INCLUDE_SELF = 1,
  OBJECT_INCLUDE_OTHERS = 2,
  ObjectIncludeMode_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  ObjectIncludeMode_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t ObjectIncludeMode_internal_data_[];
inline constexpr ObjectIncludeMode ObjectIncludeMode_MIN =
    static_cast<ObjectIncludeMode>(0);
inline constexpr ObjectIncludeMode ObjectIncludeMode_MAX =
    static_cast<ObjectIncludeMode>(2);
inline bool ObjectIncludeMode_IsValid(int value) {
  return 0 <= value && value <= 2;
}
inline constexpr int ObjectIncludeMode_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL ObjectIncludeMode_descriptor();
template <typename T>
const ::std::string& ObjectIncludeMode_Name(T value) {
  static_assert(::std::is_same<T, ObjectIncludeMode>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to ObjectIncludeMode_Name().");
  return ObjectIncludeMode_Name(static_cast<ObjectIncludeMode>(value));
}
template <>
inline const ::std::string& ObjectIncludeMode_Name(ObjectIncludeMode value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ObjectIncludeMode_descriptor, 0, 2>(
      static_cast<int>(value));
}
inline bool ObjectIncludeMode_Parse(
    ::absl::string_view name, ObjectIncludeMode* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<ObjectIncludeMode>(ObjectIncludeMode_descriptor(), name,
                                           value);
}
enum ObjImportColorSpace : int {
  OBJIMP_RGB_LINEAR_SRGB = 0,
  OBJIMP_RGB_SRGB = 1,
  ObjImportColorSpace_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  ObjImportColorSpace_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t ObjImportColorSpace_internal_data_[];
inline constexpr ObjImportColorSpace ObjImportColorSpace_MIN =
    static_cast<ObjImportColorSpace>(0);
inline constexpr ObjImportColorSpace ObjImportColorSpace_MAX =
    static_cast<ObjImportColorSpace>(1);
inline bool ObjImportColorSpace_IsValid(int value) {
  return 0 <= value && value <= 1;
}
inline constexpr int ObjImportColorSpace_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL ObjImportColorSpace_descriptor();
template <typename T>
const ::std::string& ObjImportColorSpace_Name(T value) {
  static_assert(::std::is_same<T, ObjImportColorSpace>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to ObjImportColorSpace_Name().");
  return ObjImportColorSpace_Name(static_cast<ObjImportColorSpace>(value));
}
template <>
inline const ::std::string& ObjImportColorSpace_Name(ObjImportColorSpace value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ObjImportColorSpace_descriptor, 0, 1>(
      static_cast<int>(value));
}
inline bool ObjImportColorSpace_Parse(
    ::absl::string_view name, ObjImportColorSpace* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<ObjImportColorSpace>(ObjImportColorSpace_descriptor(), name,
                                           value);
}
enum OctaneLiveCategory : int {
  OLCAT_UNDEFINED = 0,
  OLCAT_ROOT = 1,
  OLCAT_MATERIALS = 2,
  OLCAT_TEXTURES = 3,
  OLCAT_EMISSIONS = 4,
  OctaneLiveCategory_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  OctaneLiveCategory_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t OctaneLiveCategory_internal_data_[];
inline constexpr OctaneLiveCategory OctaneLiveCategory_MIN =
    static_cast<OctaneLiveCategory>(0);
inline constexpr OctaneLiveCategory OctaneLiveCategory_MAX =
    static_cast<OctaneLiveCategory>(4);
inline bool OctaneLiveCategory_IsValid(int value) {
  return 0 <= value && value <= 4;
}
inline constexpr int OctaneLiveCategory_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL OctaneLiveCategory_descriptor();
template <typename T>
const ::std::string& OctaneLiveCategory_Name(T value) {
  static_assert(::std::is_same<T, OctaneLiveCategory>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to OctaneLiveCategory_Name().");
  return OctaneLiveCategory_Name(static_cast<OctaneLiveCategory>(value));
}
template <>
inline const ::std::string& OctaneLiveCategory_Name(OctaneLiveCategory value) {
  return ::google::protobuf::internal::NameOfDenseEnum<OctaneLiveCategory_descriptor, 0, 4>(
      static_cast<int>(value));
}
inline bool OctaneLiveCategory_Parse(
    ::absl::string_view name, OctaneLiveCategory* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<OctaneLiveCategory>(OctaneLiveCategory_descriptor(), name,
                                           value);
}
enum TextureValueType : int {
  TEXTURE_VALUE_TYPE_UNKNOWN = 0,
  TEXTURE_VALUE_TYPE_INT = 1,
  TEXTURE_VALUE_TYPE_FLOAT = 2,
  TEXTURE_VALUE_TYPE_VECTOR2 = 4,
  TEXTURE_VALUE_TYPE_VECTOR3 = 8,
  TEXTURE_VALUE_TYPE_VECTOR4 = 16,
  TEXTURE_VALUE_TYPE_COLOR4 = 32,
  TEXTURE_VALUE_TYPE_COLOR3 = 64,
  TEXTURE_VALUE_TYPE_POINT = 128,
  TEXTURE_VALUE_TYPE_NORMAL = 256,
  TEXTURE_VALUE_TYPE_MATRIX = 512,
  TEXTURE_VALUE_TYPE_MATRIX3 = 1024,
  TEXTURE_VALUE_TYPE_STRING = 2048,
  TEXTURE_VALUE_TYPE_BOOL = 4096,
  TextureValueType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  TextureValueType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t TextureValueType_internal_data_[];
inline constexpr TextureValueType TextureValueType_MIN =
    static_cast<TextureValueType>(0);
inline constexpr TextureValueType TextureValueType_MAX =
    static_cast<TextureValueType>(4096);
inline bool TextureValueType_IsValid(int value) {
  return ::google::protobuf::internal::ValidateEnum(value, TextureValueType_internal_data_);
}
inline constexpr int TextureValueType_ARRAYSIZE = 4096 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL TextureValueType_descriptor();
template <typename T>
const ::std::string& TextureValueType_Name(T value) {
  static_assert(::std::is_same<T, TextureValueType>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to TextureValueType_Name().");
  return ::google::protobuf::internal::NameOfEnum(TextureValueType_descriptor(), value);
}
inline bool TextureValueType_Parse(
    ::absl::string_view name, TextureValueType* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<TextureValueType>(TextureValueType_descriptor(), name,
                                           value);
}
enum TextureNodeTypeMode : int {
  TEXTURE_NODE_VALUE_TYPE_MODE_NONE = 0,
  TEXTURE_NODE_VALUE_TYPE_MODE_STATIC = 1,
  TEXTURE_NODE_VALUE_TYPE_MODE_SETTABLE = 2,
  TEXTURE_NODE_VALUE_TYPE_MODE_DERIVED = 3,
  TextureNodeTypeMode_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  TextureNodeTypeMode_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t TextureNodeTypeMode_internal_data_[];
inline constexpr TextureNodeTypeMode TextureNodeTypeMode_MIN =
    static_cast<TextureNodeTypeMode>(0);
inline constexpr TextureNodeTypeMode TextureNodeTypeMode_MAX =
    static_cast<TextureNodeTypeMode>(3);
inline bool TextureNodeTypeMode_IsValid(int value) {
  return 0 <= value && value <= 3;
}
inline constexpr int TextureNodeTypeMode_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL TextureNodeTypeMode_descriptor();
template <typename T>
const ::std::string& TextureNodeTypeMode_Name(T value) {
  static_assert(::std::is_same<T, TextureNodeTypeMode>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to TextureNodeTypeMode_Name().");
  return TextureNodeTypeMode_Name(static_cast<TextureNodeTypeMode>(value));
}
template <>
inline const ::std::string& TextureNodeTypeMode_Name(TextureNodeTypeMode value) {
  return ::google::protobuf::internal::NameOfDenseEnum<TextureNodeTypeMode_descriptor, 0, 3>(
      static_cast<int>(value));
}
inline bool TextureNodeTypeMode_Parse(
    ::absl::string_view name, TextureNodeTypeMode* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<TextureNodeTypeMode>(TextureNodeTypeMode_descriptor(), name,
                                           value);
}
enum TexturePinValueTypeMode : int {
  TEXTURE_PIN_VALUE_TYPE_MODE_NONE = 0,
  TEXTURE_PIN_VALUE_TYPE_MODE_STATIC = 1,
  TEXTURE_PIN_VALUE_TYPE_MODE_SPECIFIC_AND_CAN_BE_TOGGLED = 2,
  TEXTURE_PIN_VALUE_TYPE_MODE_DERIVED_AND_MAY_BE_TOGGLED = 3,
  TexturePinValueTypeMode_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  TexturePinValueTypeMode_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t TexturePinValueTypeMode_internal_data_[];
inline constexpr TexturePinValueTypeMode TexturePinValueTypeMode_MIN =
    static_cast<TexturePinValueTypeMode>(0);
inline constexpr TexturePinValueTypeMode TexturePinValueTypeMode_MAX =
    static_cast<TexturePinValueTypeMode>(3);
inline bool TexturePinValueTypeMode_IsValid(int value) {
  return 0 <= value && value <= 3;
}
inline constexpr int TexturePinValueTypeMode_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL TexturePinValueTypeMode_descriptor();
template <typename T>
const ::std::string& TexturePinValueTypeMode_Name(T value) {
  static_assert(::std::is_same<T, TexturePinValueTypeMode>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to TexturePinValueTypeMode_Name().");
  return TexturePinValueTypeMode_Name(static_cast<TexturePinValueTypeMode>(value));
}
template <>
inline const ::std::string& TexturePinValueTypeMode_Name(TexturePinValueTypeMode value) {
  return ::google::protobuf::internal::NameOfDenseEnum<TexturePinValueTypeMode_descriptor, 0, 3>(
      static_cast<int>(value));
}
inline bool TexturePinValueTypeMode_Parse(
    ::absl::string_view name, TexturePinValueTypeMode* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<TexturePinValueTypeMode>(TexturePinValueTypeMode_descriptor(), name,
                                           value);
}
enum UnblendExtractMode : int {
  UNBLEND_EXTRACT_MODE_FOREGROUND = 0,
  UNBLEND_EXTRACT_MODE_BACKGROUND = 1,
  UnblendExtractMode_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  UnblendExtractMode_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t UnblendExtractMode_internal_data_[];
inline constexpr UnblendExtractMode UnblendExtractMode_MIN =
    static_cast<UnblendExtractMode>(0);
inline constexpr UnblendExtractMode UnblendExtractMode_MAX =
    static_cast<UnblendExtractMode>(1);
inline bool UnblendExtractMode_IsValid(int value) {
  return 0 <= value && value <= 1;
}
inline constexpr int UnblendExtractMode_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL UnblendExtractMode_descriptor();
template <typename T>
const ::std::string& UnblendExtractMode_Name(T value) {
  static_assert(::std::is_same<T, UnblendExtractMode>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to UnblendExtractMode_Name().");
  return UnblendExtractMode_Name(static_cast<UnblendExtractMode>(value));
}
template <>
inline const ::std::string& UnblendExtractMode_Name(UnblendExtractMode value) {
  return ::google::protobuf::internal::NameOfDenseEnum<UnblendExtractMode_descriptor, 0, 1>(
      static_cast<int>(value));
}
inline bool UnblendExtractMode_Parse(
    ::absl::string_view name, UnblendExtractMode* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<UnblendExtractMode>(UnblendExtractMode_descriptor(), name,
                                           value);
}
enum UnblendOutputColorRange : int {
  UNBLEND_OUTPUT_COLOR_RANGE_HDR_UNLIMITED = 0,
  UNBLEND_OUTPUT_COLOR_RANGE_HDR_ACESCG_GAMUT = 1,
  UNBLEND_OUTPUT_COLOR_RANGE_HDR_SRGB_GAMUT = 2,
  UNBLEND_OUTPUT_COLOR_RANGE_SDR_SRGB = 3,
  UnblendOutputColorRange_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  UnblendOutputColorRange_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t UnblendOutputColorRange_internal_data_[];
inline constexpr UnblendOutputColorRange UnblendOutputColorRange_MIN =
    static_cast<UnblendOutputColorRange>(0);
inline constexpr UnblendOutputColorRange UnblendOutputColorRange_MAX =
    static_cast<UnblendOutputColorRange>(3);
inline bool UnblendOutputColorRange_IsValid(int value) {
  return 0 <= value && value <= 3;
}
inline constexpr int UnblendOutputColorRange_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL UnblendOutputColorRange_descriptor();
template <typename T>
const ::std::string& UnblendOutputColorRange_Name(T value) {
  static_assert(::std::is_same<T, UnblendOutputColorRange>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to UnblendOutputColorRange_Name().");
  return UnblendOutputColorRange_Name(static_cast<UnblendOutputColorRange>(value));
}
template <>
inline const ::std::string& UnblendOutputColorRange_Name(UnblendOutputColorRange value) {
  return ::google::protobuf::internal::NameOfDenseEnum<UnblendOutputColorRange_descriptor, 0, 3>(
      static_cast<int>(value));
}
inline bool UnblendOutputColorRange_Parse(
    ::absl::string_view name, UnblendOutputColorRange* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<UnblendOutputColorRange>(UnblendOutputColorRange_descriptor(), name,
                                           value);
}
enum PanoramicCameraMode : int {
  SPHERICAL_CAMERA = 0,
  CYLINDRICAL_CAMERA = 1,
  CUBE_MAPPED_CAMERA = 2,
  CUBE_MAPPED_CAMERA_PX = 3,
  CUBE_MAPPED_CAMERA_MX = 4,
  CUBE_MAPPED_CAMERA_PY = 5,
  CUBE_MAPPED_CAMERA_MY = 6,
  CUBE_MAPPED_CAMERA_PZ = 7,
  CUBE_MAPPED_CAMERA_MZ = 8,
  PanoramicCameraMode_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  PanoramicCameraMode_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t PanoramicCameraMode_internal_data_[];
inline constexpr PanoramicCameraMode PanoramicCameraMode_MIN =
    static_cast<PanoramicCameraMode>(0);
inline constexpr PanoramicCameraMode PanoramicCameraMode_MAX =
    static_cast<PanoramicCameraMode>(8);
inline bool PanoramicCameraMode_IsValid(int value) {
  return 0 <= value && value <= 8;
}
inline constexpr int PanoramicCameraMode_ARRAYSIZE = 8 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL PanoramicCameraMode_descriptor();
template <typename T>
const ::std::string& PanoramicCameraMode_Name(T value) {
  static_assert(::std::is_same<T, PanoramicCameraMode>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to PanoramicCameraMode_Name().");
  return PanoramicCameraMode_Name(static_cast<PanoramicCameraMode>(value));
}
template <>
inline const ::std::string& PanoramicCameraMode_Name(PanoramicCameraMode value) {
  return ::google::protobuf::internal::NameOfDenseEnum<PanoramicCameraMode_descriptor, 0, 8>(
      static_cast<int>(value));
}
inline bool PanoramicCameraMode_Parse(
    ::absl::string_view name, PanoramicCameraMode* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<PanoramicCameraMode>(PanoramicCameraMode_descriptor(), name,
                                           value);
}
enum PhotonTypes : int {
  PhotonTypes_UNSPECIFIED = 0,
  PHOTONS_EVERYTHING = 1,
  PHOTONS_INDIRECT = 2,
  PHOTONS_CAUSTIC = 3,
  PhotonTypes_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  PhotonTypes_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t PhotonTypes_internal_data_[];
inline constexpr PhotonTypes PhotonTypes_MIN =
    static_cast<PhotonTypes>(0);
inline constexpr PhotonTypes PhotonTypes_MAX =
    static_cast<PhotonTypes>(3);
inline bool PhotonTypes_IsValid(int value) {
  return 0 <= value && value <= 3;
}
inline constexpr int PhotonTypes_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL PhotonTypes_descriptor();
template <typename T>
const ::std::string& PhotonTypes_Name(T value) {
  static_assert(::std::is_same<T, PhotonTypes>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to PhotonTypes_Name().");
  return PhotonTypes_Name(static_cast<PhotonTypes>(value));
}
template <>
inline const ::std::string& PhotonTypes_Name(PhotonTypes value) {
  return ::google::protobuf::internal::NameOfDenseEnum<PhotonTypes_descriptor, 0, 3>(
      static_cast<int>(value));
}
inline bool PhotonTypes_Parse(
    ::absl::string_view name, PhotonTypes* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<PhotonTypes>(PhotonTypes_descriptor(), name,
                                           value);
}
enum PositionType : int {
  PositionType_UNSPECIFIED = 0,
  POSITION_GLOBAL = 1,
  POSITION_OBJECT = 3,
  POSITION_NORMAL = 4,
  PositionType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  PositionType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t PositionType_internal_data_[];
inline constexpr PositionType PositionType_MIN =
    static_cast<PositionType>(0);
inline constexpr PositionType PositionType_MAX =
    static_cast<PositionType>(4);
inline bool PositionType_IsValid(int value) {
  return 0 <= value && value <= 4 && ((27u >> value) & 1) != 0;
}
inline constexpr int PositionType_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL PositionType_descriptor();
template <typename T>
const ::std::string& PositionType_Name(T value) {
  static_assert(::std::is_same<T, PositionType>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to PositionType_Name().");
  return PositionType_Name(static_cast<PositionType>(value));
}
template <>
inline const ::std::string& PositionType_Name(PositionType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<PositionType_descriptor, 0, 4>(
      static_cast<int>(value));
}
inline bool PositionType_Parse(
    ::absl::string_view name, PositionType* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<PositionType>(PositionType_descriptor(), name,
                                           value);
}
enum PreferencesTabId : int {
  PREFERENCES_TAB_ID_UNKNOWN = 0,
  PREFERENCES_TAB_ID_APPLICATION = 1,
  PREFERENCES_TAB_ID_COLOR_MANAGEMENT = 2,
  PREFERENCES_TAB_ID_CONTROLS = 3,
  PREFERENCES_TAB_ID_DEVICES = 4,
  PREFERENCES_TAB_ID_OUT_OF_CORE = 5,
  PREFERENCES_TAB_ID_GEOMETRY_IMPORT = 6,
  PREFERENCES_TAB_ID_GEOMETRY_IMPORT_OBJ = 7,
  PREFERENCES_TAB_ID_GEOMETRY_IMPORT_ALEMBIC = 8,
  PREFERENCES_TAB_ID_GEOMETRY_IMPORT_FBX = 9,
  PREFERENCES_TAB_ID_GEOMETRY_IMPORT_USD = 10,
  PREFERENCES_TAB_ID_GEOMETRY_IMPORT_VDB = 11,
  PREFERENCES_TAB_ID_IMAGE_IMPORT = 12,
  PREFERENCES_TAB_ID_EXPORT = 13,
  PREFERENCES_TAB_ID_NETWORK_RENDERING = 14,
  PREFERENCES_TAB_ID_KEYBOARD_SHORTCUTS = 15,
  PREFERENCES_TAB_ID_MODULES = 16,
  PREFERENCES_TAB_ID_MATERIALX_IMPORT = 17,
  PREFERENCES_TAB_ID_FILESYSTEM_CACHING = 18,
  PreferencesTabId_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  PreferencesTabId_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t PreferencesTabId_internal_data_[];
inline constexpr PreferencesTabId PreferencesTabId_MIN =
    static_cast<PreferencesTabId>(0);
inline constexpr PreferencesTabId PreferencesTabId_MAX =
    static_cast<PreferencesTabId>(18);
inline bool PreferencesTabId_IsValid(int value) {
  return 0 <= value && value <= 18;
}
inline constexpr int PreferencesTabId_ARRAYSIZE = 18 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL PreferencesTabId_descriptor();
template <typename T>
const ::std::string& PreferencesTabId_Name(T value) {
  static_assert(::std::is_same<T, PreferencesTabId>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to PreferencesTabId_Name().");
  return PreferencesTabId_Name(static_cast<PreferencesTabId>(value));
}
template <>
inline const ::std::string& PreferencesTabId_Name(PreferencesTabId value) {
  return ::google::protobuf::internal::NameOfDenseEnum<PreferencesTabId_descriptor, 0, 18>(
      static_cast<int>(value));
}
inline bool PreferencesTabId_Parse(
    ::absl::string_view name, PreferencesTabId* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<PreferencesTabId>(PreferencesTabId_descriptor(), name,
                                           value);
}
enum PremultipliedAlphaType : int {
  PREMULTIPLIED_ALPHA_TYPE_NONE = 0,
  PREMULTIPLIED_ALPHA_TYPE_LINEARIZED = 1,
  PREMULTIPLIED_ALPHA_TYPE_ENCODED = 2,
  PremultipliedAlphaType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  PremultipliedAlphaType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t PremultipliedAlphaType_internal_data_[];
inline constexpr PremultipliedAlphaType PremultipliedAlphaType_MIN =
    static_cast<PremultipliedAlphaType>(0);
inline constexpr PremultipliedAlphaType PremultipliedAlphaType_MAX =
    static_cast<PremultipliedAlphaType>(2);
inline bool PremultipliedAlphaType_IsValid(int value) {
  return 0 <= value && value <= 2;
}
inline constexpr int PremultipliedAlphaType_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL PremultipliedAlphaType_descriptor();
template <typename T>
const ::std::string& PremultipliedAlphaType_Name(T value) {
  static_assert(::std::is_same<T, PremultipliedAlphaType>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to PremultipliedAlphaType_Name().");
  return PremultipliedAlphaType_Name(static_cast<PremultipliedAlphaType>(value));
}
template <>
inline const ::std::string& PremultipliedAlphaType_Name(PremultipliedAlphaType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<PremultipliedAlphaType_descriptor, 0, 2>(
      static_cast<int>(value));
}
inline bool PremultipliedAlphaType_Parse(
    ::absl::string_view name, PremultipliedAlphaType* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<PremultipliedAlphaType>(PremultipliedAlphaType_descriptor(), name,
                                           value);
}
enum PrePassType : int {
  PrePassType_UNSPECIFIED = 0,
  PRE_PASS_TYPE_NRC_SAMPLE_GENERATION = 1,
  PRE_PASS_TYPE_INVALID = 2,
  PrePassType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  PrePassType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t PrePassType_internal_data_[];
inline constexpr PrePassType PrePassType_MIN =
    static_cast<PrePassType>(0);
inline constexpr PrePassType PrePassType_MAX =
    static_cast<PrePassType>(2);
inline bool PrePassType_IsValid(int value) {
  return 0 <= value && value <= 2;
}
inline constexpr int PrePassType_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL PrePassType_descriptor();
template <typename T>
const ::std::string& PrePassType_Name(T value) {
  static_assert(::std::is_same<T, PrePassType>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to PrePassType_Name().");
  return PrePassType_Name(static_cast<PrePassType>(value));
}
template <>
inline const ::std::string& PrePassType_Name(PrePassType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<PrePassType_descriptor, 0, 2>(
      static_cast<int>(value));
}
inline bool PrePassType_Parse(
    ::absl::string_view name, PrePassType* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<PrePassType>(PrePassType_descriptor(), name,
                                           value);
}
enum PreviewType : int {
  PreviewType_UNSPECIFIED = 0,
  PREVIEW_PLANE = 1,
  PREVIEW_SPHERE = 2,
  PREVIEW_PLANE_WITH_ALPHA = 3,
  PreviewType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  PreviewType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t PreviewType_internal_data_[];
inline constexpr PreviewType PreviewType_MIN =
    static_cast<PreviewType>(0);
inline constexpr PreviewType PreviewType_MAX =
    static_cast<PreviewType>(3);
inline bool PreviewType_IsValid(int value) {
  return 0 <= value && value <= 3;
}
inline constexpr int PreviewType_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL PreviewType_descriptor();
template <typename T>
const ::std::string& PreviewType_Name(T value) {
  static_assert(::std::is_same<T, PreviewType>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to PreviewType_Name().");
  return PreviewType_Name(static_cast<PreviewType>(value));
}
template <>
inline const ::std::string& PreviewType_Name(PreviewType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<PreviewType_descriptor, 0, 3>(
      static_cast<int>(value));
}
inline bool PreviewType_Parse(
    ::absl::string_view name, PreviewType* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<PreviewType>(PreviewType_descriptor(), name,
                                           value);
}
enum PrimitiveType : int {
  PRIMITIVE_TRIANGLE = 0,
  PRIMITIVE_OLD_DISPLACEMENT_TRIANGLE = 1,
  PRIMITIVE_DISPLACEMENT_TRIANGLE = 2,
  PRIMITIVE_HAIR = 3,
  PRIMITIVE_SPHERE = 4,
  PRIMITIVE_QUAD = 5,
  PRIMITIVE_DISK = 6,
  PRIMITIVE_TUBE = 7,
  PRIMITIVE_PLANE = 8,
  PRIMITIVE_INSTANCE = 9,
  PRIMITIVE_VOLUME = 10,
  PRIMITIVE_GS_CLOUD = 11,
  PRIMITIVE_VECTRON = 12,
  PRIMITIVE_TYPE_COUNT = 13,
  PRIMITIVE_INVALID = 13,
  PrimitiveType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  PrimitiveType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t PrimitiveType_internal_data_[];
inline constexpr PrimitiveType PrimitiveType_MIN =
    static_cast<PrimitiveType>(0);
inline constexpr PrimitiveType PrimitiveType_MAX =
    static_cast<PrimitiveType>(13);
inline bool PrimitiveType_IsValid(int value) {
  return 0 <= value && value <= 13;
}
inline constexpr int PrimitiveType_ARRAYSIZE = 13 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL PrimitiveType_descriptor();
template <typename T>
const ::std::string& PrimitiveType_Name(T value) {
  static_assert(::std::is_same<T, PrimitiveType>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to PrimitiveType_Name().");
  return PrimitiveType_Name(static_cast<PrimitiveType>(value));
}
template <>
inline const ::std::string& PrimitiveType_Name(PrimitiveType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<PrimitiveType_descriptor, 0, 13>(
      static_cast<int>(value));
}
inline bool PrimitiveType_Parse(
    ::absl::string_view name, PrimitiveType* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<PrimitiveType>(PrimitiveType_descriptor(), name,
                                           value);
}
enum ProceduralEffectType : int {
  PROCEDURAL_EFFECT_COMBUSTIBLE_VORONOI = 0,
  PROCEDURAL_EFFECT_FRACTAL = 1,
  PROCEDURAL_EFFECT_KALEIDOSCOPE = 2,
  PROCEDURAL_EFFECT_NEON_STRIPES = 3,
  PROCEDURAL_EFFECT_PAINT_COLORS = 4,
  PROCEDURAL_EFFECT_PARTICLES = 5,
  PROCEDURAL_EFFECT_STAR_SCROLLER = 6,
  PROCEDURAL_EFFECT_WAVEY_COLORS = 7,
  PROCEDURAL_EFFECT_FIRE_EMITTER = 8,
  PROCEDURAL_EFFECT_MIST = 9,
  PROCEDURAL_EFFECT_TUNNEL = 10,
  PROCEDURAL_EFFECT_BLASCHKE_PRODUCT = 11,
  PROCEDURAL_EFFECT_FRACTAL3 = 12,
  PROCEDURAL_EFFECT_SKINNER = 13,
  PROCEDURAL_EFFECT_SUN_SURFACE = 14,
  PROCEDURAL_EFFECT_PAINT_COLORS2 = 15,
  PROCEDURAL_EFFECT_SPIRAL = 16,
  PROCEDURAL_EFFECT_NOISE_SMOKE_FLOW = 17,
  PROCEDURAL_EFFECT_FRACTAL2 = 18,
  PROCEDURAL_EFFECT_PORTAL = 19,
  PROCEDURAL_EFFECT_CANDLE_FLAME = 20,
  ProceduralEffectType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  ProceduralEffectType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t ProceduralEffectType_internal_data_[];
inline constexpr ProceduralEffectType ProceduralEffectType_MIN =
    static_cast<ProceduralEffectType>(0);
inline constexpr ProceduralEffectType ProceduralEffectType_MAX =
    static_cast<ProceduralEffectType>(20);
inline bool ProceduralEffectType_IsValid(int value) {
  return 0 <= value && value <= 20;
}
inline constexpr int ProceduralEffectType_ARRAYSIZE = 20 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL ProceduralEffectType_descriptor();
template <typename T>
const ::std::string& ProceduralEffectType_Name(T value) {
  static_assert(::std::is_same<T, ProceduralEffectType>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to ProceduralEffectType_Name().");
  return ProceduralEffectType_Name(static_cast<ProceduralEffectType>(value));
}
template <>
inline const ::std::string& ProceduralEffectType_Name(ProceduralEffectType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ProceduralEffectType_descriptor, 0, 20>(
      static_cast<int>(value));
}
inline bool ProceduralEffectType_Parse(
    ::absl::string_view name, ProceduralEffectType* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<ProceduralEffectType>(ProceduralEffectType_descriptor(), name,
                                           value);
}
enum ReferenceAABBDisplay : int {
  ReferenceAABBDisplay_UNSPECIFIED = 0,
  REFERENCE_AABB_DISPLAY_NEVER = 1,
  REFERENCE_AABB_DISPLAY_WHEN_UNLOADED = 2,
  REFERENCE_AABB_DISPLAY_ALWAYS = 3,
  ReferenceAABBDisplay_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  ReferenceAABBDisplay_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t ReferenceAABBDisplay_internal_data_[];
inline constexpr ReferenceAABBDisplay ReferenceAABBDisplay_MIN =
    static_cast<ReferenceAABBDisplay>(0);
inline constexpr ReferenceAABBDisplay ReferenceAABBDisplay_MAX =
    static_cast<ReferenceAABBDisplay>(3);
inline bool ReferenceAABBDisplay_IsValid(int value) {
  return 0 <= value && value <= 3;
}
inline constexpr int ReferenceAABBDisplay_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL ReferenceAABBDisplay_descriptor();
template <typename T>
const ::std::string& ReferenceAABBDisplay_Name(T value) {
  static_assert(::std::is_same<T, ReferenceAABBDisplay>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to ReferenceAABBDisplay_Name().");
  return ReferenceAABBDisplay_Name(static_cast<ReferenceAABBDisplay>(value));
}
template <>
inline const ::std::string& ReferenceAABBDisplay_Name(ReferenceAABBDisplay value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ReferenceAABBDisplay_descriptor, 0, 3>(
      static_cast<int>(value));
}
inline bool ReferenceAABBDisplay_Parse(
    ::absl::string_view name, ReferenceAABBDisplay* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<ReferenceAABBDisplay>(ReferenceAABBDisplay_descriptor(), name,
                                           value);
}
enum RenderDeviceState : int {
  RENDER_DEVICE_STATE_UNKNOWN = 0,
  RENDER_DEVICE_STATE_NOT_SUPPORTED = 1,
  RENDER_DEVICE_STATE_DISABLED = 2,
  RENDER_DEVICE_STATE_ENABLED = 3,
  RENDER_DEVICE_STATE_ACTIVE_OK = 4,
  RENDER_DEVICE_STATE_ACTIVE_FAILED = 5,
  RenderDeviceState_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  RenderDeviceState_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t RenderDeviceState_internal_data_[];
inline constexpr RenderDeviceState RenderDeviceState_MIN =
    static_cast<RenderDeviceState>(0);
inline constexpr RenderDeviceState RenderDeviceState_MAX =
    static_cast<RenderDeviceState>(5);
inline bool RenderDeviceState_IsValid(int value) {
  return 0 <= value && value <= 5;
}
inline constexpr int RenderDeviceState_ARRAYSIZE = 5 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL RenderDeviceState_descriptor();
template <typename T>
const ::std::string& RenderDeviceState_Name(T value) {
  static_assert(::std::is_same<T, RenderDeviceState>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to RenderDeviceState_Name().");
  return RenderDeviceState_Name(static_cast<RenderDeviceState>(value));
}
template <>
inline const ::std::string& RenderDeviceState_Name(RenderDeviceState value) {
  return ::google::protobuf::internal::NameOfDenseEnum<RenderDeviceState_descriptor, 0, 5>(
      static_cast<int>(value));
}
inline bool RenderDeviceState_Parse(
    ::absl::string_view name, RenderDeviceState* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<RenderDeviceState>(RenderDeviceState_descriptor(), name,
                                           value);
}
enum RenderError : int {
  RENDER_ERROR_NONE = 0,
  RENDER_ERROR_NOT_ENOUGH_DEVICE_MEMORY = 1,
  RENDER_ERROR_NOT_ENOUGH_HOST_MEMORY = 2,
  RENDER_ERROR_KERNEL_FAILED = 3,
  RENDER_ERROR_ACTIVATION_REQUIRED = 4,
  RENDER_ERROR_DEVICE_UNSUPPORTED = 5,
  RENDER_ERROR_PEER_CONNECTION_CLOSED = 6,
  RENDER_ERROR_MODULE_LOAD_FAILED = 7,
  RENDER_ERROR_OSL = 8,
  RENDER_ERROR_OSL_INTERNAL = 9,
  RENDER_ERROR_LOD_DATA = 10,
  RENDER_ERROR_UNSPECIFIED = 11,
  RenderError_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  RenderError_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t RenderError_internal_data_[];
inline constexpr RenderError RenderError_MIN =
    static_cast<RenderError>(0);
inline constexpr RenderError RenderError_MAX =
    static_cast<RenderError>(11);
inline bool RenderError_IsValid(int value) {
  return 0 <= value && value <= 11;
}
inline constexpr int RenderError_ARRAYSIZE = 11 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL RenderError_descriptor();
template <typename T>
const ::std::string& RenderError_Name(T value) {
  static_assert(::std::is_same<T, RenderError>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to RenderError_Name().");
  return RenderError_Name(static_cast<RenderError>(value));
}
template <>
inline const ::std::string& RenderError_Name(RenderError value) {
  return ::google::protobuf::internal::NameOfDenseEnum<RenderError_descriptor, 0, 11>(
      static_cast<int>(value));
}
inline bool RenderError_Parse(
    ::absl::string_view name, RenderError* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<RenderError>(RenderError_descriptor(), name,
                                           value);
}
enum RenderJobAction : int {
  RENDER_JOB_ACTION_NONE = 0,
  RENDER_JOB_ACTION_START_ITERATION = 1,
  RENDER_JOB_ACTION_FINISH_ITERATION = 2,
  RENDER_JOB_ACTION_RENDER = 3,
  RenderJobAction_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  RenderJobAction_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t RenderJobAction_internal_data_[];
inline constexpr RenderJobAction RenderJobAction_MIN =
    static_cast<RenderJobAction>(0);
inline constexpr RenderJobAction RenderJobAction_MAX =
    static_cast<RenderJobAction>(3);
inline bool RenderJobAction_IsValid(int value) {
  return 0 <= value && value <= 3;
}
inline constexpr int RenderJobAction_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL RenderJobAction_descriptor();
template <typename T>
const ::std::string& RenderJobAction_Name(T value) {
  static_assert(::std::is_same<T, RenderJobAction>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to RenderJobAction_Name().");
  return RenderJobAction_Name(static_cast<RenderJobAction>(value));
}
template <>
inline const ::std::string& RenderJobAction_Name(RenderJobAction value) {
  return ::google::protobuf::internal::NameOfDenseEnum<RenderJobAction_descriptor, 0, 3>(
      static_cast<int>(value));
}
inline bool RenderJobAction_Parse(
    ::absl::string_view name, RenderJobAction* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<RenderJobAction>(RenderJobAction_descriptor(), name,
                                           value);
}
enum RenderJobStatus : int {
  RENDER_JOB_STATUS_NONE = 0,
  RENDER_JOB_STATUS_COMPLETED = 2,
  RENDER_JOB_STATUS_RENDER_ERROR = 3,
  RENDER_JOB_STATUS_SAVE_ERROR = 4,
  RENDER_JOB_STATUS_SKIPPED = 5,
  RENDER_JOB_STATUS_SCRIPT_ERROR = 6,
  RenderJobStatus_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  RenderJobStatus_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t RenderJobStatus_internal_data_[];
inline constexpr RenderJobStatus RenderJobStatus_MIN =
    static_cast<RenderJobStatus>(0);
inline constexpr RenderJobStatus RenderJobStatus_MAX =
    static_cast<RenderJobStatus>(6);
inline bool RenderJobStatus_IsValid(int value) {
  return 0 <= value && value <= 6 && ((125u >> value) & 1) != 0;
}
inline constexpr int RenderJobStatus_ARRAYSIZE = 6 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL RenderJobStatus_descriptor();
template <typename T>
const ::std::string& RenderJobStatus_Name(T value) {
  static_assert(::std::is_same<T, RenderJobStatus>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to RenderJobStatus_Name().");
  return RenderJobStatus_Name(static_cast<RenderJobStatus>(value));
}
template <>
inline const ::std::string& RenderJobStatus_Name(RenderJobStatus value) {
  return ::google::protobuf::internal::NameOfDenseEnum<RenderJobStatus_descriptor, 0, 6>(
      static_cast<int>(value));
}
inline bool RenderJobStatus_Parse(
    ::absl::string_view name, RenderJobStatus* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<RenderJobStatus>(RenderJobStatus_descriptor(), name,
                                           value);
}
enum RenderLayerMode : int {
  RENDER_LAYER_MODE_NORMAL = 0,
  RENDER_LAYER_MODE_HIDE_INACTIVE_LAYERs = 1,
  RENDER_LAYER_MODE_ONLY_SIDE_EFFECTS = 2,
  RENDER_LAYER_MODE_HIDE_FROM_CAMERA = 3,
  RenderLayerMode_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  RenderLayerMode_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t RenderLayerMode_internal_data_[];
inline constexpr RenderLayerMode RenderLayerMode_MIN =
    static_cast<RenderLayerMode>(0);
inline constexpr RenderLayerMode RenderLayerMode_MAX =
    static_cast<RenderLayerMode>(3);
inline bool RenderLayerMode_IsValid(int value) {
  return 0 <= value && value <= 3;
}
inline constexpr int RenderLayerMode_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL RenderLayerMode_descriptor();
template <typename T>
const ::std::string& RenderLayerMode_Name(T value) {
  static_assert(::std::is_same<T, RenderLayerMode>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to RenderLayerMode_Name().");
  return RenderLayerMode_Name(static_cast<RenderLayerMode>(value));
}
template <>
inline const ::std::string& RenderLayerMode_Name(RenderLayerMode value) {
  return ::google::protobuf::internal::NameOfDenseEnum<RenderLayerMode_descriptor, 0, 3>(
      static_cast<int>(value));
}
inline bool RenderLayerMode_Parse(
    ::absl::string_view name, RenderLayerMode* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<RenderLayerMode>(RenderLayerMode_descriptor(), name,
                                           value);
}
enum RenderPassGroupId : int {
  RENDER_PASS_GROUP_NONE = 0,
  RENDER_PASS_GROUP_DEFAULT = 0,
  RENDER_PASS_GROUP_BEAUTY = 1,
  RENDER_PASS_GROUP_LAYER = 2,
  RENDER_PASS_GROUP_POST_PROC = 3,
  RENDER_PASS_GROUP_LIGHT = 4,
  RENDER_PASS_GROUP_INFO = 5,
  RENDER_PASS_GROUP_MATERIAL = 6,
  RENDER_PASS_GROUP_DENOISER = 7,
  RENDER_PASS_GROUP_CRYPTOMATTE = 8,
  RENDER_PASS_GROUP_CUSTOM = 9,
  RENDER_PASS_GROUP_GLOBAL_TEX = 10,
  RenderPassGroupId_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  RenderPassGroupId_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t RenderPassGroupId_internal_data_[];
inline constexpr RenderPassGroupId RenderPassGroupId_MIN =
    static_cast<RenderPassGroupId>(0);
inline constexpr RenderPassGroupId RenderPassGroupId_MAX =
    static_cast<RenderPassGroupId>(10);
inline bool RenderPassGroupId_IsValid(int value) {
  return 0 <= value && value <= 10;
}
inline constexpr int RenderPassGroupId_ARRAYSIZE = 10 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL RenderPassGroupId_descriptor();
template <typename T>
const ::std::string& RenderPassGroupId_Name(T value) {
  static_assert(::std::is_same<T, RenderPassGroupId>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to RenderPassGroupId_Name().");
  return RenderPassGroupId_Name(static_cast<RenderPassGroupId>(value));
}
template <>
inline const ::std::string& RenderPassGroupId_Name(RenderPassGroupId value) {
  return ::google::protobuf::internal::NameOfDenseEnum<RenderPassGroupId_descriptor, 0, 10>(
      static_cast<int>(value));
}
inline bool RenderPassGroupId_Parse(
    ::absl::string_view name, RenderPassGroupId* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<RenderPassGroupId>(RenderPassGroupId_descriptor(), name,
                                           value);
}
enum RenderPassId : int {
  RENDER_PASS_BEAUTY = 0,
  RENDER_PASS_EMIT = 1,
  RENDER_PASS_ENVIRONMENT = 2,
  RENDER_PASS_DIFFUSE = 3,
  RENDER_PASS_DIFFUSE_DIRECT = 4,
  RENDER_PASS_DIFFUSE_INDIRECT = 5,
  RENDER_PASS_DIFFUSE_FILTER = 6,
  RENDER_PASS_REFLECTION = 7,
  RENDER_PASS_REFLECTION_DIRECT = 8,
  RENDER_PASS_REFLECTION_INDIRECT = 9,
  RENDER_PASS_REFLECTION_FILTER = 10,
  RENDER_PASS_REFRACTION = 11,
  RENDER_PASS_REFRACTION_FILTER = 12,
  RENDER_PASS_TRANSMISSION = 13,
  RENDER_PASS_TRANSMISSION_FILTER = 14,
  RENDER_PASS_SSS = 15,
  RENDER_PASS_POST_PROC = 16,
  RENDER_PASS_LAYER_SHADOWS = 17,
  RENDER_PASS_LAYER_BLACK_SHADOWS = 18,
  RENDER_PASS_LAYER_REFLECTIONS = 20,
  RENDER_PASS_AMBIENT_LIGHT = 21,
  RENDER_PASS_SUNLIGHT = 22,
  RENDER_PASS_LIGHT_1 = 23,
  RENDER_PASS_LIGHT_2 = 24,
  RENDER_PASS_LIGHT_3 = 25,
  RENDER_PASS_LIGHT_4 = 26,
  RENDER_PASS_LIGHT_5 = 27,
  RENDER_PASS_LIGHT_6 = 28,
  RENDER_PASS_LIGHT_7 = 29,
  RENDER_PASS_LIGHT_8 = 30,
  RENDER_PASS_NOISE_BEAUTY = 31,
  RENDER_PASS_SHADOW = 32,
  RENDER_PASS_IRRADIANCE = 33,
  RENDER_PASS_LIGHT_DIRECTION = 34,
  RENDER_PASS_VOLUME = 35,
  RENDER_PASS_VOLUME_MASK = 36,
  RENDER_PASS_VOLUME_EMISSION = 37,
  RENDER_PASS_VOLUME_Z_DEPTH_FRONT = 38,
  RENDER_PASS_VOLUME_Z_DEPTH_BACK = 39,
  RENDER_PASS_DENOISE_NORMAL = 40,
  RENDER_PASS_DENOISE_HIT_DISTANCE = 41,
  RENDER_PASS_DENOISE_ROUGHNESS = 42,
  RENDER_PASS_BEAUTY_DENOISER_OUTPUT = 43,
  RENDER_PASS_DIFFUSE_DIRECT_DENOISER_OUTPUT = 44,
  RENDER_PASS_DIFFUSE_INDIRECT_DENOISER_OUTPUT = 45,
  RENDER_PASS_REFLECTION_DIRECT_DENOISER_OUTPUT = 46,
  RENDER_PASS_REFLECTION_INDIRECT_DENOISER_OUTPUT = 47,
  RENDER_PASS_REMAINDER_DENOISER_OUTPUT = 49,
  RENDER_PASS_NOISE_DIFFUSE_DIRECT = 50,
  RENDER_PASS_NOISE_DIFFUSE_INDIRECT = 51,
  RENDER_PASS_NOISE_REFLECTION_DIRECT = 52,
  RENDER_PASS_NOISE_REFLECTION_INDIRECT = 53,
  RENDER_PASS_AMBIENT_LIGHT_DIRECT = 54,
  RENDER_PASS_AMBIENT_LIGHT_INDIRECT = 55,
  RENDER_PASS_SUNLIGHT_DIRECT = 56,
  RENDER_PASS_SUNLIGHT_INDIRECT = 57,
  RENDER_PASS_LIGHT_1_DIRECT = 58,
  RENDER_PASS_LIGHT_2_DIRECT = 59,
  RENDER_PASS_LIGHT_3_DIRECT = 60,
  RENDER_PASS_LIGHT_4_DIRECT = 61,
  RENDER_PASS_LIGHT_5_DIRECT = 62,
  RENDER_PASS_LIGHT_6_DIRECT = 63,
  RENDER_PASS_LIGHT_7_DIRECT = 64,
  RENDER_PASS_LIGHT_8_DIRECT = 65,
  RENDER_PASS_LIGHT_1_INDIRECT = 66,
  RENDER_PASS_LIGHT_2_INDIRECT = 67,
  RENDER_PASS_LIGHT_3_INDIRECT = 68,
  RENDER_PASS_LIGHT_4_INDIRECT = 69,
  RENDER_PASS_LIGHT_5_INDIRECT = 70,
  RENDER_PASS_LIGHT_6_INDIRECT = 71,
  RENDER_PASS_LIGHT_7_INDIRECT = 72,
  RENDER_PASS_LIGHT_8_INDIRECT = 73,
  RENDER_PASS_VOLUME_DENOISER_OUTPUT = 74,
  RENDER_PASS_VOLUME_EMISSION_DENOISER_OUTPUT = 75,
  RENDER_PASS_EMISSION_DENOISER_OUTPUT = 76,
  RENDER_PASS_POSTFX_MEDIA = 84,
  RENDER_PASS_LIGHT_9 = 85,
  RENDER_PASS_LIGHT_10 = 86,
  RENDER_PASS_LIGHT_11 = 87,
  RENDER_PASS_LIGHT_12 = 88,
  RENDER_PASS_LIGHT_13 = 89,
  RENDER_PASS_LIGHT_14 = 90,
  RENDER_PASS_LIGHT_15 = 91,
  RENDER_PASS_LIGHT_16 = 92,
  RENDER_PASS_LIGHT_17 = 93,
  RENDER_PASS_LIGHT_18 = 94,
  RENDER_PASS_LIGHT_19 = 95,
  RENDER_PASS_LIGHT_20 = 96,
  RENDER_PASS_LIGHT_9_DIRECT = 97,
  RENDER_PASS_LIGHT_10_DIRECT = 98,
  RENDER_PASS_LIGHT_11_DIRECT = 99,
  RENDER_PASS_LIGHT_12_DIRECT = 100,
  RENDER_PASS_LIGHT_13_DIRECT = 101,
  RENDER_PASS_LIGHT_14_DIRECT = 102,
  RENDER_PASS_LIGHT_15_DIRECT = 103,
  RENDER_PASS_LIGHT_16_DIRECT = 104,
  RENDER_PASS_LIGHT_17_DIRECT = 105,
  RENDER_PASS_LIGHT_18_DIRECT = 106,
  RENDER_PASS_LIGHT_19_DIRECT = 107,
  RENDER_PASS_LIGHT_20_DIRECT = 108,
  RENDER_PASS_LIGHT_9_INDIRECT = 109,
  RENDER_PASS_LIGHT_10_INDIRECT = 110,
  RENDER_PASS_LIGHT_11_INDIRECT = 111,
  RENDER_PASS_LIGHT_12_INDIRECT = 112,
  RENDER_PASS_LIGHT_13_INDIRECT = 113,
  RENDER_PASS_LIGHT_14_INDIRECT = 114,
  RENDER_PASS_LIGHT_15_INDIRECT = 115,
  RENDER_PASS_LIGHT_16_INDIRECT = 116,
  RENDER_PASS_LIGHT_17_INDIRECT = 117,
  RENDER_PASS_LIGHT_18_INDIRECT = 118,
  RENDER_PASS_LIGHT_19_INDIRECT = 119,
  RENDER_PASS_LIGHT_20_INDIRECT = 120,
  RENDER_PASS_DENOISE_ALBEDO = 123,
  RENDER_PASS_MIST = 124,
  RENDER_PASS_CAMERA_MASK = 125,
  RENDER_PASS_ALPHA = 126,
  RENDER_PASS_GAUSSIAN_SPLAT = 127,
  RENDER_PASS_POSTFX_MEDIA_MASK = 128,
  RENDER_PASS_ENVIRONMENT_UNOCCLUDED = 129,
  RENDER_PASS_CUSTOM_OFFSET = 500,
  RENDER_PASS_CUSTOM_1 = 501,
  RENDER_PASS_CUSTOM_2 = 502,
  RENDER_PASS_CUSTOM_3 = 503,
  RENDER_PASS_CUSTOM_4 = 504,
  RENDER_PASS_CUSTOM_5 = 505,
  RENDER_PASS_CUSTOM_6 = 506,
  RENDER_PASS_CUSTOM_7 = 507,
  RENDER_PASS_CUSTOM_8 = 508,
  RENDER_PASS_CUSTOM_9 = 509,
  RENDER_PASS_CUSTOM_10 = 510,
  RENDER_PASS_CUSTOM_11 = 511,
  RENDER_PASS_CUSTOM_12 = 512,
  RENDER_PASS_CUSTOM_13 = 513,
  RENDER_PASS_CUSTOM_14 = 514,
  RENDER_PASS_CUSTOM_15 = 515,
  RENDER_PASS_CUSTOM_16 = 516,
  RENDER_PASS_CUSTOM_17 = 517,
  RENDER_PASS_CUSTOM_18 = 518,
  RENDER_PASS_CUSTOM_19 = 519,
  RENDER_PASS_CUSTOM_LAST = 520,
  RENDER_PASS_CUSTOM_20 = 520,
  RENDER_PASS_INFO_OFFSET = 1000,
  RENDER_PASS_GEOMETRIC_NORMAL = 1000,
  RENDER_PASS_SHADING_NORMAL = 1001,
  RENDER_PASS_POSITION = 1002,
  RENDER_PASS_Z_DEPTH = 1003,
  RENDER_PASS_MATERIAL_ID = 1004,
  RENDER_PASS_UV_COORD = 1005,
  RENDER_PASS_TANGENT_U = 1006,
  RENDER_PASS_WIREFRAME = 1007,
  RENDER_PASS_SMOOTH_NORMAL = 1008,
  RENDER_PASS_VERTEX_NORMAL = 1008,
  RENDER_PASS_OBJECT_ID = 1009,
  RENDER_PASS_AMBIENT_OCCLUSION = 1010,
  RENDER_PASS_MOTION_VECTOR = 1011,
  RENDER_PASS_RENDER_LAYER_ID = 1012,
  RENDER_PASS_RENDER_LAYER_MASK = 1013,
  RENDER_PASS_LIGHT_PASS_ID = 1014,
  RENDER_PASS_TANGENT_NORMAL = 1015,
  RENDER_PASS_OPACITY = 1016,
  RENDER_PASS_BAKING_GROUP_ID = 1017,
  RENDER_PASS_ROUGHNESS = 1018,
  RENDER_PASS_IOR = 1019,
  RENDER_PASS_DIFFUSE_FILTER_INFO = 1020,
  RENDER_PASS_REFLECTION_FILTER_INFO = 1021,
  RENDER_PASS_REFRACTION_FILTER_INFO = 1022,
  RENDER_PASS_TRANSMISSION_FILTER_INFO = 1023,
  RENDER_PASS_OBJECT_LAYER_COLOR = 1024,
  RENDER_PASS_GAUSSIAN_SPLAT_INFO = 1025,
  RENDER_PASS_TRACE_CLOCK = 1026,
  RENDER_PASS_PRIMITIVE_TYPE = 1027,
  RENDER_PASS_GLOBAL_TEX_OFFSET = 1100,
  RENDER_PASS_GLOBAL_TEX_1 = 1101,
  RENDER_PASS_GLOBAL_TEX_2 = 1102,
  RENDER_PASS_GLOBAL_TEX_3 = 1103,
  RENDER_PASS_GLOBAL_TEX_4 = 1104,
  RENDER_PASS_GLOBAL_TEX_5 = 1105,
  RENDER_PASS_GLOBAL_TEX_6 = 1106,
  RENDER_PASS_GLOBAL_TEX_7 = 1107,
  RENDER_PASS_GLOBAL_TEX_8 = 1108,
  RENDER_PASS_GLOBAL_TEX_9 = 1109,
  RENDER_PASS_GLOBAL_TEX_10 = 1110,
  RENDER_PASS_GLOBAL_TEX_11 = 1111,
  RENDER_PASS_GLOBAL_TEX_12 = 1112,
  RENDER_PASS_GLOBAL_TEX_13 = 1113,
  RENDER_PASS_GLOBAL_TEX_14 = 1114,
  RENDER_PASS_GLOBAL_TEX_15 = 1115,
  RENDER_PASS_GLOBAL_TEX_16 = 1116,
  RENDER_PASS_GLOBAL_TEX_17 = 1117,
  RENDER_PASS_GLOBAL_TEX_18 = 1118,
  RENDER_PASS_GLOBAL_TEX_19 = 1119,
  RENDER_PASS_GLOBAL_TEX_20 = 1120,
  RENDER_PASS_GLOBAL_TEX_LAST = 1120,
  RENDER_PASS_CRYPTOMATTE_OFFSET = 2000,
  RENDER_PASS_CRYPTOMATTE_MATERIAL_NODE_NAME = 2001,
  RENDER_PASS_CRYPTOMATTE_MATERIAL_PIN_NAME = 2002,
  RENDER_PASS_CRYPTOMATTE_OBJECT_NODE_NAME = 2003,
  RENDER_PASS_CRYPTOMATTE_OBJECT_NODE = 2004,
  RENDER_PASS_CRYPTOMATTE_INSTANCE = 2005,
  RENDER_PASS_CRYPTOMATTE_MATERIAL_NODE = 2006,
  RENDER_PASS_CRYPTOMATTE_OBJECT_PIN_NAME = 2007,
  RENDER_PASS_CRYPTOMATTE_GEOMETRY_NODE_NAME = 2008,
  RENDER_PASS_CRYPTOMATTE_RENDER_LAYER = 2009,
  RENDER_PASS_CRYPTOMATTE_USER_INSTANCE_ID = 2010,
  RENDER_PASS_CRYPTOMATTE_LAST = 4999,
  RENDER_PASS_UNKNOWN = 5000,
  RENDER_PASS_OUTPUT_AOV_IDS_OFFSET = 10000,
  RENDER_PASS_OUTPUT_AOV_IDS_INTERNAL1 = 11000,
  RENDER_PASS_OUTPUT_AOV_IDS_INTERNAL2 = 11001,
  RENDER_PASS_OUTPUT_AOV_IDS_INTERNAL3 = 11002,
  RENDER_PASS_OUTPUT_AOV_IDS_INTERNAL4 = 11003,
  RENDER_PASS_OUTPUT_AOV_IDS_INTERNAL5 = 11004,
  RENDER_PASS_OUTPUT_AOV_IDS_INTERNAL6 = 11005,
  RENDER_PASS_OUTPUT_AOV_IDS_INTERNAL7 = 11006,
  RENDER_PASS_OUTPUT_AOV_IDS_INTERNAL8 = 11007,
  RENDER_PASS_OUTPUT_AOV_IDS_INTERNAL9 = 11008,
  RenderPassId_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  RenderPassId_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t RenderPassId_internal_data_[];
inline constexpr RenderPassId RenderPassId_MIN =
    static_cast<RenderPassId>(0);
inline constexpr RenderPassId RenderPassId_MAX =
    static_cast<RenderPassId>(11008);
inline bool RenderPassId_IsValid(int value) {
  return ::google::protobuf::internal::ValidateEnum(value, RenderPassId_internal_data_);
}
inline constexpr int RenderPassId_ARRAYSIZE = 11008 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL RenderPassId_descriptor();
template <typename T>
const ::std::string& RenderPassId_Name(T value) {
  static_assert(::std::is_same<T, RenderPassId>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to RenderPassId_Name().");
  return ::google::protobuf::internal::NameOfEnum(RenderPassId_descriptor(), value);
}
inline bool RenderPassId_Parse(
    ::absl::string_view name, RenderPassId* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<RenderPassId>(RenderPassId_descriptor(), name,
                                           value);
}
enum RenderState : int {
  RSTATE_STOPPED = 0,
  RSTATE_WAITING_FOR_DATA = 1,
  RSTATE_RENDERING = 2,
  RSTATE_PAUSED = 3,
  RSTATE_FINISHED = 4,
  RenderState_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  RenderState_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t RenderState_internal_data_[];
inline constexpr RenderState RenderState_MIN =
    static_cast<RenderState>(0);
inline constexpr RenderState RenderState_MAX =
    static_cast<RenderState>(4);
inline bool RenderState_IsValid(int value) {
  return 0 <= value && value <= 4;
}
inline constexpr int RenderState_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL RenderState_descriptor();
template <typename T>
const ::std::string& RenderState_Name(T value) {
  static_assert(::std::is_same<T, RenderState>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to RenderState_Name().");
  return RenderState_Name(static_cast<RenderState>(value));
}
template <>
inline const ::std::string& RenderState_Name(RenderState value) {
  return ::google::protobuf::internal::NameOfDenseEnum<RenderState_descriptor, 0, 4>(
      static_cast<int>(value));
}
inline bool RenderState_Parse(
    ::absl::string_view name, RenderState* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<RenderState>(RenderState_descriptor(), name,
                                           value);
}
enum ResourceCategory : int {
  RESOURCE_CATEGORY_GEOMETRY = 0,
  RESOURCE_CATEGORY_IMAGES = 1,
  RESOURCE_CATEGORY_RUN_TIME = 2,
  RESOURCE_CATEGORY_NODE_SYSTEM = 3,
  RESOURCE_CATEGORY_FILM_BUFFER = 4,
  RESOURCE_CATEGORY_COMPOSITOR = 5,
  RESOURCE_CATEGORY_COUNT = 6,
  RESOURCE_CATEGORY_UNKNOWN = 6,
  ResourceCategory_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  ResourceCategory_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t ResourceCategory_internal_data_[];
inline constexpr ResourceCategory ResourceCategory_MIN =
    static_cast<ResourceCategory>(0);
inline constexpr ResourceCategory ResourceCategory_MAX =
    static_cast<ResourceCategory>(6);
inline bool ResourceCategory_IsValid(int value) {
  return 0 <= value && value <= 6;
}
inline constexpr int ResourceCategory_ARRAYSIZE = 6 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL ResourceCategory_descriptor();
template <typename T>
const ::std::string& ResourceCategory_Name(T value) {
  static_assert(::std::is_same<T, ResourceCategory>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to ResourceCategory_Name().");
  return ResourceCategory_Name(static_cast<ResourceCategory>(value));
}
template <>
inline const ::std::string& ResourceCategory_Name(ResourceCategory value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ResourceCategory_descriptor, 0, 6>(
      static_cast<int>(value));
}
inline bool ResourceCategory_Parse(
    ::absl::string_view name, ResourceCategory* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<ResourceCategory>(ResourceCategory_descriptor(), name,
                                           value);
}
enum ResponseCurveId : int {
  ResponseCurveId_UNSPECIFIED = 0,
  CURVE_AGFACOLOR_FUTURA_100CD = 99,
  CURVE_AGFACOLOR_FUTURA_200CD = 100,
  CURVE_AGFACOLOR_FUTURA_400CD = 101,
  CURVE_AGFACOLOR_FUTURA_II_100CD = 102,
  CURVE_AGFACOLOR_FUTURA_II_200CD = 103,
  CURVE_AGFACOLOR_FUTURA_II_400CD = 104,
  CURVE_AGFACOLOR_HDC_100_PLUSCD = 105,
  CURVE_AGFACOLOR_HDC_200_PLUSCD = 106,
  CURVE_AGFACOLOR_HDC_400_PLUSCD = 107,
  CURVE_AGFACOLOR_OPTIMA_II_100CD = 108,
  CURVE_AGFACOLOR_OPTIMA_II_200CD = 109,
  CURVE_AGFACOLOR_ULTRA_050CD = 110,
  CURVE_AGFACOLOR_VISTA_100CD = 111,
  CURVE_AGFACOLOR_VISTA_200CD = 112,
  CURVE_AGFACOLOR_VISTA_400CD = 113,
  CURVE_AGFACOLOR_VISTA_800CD = 114,
  CURVE_AGFACHROME_CT_PRECISA_100CD = 115,
  CURVE_AGFACHROME_CT_PRECISA_200CD = 116,
  CURVE_AGFACHROME_RSX2_050CD = 117,
  CURVE_AGFACHROME_RSX2_100CD = 118,
  CURVE_AGFACHROME_RSX2_200CD = 119,
  CURVE_ADVANTIX_100CD = 201,
  CURVE_ADVANTIX_200CD = 202,
  CURVE_ADVANTIX_400CD = 203,
  CURVE_GOLD_100CD = 204,
  CURVE_GOLD_200CD = 205,
  CURVE_MAX_ZOOM_800CD = 206,
  CURVE_PORTRA_100TCD = 207,
  CURVE_PORTRA_160NCCD = 208,
  CURVE_PORTRA_160VCCD = 209,
  CURVE_PORTRA_800CD = 210,
  CURVE_PORTRA_400VCCD = 211,
  CURVE_PORTRA_400NCCD = 212,
  CURVE_EKTACHROME_100_PLUSCD = 213,
  CURVE_EKTACHROME_320TCD = 214,
  CURVE_EKTACHROME_400XCD = 215,
  CURVE_EKTACHROME_64CD = 216,
  CURVE_EKTACHROME_64TCD = 217,
  CURVE_EKTACHROME_E100SCD = 218,
  CURVE_EKTACHROME_100CD = 219,
  CURVE_KODACHROME_200CD = 220,
  CURVE_KODACHROME_25 = 221,
  CURVE_KODACHROME_64CD = 222,
  CURVE_F125CD = 301,
  CURVE_F250CD = 302,
  CURVE_F400CD = 303,
  CURVE_FCICD = 304,
  CURVE_DSCS315_1 = 305,
  CURVE_DSCS315_2 = 306,
  CURVE_DSCS315_3 = 307,
  CURVE_DSCS315_4 = 308,
  CURVE_DSCS315_5 = 309,
  CURVE_DSCS315_6 = 310,
  CURVE_FP2900Z = 311,
  CURVE_LINEAR = 400,
  CURVE_SRGB = 401,
  CURVE_GAMMA1_8 = 402,
  CURVE_GAMMA2_2 = 403,
  ResponseCurveId_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  ResponseCurveId_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t ResponseCurveId_internal_data_[];
inline constexpr ResponseCurveId ResponseCurveId_MIN =
    static_cast<ResponseCurveId>(0);
inline constexpr ResponseCurveId ResponseCurveId_MAX =
    static_cast<ResponseCurveId>(403);
inline bool ResponseCurveId_IsValid(int value) {
  return ::google::protobuf::internal::ValidateEnum(value, ResponseCurveId_internal_data_);
}
inline constexpr int ResponseCurveId_ARRAYSIZE = 403 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL ResponseCurveId_descriptor();
template <typename T>
const ::std::string& ResponseCurveId_Name(T value) {
  static_assert(::std::is_same<T, ResponseCurveId>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to ResponseCurveId_Name().");
  return ::google::protobuf::internal::NameOfEnum(ResponseCurveId_descriptor(), value);
}
inline bool ResponseCurveId_Parse(
    ::absl::string_view name, ResponseCurveId* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<ResponseCurveId>(ResponseCurveId_descriptor(), name,
                                           value);
}
enum RoundEdgesMode : int {
  ROUND_EDGES_MODE_OFF = 0,
  ROUND_EDGES_MODE_FAST = 1,
  ROUND_EDGES_MODE_ACCURATE = 2,
  ROUND_EDGES_MODE_ACCURATE_CONVEX = 3,
  ROUND_EDGES_MODE_ACCURATE_CONCAVE = 4,
  RoundEdgesMode_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  RoundEdgesMode_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t RoundEdgesMode_internal_data_[];
inline constexpr RoundEdgesMode RoundEdgesMode_MIN =
    static_cast<RoundEdgesMode>(0);
inline constexpr RoundEdgesMode RoundEdgesMode_MAX =
    static_cast<RoundEdgesMode>(4);
inline bool RoundEdgesMode_IsValid(int value) {
  return 0 <= value && value <= 4;
}
inline constexpr int RoundEdgesMode_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL RoundEdgesMode_descriptor();
template <typename T>
const ::std::string& RoundEdgesMode_Name(T value) {
  static_assert(::std::is_same<T, RoundEdgesMode>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to RoundEdgesMode_Name().");
  return RoundEdgesMode_Name(static_cast<RoundEdgesMode>(value));
}
template <>
inline const ::std::string& RoundEdgesMode_Name(RoundEdgesMode value) {
  return ::google::protobuf::internal::NameOfDenseEnum<RoundEdgesMode_descriptor, 0, 4>(
      static_cast<int>(value));
}
inline bool RoundEdgesMode_Parse(
    ::absl::string_view name, RoundEdgesMode* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<RoundEdgesMode>(RoundEdgesMode_descriptor(), name,
                                           value);
}
enum RoundingMode : int {
  ROUNDING_MODE_ROUND = 0,
  ROUNDING_MODE_FLOOR = 1,
  ROUNDING_MODE_CEIL = 2,
  ROUNDING_MODE_TRUNC = 3,
  RoundingMode_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  RoundingMode_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t RoundingMode_internal_data_[];
inline constexpr RoundingMode RoundingMode_MIN =
    static_cast<RoundingMode>(0);
inline constexpr RoundingMode RoundingMode_MAX =
    static_cast<RoundingMode>(3);
inline bool RoundingMode_IsValid(int value) {
  return 0 <= value && value <= 3;
}
inline constexpr int RoundingMode_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL RoundingMode_descriptor();
template <typename T>
const ::std::string& RoundingMode_Name(T value) {
  static_assert(::std::is_same<T, RoundingMode>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to RoundingMode_Name().");
  return RoundingMode_Name(static_cast<RoundingMode>(value));
}
template <>
inline const ::std::string& RoundingMode_Name(RoundingMode value) {
  return ::google::protobuf::internal::NameOfDenseEnum<RoundingMode_descriptor, 0, 3>(
      static_cast<int>(value));
}
inline bool RoundingMode_Parse(
    ::absl::string_view name, RoundingMode* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<RoundingMode>(RoundingMode_descriptor(), name,
                                           value);
}
enum SamplerType : int {
  SAMPLER_QMC = 0,
  SAMPLER_BEST_CANDIDATE = 1,
  SamplerType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  SamplerType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t SamplerType_internal_data_[];
inline constexpr SamplerType SamplerType_MIN =
    static_cast<SamplerType>(0);
inline constexpr SamplerType SamplerType_MAX =
    static_cast<SamplerType>(1);
inline bool SamplerType_IsValid(int value) {
  return 0 <= value && value <= 1;
}
inline constexpr int SamplerType_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL SamplerType_descriptor();
template <typename T>
const ::std::string& SamplerType_Name(T value) {
  static_assert(::std::is_same<T, SamplerType>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to SamplerType_Name().");
  return SamplerType_Name(static_cast<SamplerType>(value));
}
template <>
inline const ::std::string& SamplerType_Name(SamplerType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<SamplerType_descriptor, 0, 1>(
      static_cast<int>(value));
}
inline bool SamplerType_Parse(
    ::absl::string_view name, SamplerType* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<SamplerType>(SamplerType_descriptor(), name,
                                           value);
}
enum ScriptExecuteType : int {
  SCRIPT_EX_NONE = 0,
  SCRIPT_EX_EVAL = 1,
  SCRIPT_EX_INIT = 2,
  SCRIPT_EX_TRIGGER = 3,
  ScriptExecuteType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  ScriptExecuteType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t ScriptExecuteType_internal_data_[];
inline constexpr ScriptExecuteType ScriptExecuteType_MIN =
    static_cast<ScriptExecuteType>(0);
inline constexpr ScriptExecuteType ScriptExecuteType_MAX =
    static_cast<ScriptExecuteType>(3);
inline bool ScriptExecuteType_IsValid(int value) {
  return 0 <= value && value <= 3;
}
inline constexpr int ScriptExecuteType_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL ScriptExecuteType_descriptor();
template <typename T>
const ::std::string& ScriptExecuteType_Name(T value) {
  static_assert(::std::is_same<T, ScriptExecuteType>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to ScriptExecuteType_Name().");
  return ScriptExecuteType_Name(static_cast<ScriptExecuteType>(value));
}
template <>
inline const ::std::string& ScriptExecuteType_Name(ScriptExecuteType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ScriptExecuteType_descriptor, 0, 3>(
      static_cast<int>(value));
}
inline bool ScriptExecuteType_Parse(
    ::absl::string_view name, ScriptExecuteType* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<ScriptExecuteType>(ScriptExecuteType_descriptor(), name,
                                           value);
}
enum SharedSurfaceType : int {
  SHARED_SURFACE_TYPE_NONE = 0,
  SHARED_SURFACE_TYPE_D3D11 = 1,
  SharedSurfaceType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  SharedSurfaceType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t SharedSurfaceType_internal_data_[];
inline constexpr SharedSurfaceType SharedSurfaceType_MIN =
    static_cast<SharedSurfaceType>(0);
inline constexpr SharedSurfaceType SharedSurfaceType_MAX =
    static_cast<SharedSurfaceType>(1);
inline bool SharedSurfaceType_IsValid(int value) {
  return 0 <= value && value <= 1;
}
inline constexpr int SharedSurfaceType_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL SharedSurfaceType_descriptor();
template <typename T>
const ::std::string& SharedSurfaceType_Name(T value) {
  static_assert(::std::is_same<T, SharedSurfaceType>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to SharedSurfaceType_Name().");
  return SharedSurfaceType_Name(static_cast<SharedSurfaceType>(value));
}
template <>
inline const ::std::string& SharedSurfaceType_Name(SharedSurfaceType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<SharedSurfaceType_descriptor, 0, 1>(
      static_cast<int>(value));
}
inline bool SharedSurfaceType_Parse(
    ::absl::string_view name, SharedSurfaceType* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<SharedSurfaceType>(SharedSurfaceType_descriptor(), name,
                                           value);
}
enum ShutterIntervalAlignment : int {
  ShutterIntervalAlignment_UNSPECIFIED = 0,
  SHUTTER_INTERVAL_BEFORE = 1,
  SHUTTER_INTERVAL_SYMMETRIC = 2,
  SHUTTER_INTERVAL_AFTER = 3,
  ShutterIntervalAlignment_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  ShutterIntervalAlignment_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t ShutterIntervalAlignment_internal_data_[];
inline constexpr ShutterIntervalAlignment ShutterIntervalAlignment_MIN =
    static_cast<ShutterIntervalAlignment>(0);
inline constexpr ShutterIntervalAlignment ShutterIntervalAlignment_MAX =
    static_cast<ShutterIntervalAlignment>(3);
inline bool ShutterIntervalAlignment_IsValid(int value) {
  return 0 <= value && value <= 3;
}
inline constexpr int ShutterIntervalAlignment_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL ShutterIntervalAlignment_descriptor();
template <typename T>
const ::std::string& ShutterIntervalAlignment_Name(T value) {
  static_assert(::std::is_same<T, ShutterIntervalAlignment>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to ShutterIntervalAlignment_Name().");
  return ShutterIntervalAlignment_Name(static_cast<ShutterIntervalAlignment>(value));
}
template <>
inline const ::std::string& ShutterIntervalAlignment_Name(ShutterIntervalAlignment value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ShutterIntervalAlignment_descriptor, 0, 3>(
      static_cast<int>(value));
}
inline bool ShutterIntervalAlignment_Parse(
    ::absl::string_view name, ShutterIntervalAlignment* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<ShutterIntervalAlignment>(ShutterIntervalAlignment_descriptor(), name,
                                           value);
}
enum SimulatedLens : int {
  SimulatedLens_UNSPECIFIED = 0,
  LENS_SIMPLE_100MM = 1,
  LENS_FILM_100MM = 2,
  LENS_PORTRAIT_58MM = 3,
  LENS_PETZVAL_100MM = 4,
  LENS_WIDE_28MM = 5,
  LENS_FISHEYE_14MM = 6,
  LENS_PETZVAL_85MM = 7,
  LENS_FILM_40MM = 8,
  LENS_LENS_50MM_F125 = 9,
  LENS_GAUSS_58MM = 10,
  LENS_LENS_50MM_F140 = 11,
  LENS_LENS_50MM_F200 = 12,
  LENS_RETROFOCUS_35MM = 13,
  LENS_FISHEYE_16MM = 14,
  LENS_LENS_35MM_F180 = 15,
  LENS_ANASTIGMATIC_31MM = 16,
  SimulatedLens_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  SimulatedLens_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t SimulatedLens_internal_data_[];
inline constexpr SimulatedLens SimulatedLens_MIN =
    static_cast<SimulatedLens>(0);
inline constexpr SimulatedLens SimulatedLens_MAX =
    static_cast<SimulatedLens>(16);
inline bool SimulatedLens_IsValid(int value) {
  return 0 <= value && value <= 16;
}
inline constexpr int SimulatedLens_ARRAYSIZE = 16 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL SimulatedLens_descriptor();
template <typename T>
const ::std::string& SimulatedLens_Name(T value) {
  static_assert(::std::is_same<T, SimulatedLens>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to SimulatedLens_Name().");
  return SimulatedLens_Name(static_cast<SimulatedLens>(value));
}
template <>
inline const ::std::string& SimulatedLens_Name(SimulatedLens value) {
  return ::google::protobuf::internal::NameOfDenseEnum<SimulatedLens_descriptor, 0, 16>(
      static_cast<int>(value));
}
inline bool SimulatedLens_Parse(
    ::absl::string_view name, SimulatedLens* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<SimulatedLens>(SimulatedLens_descriptor(), name,
                                           value);
}
enum SpotlightOrientation : int {
  SpotlightOrientation_UNSPECIFIED = 0,
  SPOTLIGHT_NORMAL = 1,
  SPOTLIGHT_DIRECTION = 2,
  SPOTLIGHT_DIRECTION_OBJECT = 3,
  SPOTLIGHT_TARGET = 4,
  SPOTLIGHT_TARGET_OBJECT = 5,
  SpotlightOrientation_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  SpotlightOrientation_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t SpotlightOrientation_internal_data_[];
inline constexpr SpotlightOrientation SpotlightOrientation_MIN =
    static_cast<SpotlightOrientation>(0);
inline constexpr SpotlightOrientation SpotlightOrientation_MAX =
    static_cast<SpotlightOrientation>(5);
inline bool SpotlightOrientation_IsValid(int value) {
  return 0 <= value && value <= 5;
}
inline constexpr int SpotlightOrientation_ARRAYSIZE = 5 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL SpotlightOrientation_descriptor();
template <typename T>
const ::std::string& SpotlightOrientation_Name(T value) {
  static_assert(::std::is_same<T, SpotlightOrientation>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to SpotlightOrientation_Name().");
  return SpotlightOrientation_Name(static_cast<SpotlightOrientation>(value));
}
template <>
inline const ::std::string& SpotlightOrientation_Name(SpotlightOrientation value) {
  return ::google::protobuf::internal::NameOfDenseEnum<SpotlightOrientation_descriptor, 0, 5>(
      static_cast<int>(value));
}
inline bool SpotlightOrientation_Parse(
    ::absl::string_view name, SpotlightOrientation* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<SpotlightOrientation>(SpotlightOrientation_descriptor(), name,
                                           value);
}
enum StereoMode : int {
  StereoMode_UNSPECIFIED = 0,
  STEREO_MODE_OFF_AXIS = 1,
  STEREO_MODE_PARALLEL = 2,
  StereoMode_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  StereoMode_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t StereoMode_internal_data_[];
inline constexpr StereoMode StereoMode_MIN =
    static_cast<StereoMode>(0);
inline constexpr StereoMode StereoMode_MAX =
    static_cast<StereoMode>(2);
inline bool StereoMode_IsValid(int value) {
  return 0 <= value && value <= 2;
}
inline constexpr int StereoMode_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL StereoMode_descriptor();
template <typename T>
const ::std::string& StereoMode_Name(T value) {
  static_assert(::std::is_same<T, StereoMode>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to StereoMode_Name().");
  return StereoMode_Name(static_cast<StereoMode>(value));
}
template <>
inline const ::std::string& StereoMode_Name(StereoMode value) {
  return ::google::protobuf::internal::NameOfDenseEnum<StereoMode_descriptor, 0, 2>(
      static_cast<int>(value));
}
inline bool StereoMode_Parse(
    ::absl::string_view name, StereoMode* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<StereoMode>(StereoMode_descriptor(), name,
                                           value);
}
enum StereoOutput : int {
  STEREO_OUTPUT_DISABLED = 0,
  STEREO_OUTPUT_LEFT_EYE = 1,
  STEREO_OUTPUT_RIGHT_EYE = 2,
  STEREO_OUTPUT_SIDE_BY_SIDE = 3,
  STEREO_OUTPUT_ANAGLYPHIC = 4,
  STEREO_OUTPUT_OVER_UNDER = 5,
  StereoOutput_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  StereoOutput_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t StereoOutput_internal_data_[];
inline constexpr StereoOutput StereoOutput_MIN =
    static_cast<StereoOutput>(0);
inline constexpr StereoOutput StereoOutput_MAX =
    static_cast<StereoOutput>(5);
inline bool StereoOutput_IsValid(int value) {
  return 0 <= value && value <= 5;
}
inline constexpr int StereoOutput_ARRAYSIZE = 5 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL StereoOutput_descriptor();
template <typename T>
const ::std::string& StereoOutput_Name(T value) {
  static_assert(::std::is_same<T, StereoOutput>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to StereoOutput_Name().");
  return StereoOutput_Name(static_cast<StereoOutput>(value));
}
template <>
inline const ::std::string& StereoOutput_Name(StereoOutput value) {
  return ::google::protobuf::internal::NameOfDenseEnum<StereoOutput_descriptor, 0, 5>(
      static_cast<int>(value));
}
inline bool StereoOutput_Parse(
    ::absl::string_view name, StereoOutput* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<StereoOutput>(StereoOutput_descriptor(), name,
                                           value);
}
enum SubDivSchemeType : int {
  SubDivSchemeType_UNSPECIFIED = 0,
  SUBDIV_CATMARK = 1,
  SUBDIV_LOOP = 2,
  SUBDIV_BILINEAR = 3,
  SUBDIV_CATMARK_SMOOTH = 4,
  SubDivSchemeType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  SubDivSchemeType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t SubDivSchemeType_internal_data_[];
inline constexpr SubDivSchemeType SubDivSchemeType_MIN =
    static_cast<SubDivSchemeType>(0);
inline constexpr SubDivSchemeType SubDivSchemeType_MAX =
    static_cast<SubDivSchemeType>(4);
inline bool SubDivSchemeType_IsValid(int value) {
  return 0 <= value && value <= 4;
}
inline constexpr int SubDivSchemeType_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL SubDivSchemeType_descriptor();
template <typename T>
const ::std::string& SubDivSchemeType_Name(T value) {
  static_assert(::std::is_same<T, SubDivSchemeType>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to SubDivSchemeType_Name().");
  return SubDivSchemeType_Name(static_cast<SubDivSchemeType>(value));
}
template <>
inline const ::std::string& SubDivSchemeType_Name(SubDivSchemeType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<SubDivSchemeType_descriptor, 0, 4>(
      static_cast<int>(value));
}
inline bool SubDivSchemeType_Parse(
    ::absl::string_view name, SubDivSchemeType* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<SubDivSchemeType>(SubDivSchemeType_descriptor(), name,
                                           value);
}
enum SubDivInterpolateBoundary : int {
  SubDivInterpolateBoundary_UNSPECIFIED = 0,
  SUBDIV_BOUNDARY_NONE = 1,
  SUBDIV_BOUNDARY_EDGEONLY = 2,
  SUBDIV_BOUNDARY_EDGEANDCORNER = 3,
  SUBDIV_BOUNDARY_ALWAYSSHARP = 4,
  SubDivInterpolateBoundary_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  SubDivInterpolateBoundary_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t SubDivInterpolateBoundary_internal_data_[];
inline constexpr SubDivInterpolateBoundary SubDivInterpolateBoundary_MIN =
    static_cast<SubDivInterpolateBoundary>(0);
inline constexpr SubDivInterpolateBoundary SubDivInterpolateBoundary_MAX =
    static_cast<SubDivInterpolateBoundary>(4);
inline bool SubDivInterpolateBoundary_IsValid(int value) {
  return 0 <= value && value <= 4;
}
inline constexpr int SubDivInterpolateBoundary_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL SubDivInterpolateBoundary_descriptor();
template <typename T>
const ::std::string& SubDivInterpolateBoundary_Name(T value) {
  static_assert(::std::is_same<T, SubDivInterpolateBoundary>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to SubDivInterpolateBoundary_Name().");
  return SubDivInterpolateBoundary_Name(static_cast<SubDivInterpolateBoundary>(value));
}
template <>
inline const ::std::string& SubDivInterpolateBoundary_Name(SubDivInterpolateBoundary value) {
  return ::google::protobuf::internal::NameOfDenseEnum<SubDivInterpolateBoundary_descriptor, 0, 4>(
      static_cast<int>(value));
}
inline bool SubDivInterpolateBoundary_Parse(
    ::absl::string_view name, SubDivInterpolateBoundary* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<SubDivInterpolateBoundary>(SubDivInterpolateBoundary_descriptor(), name,
                                           value);
}
enum SubDivFVarInterpolateBoundary : int {
  SubDivFVarInterpolateBoundary_UNSPECIFIED = 0,
  SUBDIV_FVAR_LINEAR_ALL = 1,
  SUBDIV_FVAR_LINEAR_NONE = 2,
  SUBDIV_FVAR_LINEAR_CORNERS_PLUS = 3,
  SUBDIV_FVAR_LINEAR_BOUNDARIES = 4,
  SUBDIV_FVAR_LINEAR_CORNERS_ONLY = 5,
  SubDivFVarInterpolateBoundary_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  SubDivFVarInterpolateBoundary_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t SubDivFVarInterpolateBoundary_internal_data_[];
inline constexpr SubDivFVarInterpolateBoundary SubDivFVarInterpolateBoundary_MIN =
    static_cast<SubDivFVarInterpolateBoundary>(0);
inline constexpr SubDivFVarInterpolateBoundary SubDivFVarInterpolateBoundary_MAX =
    static_cast<SubDivFVarInterpolateBoundary>(5);
inline bool SubDivFVarInterpolateBoundary_IsValid(int value) {
  return 0 <= value && value <= 5;
}
inline constexpr int SubDivFVarInterpolateBoundary_ARRAYSIZE = 5 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL SubDivFVarInterpolateBoundary_descriptor();
template <typename T>
const ::std::string& SubDivFVarInterpolateBoundary_Name(T value) {
  static_assert(::std::is_same<T, SubDivFVarInterpolateBoundary>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to SubDivFVarInterpolateBoundary_Name().");
  return SubDivFVarInterpolateBoundary_Name(static_cast<SubDivFVarInterpolateBoundary>(value));
}
template <>
inline const ::std::string& SubDivFVarInterpolateBoundary_Name(SubDivFVarInterpolateBoundary value) {
  return ::google::protobuf::internal::NameOfDenseEnum<SubDivFVarInterpolateBoundary_descriptor, 0, 5>(
      static_cast<int>(value));
}
inline bool SubDivFVarInterpolateBoundary_Parse(
    ::absl::string_view name, SubDivFVarInterpolateBoundary* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<SubDivFVarInterpolateBoundary>(SubDivFVarInterpolateBoundary_descriptor(), name,
                                           value);
}
enum SubSampleMode : int {
  SubSampleMode_UNSPECIFIED = 0,
  SUBSAMPLEMODE_NONE = 1,
  SUBSAMPLEMODE_2X2 = 2,
  SUBSAMPLEMODE_4X4 = 4,
  SubSampleMode_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  SubSampleMode_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t SubSampleMode_internal_data_[];
inline constexpr SubSampleMode SubSampleMode_MIN =
    static_cast<SubSampleMode>(0);
inline constexpr SubSampleMode SubSampleMode_MAX =
    static_cast<SubSampleMode>(4);
inline bool SubSampleMode_IsValid(int value) {
  return 0 <= value && value <= 4 && ((23u >> value) & 1) != 0;
}
inline constexpr int SubSampleMode_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL SubSampleMode_descriptor();
template <typename T>
const ::std::string& SubSampleMode_Name(T value) {
  static_assert(::std::is_same<T, SubSampleMode>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to SubSampleMode_Name().");
  return SubSampleMode_Name(static_cast<SubSampleMode>(value));
}
template <>
inline const ::std::string& SubSampleMode_Name(SubSampleMode value) {
  return ::google::protobuf::internal::NameOfDenseEnum<SubSampleMode_descriptor, 0, 4>(
      static_cast<int>(value));
}
inline bool SubSampleMode_Parse(
    ::absl::string_view name, SubSampleMode* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<SubSampleMode>(SubSampleMode_descriptor(), name,
                                           value);
}
enum TexelType : int {
  TEXEL_TYPE_IMAGE = 0,
  TEXEL_TYPE_FLOAT = 1,
  TEXEL_TYPE_FLOAT4 = 2,
  TexelType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  TexelType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t TexelType_internal_data_[];
inline constexpr TexelType TexelType_MIN =
    static_cast<TexelType>(0);
inline constexpr TexelType TexelType_MAX =
    static_cast<TexelType>(2);
inline bool TexelType_IsValid(int value) {
  return 0 <= value && value <= 2;
}
inline constexpr int TexelType_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL TexelType_descriptor();
template <typename T>
const ::std::string& TexelType_Name(T value) {
  static_assert(::std::is_same<T, TexelType>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to TexelType_Name().");
  return TexelType_Name(static_cast<TexelType>(value));
}
template <>
inline const ::std::string& TexelType_Name(TexelType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<TexelType_descriptor, 0, 2>(
      static_cast<int>(value));
}
inline bool TexelType_Parse(
    ::absl::string_view name, TexelType* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<TexelType>(TexelType_descriptor(), name,
                                           value);
}
enum TiffCompressionType : int {
  TiffCompressionType_UNSPECIFIED = 0,
  TIFF_COMPRESSION_NO_COMPRESSION = 1,
  TIFF_COMPRESSION_DEFLATE = 2,
  TIFF_COMPRESSION_LZW = 3,
  TIFF_COMPRESSION_PACK_BITS = 4,
  TiffCompressionType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  TiffCompressionType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t TiffCompressionType_internal_data_[];
inline constexpr TiffCompressionType TiffCompressionType_MIN =
    static_cast<TiffCompressionType>(0);
inline constexpr TiffCompressionType TiffCompressionType_MAX =
    static_cast<TiffCompressionType>(4);
inline bool TiffCompressionType_IsValid(int value) {
  return 0 <= value && value <= 4;
}
inline constexpr int TiffCompressionType_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL TiffCompressionType_descriptor();
template <typename T>
const ::std::string& TiffCompressionType_Name(T value) {
  static_assert(::std::is_same<T, TiffCompressionType>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to TiffCompressionType_Name().");
  return TiffCompressionType_Name(static_cast<TiffCompressionType>(value));
}
template <>
inline const ::std::string& TiffCompressionType_Name(TiffCompressionType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<TiffCompressionType_descriptor, 0, 4>(
      static_cast<int>(value));
}
inline bool TiffCompressionType_Parse(
    ::absl::string_view name, TiffCompressionType* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<TiffCompressionType>(TiffCompressionType_descriptor(), name,
                                           value);
}
enum TilePatternType : int {
  TILE_PATTERN_BRICKS = 0,
  TILE_PATTERN_FANCY_TILES = 1,
  TILE_PATTERN_HEXAGONS = 2,
  TILE_PATTERN_SCALES = 3,
  TILE_PATTERN_TRIANGLES = 4,
  TILE_PATTERN_VORONOI = 5,
  TilePatternType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  TilePatternType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t TilePatternType_internal_data_[];
inline constexpr TilePatternType TilePatternType_MIN =
    static_cast<TilePatternType>(0);
inline constexpr TilePatternType TilePatternType_MAX =
    static_cast<TilePatternType>(5);
inline bool TilePatternType_IsValid(int value) {
  return 0 <= value && value <= 5;
}
inline constexpr int TilePatternType_ARRAYSIZE = 5 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL TilePatternType_descriptor();
template <typename T>
const ::std::string& TilePatternType_Name(T value) {
  static_assert(::std::is_same<T, TilePatternType>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to TilePatternType_Name().");
  return TilePatternType_Name(static_cast<TilePatternType>(value));
}
template <>
inline const ::std::string& TilePatternType_Name(TilePatternType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<TilePatternType_descriptor, 0, 5>(
      static_cast<int>(value));
}
inline bool TilePatternType_Parse(
    ::absl::string_view name, TilePatternType* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<TilePatternType>(TilePatternType_descriptor(), name,
                                           value);
}
enum TimeEventType : int {
  GRAPH_TIME_CHANGED = 0,
  GRAPH_INTERVAL_CHANGED = 1,
  FRAME_RATE_CHANGED = 2,
  TimeEventType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  TimeEventType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t TimeEventType_internal_data_[];
inline constexpr TimeEventType TimeEventType_MIN =
    static_cast<TimeEventType>(0);
inline constexpr TimeEventType TimeEventType_MAX =
    static_cast<TimeEventType>(2);
inline bool TimeEventType_IsValid(int value) {
  return 0 <= value && value <= 2;
}
inline constexpr int TimeEventType_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL TimeEventType_descriptor();
template <typename T>
const ::std::string& TimeEventType_Name(T value) {
  static_assert(::std::is_same<T, TimeEventType>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to TimeEventType_Name().");
  return TimeEventType_Name(static_cast<TimeEventType>(value));
}
template <>
inline const ::std::string& TimeEventType_Name(TimeEventType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<TimeEventType_descriptor, 0, 2>(
      static_cast<int>(value));
}
inline bool TimeEventType_Parse(
    ::absl::string_view name, TimeEventType* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<TimeEventType>(TimeEventType_descriptor(), name,
                                           value);
}
enum TonemapOrder : int {
  TM_ORDER_RESPONSE_GAMMA_LUT = 0,
  TM_ORDER_GAMMA_RESPONSE_LUT = 1,
  TM_ORDER_LUT_RESPONSE_GAMMA = 2,
  TM_ORDER_LUT_GAMMA_RESPONSE = 3,
  TM_ORDER_RESPONSE_LUT_GAMMA = 4,
  TM_ORDER_GAMMA_LUT_RESPONSE = 5,
  TonemapOrder_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  TonemapOrder_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t TonemapOrder_internal_data_[];
inline constexpr TonemapOrder TonemapOrder_MIN =
    static_cast<TonemapOrder>(0);
inline constexpr TonemapOrder TonemapOrder_MAX =
    static_cast<TonemapOrder>(5);
inline bool TonemapOrder_IsValid(int value) {
  return 0 <= value && value <= 5;
}
inline constexpr int TonemapOrder_ARRAYSIZE = 5 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL TonemapOrder_descriptor();
template <typename T>
const ::std::string& TonemapOrder_Name(T value) {
  static_assert(::std::is_same<T, TonemapOrder>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to TonemapOrder_Name().");
  return TonemapOrder_Name(static_cast<TonemapOrder>(value));
}
template <>
inline const ::std::string& TonemapOrder_Name(TonemapOrder value) {
  return ::google::protobuf::internal::NameOfDenseEnum<TonemapOrder_descriptor, 0, 5>(
      static_cast<int>(value));
}
inline bool TonemapOrder_Parse(
    ::absl::string_view name, TonemapOrder* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<TonemapOrder>(TonemapOrder_descriptor(), name,
                                           value);
}
enum TonemapBufferType : int {
  TONEMAP_BUFFER_TYPE_LDR = 0,
  TONEMAP_BUFFER_TYPE_HDR_FLOAT = 1,
  TONEMAP_BUFFER_TYPE_HDR_HALF = 2,
  TONEMAP_BUFFER_TYPE_COUNT = 3,
  TonemapBufferType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  TonemapBufferType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t TonemapBufferType_internal_data_[];
inline constexpr TonemapBufferType TonemapBufferType_MIN =
    static_cast<TonemapBufferType>(0);
inline constexpr TonemapBufferType TonemapBufferType_MAX =
    static_cast<TonemapBufferType>(3);
inline bool TonemapBufferType_IsValid(int value) {
  return 0 <= value && value <= 3;
}
inline constexpr int TonemapBufferType_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL TonemapBufferType_descriptor();
template <typename T>
const ::std::string& TonemapBufferType_Name(T value) {
  static_assert(::std::is_same<T, TonemapBufferType>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to TonemapBufferType_Name().");
  return TonemapBufferType_Name(static_cast<TonemapBufferType>(value));
}
template <>
inline const ::std::string& TonemapBufferType_Name(TonemapBufferType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<TonemapBufferType_descriptor, 0, 3>(
      static_cast<int>(value));
}
inline bool TonemapBufferType_Parse(
    ::absl::string_view name, TonemapBufferType* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<TonemapBufferType>(TonemapBufferType_descriptor(), name,
                                           value);
}
enum ToonLightMode : int {
  TOON_LIGHT_SOURCES = 0,
  TOON_LIGHT_CAMERA = 1,
  ToonLightMode_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  ToonLightMode_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t ToonLightMode_internal_data_[];
inline constexpr ToonLightMode ToonLightMode_MIN =
    static_cast<ToonLightMode>(0);
inline constexpr ToonLightMode ToonLightMode_MAX =
    static_cast<ToonLightMode>(1);
inline bool ToonLightMode_IsValid(int value) {
  return 0 <= value && value <= 1;
}
inline constexpr int ToonLightMode_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL ToonLightMode_descriptor();
template <typename T>
const ::std::string& ToonLightMode_Name(T value) {
  static_assert(::std::is_same<T, ToonLightMode>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to ToonLightMode_Name().");
  return ToonLightMode_Name(static_cast<ToonLightMode>(value));
}
template <>
inline const ::std::string& ToonLightMode_Name(ToonLightMode value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ToonLightMode_descriptor, 0, 1>(
      static_cast<int>(value));
}
inline bool ToonLightMode_Parse(
    ::absl::string_view name, ToonLightMode* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<ToonLightMode>(ToonLightMode_descriptor(), name,
                                           value);
}
enum TraceSetBounceType : int {
  TRACE_SET_BOUNCE_TYPE_REFLECTION = 0,
  TRACE_SET_BOUNCE_TYPE_REFRACTION = 1,
  TRACE_SET_BOUNCE_TYPE_DIFFUSE = 2,
  TRACE_SET_BOUNCE_TYPE_SHADOW = 3,
  TRACE_SET_BOUNCE_TYPE_COUNT = 4,
  TraceSetBounceType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  TraceSetBounceType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t TraceSetBounceType_internal_data_[];
inline constexpr TraceSetBounceType TraceSetBounceType_MIN =
    static_cast<TraceSetBounceType>(0);
inline constexpr TraceSetBounceType TraceSetBounceType_MAX =
    static_cast<TraceSetBounceType>(4);
inline bool TraceSetBounceType_IsValid(int value) {
  return 0 <= value && value <= 4;
}
inline constexpr int TraceSetBounceType_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL TraceSetBounceType_descriptor();
template <typename T>
const ::std::string& TraceSetBounceType_Name(T value) {
  static_assert(::std::is_same<T, TraceSetBounceType>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to TraceSetBounceType_Name().");
  return TraceSetBounceType_Name(static_cast<TraceSetBounceType>(value));
}
template <>
inline const ::std::string& TraceSetBounceType_Name(TraceSetBounceType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<TraceSetBounceType_descriptor, 0, 4>(
      static_cast<int>(value));
}
inline bool TraceSetBounceType_Parse(
    ::absl::string_view name, TraceSetBounceType* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<TraceSetBounceType>(TraceSetBounceType_descriptor(), name,
                                           value);
}
enum TraceSetFutureHits : int {
  TRACE_SET_FUTURE_HITS_NEXT_HIT = 0,
  TRACE_SET_FUTURE_HITS_HITS_AFTER_NEXT_HIT = 1,
  TRACE_SET_FUTURE_HITS_COUNT = 2,
  TraceSetFutureHits_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  TraceSetFutureHits_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t TraceSetFutureHits_internal_data_[];
inline constexpr TraceSetFutureHits TraceSetFutureHits_MIN =
    static_cast<TraceSetFutureHits>(0);
inline constexpr TraceSetFutureHits TraceSetFutureHits_MAX =
    static_cast<TraceSetFutureHits>(2);
inline bool TraceSetFutureHits_IsValid(int value) {
  return 0 <= value && value <= 2;
}
inline constexpr int TraceSetFutureHits_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL TraceSetFutureHits_descriptor();
template <typename T>
const ::std::string& TraceSetFutureHits_Name(T value) {
  static_assert(::std::is_same<T, TraceSetFutureHits>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to TraceSetFutureHits_Name().");
  return TraceSetFutureHits_Name(static_cast<TraceSetFutureHits>(value));
}
template <>
inline const ::std::string& TraceSetFutureHits_Name(TraceSetFutureHits value) {
  return ::google::protobuf::internal::NameOfDenseEnum<TraceSetFutureHits_descriptor, 0, 2>(
      static_cast<int>(value));
}
inline bool TraceSetFutureHits_Parse(
    ::absl::string_view name, TraceSetFutureHits* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<TraceSetFutureHits>(TraceSetFutureHits_descriptor(), name,
                                           value);
}
enum UIOperationsFlag : int {
  UIOperationsFlag_UNSPECIFIED = 0,
  UI_OPERATION_DELETABLE = 1,
  UI_OPERATION_RENAMABLE = 4,
  UI_OPERATION_ALL = 5,
  UIOperationsFlag_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  UIOperationsFlag_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t UIOperationsFlag_internal_data_[];
inline constexpr UIOperationsFlag UIOperationsFlag_MIN =
    static_cast<UIOperationsFlag>(0);
inline constexpr UIOperationsFlag UIOperationsFlag_MAX =
    static_cast<UIOperationsFlag>(5);
inline bool UIOperationsFlag_IsValid(int value) {
  return 0 <= value && value <= 5 && ((51u >> value) & 1) != 0;
}
inline constexpr int UIOperationsFlag_ARRAYSIZE = 5 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL UIOperationsFlag_descriptor();
template <typename T>
const ::std::string& UIOperationsFlag_Name(T value) {
  static_assert(::std::is_same<T, UIOperationsFlag>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to UIOperationsFlag_Name().");
  return UIOperationsFlag_Name(static_cast<UIOperationsFlag>(value));
}
template <>
inline const ::std::string& UIOperationsFlag_Name(UIOperationsFlag value) {
  return ::google::protobuf::internal::NameOfDenseEnum<UIOperationsFlag_descriptor, 0, 5>(
      static_cast<int>(value));
}
inline bool UIOperationsFlag_Parse(
    ::absl::string_view name, UIOperationsFlag* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<UIOperationsFlag>(UIOperationsFlag_descriptor(), name,
                                           value);
}
enum UnaryOperation : int {
  UNARY_OP_ABS = 0,
  UNARY_OP_ACOS = 1,
  UNARY_OP_ASIN = 2,
  UNARY_OP_ATAN = 3,
  UNARY_OP_CEIL = 4,
  UNARY_OP_COS = 5,
  UNARY_OP_COSH = 6,
  UNARY_OP_DEGREES = 7,
  UNARY_OP_EXP = 8,
  UNARY_OP_EXP2 = 9,
  UNARY_OP_EXPM1 = 10,
  UNARY_OP_FLOOR = 11,
  UNARY_OP_FRAC = 12,
  UNARY_OP_INVERSE_SQRT = 13,
  UNARY_OP_INVERT = 14,
  UNARY_OP_LOG = 15,
  UNARY_OP_LOG2 = 16,
  UNARY_OP_LOG10 = 17,
  UNARY_OP_LOGB = 18,
  UNARY_OP_NEGATE = 19,
  UNARY_OP_RADIANS = 20,
  UNARY_OP_RECIPROCAL = 21,
  UNARY_OP_ROUND = 22,
  UNARY_OP_SIGN = 23,
  UNARY_OP_SIN = 24,
  UNARY_OP_SINH = 25,
  UNARY_OP_SQRT = 26,
  UNARY_OP_TAN = 27,
  UNARY_OP_TANH = 28,
  UNARY_OP_TRUNC = 29,
  UNARY_OP_LENGTH = 30,
  UNARY_OP_NORMALIZE = 31,
  UnaryOperation_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  UnaryOperation_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t UnaryOperation_internal_data_[];
inline constexpr UnaryOperation UnaryOperation_MIN =
    static_cast<UnaryOperation>(0);
inline constexpr UnaryOperation UnaryOperation_MAX =
    static_cast<UnaryOperation>(31);
inline bool UnaryOperation_IsValid(int value) {
  return 0 <= value && value <= 31;
}
inline constexpr int UnaryOperation_ARRAYSIZE = 31 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL UnaryOperation_descriptor();
template <typename T>
const ::std::string& UnaryOperation_Name(T value) {
  static_assert(::std::is_same<T, UnaryOperation>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to UnaryOperation_Name().");
  return UnaryOperation_Name(static_cast<UnaryOperation>(value));
}
template <>
inline const ::std::string& UnaryOperation_Name(UnaryOperation value) {
  return ::google::protobuf::internal::NameOfDenseEnum<UnaryOperation_descriptor, 0, 31>(
      static_cast<int>(value));
}
inline bool UnaryOperation_Parse(
    ::absl::string_view name, UnaryOperation* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<UnaryOperation>(UnaryOperation_descriptor(), name,
                                           value);
}
enum UniversalCamApertureShape : int {
  UniversalCamApertureShape_UNSPECIFIED = 0,
  UNIVERSAL_CAM_APERTURE_CIRCULAR = 1,
  UNIVERSAL_CAM_APERTURE_POLYGONAL = 2,
  UNIVERSAL_CAM_APERTURE_NOTCHED = 3,
  UNIVERSAL_CAM_APERTURE_CUSTOM = 4,
  UniversalCamApertureShape_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  UniversalCamApertureShape_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t UniversalCamApertureShape_internal_data_[];
inline constexpr UniversalCamApertureShape UniversalCamApertureShape_MIN =
    static_cast<UniversalCamApertureShape>(0);
inline constexpr UniversalCamApertureShape UniversalCamApertureShape_MAX =
    static_cast<UniversalCamApertureShape>(4);
inline bool UniversalCamApertureShape_IsValid(int value) {
  return 0 <= value && value <= 4;
}
inline constexpr int UniversalCamApertureShape_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL UniversalCamApertureShape_descriptor();
template <typename T>
const ::std::string& UniversalCamApertureShape_Name(T value) {
  static_assert(::std::is_same<T, UniversalCamApertureShape>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to UniversalCamApertureShape_Name().");
  return UniversalCamApertureShape_Name(static_cast<UniversalCamApertureShape>(value));
}
template <>
inline const ::std::string& UniversalCamApertureShape_Name(UniversalCamApertureShape value) {
  return ::google::protobuf::internal::NameOfDenseEnum<UniversalCamApertureShape_descriptor, 0, 4>(
      static_cast<int>(value));
}
inline bool UniversalCamApertureShape_Parse(
    ::absl::string_view name, UniversalCamApertureShape* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<UniversalCamApertureShape>(UniversalCamApertureShape_descriptor(), name,
                                           value);
}
enum UniversalCamCubemapLayout : int {
  UniversalCamCubemapLayout_UNSPECIFIED = 0,
  UNIVERSAL_CAM_CUBEMAP_6X1 = 1,
  UNIVERSAL_CAM_CUBEMAP_3X2 = 2,
  UNIVERSAL_CAM_CUBEMAP_2X3 = 3,
  UNIVERSAL_CAM_CUBEMAP_1X6 = 4,
  UniversalCamCubemapLayout_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  UniversalCamCubemapLayout_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t UniversalCamCubemapLayout_internal_data_[];
inline constexpr UniversalCamCubemapLayout UniversalCamCubemapLayout_MIN =
    static_cast<UniversalCamCubemapLayout>(0);
inline constexpr UniversalCamCubemapLayout UniversalCamCubemapLayout_MAX =
    static_cast<UniversalCamCubemapLayout>(4);
inline bool UniversalCamCubemapLayout_IsValid(int value) {
  return 0 <= value && value <= 4;
}
inline constexpr int UniversalCamCubemapLayout_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL UniversalCamCubemapLayout_descriptor();
template <typename T>
const ::std::string& UniversalCamCubemapLayout_Name(T value) {
  static_assert(::std::is_same<T, UniversalCamCubemapLayout>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to UniversalCamCubemapLayout_Name().");
  return UniversalCamCubemapLayout_Name(static_cast<UniversalCamCubemapLayout>(value));
}
template <>
inline const ::std::string& UniversalCamCubemapLayout_Name(UniversalCamCubemapLayout value) {
  return ::google::protobuf::internal::NameOfDenseEnum<UniversalCamCubemapLayout_descriptor, 0, 4>(
      static_cast<int>(value));
}
inline bool UniversalCamCubemapLayout_Parse(
    ::absl::string_view name, UniversalCamCubemapLayout* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<UniversalCamCubemapLayout>(UniversalCamCubemapLayout_descriptor(), name,
                                           value);
}
enum UniversalCamFisheyeProjection : int {
  UniversalCamFisheyeProjection_UNSPECIFIED = 0,
  UNIVERSAL_CAM_FISHEYE_STEREOGRAPHIC = 1,
  UNIVERSAL_CAM_FISHEYE_EQUIDISTANT = 2,
  UNIVERSAL_CAM_FISHEYE_EQUISOLID = 3,
  UNIVERSAL_CAM_FISHEYE_ORTHOGRAPHIC = 4,
  UniversalCamFisheyeProjection_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  UniversalCamFisheyeProjection_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t UniversalCamFisheyeProjection_internal_data_[];
inline constexpr UniversalCamFisheyeProjection UniversalCamFisheyeProjection_MIN =
    static_cast<UniversalCamFisheyeProjection>(0);
inline constexpr UniversalCamFisheyeProjection UniversalCamFisheyeProjection_MAX =
    static_cast<UniversalCamFisheyeProjection>(4);
inline bool UniversalCamFisheyeProjection_IsValid(int value) {
  return 0 <= value && value <= 4;
}
inline constexpr int UniversalCamFisheyeProjection_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL UniversalCamFisheyeProjection_descriptor();
template <typename T>
const ::std::string& UniversalCamFisheyeProjection_Name(T value) {
  static_assert(::std::is_same<T, UniversalCamFisheyeProjection>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to UniversalCamFisheyeProjection_Name().");
  return UniversalCamFisheyeProjection_Name(static_cast<UniversalCamFisheyeProjection>(value));
}
template <>
inline const ::std::string& UniversalCamFisheyeProjection_Name(UniversalCamFisheyeProjection value) {
  return ::google::protobuf::internal::NameOfDenseEnum<UniversalCamFisheyeProjection_descriptor, 0, 4>(
      static_cast<int>(value));
}
inline bool UniversalCamFisheyeProjection_Parse(
    ::absl::string_view name, UniversalCamFisheyeProjection* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<UniversalCamFisheyeProjection>(UniversalCamFisheyeProjection_descriptor(), name,
                                           value);
}
enum UniversalCamFisheyeType : int {
  UniversalCamFisheyeType_UNSPECIFIED = 0,
  UNIVERSAL_CAM_FISHEYE_CIRCULAR = 1,
  UNIVERSAL_CAM_FISHEYE_FULL_FRAME = 2,
  UniversalCamFisheyeType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  UniversalCamFisheyeType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t UniversalCamFisheyeType_internal_data_[];
inline constexpr UniversalCamFisheyeType UniversalCamFisheyeType_MIN =
    static_cast<UniversalCamFisheyeType>(0);
inline constexpr UniversalCamFisheyeType UniversalCamFisheyeType_MAX =
    static_cast<UniversalCamFisheyeType>(2);
inline bool UniversalCamFisheyeType_IsValid(int value) {
  return 0 <= value && value <= 2;
}
inline constexpr int UniversalCamFisheyeType_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL UniversalCamFisheyeType_descriptor();
template <typename T>
const ::std::string& UniversalCamFisheyeType_Name(T value) {
  static_assert(::std::is_same<T, UniversalCamFisheyeType>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to UniversalCamFisheyeType_Name().");
  return UniversalCamFisheyeType_Name(static_cast<UniversalCamFisheyeType>(value));
}
template <>
inline const ::std::string& UniversalCamFisheyeType_Name(UniversalCamFisheyeType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<UniversalCamFisheyeType_descriptor, 0, 2>(
      static_cast<int>(value));
}
inline bool UniversalCamFisheyeType_Parse(
    ::absl::string_view name, UniversalCamFisheyeType* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<UniversalCamFisheyeType>(UniversalCamFisheyeType_descriptor(), name,
                                           value);
}
enum UniversalCamMode : int {
  UniversalCamMode_UNSPECIFIED = 0,
  UNIVERSAL_CAM_THINLENS = 1,
  UNIVERSAL_CAM_ORTHOGRAPHIC = 2,
  UNIVERSAL_CAM_FISHEYE = 3,
  UNIVERSAL_CAM_EQUIRECTANGULAR = 4,
  UNIVERSAL_CAM_CUBEMAP = 5,
  UniversalCamMode_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  UniversalCamMode_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t UniversalCamMode_internal_data_[];
inline constexpr UniversalCamMode UniversalCamMode_MIN =
    static_cast<UniversalCamMode>(0);
inline constexpr UniversalCamMode UniversalCamMode_MAX =
    static_cast<UniversalCamMode>(5);
inline bool UniversalCamMode_IsValid(int value) {
  return 0 <= value && value <= 5;
}
inline constexpr int UniversalCamMode_ARRAYSIZE = 5 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL UniversalCamMode_descriptor();
template <typename T>
const ::std::string& UniversalCamMode_Name(T value) {
  static_assert(::std::is_same<T, UniversalCamMode>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to UniversalCamMode_Name().");
  return UniversalCamMode_Name(static_cast<UniversalCamMode>(value));
}
template <>
inline const ::std::string& UniversalCamMode_Name(UniversalCamMode value) {
  return ::google::protobuf::internal::NameOfDenseEnum<UniversalCamMode_descriptor, 0, 5>(
      static_cast<int>(value));
}
inline bool UniversalCamMode_Parse(
    ::absl::string_view name, UniversalCamMode* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<UniversalCamMode>(UniversalCamMode_descriptor(), name,
                                           value);
}
enum UpSampleMode : int {
  UpSampleMode_UNSPECIFIED = 0,
  UPSAMPLEMODE_NONE = 1,
  UPSAMPLEMODE_2X2 = 2,
  UPSAMPLEMODE_4X4 = 4,
  UpSampleMode_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  UpSampleMode_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t UpSampleMode_internal_data_[];
inline constexpr UpSampleMode UpSampleMode_MIN =
    static_cast<UpSampleMode>(0);
inline constexpr UpSampleMode UpSampleMode_MAX =
    static_cast<UpSampleMode>(4);
inline bool UpSampleMode_IsValid(int value) {
  return 0 <= value && value <= 4 && ((23u >> value) & 1) != 0;
}
inline constexpr int UpSampleMode_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL UpSampleMode_descriptor();
template <typename T>
const ::std::string& UpSampleMode_Name(T value) {
  static_assert(::std::is_same<T, UpSampleMode>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to UpSampleMode_Name().");
  return UpSampleMode_Name(static_cast<UpSampleMode>(value));
}
template <>
inline const ::std::string& UpSampleMode_Name(UpSampleMode value) {
  return ::google::protobuf::internal::NameOfDenseEnum<UpSampleMode_descriptor, 0, 4>(
      static_cast<int>(value));
}
inline bool UpSampleMode_Parse(
    ::absl::string_view name, UpSampleMode* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<UpSampleMode>(UpSampleMode_descriptor(), name,
                                           value);
}
enum UpSamplerType : int {
  UPSAMPLER_NONE = 0,
  UPSAMPLER_LINEAR = 1,
  UPSAMPLER_LEGACY_AI = 2,
  UPSAMPLER_DLSS = 3,
  UPSAMPLER_DLSS_RR = 4,
  UPSAMPLER_FSR = 5,
  UpSamplerType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  UpSamplerType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t UpSamplerType_internal_data_[];
inline constexpr UpSamplerType UpSamplerType_MIN =
    static_cast<UpSamplerType>(0);
inline constexpr UpSamplerType UpSamplerType_MAX =
    static_cast<UpSamplerType>(5);
inline bool UpSamplerType_IsValid(int value) {
  return 0 <= value && value <= 5;
}
inline constexpr int UpSamplerType_ARRAYSIZE = 5 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL UpSamplerType_descriptor();
template <typename T>
const ::std::string& UpSamplerType_Name(T value) {
  static_assert(::std::is_same<T, UpSamplerType>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to UpSamplerType_Name().");
  return UpSamplerType_Name(static_cast<UpSamplerType>(value));
}
template <>
inline const ::std::string& UpSamplerType_Name(UpSamplerType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<UpSamplerType_descriptor, 0, 5>(
      static_cast<int>(value));
}
inline bool UpSamplerType_Parse(
    ::absl::string_view name, UpSamplerType* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<UpSamplerType>(UpSamplerType_descriptor(), name,
                                           value);
}
enum UpSampleSourcePercentage : int {
  UPSAMPLE_SOURCE_PERCENTAGE_100 = 0,
  UPSAMPLE_SOURCE_PERCENTAGE_66 = 1,
  UPSAMPLE_SOURCE_PERCENTAGE_50 = 2,
  UPSAMPLE_SOURCE_PERCENTAGE_33 = 3,
  UPSAMPLE_SOURCE_PERCENTAGE_25 = 4,
  UpSampleSourcePercentage_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  UpSampleSourcePercentage_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t UpSampleSourcePercentage_internal_data_[];
inline constexpr UpSampleSourcePercentage UpSampleSourcePercentage_MIN =
    static_cast<UpSampleSourcePercentage>(0);
inline constexpr UpSampleSourcePercentage UpSampleSourcePercentage_MAX =
    static_cast<UpSampleSourcePercentage>(4);
inline bool UpSampleSourcePercentage_IsValid(int value) {
  return 0 <= value && value <= 4;
}
inline constexpr int UpSampleSourcePercentage_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL UpSampleSourcePercentage_descriptor();
template <typename T>
const ::std::string& UpSampleSourcePercentage_Name(T value) {
  static_assert(::std::is_same<T, UpSampleSourcePercentage>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to UpSampleSourcePercentage_Name().");
  return UpSampleSourcePercentage_Name(static_cast<UpSampleSourcePercentage>(value));
}
template <>
inline const ::std::string& UpSampleSourcePercentage_Name(UpSampleSourcePercentage value) {
  return ::google::protobuf::internal::NameOfDenseEnum<UpSampleSourcePercentage_descriptor, 0, 4>(
      static_cast<int>(value));
}
inline bool UpSampleSourcePercentage_Parse(
    ::absl::string_view name, UpSampleSourcePercentage* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<UpSampleSourcePercentage>(UpSampleSourcePercentage_descriptor(), name,
                                           value);
}
enum UsdDisplayPurpose : int {
  UsdDisplayPurpose_UNSPECIFIED = 0,
  USD_DISPLAY_PURPOSE_RENDER = 1,
  USD_DISPLAY_PURPOSE_PROXY = 2,
  USD_DISPLAY_PURPOSE_GUIDE = 4,
  UsdDisplayPurpose_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  UsdDisplayPurpose_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t UsdDisplayPurpose_internal_data_[];
inline constexpr UsdDisplayPurpose UsdDisplayPurpose_MIN =
    static_cast<UsdDisplayPurpose>(0);
inline constexpr UsdDisplayPurpose UsdDisplayPurpose_MAX =
    static_cast<UsdDisplayPurpose>(4);
inline bool UsdDisplayPurpose_IsValid(int value) {
  return 0 <= value && value <= 4 && ((23u >> value) & 1) != 0;
}
inline constexpr int UsdDisplayPurpose_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL UsdDisplayPurpose_descriptor();
template <typename T>
const ::std::string& UsdDisplayPurpose_Name(T value) {
  static_assert(::std::is_same<T, UsdDisplayPurpose>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to UsdDisplayPurpose_Name().");
  return UsdDisplayPurpose_Name(static_cast<UsdDisplayPurpose>(value));
}
template <>
inline const ::std::string& UsdDisplayPurpose_Name(UsdDisplayPurpose value) {
  return ::google::protobuf::internal::NameOfDenseEnum<UsdDisplayPurpose_descriptor, 0, 4>(
      static_cast<int>(value));
}
inline bool UsdDisplayPurpose_Parse(
    ::absl::string_view name, UsdDisplayPurpose* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<UsdDisplayPurpose>(UsdDisplayPurpose_descriptor(), name,
                                           value);
}
enum VdbGridIds : int {
  VDB_GRID_USE_NAME = 0,
  VDB_GRID_SCATTER = 1,
  VDB_GRID_ABSORPTION = 2,
  VDB_GRID_EMISSION = 3,
  VDB_GRID_VELOCITY_X = 4,
  VDB_GRID_VELOCITY_Y = 5,
  VDB_GRID_VELOCITY_Z = 6,
  VDB_GRID_VELOCITY = 7,
  VdbGridIds_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  VdbGridIds_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t VdbGridIds_internal_data_[];
inline constexpr VdbGridIds VdbGridIds_MIN =
    static_cast<VdbGridIds>(0);
inline constexpr VdbGridIds VdbGridIds_MAX =
    static_cast<VdbGridIds>(7);
inline bool VdbGridIds_IsValid(int value) {
  return 0 <= value && value <= 7;
}
inline constexpr int VdbGridIds_ARRAYSIZE = 7 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL VdbGridIds_descriptor();
template <typename T>
const ::std::string& VdbGridIds_Name(T value) {
  static_assert(::std::is_same<T, VdbGridIds>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to VdbGridIds_Name().");
  return VdbGridIds_Name(static_cast<VdbGridIds>(value));
}
template <>
inline const ::std::string& VdbGridIds_Name(VdbGridIds value) {
  return ::google::protobuf::internal::NameOfDenseEnum<VdbGridIds_descriptor, 0, 7>(
      static_cast<int>(value));
}
inline bool VdbGridIds_Parse(
    ::absl::string_view name, VdbGridIds* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<VdbGridIds>(VdbGridIds_descriptor(), name,
                                           value);
}
enum VectronCircleType : int {
  CIRCLE_TYPE_CIRCLE = 0,
  CIRCLE_TYPE_SLICE = 1,
  CIRCLE_TYPE_SEGMENT = 2,
  CIRCLE_TYPE_ARC = 3,
  VectronCircleType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  VectronCircleType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t VectronCircleType_internal_data_[];
inline constexpr VectronCircleType VectronCircleType_MIN =
    static_cast<VectronCircleType>(0);
inline constexpr VectronCircleType VectronCircleType_MAX =
    static_cast<VectronCircleType>(3);
inline bool VectronCircleType_IsValid(int value) {
  return 0 <= value && value <= 3;
}
inline constexpr int VectronCircleType_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL VectronCircleType_descriptor();
template <typename T>
const ::std::string& VectronCircleType_Name(T value) {
  static_assert(::std::is_same<T, VectronCircleType>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to VectronCircleType_Name().");
  return VectronCircleType_Name(static_cast<VectronCircleType>(value));
}
template <>
inline const ::std::string& VectronCircleType_Name(VectronCircleType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<VectronCircleType_descriptor, 0, 3>(
      static_cast<int>(value));
}
inline bool VectronCircleType_Parse(
    ::absl::string_view name, VectronCircleType* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<VectronCircleType>(VectronCircleType_descriptor(), name,
                                           value);
}
enum VectronEdgeType : int {
  EDGE_TYPE_SHARP = 0,
  EDGE_TYPE_FILLET = 1,
  EDGE_TYPE_CHAMFER = 2,
  VectronEdgeType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  VectronEdgeType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t VectronEdgeType_internal_data_[];
inline constexpr VectronEdgeType VectronEdgeType_MIN =
    static_cast<VectronEdgeType>(0);
inline constexpr VectronEdgeType VectronEdgeType_MAX =
    static_cast<VectronEdgeType>(2);
inline bool VectronEdgeType_IsValid(int value) {
  return 0 <= value && value <= 2;
}
inline constexpr int VectronEdgeType_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL VectronEdgeType_descriptor();
template <typename T>
const ::std::string& VectronEdgeType_Name(T value) {
  static_assert(::std::is_same<T, VectronEdgeType>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to VectronEdgeType_Name().");
  return VectronEdgeType_Name(static_cast<VectronEdgeType>(value));
}
template <>
inline const ::std::string& VectronEdgeType_Name(VectronEdgeType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<VectronEdgeType_descriptor, 0, 2>(
      static_cast<int>(value));
}
inline bool VectronEdgeType_Parse(
    ::absl::string_view name, VectronEdgeType* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<VectronEdgeType>(VectronEdgeType_descriptor(), name,
                                           value);
}
enum VirtualTexturingMode : int {
  VIRTUAL_TEX_OFF = 0,
  VIRTUAL_TEX_ALBEDO = 1,
  VIRTUAL_TEX_NORMALS = 2,
  VirtualTexturingMode_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  VirtualTexturingMode_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t VirtualTexturingMode_internal_data_[];
inline constexpr VirtualTexturingMode VirtualTexturingMode_MIN =
    static_cast<VirtualTexturingMode>(0);
inline constexpr VirtualTexturingMode VirtualTexturingMode_MAX =
    static_cast<VirtualTexturingMode>(2);
inline bool VirtualTexturingMode_IsValid(int value) {
  return 0 <= value && value <= 2;
}
inline constexpr int VirtualTexturingMode_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL VirtualTexturingMode_descriptor();
template <typename T>
const ::std::string& VirtualTexturingMode_Name(T value) {
  static_assert(::std::is_same<T, VirtualTexturingMode>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to VirtualTexturingMode_Name().");
  return VirtualTexturingMode_Name(static_cast<VirtualTexturingMode>(value));
}
template <>
inline const ::std::string& VirtualTexturingMode_Name(VirtualTexturingMode value) {
  return ::google::protobuf::internal::NameOfDenseEnum<VirtualTexturingMode_descriptor, 0, 2>(
      static_cast<int>(value));
}
inline bool VirtualTexturingMode_Parse(
    ::absl::string_view name, VirtualTexturingMode* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<VirtualTexturingMode>(VirtualTexturingMode_descriptor(), name,
                                           value);
}
enum VolumeEmissionType : int {
  VOLUME_EMISSION_NONE = 0,
  VOLUME_EMISSION_CHANNEL = 1,
  VOLUME_EMISSION_DENSITY = 2,
  VOLUME_EMISSION_BLACK_BODY = 3,
  VolumeEmissionType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  VolumeEmissionType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t VolumeEmissionType_internal_data_[];
inline constexpr VolumeEmissionType VolumeEmissionType_MIN =
    static_cast<VolumeEmissionType>(0);
inline constexpr VolumeEmissionType VolumeEmissionType_MAX =
    static_cast<VolumeEmissionType>(3);
inline bool VolumeEmissionType_IsValid(int value) {
  return 0 <= value && value <= 3;
}
inline constexpr int VolumeEmissionType_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL VolumeEmissionType_descriptor();
template <typename T>
const ::std::string& VolumeEmissionType_Name(T value) {
  static_assert(::std::is_same<T, VolumeEmissionType>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to VolumeEmissionType_Name().");
  return VolumeEmissionType_Name(static_cast<VolumeEmissionType>(value));
}
template <>
inline const ::std::string& VolumeEmissionType_Name(VolumeEmissionType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<VolumeEmissionType_descriptor, 0, 3>(
      static_cast<int>(value));
}
inline bool VolumeEmissionType_Parse(
    ::absl::string_view name, VolumeEmissionType* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<VolumeEmissionType>(VolumeEmissionType_descriptor(), name,
                                           value);
}
enum VolumeInterpolationType : int {
  VOLUME_INTERPOLATION_CLOSEST = 0,
  VOLUME_INTERPOLATION_TRILINEAR = 1,
  VOLUME_INTERPOLATION_TRICUBIC = 2,
  VolumeInterpolationType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  VolumeInterpolationType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t VolumeInterpolationType_internal_data_[];
inline constexpr VolumeInterpolationType VolumeInterpolationType_MIN =
    static_cast<VolumeInterpolationType>(0);
inline constexpr VolumeInterpolationType VolumeInterpolationType_MAX =
    static_cast<VolumeInterpolationType>(2);
inline bool VolumeInterpolationType_IsValid(int value) {
  return 0 <= value && value <= 2;
}
inline constexpr int VolumeInterpolationType_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL VolumeInterpolationType_descriptor();
template <typename T>
const ::std::string& VolumeInterpolationType_Name(T value) {
  static_assert(::std::is_same<T, VolumeInterpolationType>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to VolumeInterpolationType_Name().");
  return VolumeInterpolationType_Name(static_cast<VolumeInterpolationType>(value));
}
template <>
inline const ::std::string& VolumeInterpolationType_Name(VolumeInterpolationType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<VolumeInterpolationType_descriptor, 0, 2>(
      static_cast<int>(value));
}
inline bool VolumeInterpolationType_Parse(
    ::absl::string_view name, VolumeInterpolationType* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<VolumeInterpolationType>(VolumeInterpolationType_descriptor(), name,
                                           value);
}
enum VolumeSampling : int {
  VOLUME_SAMPLING_LEGACY = 0,
  VOLUME_SAMPLING_2018 = 1,
  VOLUME_SAMPLING_IMPROVED = 2,
  VolumeSampling_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  VolumeSampling_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t VolumeSampling_internal_data_[];
inline constexpr VolumeSampling VolumeSampling_MIN =
    static_cast<VolumeSampling>(0);
inline constexpr VolumeSampling VolumeSampling_MAX =
    static_cast<VolumeSampling>(2);
inline bool VolumeSampling_IsValid(int value) {
  return 0 <= value && value <= 2;
}
inline constexpr int VolumeSampling_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL VolumeSampling_descriptor();
template <typename T>
const ::std::string& VolumeSampling_Name(T value) {
  static_assert(::std::is_same<T, VolumeSampling>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to VolumeSampling_Name().");
  return VolumeSampling_Name(static_cast<VolumeSampling>(value));
}
template <>
inline const ::std::string& VolumeSampling_Name(VolumeSampling value) {
  return ::google::protobuf::internal::NameOfDenseEnum<VolumeSampling_descriptor, 0, 2>(
      static_cast<int>(value));
}
inline bool VolumeSampling_Parse(
    ::absl::string_view name, VolumeSampling* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<VolumeSampling>(VolumeSampling_descriptor(), name,
                                           value);
}
enum Waveform : int {
  WAVEFORM_SINE = 0,
  WAVEFORM_SQUARE = 1,
  WAVEFORM_SAW = 2,
  Waveform_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  Waveform_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t Waveform_internal_data_[];
inline constexpr Waveform Waveform_MIN =
    static_cast<Waveform>(0);
inline constexpr Waveform Waveform_MAX =
    static_cast<Waveform>(2);
inline bool Waveform_IsValid(int value) {
  return 0 <= value && value <= 2;
}
inline constexpr int Waveform_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL Waveform_descriptor();
template <typename T>
const ::std::string& Waveform_Name(T value) {
  static_assert(::std::is_same<T, Waveform>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to Waveform_Name().");
  return Waveform_Name(static_cast<Waveform>(value));
}
template <>
inline const ::std::string& Waveform_Name(Waveform value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Waveform_descriptor, 0, 2>(
      static_cast<int>(value));
}
inline bool Waveform_Parse(
    ::absl::string_view name, Waveform* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<Waveform>(Waveform_descriptor(), name,
                                           value);
}
enum WCoordinateBorderMode : int {
  W_COORDINATE_BORDER_MODE_NONE = 0,
  W_COORDINATE_BORDER_MODE_WRAP = 1,
  W_COORDINATE_BORDER_MODE_MIRROR = 2,
  W_COORDINATE_BORDER_MODE_CLAMP = 3,
  WCoordinateBorderMode_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  WCoordinateBorderMode_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t WCoordinateBorderMode_internal_data_[];
inline constexpr WCoordinateBorderMode WCoordinateBorderMode_MIN =
    static_cast<WCoordinateBorderMode>(0);
inline constexpr WCoordinateBorderMode WCoordinateBorderMode_MAX =
    static_cast<WCoordinateBorderMode>(3);
inline bool WCoordinateBorderMode_IsValid(int value) {
  return 0 <= value && value <= 3;
}
inline constexpr int WCoordinateBorderMode_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL WCoordinateBorderMode_descriptor();
template <typename T>
const ::std::string& WCoordinateBorderMode_Name(T value) {
  static_assert(::std::is_same<T, WCoordinateBorderMode>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to WCoordinateBorderMode_Name().");
  return WCoordinateBorderMode_Name(static_cast<WCoordinateBorderMode>(value));
}
template <>
inline const ::std::string& WCoordinateBorderMode_Name(WCoordinateBorderMode value) {
  return ::google::protobuf::internal::NameOfDenseEnum<WCoordinateBorderMode_descriptor, 0, 3>(
      static_cast<int>(value));
}
inline bool WCoordinateBorderMode_Parse(
    ::absl::string_view name, WCoordinateBorderMode* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<WCoordinateBorderMode>(WCoordinateBorderMode_descriptor(), name,
                                           value);
}
enum WhiteLightSpectrum : int {
  WHITE_LIGHT_SPECTRUM_FLAT = 0,
  WHITE_LIGHT_SPECTRUM_D65 = 1,
  WhiteLightSpectrum_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  WhiteLightSpectrum_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t WhiteLightSpectrum_internal_data_[];
inline constexpr WhiteLightSpectrum WhiteLightSpectrum_MIN =
    static_cast<WhiteLightSpectrum>(0);
inline constexpr WhiteLightSpectrum WhiteLightSpectrum_MAX =
    static_cast<WhiteLightSpectrum>(1);
inline bool WhiteLightSpectrum_IsValid(int value) {
  return 0 <= value && value <= 1;
}
inline constexpr int WhiteLightSpectrum_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL WhiteLightSpectrum_descriptor();
template <typename T>
const ::std::string& WhiteLightSpectrum_Name(T value) {
  static_assert(::std::is_same<T, WhiteLightSpectrum>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to WhiteLightSpectrum_Name().");
  return WhiteLightSpectrum_Name(static_cast<WhiteLightSpectrum>(value));
}
template <>
inline const ::std::string& WhiteLightSpectrum_Name(WhiteLightSpectrum value) {
  return ::google::protobuf::internal::NameOfDenseEnum<WhiteLightSpectrum_descriptor, 0, 1>(
      static_cast<int>(value));
}
inline bool WhiteLightSpectrum_Parse(
    ::absl::string_view name, WhiteLightSpectrum* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<WhiteLightSpectrum>(WhiteLightSpectrum_descriptor(), name,
                                           value);
}
enum WindingOrder : int {
  WindingOrder_UNSPECIFIED = 0,
  WINDING_COUNTERCLOCKWISE = 1,
  WINDING_CLOCKWISE = 2,
  WINDING_AUTO = 3,
  WindingOrder_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  WindingOrder_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t WindingOrder_internal_data_[];
inline constexpr WindingOrder WindingOrder_MIN =
    static_cast<WindingOrder>(0);
inline constexpr WindingOrder WindingOrder_MAX =
    static_cast<WindingOrder>(3);
inline bool WindingOrder_IsValid(int value) {
  return 0 <= value && value <= 3;
}
inline constexpr int WindingOrder_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL WindingOrder_descriptor();
template <typename T>
const ::std::string& WindingOrder_Name(T value) {
  static_assert(::std::is_same<T, WindingOrder>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to WindingOrder_Name().");
  return WindingOrder_Name(static_cast<WindingOrder>(value));
}
template <>
inline const ::std::string& WindingOrder_Name(WindingOrder value) {
  return ::google::protobuf::internal::NameOfDenseEnum<WindingOrder_descriptor, 0, 3>(
      static_cast<int>(value));
}
inline bool WindingOrder_Parse(
    ::absl::string_view name, WindingOrder* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<WindingOrder>(WindingOrder_descriptor(), name,
                                           value);
}
enum ScatterSurfacePolygonMode : int {
  SCATTER_SURFACE_POLYGON_MODE_VERTICES = 0,
  SCATTER_SURFACE_POLYGON_MODE_CENTERS = 1,
  SCATTER_SURFACE_POLYGON_MODE_BYAREA = 2,
  SCATTER_SURFACE_POLYGON_MODE_BYDENSITYMAP = 3,
  SCATTER_SURFACE_POLYGON_MODE_EDGEPOSITION = 4,
  SCATTER_SURFACE_POLYGON_MODE_EDGESPACING = 5,
  SCATTER_SURFACE_POLYGON_MODE_DISABLED = 6,
  ScatterSurfacePolygonMode_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  ScatterSurfacePolygonMode_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t ScatterSurfacePolygonMode_internal_data_[];
inline constexpr ScatterSurfacePolygonMode ScatterSurfacePolygonMode_MIN =
    static_cast<ScatterSurfacePolygonMode>(0);
inline constexpr ScatterSurfacePolygonMode ScatterSurfacePolygonMode_MAX =
    static_cast<ScatterSurfacePolygonMode>(6);
inline bool ScatterSurfacePolygonMode_IsValid(int value) {
  return 0 <= value && value <= 6;
}
inline constexpr int ScatterSurfacePolygonMode_ARRAYSIZE = 6 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL ScatterSurfacePolygonMode_descriptor();
template <typename T>
const ::std::string& ScatterSurfacePolygonMode_Name(T value) {
  static_assert(::std::is_same<T, ScatterSurfacePolygonMode>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to ScatterSurfacePolygonMode_Name().");
  return ScatterSurfacePolygonMode_Name(static_cast<ScatterSurfacePolygonMode>(value));
}
template <>
inline const ::std::string& ScatterSurfacePolygonMode_Name(ScatterSurfacePolygonMode value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ScatterSurfacePolygonMode_descriptor, 0, 6>(
      static_cast<int>(value));
}
inline bool ScatterSurfacePolygonMode_Parse(
    ::absl::string_view name, ScatterSurfacePolygonMode* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<ScatterSurfacePolygonMode>(ScatterSurfacePolygonMode_descriptor(), name,
                                           value);
}
enum ScatterSurfaceParticleMode : int {
  SCATTER_SURFACE_PARTICLE_MODE_CENTERS = 0,
  SCATTER_SURFACE_PARTICLE_MODE_DISABLED = 1,
  ScatterSurfaceParticleMode_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  ScatterSurfaceParticleMode_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t ScatterSurfaceParticleMode_internal_data_[];
inline constexpr ScatterSurfaceParticleMode ScatterSurfaceParticleMode_MIN =
    static_cast<ScatterSurfaceParticleMode>(0);
inline constexpr ScatterSurfaceParticleMode ScatterSurfaceParticleMode_MAX =
    static_cast<ScatterSurfaceParticleMode>(1);
inline bool ScatterSurfaceParticleMode_IsValid(int value) {
  return 0 <= value && value <= 1;
}
inline constexpr int ScatterSurfaceParticleMode_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL ScatterSurfaceParticleMode_descriptor();
template <typename T>
const ::std::string& ScatterSurfaceParticleMode_Name(T value) {
  static_assert(::std::is_same<T, ScatterSurfaceParticleMode>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to ScatterSurfaceParticleMode_Name().");
  return ScatterSurfaceParticleMode_Name(static_cast<ScatterSurfaceParticleMode>(value));
}
template <>
inline const ::std::string& ScatterSurfaceParticleMode_Name(ScatterSurfaceParticleMode value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ScatterSurfaceParticleMode_descriptor, 0, 1>(
      static_cast<int>(value));
}
inline bool ScatterSurfaceParticleMode_Parse(
    ::absl::string_view name, ScatterSurfaceParticleMode* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<ScatterSurfaceParticleMode>(ScatterSurfaceParticleMode_descriptor(), name,
                                           value);
}
enum ScatterSurfaceHairMode : int {
  SCATTER_SURFACE_HAIR_MODE_VERTICES = 0,
  SCATTER_SURFACE_HAIR_MODE_POSITION = 1,
  SCATTER_SURFACE_HAIR_MODE_SPACING = 2,
  SCATTER_SURFACE_HAIR_MODE_DISABLED = 3,
  ScatterSurfaceHairMode_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  ScatterSurfaceHairMode_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t ScatterSurfaceHairMode_internal_data_[];
inline constexpr ScatterSurfaceHairMode ScatterSurfaceHairMode_MIN =
    static_cast<ScatterSurfaceHairMode>(0);
inline constexpr ScatterSurfaceHairMode ScatterSurfaceHairMode_MAX =
    static_cast<ScatterSurfaceHairMode>(3);
inline bool ScatterSurfaceHairMode_IsValid(int value) {
  return 0 <= value && value <= 3;
}
inline constexpr int ScatterSurfaceHairMode_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL ScatterSurfaceHairMode_descriptor();
template <typename T>
const ::std::string& ScatterSurfaceHairMode_Name(T value) {
  static_assert(::std::is_same<T, ScatterSurfaceHairMode>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to ScatterSurfaceHairMode_Name().");
  return ScatterSurfaceHairMode_Name(static_cast<ScatterSurfaceHairMode>(value));
}
template <>
inline const ::std::string& ScatterSurfaceHairMode_Name(ScatterSurfaceHairMode value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ScatterSurfaceHairMode_descriptor, 0, 3>(
      static_cast<int>(value));
}
inline bool ScatterSurfaceHairMode_Parse(
    ::absl::string_view name, ScatterSurfaceHairMode* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<ScatterSurfaceHairMode>(ScatterSurfaceHairMode_descriptor(), name,
                                           value);
}
enum ScatterSurfaceSelectionMode : int {
  SCATTER_SURFACE_SELECTION_MODE_SEQUENTIAL = 0,
  SCATTER_SURFACE_SELECTION_MODE_RANDOM = 1,
  SCATTER_SURFACE_SELECTION_MODE_MAP = 2,
  ScatterSurfaceSelectionMode_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  ScatterSurfaceSelectionMode_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t ScatterSurfaceSelectionMode_internal_data_[];
inline constexpr ScatterSurfaceSelectionMode ScatterSurfaceSelectionMode_MIN =
    static_cast<ScatterSurfaceSelectionMode>(0);
inline constexpr ScatterSurfaceSelectionMode ScatterSurfaceSelectionMode_MAX =
    static_cast<ScatterSurfaceSelectionMode>(2);
inline bool ScatterSurfaceSelectionMode_IsValid(int value) {
  return 0 <= value && value <= 2;
}
inline constexpr int ScatterSurfaceSelectionMode_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL ScatterSurfaceSelectionMode_descriptor();
template <typename T>
const ::std::string& ScatterSurfaceSelectionMode_Name(T value) {
  static_assert(::std::is_same<T, ScatterSurfaceSelectionMode>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to ScatterSurfaceSelectionMode_Name().");
  return ScatterSurfaceSelectionMode_Name(static_cast<ScatterSurfaceSelectionMode>(value));
}
template <>
inline const ::std::string& ScatterSurfaceSelectionMode_Name(ScatterSurfaceSelectionMode value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ScatterSurfaceSelectionMode_descriptor, 0, 2>(
      static_cast<int>(value));
}
inline bool ScatterSurfaceSelectionMode_Parse(
    ::absl::string_view name, ScatterSurfaceSelectionMode* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<ScatterSurfaceSelectionMode>(ScatterSurfaceSelectionMode_descriptor(), name,
                                           value);
}
enum ScatterSurfaceOrientationPriority : int {
  SCATTER_SURFACE_ORIENTATION_PRIORITY_UP = 0,
  SCATTER_SURFACE_ORIENTATION_PRIORITY_FRONT = 1,
  ScatterSurfaceOrientationPriority_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  ScatterSurfaceOrientationPriority_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t ScatterSurfaceOrientationPriority_internal_data_[];
inline constexpr ScatterSurfaceOrientationPriority ScatterSurfaceOrientationPriority_MIN =
    static_cast<ScatterSurfaceOrientationPriority>(0);
inline constexpr ScatterSurfaceOrientationPriority ScatterSurfaceOrientationPriority_MAX =
    static_cast<ScatterSurfaceOrientationPriority>(1);
inline bool ScatterSurfaceOrientationPriority_IsValid(int value) {
  return 0 <= value && value <= 1;
}
inline constexpr int ScatterSurfaceOrientationPriority_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL ScatterSurfaceOrientationPriority_descriptor();
template <typename T>
const ::std::string& ScatterSurfaceOrientationPriority_Name(T value) {
  static_assert(::std::is_same<T, ScatterSurfaceOrientationPriority>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to ScatterSurfaceOrientationPriority_Name().");
  return ScatterSurfaceOrientationPriority_Name(static_cast<ScatterSurfaceOrientationPriority>(value));
}
template <>
inline const ::std::string& ScatterSurfaceOrientationPriority_Name(ScatterSurfaceOrientationPriority value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ScatterSurfaceOrientationPriority_descriptor, 0, 1>(
      static_cast<int>(value));
}
inline bool ScatterSurfaceOrientationPriority_Parse(
    ::absl::string_view name, ScatterSurfaceOrientationPriority* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<ScatterSurfaceOrientationPriority>(ScatterSurfaceOrientationPriority_descriptor(), name,
                                           value);
}
enum ScatterSurfaceReferenceType : int {
  SCATTER_SURFACE_REFERENCE_TYPE_DIRECTION = 0,
  SCATTER_SURFACE_REFERENCE_TYPE_POINT = 1,
  ScatterSurfaceReferenceType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  ScatterSurfaceReferenceType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t ScatterSurfaceReferenceType_internal_data_[];
inline constexpr ScatterSurfaceReferenceType ScatterSurfaceReferenceType_MIN =
    static_cast<ScatterSurfaceReferenceType>(0);
inline constexpr ScatterSurfaceReferenceType ScatterSurfaceReferenceType_MAX =
    static_cast<ScatterSurfaceReferenceType>(1);
inline bool ScatterSurfaceReferenceType_IsValid(int value) {
  return 0 <= value && value <= 1;
}
inline constexpr int ScatterSurfaceReferenceType_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL ScatterSurfaceReferenceType_descriptor();
template <typename T>
const ::std::string& ScatterSurfaceReferenceType_Name(T value) {
  static_assert(::std::is_same<T, ScatterSurfaceReferenceType>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to ScatterSurfaceReferenceType_Name().");
  return ScatterSurfaceReferenceType_Name(static_cast<ScatterSurfaceReferenceType>(value));
}
template <>
inline const ::std::string& ScatterSurfaceReferenceType_Name(ScatterSurfaceReferenceType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ScatterSurfaceReferenceType_descriptor, 0, 1>(
      static_cast<int>(value));
}
inline bool ScatterSurfaceReferenceType_Parse(
    ::absl::string_view name, ScatterSurfaceReferenceType* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<ScatterSurfaceReferenceType>(ScatterSurfaceReferenceType_descriptor(), name,
                                           value);
}
enum ScatterSurfaceTransformType : int {
  SCATTER_SURFACE_TRANSFORM_TYPE_FIXED = 0,
  SCATTER_SURFACE_TRANSFORM_TYPE_RANDOM_INDEPENDENT = 1,
  SCATTER_SURFACE_TRANSFORM_TYPE_RANDOM_COUPLED = 2,
  SCATTER_SURFACE_TRANSFORM_TYPE_MAP = 3,
  ScatterSurfaceTransformType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  ScatterSurfaceTransformType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t ScatterSurfaceTransformType_internal_data_[];
inline constexpr ScatterSurfaceTransformType ScatterSurfaceTransformType_MIN =
    static_cast<ScatterSurfaceTransformType>(0);
inline constexpr ScatterSurfaceTransformType ScatterSurfaceTransformType_MAX =
    static_cast<ScatterSurfaceTransformType>(3);
inline bool ScatterSurfaceTransformType_IsValid(int value) {
  return 0 <= value && value <= 3;
}
inline constexpr int ScatterSurfaceTransformType_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL ScatterSurfaceTransformType_descriptor();
template <typename T>
const ::std::string& ScatterSurfaceTransformType_Name(T value) {
  static_assert(::std::is_same<T, ScatterSurfaceTransformType>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to ScatterSurfaceTransformType_Name().");
  return ScatterSurfaceTransformType_Name(static_cast<ScatterSurfaceTransformType>(value));
}
template <>
inline const ::std::string& ScatterSurfaceTransformType_Name(ScatterSurfaceTransformType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ScatterSurfaceTransformType_descriptor, 0, 3>(
      static_cast<int>(value));
}
inline bool ScatterSurfaceTransformType_Parse(
    ::absl::string_view name, ScatterSurfaceTransformType* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<ScatterSurfaceTransformType>(ScatterSurfaceTransformType_descriptor(), name,
                                           value);
}
enum ScatterVolumeSelectionMode : int {
  SCATTER_VOLUME_SELECTION_MODE_SEQUENTIAL = 0,
  SCATTER_VOLUME_SELECTION_MODE_RANDOM = 1,
  SCATTER_VOLUME_SELECTION_MODE_MAP = 2,
  ScatterVolumeSelectionMode_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  ScatterVolumeSelectionMode_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t ScatterVolumeSelectionMode_internal_data_[];
inline constexpr ScatterVolumeSelectionMode ScatterVolumeSelectionMode_MIN =
    static_cast<ScatterVolumeSelectionMode>(0);
inline constexpr ScatterVolumeSelectionMode ScatterVolumeSelectionMode_MAX =
    static_cast<ScatterVolumeSelectionMode>(2);
inline bool ScatterVolumeSelectionMode_IsValid(int value) {
  return 0 <= value && value <= 2;
}
inline constexpr int ScatterVolumeSelectionMode_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL ScatterVolumeSelectionMode_descriptor();
template <typename T>
const ::std::string& ScatterVolumeSelectionMode_Name(T value) {
  static_assert(::std::is_same<T, ScatterVolumeSelectionMode>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to ScatterVolumeSelectionMode_Name().");
  return ScatterVolumeSelectionMode_Name(static_cast<ScatterVolumeSelectionMode>(value));
}
template <>
inline const ::std::string& ScatterVolumeSelectionMode_Name(ScatterVolumeSelectionMode value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ScatterVolumeSelectionMode_descriptor, 0, 2>(
      static_cast<int>(value));
}
inline bool ScatterVolumeSelectionMode_Parse(
    ::absl::string_view name, ScatterVolumeSelectionMode* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<ScatterVolumeSelectionMode>(ScatterVolumeSelectionMode_descriptor(), name,
                                           value);
}
enum ScatterVolumeShape : int {
  SCATTER_VOLUME_SHAPE_BOX = 0,
  SCATTER_VOLUME_SHAPE_SPHERE = 1,
  SCATTER_VOLUME_SHAPE_CYLINDER = 2,
  SCATTER_VOLUME_SHAPE_CONE = 3,
  ScatterVolumeShape_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  ScatterVolumeShape_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t ScatterVolumeShape_internal_data_[];
inline constexpr ScatterVolumeShape ScatterVolumeShape_MIN =
    static_cast<ScatterVolumeShape>(0);
inline constexpr ScatterVolumeShape ScatterVolumeShape_MAX =
    static_cast<ScatterVolumeShape>(3);
inline bool ScatterVolumeShape_IsValid(int value) {
  return 0 <= value && value <= 3;
}
inline constexpr int ScatterVolumeShape_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL ScatterVolumeShape_descriptor();
template <typename T>
const ::std::string& ScatterVolumeShape_Name(T value) {
  static_assert(::std::is_same<T, ScatterVolumeShape>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to ScatterVolumeShape_Name().");
  return ScatterVolumeShape_Name(static_cast<ScatterVolumeShape>(value));
}
template <>
inline const ::std::string& ScatterVolumeShape_Name(ScatterVolumeShape value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ScatterVolumeShape_descriptor, 0, 3>(
      static_cast<int>(value));
}
inline bool ScatterVolumeShape_Parse(
    ::absl::string_view name, ScatterVolumeShape* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<ScatterVolumeShape>(ScatterVolumeShape_descriptor(), name,
                                           value);
}
enum ScatterVolumeOrientationPriority : int {
  SCATTER_VOLUME_ORIENTATION_PRIORITY_UP = 0,
  SCATTER_VOLUME_ORIENTATION_PRIORITY_FRONT = 1,
  ScatterVolumeOrientationPriority_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  ScatterVolumeOrientationPriority_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t ScatterVolumeOrientationPriority_internal_data_[];
inline constexpr ScatterVolumeOrientationPriority ScatterVolumeOrientationPriority_MIN =
    static_cast<ScatterVolumeOrientationPriority>(0);
inline constexpr ScatterVolumeOrientationPriority ScatterVolumeOrientationPriority_MAX =
    static_cast<ScatterVolumeOrientationPriority>(1);
inline bool ScatterVolumeOrientationPriority_IsValid(int value) {
  return 0 <= value && value <= 1;
}
inline constexpr int ScatterVolumeOrientationPriority_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL ScatterVolumeOrientationPriority_descriptor();
template <typename T>
const ::std::string& ScatterVolumeOrientationPriority_Name(T value) {
  static_assert(::std::is_same<T, ScatterVolumeOrientationPriority>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to ScatterVolumeOrientationPriority_Name().");
  return ScatterVolumeOrientationPriority_Name(static_cast<ScatterVolumeOrientationPriority>(value));
}
template <>
inline const ::std::string& ScatterVolumeOrientationPriority_Name(ScatterVolumeOrientationPriority value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ScatterVolumeOrientationPriority_descriptor, 0, 1>(
      static_cast<int>(value));
}
inline bool ScatterVolumeOrientationPriority_Parse(
    ::absl::string_view name, ScatterVolumeOrientationPriority* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<ScatterVolumeOrientationPriority>(ScatterVolumeOrientationPriority_descriptor(), name,
                                           value);
}
enum ScatterVolumeReferenceType : int {
  SCATTER_VOLUME_REFERENCE_TYPE_DIRECTION = 0,
  SCATTER_VOLUME_REFERENCE_TYPE_POINT = 1,
  ScatterVolumeReferenceType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  ScatterVolumeReferenceType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t ScatterVolumeReferenceType_internal_data_[];
inline constexpr ScatterVolumeReferenceType ScatterVolumeReferenceType_MIN =
    static_cast<ScatterVolumeReferenceType>(0);
inline constexpr ScatterVolumeReferenceType ScatterVolumeReferenceType_MAX =
    static_cast<ScatterVolumeReferenceType>(1);
inline bool ScatterVolumeReferenceType_IsValid(int value) {
  return 0 <= value && value <= 1;
}
inline constexpr int ScatterVolumeReferenceType_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL ScatterVolumeReferenceType_descriptor();
template <typename T>
const ::std::string& ScatterVolumeReferenceType_Name(T value) {
  static_assert(::std::is_same<T, ScatterVolumeReferenceType>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to ScatterVolumeReferenceType_Name().");
  return ScatterVolumeReferenceType_Name(static_cast<ScatterVolumeReferenceType>(value));
}
template <>
inline const ::std::string& ScatterVolumeReferenceType_Name(ScatterVolumeReferenceType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ScatterVolumeReferenceType_descriptor, 0, 1>(
      static_cast<int>(value));
}
inline bool ScatterVolumeReferenceType_Parse(
    ::absl::string_view name, ScatterVolumeReferenceType* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<ScatterVolumeReferenceType>(ScatterVolumeReferenceType_descriptor(), name,
                                           value);
}
enum ScatterVolumeTransformType : int {
  SCATTER_VOLUME_TRANSFORM_TYPE_FIXED = 0,
  SCATTER_VOLUME_TRANSFORM_TYPE_RANDOM_INDEPENDENT = 1,
  SCATTER_VOLUME_TRANSFORM_TYPE_RANDOM_COUPLED = 2,
  SCATTER_VOLUME_TRANSFORM_TYPE_MAP = 3,
  ScatterVolumeTransformType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  ScatterVolumeTransformType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t ScatterVolumeTransformType_internal_data_[];
inline constexpr ScatterVolumeTransformType ScatterVolumeTransformType_MIN =
    static_cast<ScatterVolumeTransformType>(0);
inline constexpr ScatterVolumeTransformType ScatterVolumeTransformType_MAX =
    static_cast<ScatterVolumeTransformType>(3);
inline bool ScatterVolumeTransformType_IsValid(int value) {
  return 0 <= value && value <= 3;
}
inline constexpr int ScatterVolumeTransformType_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL ScatterVolumeTransformType_descriptor();
template <typename T>
const ::std::string& ScatterVolumeTransformType_Name(T value) {
  static_assert(::std::is_same<T, ScatterVolumeTransformType>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to ScatterVolumeTransformType_Name().");
  return ScatterVolumeTransformType_Name(static_cast<ScatterVolumeTransformType>(value));
}
template <>
inline const ::std::string& ScatterVolumeTransformType_Name(ScatterVolumeTransformType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ScatterVolumeTransformType_descriptor, 0, 3>(
      static_cast<int>(value));
}
inline bool ScatterVolumeTransformType_Parse(
    ::absl::string_view name, ScatterVolumeTransformType* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<ScatterVolumeTransformType>(ScatterVolumeTransformType_descriptor(), name,
                                           value);
}

// ===================================================================


// -------------------------------------------------------------------

class ApiArrayRenderPassId final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:octaneapi.ApiArrayRenderPassId) */ {
 public:
  inline ApiArrayRenderPassId() : ApiArrayRenderPassId(nullptr) {}
  ~ApiArrayRenderPassId() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ApiArrayRenderPassId* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ApiArrayRenderPassId));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ApiArrayRenderPassId(::google::protobuf::internal::ConstantInitialized);

  inline ApiArrayRenderPassId(const ApiArrayRenderPassId& from) : ApiArrayRenderPassId(nullptr, from) {}
  inline ApiArrayRenderPassId(ApiArrayRenderPassId&& from) noexcept
      : ApiArrayRenderPassId(nullptr, ::std::move(from)) {}
  inline ApiArrayRenderPassId& operator=(const ApiArrayRenderPassId& from) {
    CopyFrom(from);
    return *this;
  }
  inline ApiArrayRenderPassId& operator=(ApiArrayRenderPassId&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ApiArrayRenderPassId& default_instance() {
    return *reinterpret_cast<const ApiArrayRenderPassId*>(
        &_ApiArrayRenderPassId_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(ApiArrayRenderPassId& a, ApiArrayRenderPassId& b) { a.Swap(&b); }
  inline void Swap(ApiArrayRenderPassId* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ApiArrayRenderPassId* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ApiArrayRenderPassId* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ApiArrayRenderPassId>(arena);
  }
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ApiArrayRenderPassId* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "octaneapi.ApiArrayRenderPassId"; }

 protected:
  explicit ApiArrayRenderPassId(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ApiArrayRenderPassId(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ApiArrayRenderPassId& from);
  ApiArrayRenderPassId(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ApiArrayRenderPassId&& from) noexcept
      : ApiArrayRenderPassId(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDataFieldNumber = 1,
  };
  // repeated .octaneapi.RenderPassId data = 1;
  int data_size() const;
  private:
  int _internal_data_size() const;

  public:
  void clear_data() ;
  public:
  ::octaneapi::RenderPassId data(int index) const;
  void set_data(int index, ::octaneapi::RenderPassId value);
  void add_data(::octaneapi::RenderPassId value);
  const ::google::protobuf::RepeatedField<int>& data() const;
  ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL mutable_data();

  private:
  const ::google::protobuf::RepeatedField<int>& _internal_data() const;
  ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL _internal_mutable_data();

  public:
  // @@protoc_insertion_point(class_scope:octaneapi.ApiArrayRenderPassId)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ApiArrayRenderPassId& from_msg);
    ::google::protobuf::RepeatedField<int> data_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_octaneenums_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ApiArrayRenderPassId_class_data_;
// -------------------------------------------------------------------

class ApiArrayImageTypeT final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:octaneapi.ApiArrayImageTypeT) */ {
 public:
  inline ApiArrayImageTypeT() : ApiArrayImageTypeT(nullptr) {}
  ~ApiArrayImageTypeT() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ApiArrayImageTypeT* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ApiArrayImageTypeT));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ApiArrayImageTypeT(::google::protobuf::internal::ConstantInitialized);

  inline ApiArrayImageTypeT(const ApiArrayImageTypeT& from) : ApiArrayImageTypeT(nullptr, from) {}
  inline ApiArrayImageTypeT(ApiArrayImageTypeT&& from) noexcept
      : ApiArrayImageTypeT(nullptr, ::std::move(from)) {}
  inline ApiArrayImageTypeT& operator=(const ApiArrayImageTypeT& from) {
    CopyFrom(from);
    return *this;
  }
  inline ApiArrayImageTypeT& operator=(ApiArrayImageTypeT&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ApiArrayImageTypeT& default_instance() {
    return *reinterpret_cast<const ApiArrayImageTypeT*>(
        &_ApiArrayImageTypeT_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(ApiArrayImageTypeT& a, ApiArrayImageTypeT& b) { a.Swap(&b); }
  inline void Swap(ApiArrayImageTypeT* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ApiArrayImageTypeT* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ApiArrayImageTypeT* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ApiArrayImageTypeT>(arena);
  }
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ApiArrayImageTypeT* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "octaneapi.ApiArrayImageTypeT"; }

 protected:
  explicit ApiArrayImageTypeT(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ApiArrayImageTypeT(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ApiArrayImageTypeT& from);
  ApiArrayImageTypeT(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ApiArrayImageTypeT&& from) noexcept
      : ApiArrayImageTypeT(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDataFieldNumber = 1,
  };
  // repeated .octaneapi.ImageType data = 1;
  int data_size() const;
  private:
  int _internal_data_size() const;

  public:
  void clear_data() ;
  public:
  ::octaneapi::ImageType data(int index) const;
  void set_data(int index, ::octaneapi::ImageType value);
  void add_data(::octaneapi::ImageType value);
  const ::google::protobuf::RepeatedField<int>& data() const;
  ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL mutable_data();

  private:
  const ::google::protobuf::RepeatedField<int>& _internal_data() const;
  ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL _internal_mutable_data();

  public:
  // @@protoc_insertion_point(class_scope:octaneapi.ApiArrayImageTypeT)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ApiArrayImageTypeT& from_msg);
    ::google::protobuf::RepeatedField<int> data_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_octaneenums_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ApiArrayImageTypeT_class_data_;

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// ApiArrayRenderPassId

// repeated .octaneapi.RenderPassId data = 1;
inline int ApiArrayRenderPassId::_internal_data_size() const {
  return _internal_data().size();
}
inline int ApiArrayRenderPassId::data_size() const {
  return _internal_data_size();
}
inline void ApiArrayRenderPassId::clear_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data_.Clear();
}
inline ::octaneapi::RenderPassId ApiArrayRenderPassId::data(int index) const {
  // @@protoc_insertion_point(field_get:octaneapi.ApiArrayRenderPassId.data)
  return static_cast<::octaneapi::RenderPassId>(_internal_data().Get(index));
}
inline void ApiArrayRenderPassId::set_data(int index, ::octaneapi::RenderPassId value) {
  _internal_mutable_data()->Set(index, value);
  // @@protoc_insertion_point(field_set:octaneapi.ApiArrayRenderPassId.data)
}
inline void ApiArrayRenderPassId::add_data(::octaneapi::RenderPassId value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_data()->Add(value);
  // @@protoc_insertion_point(field_add:octaneapi.ApiArrayRenderPassId.data)
}
inline const ::google::protobuf::RepeatedField<int>& ApiArrayRenderPassId::data() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:octaneapi.ApiArrayRenderPassId.data)
  return _internal_data();
}
inline ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL ApiArrayRenderPassId::mutable_data()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:octaneapi.ApiArrayRenderPassId.data)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_data();
}
inline const ::google::protobuf::RepeatedField<int>& ApiArrayRenderPassId::_internal_data()
    const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.data_;
}
inline ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL
ApiArrayRenderPassId::_internal_mutable_data() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.data_;
}

// -------------------------------------------------------------------

// ApiArrayImageTypeT

// repeated .octaneapi.ImageType data = 1;
inline int ApiArrayImageTypeT::_internal_data_size() const {
  return _internal_data().size();
}
inline int ApiArrayImageTypeT::data_size() const {
  return _internal_data_size();
}
inline void ApiArrayImageTypeT::clear_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data_.Clear();
}
inline ::octaneapi::ImageType ApiArrayImageTypeT::data(int index) const {
  // @@protoc_insertion_point(field_get:octaneapi.ApiArrayImageTypeT.data)
  return static_cast<::octaneapi::ImageType>(_internal_data().Get(index));
}
inline void ApiArrayImageTypeT::set_data(int index, ::octaneapi::ImageType value) {
  _internal_mutable_data()->Set(index, value);
  // @@protoc_insertion_point(field_set:octaneapi.ApiArrayImageTypeT.data)
}
inline void ApiArrayImageTypeT::add_data(::octaneapi::ImageType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_data()->Add(value);
  // @@protoc_insertion_point(field_add:octaneapi.ApiArrayImageTypeT.data)
}
inline const ::google::protobuf::RepeatedField<int>& ApiArrayImageTypeT::data() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:octaneapi.ApiArrayImageTypeT.data)
  return _internal_data();
}
inline ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL ApiArrayImageTypeT::mutable_data()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:octaneapi.ApiArrayImageTypeT.data)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_data();
}
inline const ::google::protobuf::RepeatedField<int>& ApiArrayImageTypeT::_internal_data()
    const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.data_;
}
inline ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL
ApiArrayImageTypeT::_internal_mutable_data() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.data_;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace octaneapi


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::octaneapi::ActivationResult> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::ActivationResult>() {
  return ::octaneapi::ActivationResult_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::AnimationTimeTransformType> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::AnimationTimeTransformType>() {
  return ::octaneapi::AnimationTimeTransformType_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::AsPixelGroupMode> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::AsPixelGroupMode>() {
  return ::octaneapi::AsPixelGroupMode_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::AnalyticLightType> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::AnalyticLightType>() {
  return ::octaneapi::AnalyticLightType_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::AnimationType> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::AnimationType>() {
  return ::octaneapi::AnimationType_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::BakingTextureType> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::BakingTextureType>() {
  return ::octaneapi::BakingTextureType_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::BinaryOperation> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::BinaryOperation>() {
  return ::octaneapi::BinaryOperation_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::BorderMode> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::BorderMode>() {
  return ::octaneapi::BorderMode_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::BlendRegionMask> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::BlendRegionMask>() {
  return ::octaneapi::BlendRegionMask_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::ComponentPickerOperation> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::ComponentPickerOperation>() {
  return ::octaneapi::ComponentPickerOperation_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::CompositeOperation> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::CompositeOperation>() {
  return ::octaneapi::CompositeOperation_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::BlendMode> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::BlendMode>() {
  return ::octaneapi::BlendMode_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::BrdfModel> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::BrdfModel>() {
  return ::octaneapi::BrdfModel_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::BxDFDiffuseModel> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::BxDFDiffuseModel>() {
  return ::octaneapi::BxDFDiffuseModel_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::BxDFSpecularModel> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::BxDFSpecularModel>() {
  return ::octaneapi::BxDFSpecularModel_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::BxDFSheenModel> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::BxDFSheenModel>() {
  return ::octaneapi::BxDFSheenModel_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::BxDFTranmissionType> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::BxDFTranmissionType>() {
  return ::octaneapi::BxDFTranmissionType_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::BxDFUniversalModel> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::BxDFUniversalModel>() {
  return ::octaneapi::BxDFUniversalModel_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::ChangeEventType> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::ChangeEventType>() {
  return ::octaneapi::ChangeEventType_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::ChannelGroups> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::ChannelGroups>() {
  return ::octaneapi::ChannelGroups_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::ChannelMapping> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::ChannelMapping>() {
  return ::octaneapi::ChannelMapping_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::Cinema4dNoiseType> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::Cinema4dNoiseType>() {
  return ::octaneapi::Cinema4dNoiseType_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::ClayMode> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::ClayMode>() {
  return ::octaneapi::ClayMode_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::ColorChannelType> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::ColorChannelType>() {
  return ::octaneapi::ColorChannelType_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::ColorPickerSpace> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::ColorPickerSpace>() {
  return ::octaneapi::ColorPickerSpace_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::ColorSpaceConversion> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::ColorSpaceConversion>() {
  return ::octaneapi::ColorSpaceConversion_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::ColorSpaceCurveType> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::ColorSpaceCurveType>() {
  return ::octaneapi::ColorSpaceCurveType_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::ComparisonOperation> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::ComparisonOperation>() {
  return ::octaneapi::ComparisonOperation_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::CompilationResult> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::CompilationResult>() {
  return ::octaneapi::CompilationResult_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::CompositeAlphaOperation> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::CompositeAlphaOperation>() {
  return ::octaneapi::CompositeAlphaOperation_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::CoordinateAxis> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::CoordinateAxis>() {
  return ::octaneapi::CoordinateAxis_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::CoordinateSystem> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::CoordinateSystem>() {
  return ::octaneapi::CoordinateSystem_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::CryptomatteType> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::CryptomatteType>() {
  return ::octaneapi::CryptomatteType_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::CurvatureModes> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::CurvatureModes>() {
  return ::octaneapi::CurvatureModes_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::CustomAov> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::CustomAov>() {
  return ::octaneapi::CustomAov_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::CustomAovChannel> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::CustomAovChannel>() {
  return ::octaneapi::CustomAovChannel_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::CustomAovSecondaryRayVisibility> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::CustomAovSecondaryRayVisibility>() {
  return ::octaneapi::CustomAovSecondaryRayVisibility_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::CustomCurveMode> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::CustomCurveMode>() {
  return ::octaneapi::CustomCurveMode_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::CacheStatus> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::CacheStatus>() {
  return ::octaneapi::CacheStatus_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::DaylightModel> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::DaylightModel>() {
  return ::octaneapi::DaylightModel_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::DenoiserType> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::DenoiserType>() {
  return ::octaneapi::DenoiserType_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::DenoiserQuality> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::DenoiserQuality>() {
  return ::octaneapi::DenoiserQuality_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::DecalTextureIndex> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::DecalTextureIndex>() {
  return ::octaneapi::DecalTextureIndex_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::DirectLightMode> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::DirectLightMode>() {
  return ::octaneapi::DirectLightMode_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::DispersionModel> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::DispersionModel>() {
  return ::octaneapi::DispersionModel_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::DisplacementLod> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::DisplacementLod>() {
  return ::octaneapi::DisplacementLod_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::DisplacementQuality> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::DisplacementQuality>() {
  return ::octaneapi::DisplacementQuality_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::DisplacementDirection> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::DisplacementDirection>() {
  return ::octaneapi::DisplacementDirection_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::DisplacementTextureSpace> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::DisplacementTextureSpace>() {
  return ::octaneapi::DisplacementTextureSpace_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::DisplacementMapType> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::DisplacementMapType>() {
  return ::octaneapi::DisplacementMapType_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::DisplacementTextureAxes> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::DisplacementTextureAxes>() {
  return ::octaneapi::DisplacementTextureAxes_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::DistanceMode> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::DistanceMode>() {
  return ::octaneapi::DistanceMode_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::ExpandContractRgbMode> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::ExpandContractRgbMode>() {
  return ::octaneapi::ExpandContractRgbMode_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::ExportState> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::ExportState>() {
  return ::octaneapi::ExportState_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::ExrCompressionType> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::ExrCompressionType>() {
  return ::octaneapi::ExrCompressionType_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::FaceCullingMode> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::FaceCullingMode>() {
  return ::octaneapi::FaceCullingMode_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::FalloffTextureMode> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::FalloffTextureMode>() {
  return ::octaneapi::FalloffTextureMode_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::FilterType> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::FilterType>() {
  return ::octaneapi::FilterType_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::FractalNoiseMode> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::FractalNoiseMode>() {
  return ::octaneapi::FractalNoiseMode_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::GaussianSplatClipMode> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::GaussianSplatClipMode>() {
  return ::octaneapi::GaussianSplatClipMode_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::GaussianSplatLightingMode> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::GaussianSplatLightingMode>() {
  return ::octaneapi::GaussianSplatLightingMode_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::GeometryExportFormat> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::GeometryExportFormat>() {
  return ::octaneapi::GeometryExportFormat_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::GeometryImportObjectLayers> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::GeometryImportObjectLayers>() {
  return ::octaneapi::GeometryImportObjectLayers_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::GeometryImportScale> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::GeometryImportScale>() {
  return ::octaneapi::GeometryImportScale_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::GlobalLightIdMaskAction> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::GlobalLightIdMaskAction>() {
  return ::octaneapi::GlobalLightIdMaskAction_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::GlobalTexAvo> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::GlobalTexAvo>() {
  return ::octaneapi::GlobalTexAvo_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::GradientGeneratorType> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::GradientGeneratorType>() {
  return ::octaneapi::GradientGeneratorType_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::GradientInterpColorSpace> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::GradientInterpColorSpace>() {
  return ::octaneapi::GradientInterpColorSpace_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::GradientInterpType> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::GradientInterpType>() {
  return ::octaneapi::GradientInterpType_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::HairInterpolationType> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::HairInterpolationType>() {
  return ::octaneapi::HairInterpolationType_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::HairMaterialBaseColorMode> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::HairMaterialBaseColorMode>() {
  return ::octaneapi::HairMaterialBaseColorMode_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::IesPhotometryMode> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::IesPhotometryMode>() {
  return ::octaneapi::IesPhotometryMode_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::ImageChannelType> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::ImageChannelType>() {
  return ::octaneapi::ImageChannelType_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::ImageColorType> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::ImageColorType>() {
  return ::octaneapi::ImageColorType_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::ImageFilterType> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::ImageFilterType>() {
  return ::octaneapi::ImageFilterType_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::ImageMaskSource> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::ImageMaskSource>() {
  return ::octaneapi::ImageMaskSource_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::ImageSaveFormat> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::ImageSaveFormat>() {
  return ::octaneapi::ImageSaveFormat_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::ImageType> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::ImageType>() {
  return ::octaneapi::ImageType_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::ImportRestAttributesMode> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::ImportRestAttributesMode>() {
  return ::octaneapi::ImportRestAttributesMode_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::InfoChannelType> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::InfoChannelType>() {
  return ::octaneapi::InfoChannelType_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::InfoChannelSamplingMode> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::InfoChannelSamplingMode>() {
  return ::octaneapi::InfoChannelSamplingMode_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::InputAction> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::InputAction>() {
  return ::octaneapi::InputAction_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::InterpolationType> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::InterpolationType>() {
  return ::octaneapi::InterpolationType_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::ItemDbOrigin> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::ItemDbOrigin>() {
  return ::octaneapi::ItemDbOrigin_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::LightAov> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::LightAov>() {
  return ::octaneapi::LightAov_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::LightPassMask> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::LightPassMask>() {
  return ::octaneapi::LightPassMask_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::LightSampler> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::LightSampler>() {
  return ::octaneapi::LightSampler_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::LiveDbThumbnailView> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::LiveDbThumbnailView>() {
  return ::octaneapi::LiveDbThumbnailView_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::LogicalOperator> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::LogicalOperator>() {
  return ::octaneapi::LogicalOperator_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::LuaScriptType> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::LuaScriptType>() {
  return ::octaneapi::LuaScriptType_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::MemoryLocation> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::MemoryLocation>() {
  return ::octaneapi::MemoryLocation_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::MetallicReflectionMode> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::MetallicReflectionMode>() {
  return ::octaneapi::MetallicReflectionMode_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::ModuleType> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::ModuleType>() {
  return ::octaneapi::ModuleType_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::MoireMosaicShape> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::MoireMosaicShape>() {
  return ::octaneapi::MoireMosaicShape_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::MovableInputFormat> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::MovableInputFormat>() {
  return ::octaneapi::MovableInputFormat_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::NamedColorSpace> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::NamedColorSpace>() {
  return ::octaneapi::NamedColorSpace_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::NoiseType> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::NoiseType>() {
  return ::octaneapi::NoiseType_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::NoiseTypeOsl> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::NoiseTypeOsl>() {
  return ::octaneapi::NoiseTypeOsl_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::NormalType> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::NormalType>() {
  return ::octaneapi::NormalType_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::ObjectIncludeMode> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::ObjectIncludeMode>() {
  return ::octaneapi::ObjectIncludeMode_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::ObjImportColorSpace> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::ObjImportColorSpace>() {
  return ::octaneapi::ObjImportColorSpace_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::OctaneLiveCategory> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::OctaneLiveCategory>() {
  return ::octaneapi::OctaneLiveCategory_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::TextureValueType> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::TextureValueType>() {
  return ::octaneapi::TextureValueType_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::TextureNodeTypeMode> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::TextureNodeTypeMode>() {
  return ::octaneapi::TextureNodeTypeMode_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::TexturePinValueTypeMode> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::TexturePinValueTypeMode>() {
  return ::octaneapi::TexturePinValueTypeMode_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::UnblendExtractMode> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::UnblendExtractMode>() {
  return ::octaneapi::UnblendExtractMode_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::UnblendOutputColorRange> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::UnblendOutputColorRange>() {
  return ::octaneapi::UnblendOutputColorRange_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::PanoramicCameraMode> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::PanoramicCameraMode>() {
  return ::octaneapi::PanoramicCameraMode_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::PhotonTypes> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::PhotonTypes>() {
  return ::octaneapi::PhotonTypes_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::PositionType> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::PositionType>() {
  return ::octaneapi::PositionType_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::PreferencesTabId> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::PreferencesTabId>() {
  return ::octaneapi::PreferencesTabId_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::PremultipliedAlphaType> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::PremultipliedAlphaType>() {
  return ::octaneapi::PremultipliedAlphaType_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::PrePassType> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::PrePassType>() {
  return ::octaneapi::PrePassType_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::PreviewType> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::PreviewType>() {
  return ::octaneapi::PreviewType_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::PrimitiveType> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::PrimitiveType>() {
  return ::octaneapi::PrimitiveType_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::ProceduralEffectType> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::ProceduralEffectType>() {
  return ::octaneapi::ProceduralEffectType_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::ReferenceAABBDisplay> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::ReferenceAABBDisplay>() {
  return ::octaneapi::ReferenceAABBDisplay_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::RenderDeviceState> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::RenderDeviceState>() {
  return ::octaneapi::RenderDeviceState_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::RenderError> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::RenderError>() {
  return ::octaneapi::RenderError_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::RenderJobAction> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::RenderJobAction>() {
  return ::octaneapi::RenderJobAction_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::RenderJobStatus> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::RenderJobStatus>() {
  return ::octaneapi::RenderJobStatus_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::RenderLayerMode> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::RenderLayerMode>() {
  return ::octaneapi::RenderLayerMode_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::RenderPassGroupId> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::RenderPassGroupId>() {
  return ::octaneapi::RenderPassGroupId_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::RenderPassId> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::RenderPassId>() {
  return ::octaneapi::RenderPassId_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::RenderState> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::RenderState>() {
  return ::octaneapi::RenderState_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::ResourceCategory> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::ResourceCategory>() {
  return ::octaneapi::ResourceCategory_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::ResponseCurveId> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::ResponseCurveId>() {
  return ::octaneapi::ResponseCurveId_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::RoundEdgesMode> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::RoundEdgesMode>() {
  return ::octaneapi::RoundEdgesMode_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::RoundingMode> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::RoundingMode>() {
  return ::octaneapi::RoundingMode_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::SamplerType> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::SamplerType>() {
  return ::octaneapi::SamplerType_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::ScriptExecuteType> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::ScriptExecuteType>() {
  return ::octaneapi::ScriptExecuteType_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::SharedSurfaceType> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::SharedSurfaceType>() {
  return ::octaneapi::SharedSurfaceType_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::ShutterIntervalAlignment> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::ShutterIntervalAlignment>() {
  return ::octaneapi::ShutterIntervalAlignment_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::SimulatedLens> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::SimulatedLens>() {
  return ::octaneapi::SimulatedLens_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::SpotlightOrientation> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::SpotlightOrientation>() {
  return ::octaneapi::SpotlightOrientation_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::StereoMode> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::StereoMode>() {
  return ::octaneapi::StereoMode_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::StereoOutput> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::StereoOutput>() {
  return ::octaneapi::StereoOutput_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::SubDivSchemeType> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::SubDivSchemeType>() {
  return ::octaneapi::SubDivSchemeType_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::SubDivInterpolateBoundary> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::SubDivInterpolateBoundary>() {
  return ::octaneapi::SubDivInterpolateBoundary_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::SubDivFVarInterpolateBoundary> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::SubDivFVarInterpolateBoundary>() {
  return ::octaneapi::SubDivFVarInterpolateBoundary_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::SubSampleMode> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::SubSampleMode>() {
  return ::octaneapi::SubSampleMode_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::TexelType> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::TexelType>() {
  return ::octaneapi::TexelType_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::TiffCompressionType> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::TiffCompressionType>() {
  return ::octaneapi::TiffCompressionType_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::TilePatternType> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::TilePatternType>() {
  return ::octaneapi::TilePatternType_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::TimeEventType> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::TimeEventType>() {
  return ::octaneapi::TimeEventType_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::TonemapOrder> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::TonemapOrder>() {
  return ::octaneapi::TonemapOrder_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::TonemapBufferType> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::TonemapBufferType>() {
  return ::octaneapi::TonemapBufferType_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::ToonLightMode> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::ToonLightMode>() {
  return ::octaneapi::ToonLightMode_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::TraceSetBounceType> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::TraceSetBounceType>() {
  return ::octaneapi::TraceSetBounceType_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::TraceSetFutureHits> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::TraceSetFutureHits>() {
  return ::octaneapi::TraceSetFutureHits_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::UIOperationsFlag> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::UIOperationsFlag>() {
  return ::octaneapi::UIOperationsFlag_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::UnaryOperation> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::UnaryOperation>() {
  return ::octaneapi::UnaryOperation_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::UniversalCamApertureShape> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::UniversalCamApertureShape>() {
  return ::octaneapi::UniversalCamApertureShape_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::UniversalCamCubemapLayout> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::UniversalCamCubemapLayout>() {
  return ::octaneapi::UniversalCamCubemapLayout_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::UniversalCamFisheyeProjection> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::UniversalCamFisheyeProjection>() {
  return ::octaneapi::UniversalCamFisheyeProjection_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::UniversalCamFisheyeType> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::UniversalCamFisheyeType>() {
  return ::octaneapi::UniversalCamFisheyeType_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::UniversalCamMode> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::UniversalCamMode>() {
  return ::octaneapi::UniversalCamMode_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::UpSampleMode> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::UpSampleMode>() {
  return ::octaneapi::UpSampleMode_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::UpSamplerType> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::UpSamplerType>() {
  return ::octaneapi::UpSamplerType_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::UpSampleSourcePercentage> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::UpSampleSourcePercentage>() {
  return ::octaneapi::UpSampleSourcePercentage_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::UsdDisplayPurpose> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::UsdDisplayPurpose>() {
  return ::octaneapi::UsdDisplayPurpose_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::VdbGridIds> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::VdbGridIds>() {
  return ::octaneapi::VdbGridIds_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::VectronCircleType> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::VectronCircleType>() {
  return ::octaneapi::VectronCircleType_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::VectronEdgeType> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::VectronEdgeType>() {
  return ::octaneapi::VectronEdgeType_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::VirtualTexturingMode> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::VirtualTexturingMode>() {
  return ::octaneapi::VirtualTexturingMode_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::VolumeEmissionType> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::VolumeEmissionType>() {
  return ::octaneapi::VolumeEmissionType_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::VolumeInterpolationType> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::VolumeInterpolationType>() {
  return ::octaneapi::VolumeInterpolationType_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::VolumeSampling> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::VolumeSampling>() {
  return ::octaneapi::VolumeSampling_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::Waveform> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::Waveform>() {
  return ::octaneapi::Waveform_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::WCoordinateBorderMode> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::WCoordinateBorderMode>() {
  return ::octaneapi::WCoordinateBorderMode_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::WhiteLightSpectrum> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::WhiteLightSpectrum>() {
  return ::octaneapi::WhiteLightSpectrum_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::WindingOrder> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::WindingOrder>() {
  return ::octaneapi::WindingOrder_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::ScatterSurfacePolygonMode> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::ScatterSurfacePolygonMode>() {
  return ::octaneapi::ScatterSurfacePolygonMode_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::ScatterSurfaceParticleMode> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::ScatterSurfaceParticleMode>() {
  return ::octaneapi::ScatterSurfaceParticleMode_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::ScatterSurfaceHairMode> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::ScatterSurfaceHairMode>() {
  return ::octaneapi::ScatterSurfaceHairMode_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::ScatterSurfaceSelectionMode> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::ScatterSurfaceSelectionMode>() {
  return ::octaneapi::ScatterSurfaceSelectionMode_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::ScatterSurfaceOrientationPriority> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::ScatterSurfaceOrientationPriority>() {
  return ::octaneapi::ScatterSurfaceOrientationPriority_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::ScatterSurfaceReferenceType> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::ScatterSurfaceReferenceType>() {
  return ::octaneapi::ScatterSurfaceReferenceType_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::ScatterSurfaceTransformType> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::ScatterSurfaceTransformType>() {
  return ::octaneapi::ScatterSurfaceTransformType_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::ScatterVolumeSelectionMode> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::ScatterVolumeSelectionMode>() {
  return ::octaneapi::ScatterVolumeSelectionMode_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::ScatterVolumeShape> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::ScatterVolumeShape>() {
  return ::octaneapi::ScatterVolumeShape_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::ScatterVolumeOrientationPriority> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::ScatterVolumeOrientationPriority>() {
  return ::octaneapi::ScatterVolumeOrientationPriority_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::ScatterVolumeReferenceType> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::ScatterVolumeReferenceType>() {
  return ::octaneapi::ScatterVolumeReferenceType_descriptor();
}
template <>
struct is_proto_enum<::octaneapi::ScatterVolumeTransformType> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::octaneapi::ScatterVolumeTransformType>() {
  return ::octaneapi::ScatterVolumeTransformType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // octaneenums_2eproto_2epb_2eh
