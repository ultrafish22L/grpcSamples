// Copyright (C) 2026 OTOY NZ Ltd.

// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: octanevolume.proto
// Original file comments:
// ////////////////////////////////////////////////////////////////////////////
// WARNING: This code is machine generated. Manual changes will be overridden.
//
#ifndef GRPC_octanevolume_2eproto__INCLUDED
#define GRPC_octanevolume_2eproto__INCLUDED

#include "octanevolume.pb.h"

#include <functional>
#include <grpcpp/generic/async_generic_service.h>
#include <grpcpp/support/async_stream.h>
#include <grpcpp/support/async_unary_call.h>
#include <grpcpp/support/client_callback.h>
#include <grpcpp/client_context.h>
#include <grpcpp/completion_queue.h>
#include <grpcpp/support/message_allocator.h>
#include <grpcpp/support/method_handler.h>
#include <grpcpp/impl/proto_utils.h>
#include <grpcpp/impl/rpc_method.h>
#include <grpcpp/support/server_callback.h>
#include <grpcpp/impl/server_callback_handlers.h>
#include <grpcpp/server_context.h>
#include <grpcpp/impl/service_type.h>
#include <grpcpp/support/status.h>
#include <grpcpp/support/stub_options.h>
#include <grpcpp/support/sync_stream.h>
#include <grpcpp/ports_def.inc>

namespace octaneapi {

// GRPC interface definition for class 'VdbGridInfo' from 'octanevolume.h'
class VdbGridInfoService final {
 public:
  static constexpr char const* service_full_name() {
    return "octaneapi.VdbGridInfoService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // / Returns the name of this grid
    virtual ::grpc::Status name(::grpc::ClientContext* context, const ::octaneapi::VdbGridInfo_nameRequest& request, ::octaneapi::VdbGridInfo_nameResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::VdbGridInfo_nameResponse>> Asyncname(::grpc::ClientContext* context, const ::octaneapi::VdbGridInfo_nameRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::VdbGridInfo_nameResponse>>(AsyncnameRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::VdbGridInfo_nameResponse>> PrepareAsyncname(::grpc::ClientContext* context, const ::octaneapi::VdbGridInfo_nameRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::VdbGridInfo_nameResponse>>(PrepareAsyncnameRaw(context, request, cq));
    }
    // / Returns the type of this grid
    virtual ::grpc::Status type(::grpc::ClientContext* context, const ::octaneapi::VdbGridInfo_typeRequest& request, ::octaneapi::VdbGridInfo_typeResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::VdbGridInfo_typeResponse>> Asynctype(::grpc::ClientContext* context, const ::octaneapi::VdbGridInfo_typeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::VdbGridInfo_typeResponse>>(AsynctypeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::VdbGridInfo_typeResponse>> PrepareAsynctype(::grpc::ClientContext* context, const ::octaneapi::VdbGridInfo_typeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::VdbGridInfo_typeResponse>>(PrepareAsynctypeRaw(context, request, cq));
    }
    // / Returns the width, height and depth of the grid in voxels
    virtual ::grpc::Status resolution(::grpc::ClientContext* context, const ::octaneapi::VdbGridInfo_resolutionRequest& request, ::octaneapi::VdbGridInfo_resolutionResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::VdbGridInfo_resolutionResponse>> Asyncresolution(::grpc::ClientContext* context, const ::octaneapi::VdbGridInfo_resolutionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::VdbGridInfo_resolutionResponse>>(AsyncresolutionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::VdbGridInfo_resolutionResponse>> PrepareAsyncresolution(::grpc::ClientContext* context, const ::octaneapi::VdbGridInfo_resolutionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::VdbGridInfo_resolutionResponse>>(PrepareAsyncresolutionRaw(context, request, cq));
    }
    // / Returns the minimum active voxel bounding box of the grid
    virtual ::grpc::Status minBound(::grpc::ClientContext* context, const ::octaneapi::VdbGridInfo_minBoundRequest& request, ::octaneapi::VdbGridInfo_minBoundResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::VdbGridInfo_minBoundResponse>> AsyncminBound(::grpc::ClientContext* context, const ::octaneapi::VdbGridInfo_minBoundRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::VdbGridInfo_minBoundResponse>>(AsyncminBoundRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::VdbGridInfo_minBoundResponse>> PrepareAsyncminBound(::grpc::ClientContext* context, const ::octaneapi::VdbGridInfo_minBoundRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::VdbGridInfo_minBoundResponse>>(PrepareAsyncminBoundRaw(context, request, cq));
    }
    // / Returns the maximum active voxel bounding box of the grid
    virtual ::grpc::Status maxBound(::grpc::ClientContext* context, const ::octaneapi::VdbGridInfo_maxBoundRequest& request, ::octaneapi::VdbGridInfo_maxBoundResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::VdbGridInfo_maxBoundResponse>> AsyncmaxBound(::grpc::ClientContext* context, const ::octaneapi::VdbGridInfo_maxBoundRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::VdbGridInfo_maxBoundResponse>>(AsyncmaxBoundRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::VdbGridInfo_maxBoundResponse>> PrepareAsyncmaxBound(::grpc::ClientContext* context, const ::octaneapi::VdbGridInfo_maxBoundRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::VdbGridInfo_maxBoundResponse>>(PrepareAsyncmaxBoundRaw(context, request, cq));
    }
    // / Returns the _transposed_ transform from the VDB, excluding the perspective projection
    virtual ::grpc::Status transform(::grpc::ClientContext* context, const ::octaneapi::VdbGridInfo_transformRequest& request, ::octaneapi::VdbGridInfo_transformResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::VdbGridInfo_transformResponse>> Asynctransform(::grpc::ClientContext* context, const ::octaneapi::VdbGridInfo_transformRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::VdbGridInfo_transformResponse>>(AsynctransformRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::VdbGridInfo_transformResponse>> PrepareAsynctransform(::grpc::ClientContext* context, const ::octaneapi::VdbGridInfo_transformRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::VdbGridInfo_transformResponse>>(PrepareAsynctransformRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      // / Returns the name of this grid
      virtual void name(::grpc::ClientContext* context, const ::octaneapi::VdbGridInfo_nameRequest* request, ::octaneapi::VdbGridInfo_nameResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void name(::grpc::ClientContext* context, const ::octaneapi::VdbGridInfo_nameRequest* request, ::octaneapi::VdbGridInfo_nameResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Returns the type of this grid
      virtual void type(::grpc::ClientContext* context, const ::octaneapi::VdbGridInfo_typeRequest* request, ::octaneapi::VdbGridInfo_typeResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void type(::grpc::ClientContext* context, const ::octaneapi::VdbGridInfo_typeRequest* request, ::octaneapi::VdbGridInfo_typeResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Returns the width, height and depth of the grid in voxels
      virtual void resolution(::grpc::ClientContext* context, const ::octaneapi::VdbGridInfo_resolutionRequest* request, ::octaneapi::VdbGridInfo_resolutionResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void resolution(::grpc::ClientContext* context, const ::octaneapi::VdbGridInfo_resolutionRequest* request, ::octaneapi::VdbGridInfo_resolutionResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Returns the minimum active voxel bounding box of the grid
      virtual void minBound(::grpc::ClientContext* context, const ::octaneapi::VdbGridInfo_minBoundRequest* request, ::octaneapi::VdbGridInfo_minBoundResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void minBound(::grpc::ClientContext* context, const ::octaneapi::VdbGridInfo_minBoundRequest* request, ::octaneapi::VdbGridInfo_minBoundResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Returns the maximum active voxel bounding box of the grid
      virtual void maxBound(::grpc::ClientContext* context, const ::octaneapi::VdbGridInfo_maxBoundRequest* request, ::octaneapi::VdbGridInfo_maxBoundResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void maxBound(::grpc::ClientContext* context, const ::octaneapi::VdbGridInfo_maxBoundRequest* request, ::octaneapi::VdbGridInfo_maxBoundResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Returns the _transposed_ transform from the VDB, excluding the perspective projection
      virtual void transform(::grpc::ClientContext* context, const ::octaneapi::VdbGridInfo_transformRequest* request, ::octaneapi::VdbGridInfo_transformResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void transform(::grpc::ClientContext* context, const ::octaneapi::VdbGridInfo_transformRequest* request, ::octaneapi::VdbGridInfo_transformResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::VdbGridInfo_nameResponse>* AsyncnameRaw(::grpc::ClientContext* context, const ::octaneapi::VdbGridInfo_nameRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::VdbGridInfo_nameResponse>* PrepareAsyncnameRaw(::grpc::ClientContext* context, const ::octaneapi::VdbGridInfo_nameRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::VdbGridInfo_typeResponse>* AsynctypeRaw(::grpc::ClientContext* context, const ::octaneapi::VdbGridInfo_typeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::VdbGridInfo_typeResponse>* PrepareAsynctypeRaw(::grpc::ClientContext* context, const ::octaneapi::VdbGridInfo_typeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::VdbGridInfo_resolutionResponse>* AsyncresolutionRaw(::grpc::ClientContext* context, const ::octaneapi::VdbGridInfo_resolutionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::VdbGridInfo_resolutionResponse>* PrepareAsyncresolutionRaw(::grpc::ClientContext* context, const ::octaneapi::VdbGridInfo_resolutionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::VdbGridInfo_minBoundResponse>* AsyncminBoundRaw(::grpc::ClientContext* context, const ::octaneapi::VdbGridInfo_minBoundRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::VdbGridInfo_minBoundResponse>* PrepareAsyncminBoundRaw(::grpc::ClientContext* context, const ::octaneapi::VdbGridInfo_minBoundRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::VdbGridInfo_maxBoundResponse>* AsyncmaxBoundRaw(::grpc::ClientContext* context, const ::octaneapi::VdbGridInfo_maxBoundRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::VdbGridInfo_maxBoundResponse>* PrepareAsyncmaxBoundRaw(::grpc::ClientContext* context, const ::octaneapi::VdbGridInfo_maxBoundRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::VdbGridInfo_transformResponse>* AsynctransformRaw(::grpc::ClientContext* context, const ::octaneapi::VdbGridInfo_transformRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::VdbGridInfo_transformResponse>* PrepareAsynctransformRaw(::grpc::ClientContext* context, const ::octaneapi::VdbGridInfo_transformRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status name(::grpc::ClientContext* context, const ::octaneapi::VdbGridInfo_nameRequest& request, ::octaneapi::VdbGridInfo_nameResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::VdbGridInfo_nameResponse>> Asyncname(::grpc::ClientContext* context, const ::octaneapi::VdbGridInfo_nameRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::VdbGridInfo_nameResponse>>(AsyncnameRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::VdbGridInfo_nameResponse>> PrepareAsyncname(::grpc::ClientContext* context, const ::octaneapi::VdbGridInfo_nameRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::VdbGridInfo_nameResponse>>(PrepareAsyncnameRaw(context, request, cq));
    }
    ::grpc::Status type(::grpc::ClientContext* context, const ::octaneapi::VdbGridInfo_typeRequest& request, ::octaneapi::VdbGridInfo_typeResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::VdbGridInfo_typeResponse>> Asynctype(::grpc::ClientContext* context, const ::octaneapi::VdbGridInfo_typeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::VdbGridInfo_typeResponse>>(AsynctypeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::VdbGridInfo_typeResponse>> PrepareAsynctype(::grpc::ClientContext* context, const ::octaneapi::VdbGridInfo_typeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::VdbGridInfo_typeResponse>>(PrepareAsynctypeRaw(context, request, cq));
    }
    ::grpc::Status resolution(::grpc::ClientContext* context, const ::octaneapi::VdbGridInfo_resolutionRequest& request, ::octaneapi::VdbGridInfo_resolutionResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::VdbGridInfo_resolutionResponse>> Asyncresolution(::grpc::ClientContext* context, const ::octaneapi::VdbGridInfo_resolutionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::VdbGridInfo_resolutionResponse>>(AsyncresolutionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::VdbGridInfo_resolutionResponse>> PrepareAsyncresolution(::grpc::ClientContext* context, const ::octaneapi::VdbGridInfo_resolutionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::VdbGridInfo_resolutionResponse>>(PrepareAsyncresolutionRaw(context, request, cq));
    }
    ::grpc::Status minBound(::grpc::ClientContext* context, const ::octaneapi::VdbGridInfo_minBoundRequest& request, ::octaneapi::VdbGridInfo_minBoundResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::VdbGridInfo_minBoundResponse>> AsyncminBound(::grpc::ClientContext* context, const ::octaneapi::VdbGridInfo_minBoundRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::VdbGridInfo_minBoundResponse>>(AsyncminBoundRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::VdbGridInfo_minBoundResponse>> PrepareAsyncminBound(::grpc::ClientContext* context, const ::octaneapi::VdbGridInfo_minBoundRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::VdbGridInfo_minBoundResponse>>(PrepareAsyncminBoundRaw(context, request, cq));
    }
    ::grpc::Status maxBound(::grpc::ClientContext* context, const ::octaneapi::VdbGridInfo_maxBoundRequest& request, ::octaneapi::VdbGridInfo_maxBoundResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::VdbGridInfo_maxBoundResponse>> AsyncmaxBound(::grpc::ClientContext* context, const ::octaneapi::VdbGridInfo_maxBoundRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::VdbGridInfo_maxBoundResponse>>(AsyncmaxBoundRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::VdbGridInfo_maxBoundResponse>> PrepareAsyncmaxBound(::grpc::ClientContext* context, const ::octaneapi::VdbGridInfo_maxBoundRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::VdbGridInfo_maxBoundResponse>>(PrepareAsyncmaxBoundRaw(context, request, cq));
    }
    ::grpc::Status transform(::grpc::ClientContext* context, const ::octaneapi::VdbGridInfo_transformRequest& request, ::octaneapi::VdbGridInfo_transformResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::VdbGridInfo_transformResponse>> Asynctransform(::grpc::ClientContext* context, const ::octaneapi::VdbGridInfo_transformRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::VdbGridInfo_transformResponse>>(AsynctransformRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::VdbGridInfo_transformResponse>> PrepareAsynctransform(::grpc::ClientContext* context, const ::octaneapi::VdbGridInfo_transformRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::VdbGridInfo_transformResponse>>(PrepareAsynctransformRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void name(::grpc::ClientContext* context, const ::octaneapi::VdbGridInfo_nameRequest* request, ::octaneapi::VdbGridInfo_nameResponse* response, std::function<void(::grpc::Status)>) override;
      void name(::grpc::ClientContext* context, const ::octaneapi::VdbGridInfo_nameRequest* request, ::octaneapi::VdbGridInfo_nameResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void type(::grpc::ClientContext* context, const ::octaneapi::VdbGridInfo_typeRequest* request, ::octaneapi::VdbGridInfo_typeResponse* response, std::function<void(::grpc::Status)>) override;
      void type(::grpc::ClientContext* context, const ::octaneapi::VdbGridInfo_typeRequest* request, ::octaneapi::VdbGridInfo_typeResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void resolution(::grpc::ClientContext* context, const ::octaneapi::VdbGridInfo_resolutionRequest* request, ::octaneapi::VdbGridInfo_resolutionResponse* response, std::function<void(::grpc::Status)>) override;
      void resolution(::grpc::ClientContext* context, const ::octaneapi::VdbGridInfo_resolutionRequest* request, ::octaneapi::VdbGridInfo_resolutionResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void minBound(::grpc::ClientContext* context, const ::octaneapi::VdbGridInfo_minBoundRequest* request, ::octaneapi::VdbGridInfo_minBoundResponse* response, std::function<void(::grpc::Status)>) override;
      void minBound(::grpc::ClientContext* context, const ::octaneapi::VdbGridInfo_minBoundRequest* request, ::octaneapi::VdbGridInfo_minBoundResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void maxBound(::grpc::ClientContext* context, const ::octaneapi::VdbGridInfo_maxBoundRequest* request, ::octaneapi::VdbGridInfo_maxBoundResponse* response, std::function<void(::grpc::Status)>) override;
      void maxBound(::grpc::ClientContext* context, const ::octaneapi::VdbGridInfo_maxBoundRequest* request, ::octaneapi::VdbGridInfo_maxBoundResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void transform(::grpc::ClientContext* context, const ::octaneapi::VdbGridInfo_transformRequest* request, ::octaneapi::VdbGridInfo_transformResponse* response, std::function<void(::grpc::Status)>) override;
      void transform(::grpc::ClientContext* context, const ::octaneapi::VdbGridInfo_transformRequest* request, ::octaneapi::VdbGridInfo_transformResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::octaneapi::VdbGridInfo_nameResponse>* AsyncnameRaw(::grpc::ClientContext* context, const ::octaneapi::VdbGridInfo_nameRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::VdbGridInfo_nameResponse>* PrepareAsyncnameRaw(::grpc::ClientContext* context, const ::octaneapi::VdbGridInfo_nameRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::VdbGridInfo_typeResponse>* AsynctypeRaw(::grpc::ClientContext* context, const ::octaneapi::VdbGridInfo_typeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::VdbGridInfo_typeResponse>* PrepareAsynctypeRaw(::grpc::ClientContext* context, const ::octaneapi::VdbGridInfo_typeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::VdbGridInfo_resolutionResponse>* AsyncresolutionRaw(::grpc::ClientContext* context, const ::octaneapi::VdbGridInfo_resolutionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::VdbGridInfo_resolutionResponse>* PrepareAsyncresolutionRaw(::grpc::ClientContext* context, const ::octaneapi::VdbGridInfo_resolutionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::VdbGridInfo_minBoundResponse>* AsyncminBoundRaw(::grpc::ClientContext* context, const ::octaneapi::VdbGridInfo_minBoundRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::VdbGridInfo_minBoundResponse>* PrepareAsyncminBoundRaw(::grpc::ClientContext* context, const ::octaneapi::VdbGridInfo_minBoundRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::VdbGridInfo_maxBoundResponse>* AsyncmaxBoundRaw(::grpc::ClientContext* context, const ::octaneapi::VdbGridInfo_maxBoundRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::VdbGridInfo_maxBoundResponse>* PrepareAsyncmaxBoundRaw(::grpc::ClientContext* context, const ::octaneapi::VdbGridInfo_maxBoundRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::VdbGridInfo_transformResponse>* AsynctransformRaw(::grpc::ClientContext* context, const ::octaneapi::VdbGridInfo_transformRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::VdbGridInfo_transformResponse>* PrepareAsynctransformRaw(::grpc::ClientContext* context, const ::octaneapi::VdbGridInfo_transformRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_name_;
    const ::grpc::internal::RpcMethod rpcmethod_type_;
    const ::grpc::internal::RpcMethod rpcmethod_resolution_;
    const ::grpc::internal::RpcMethod rpcmethod_minBound_;
    const ::grpc::internal::RpcMethod rpcmethod_maxBound_;
    const ::grpc::internal::RpcMethod rpcmethod_transform_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // / Returns the name of this grid
    virtual ::grpc::Status name(::grpc::ServerContext* context, const ::octaneapi::VdbGridInfo_nameRequest* request, ::octaneapi::VdbGridInfo_nameResponse* response);
    // / Returns the type of this grid
    virtual ::grpc::Status type(::grpc::ServerContext* context, const ::octaneapi::VdbGridInfo_typeRequest* request, ::octaneapi::VdbGridInfo_typeResponse* response);
    // / Returns the width, height and depth of the grid in voxels
    virtual ::grpc::Status resolution(::grpc::ServerContext* context, const ::octaneapi::VdbGridInfo_resolutionRequest* request, ::octaneapi::VdbGridInfo_resolutionResponse* response);
    // / Returns the minimum active voxel bounding box of the grid
    virtual ::grpc::Status minBound(::grpc::ServerContext* context, const ::octaneapi::VdbGridInfo_minBoundRequest* request, ::octaneapi::VdbGridInfo_minBoundResponse* response);
    // / Returns the maximum active voxel bounding box of the grid
    virtual ::grpc::Status maxBound(::grpc::ServerContext* context, const ::octaneapi::VdbGridInfo_maxBoundRequest* request, ::octaneapi::VdbGridInfo_maxBoundResponse* response);
    // / Returns the _transposed_ transform from the VDB, excluding the perspective projection
    virtual ::grpc::Status transform(::grpc::ServerContext* context, const ::octaneapi::VdbGridInfo_transformRequest* request, ::octaneapi::VdbGridInfo_transformResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_name : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_name() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_name() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status name(::grpc::ServerContext* /*context*/, const ::octaneapi::VdbGridInfo_nameRequest* /*request*/, ::octaneapi::VdbGridInfo_nameResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestname(::grpc::ServerContext* context, ::octaneapi::VdbGridInfo_nameRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::VdbGridInfo_nameResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_type : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_type() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_type() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status type(::grpc::ServerContext* /*context*/, const ::octaneapi::VdbGridInfo_typeRequest* /*request*/, ::octaneapi::VdbGridInfo_typeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requesttype(::grpc::ServerContext* context, ::octaneapi::VdbGridInfo_typeRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::VdbGridInfo_typeResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_resolution : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_resolution() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_resolution() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status resolution(::grpc::ServerContext* /*context*/, const ::octaneapi::VdbGridInfo_resolutionRequest* /*request*/, ::octaneapi::VdbGridInfo_resolutionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestresolution(::grpc::ServerContext* context, ::octaneapi::VdbGridInfo_resolutionRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::VdbGridInfo_resolutionResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_minBound : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_minBound() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_minBound() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status minBound(::grpc::ServerContext* /*context*/, const ::octaneapi::VdbGridInfo_minBoundRequest* /*request*/, ::octaneapi::VdbGridInfo_minBoundResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestminBound(::grpc::ServerContext* context, ::octaneapi::VdbGridInfo_minBoundRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::VdbGridInfo_minBoundResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_maxBound : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_maxBound() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_maxBound() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status maxBound(::grpc::ServerContext* /*context*/, const ::octaneapi::VdbGridInfo_maxBoundRequest* /*request*/, ::octaneapi::VdbGridInfo_maxBoundResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestmaxBound(::grpc::ServerContext* context, ::octaneapi::VdbGridInfo_maxBoundRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::VdbGridInfo_maxBoundResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_transform : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_transform() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_transform() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status transform(::grpc::ServerContext* /*context*/, const ::octaneapi::VdbGridInfo_transformRequest* /*request*/, ::octaneapi::VdbGridInfo_transformResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requesttransform(::grpc::ServerContext* context, ::octaneapi::VdbGridInfo_transformRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::VdbGridInfo_transformResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_name<WithAsyncMethod_type<WithAsyncMethod_resolution<WithAsyncMethod_minBound<WithAsyncMethod_maxBound<WithAsyncMethod_transform<Service > > > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_name : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_name() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::VdbGridInfo_nameRequest, ::octaneapi::VdbGridInfo_nameResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::VdbGridInfo_nameRequest* request, ::octaneapi::VdbGridInfo_nameResponse* response) { return this->name(context, request, response); }));}
    void SetMessageAllocatorFor_name(
        ::grpc::MessageAllocator< ::octaneapi::VdbGridInfo_nameRequest, ::octaneapi::VdbGridInfo_nameResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::VdbGridInfo_nameRequest, ::octaneapi::VdbGridInfo_nameResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_name() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status name(::grpc::ServerContext* /*context*/, const ::octaneapi::VdbGridInfo_nameRequest* /*request*/, ::octaneapi::VdbGridInfo_nameResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* name(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::VdbGridInfo_nameRequest* /*request*/, ::octaneapi::VdbGridInfo_nameResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_type : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_type() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::VdbGridInfo_typeRequest, ::octaneapi::VdbGridInfo_typeResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::VdbGridInfo_typeRequest* request, ::octaneapi::VdbGridInfo_typeResponse* response) { return this->type(context, request, response); }));}
    void SetMessageAllocatorFor_type(
        ::grpc::MessageAllocator< ::octaneapi::VdbGridInfo_typeRequest, ::octaneapi::VdbGridInfo_typeResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::VdbGridInfo_typeRequest, ::octaneapi::VdbGridInfo_typeResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_type() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status type(::grpc::ServerContext* /*context*/, const ::octaneapi::VdbGridInfo_typeRequest* /*request*/, ::octaneapi::VdbGridInfo_typeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* type(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::VdbGridInfo_typeRequest* /*request*/, ::octaneapi::VdbGridInfo_typeResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_resolution : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_resolution() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::VdbGridInfo_resolutionRequest, ::octaneapi::VdbGridInfo_resolutionResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::VdbGridInfo_resolutionRequest* request, ::octaneapi::VdbGridInfo_resolutionResponse* response) { return this->resolution(context, request, response); }));}
    void SetMessageAllocatorFor_resolution(
        ::grpc::MessageAllocator< ::octaneapi::VdbGridInfo_resolutionRequest, ::octaneapi::VdbGridInfo_resolutionResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::VdbGridInfo_resolutionRequest, ::octaneapi::VdbGridInfo_resolutionResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_resolution() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status resolution(::grpc::ServerContext* /*context*/, const ::octaneapi::VdbGridInfo_resolutionRequest* /*request*/, ::octaneapi::VdbGridInfo_resolutionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* resolution(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::VdbGridInfo_resolutionRequest* /*request*/, ::octaneapi::VdbGridInfo_resolutionResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_minBound : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_minBound() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::VdbGridInfo_minBoundRequest, ::octaneapi::VdbGridInfo_minBoundResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::VdbGridInfo_minBoundRequest* request, ::octaneapi::VdbGridInfo_minBoundResponse* response) { return this->minBound(context, request, response); }));}
    void SetMessageAllocatorFor_minBound(
        ::grpc::MessageAllocator< ::octaneapi::VdbGridInfo_minBoundRequest, ::octaneapi::VdbGridInfo_minBoundResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::VdbGridInfo_minBoundRequest, ::octaneapi::VdbGridInfo_minBoundResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_minBound() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status minBound(::grpc::ServerContext* /*context*/, const ::octaneapi::VdbGridInfo_minBoundRequest* /*request*/, ::octaneapi::VdbGridInfo_minBoundResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* minBound(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::VdbGridInfo_minBoundRequest* /*request*/, ::octaneapi::VdbGridInfo_minBoundResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_maxBound : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_maxBound() {
      ::grpc::Service::MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::VdbGridInfo_maxBoundRequest, ::octaneapi::VdbGridInfo_maxBoundResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::VdbGridInfo_maxBoundRequest* request, ::octaneapi::VdbGridInfo_maxBoundResponse* response) { return this->maxBound(context, request, response); }));}
    void SetMessageAllocatorFor_maxBound(
        ::grpc::MessageAllocator< ::octaneapi::VdbGridInfo_maxBoundRequest, ::octaneapi::VdbGridInfo_maxBoundResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::VdbGridInfo_maxBoundRequest, ::octaneapi::VdbGridInfo_maxBoundResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_maxBound() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status maxBound(::grpc::ServerContext* /*context*/, const ::octaneapi::VdbGridInfo_maxBoundRequest* /*request*/, ::octaneapi::VdbGridInfo_maxBoundResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* maxBound(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::VdbGridInfo_maxBoundRequest* /*request*/, ::octaneapi::VdbGridInfo_maxBoundResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_transform : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_transform() {
      ::grpc::Service::MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::VdbGridInfo_transformRequest, ::octaneapi::VdbGridInfo_transformResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::VdbGridInfo_transformRequest* request, ::octaneapi::VdbGridInfo_transformResponse* response) { return this->transform(context, request, response); }));}
    void SetMessageAllocatorFor_transform(
        ::grpc::MessageAllocator< ::octaneapi::VdbGridInfo_transformRequest, ::octaneapi::VdbGridInfo_transformResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::VdbGridInfo_transformRequest, ::octaneapi::VdbGridInfo_transformResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_transform() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status transform(::grpc::ServerContext* /*context*/, const ::octaneapi::VdbGridInfo_transformRequest* /*request*/, ::octaneapi::VdbGridInfo_transformResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* transform(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::VdbGridInfo_transformRequest* /*request*/, ::octaneapi::VdbGridInfo_transformResponse* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_name<WithCallbackMethod_type<WithCallbackMethod_resolution<WithCallbackMethod_minBound<WithCallbackMethod_maxBound<WithCallbackMethod_transform<Service > > > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_name : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_name() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_name() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status name(::grpc::ServerContext* /*context*/, const ::octaneapi::VdbGridInfo_nameRequest* /*request*/, ::octaneapi::VdbGridInfo_nameResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_type : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_type() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_type() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status type(::grpc::ServerContext* /*context*/, const ::octaneapi::VdbGridInfo_typeRequest* /*request*/, ::octaneapi::VdbGridInfo_typeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_resolution : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_resolution() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_resolution() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status resolution(::grpc::ServerContext* /*context*/, const ::octaneapi::VdbGridInfo_resolutionRequest* /*request*/, ::octaneapi::VdbGridInfo_resolutionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_minBound : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_minBound() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_minBound() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status minBound(::grpc::ServerContext* /*context*/, const ::octaneapi::VdbGridInfo_minBoundRequest* /*request*/, ::octaneapi::VdbGridInfo_minBoundResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_maxBound : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_maxBound() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_maxBound() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status maxBound(::grpc::ServerContext* /*context*/, const ::octaneapi::VdbGridInfo_maxBoundRequest* /*request*/, ::octaneapi::VdbGridInfo_maxBoundResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_transform : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_transform() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_transform() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status transform(::grpc::ServerContext* /*context*/, const ::octaneapi::VdbGridInfo_transformRequest* /*request*/, ::octaneapi::VdbGridInfo_transformResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_name : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_name() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_name() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status name(::grpc::ServerContext* /*context*/, const ::octaneapi::VdbGridInfo_nameRequest* /*request*/, ::octaneapi::VdbGridInfo_nameResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestname(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_type : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_type() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_type() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status type(::grpc::ServerContext* /*context*/, const ::octaneapi::VdbGridInfo_typeRequest* /*request*/, ::octaneapi::VdbGridInfo_typeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requesttype(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_resolution : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_resolution() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_resolution() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status resolution(::grpc::ServerContext* /*context*/, const ::octaneapi::VdbGridInfo_resolutionRequest* /*request*/, ::octaneapi::VdbGridInfo_resolutionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestresolution(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_minBound : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_minBound() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_minBound() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status minBound(::grpc::ServerContext* /*context*/, const ::octaneapi::VdbGridInfo_minBoundRequest* /*request*/, ::octaneapi::VdbGridInfo_minBoundResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestminBound(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_maxBound : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_maxBound() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_maxBound() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status maxBound(::grpc::ServerContext* /*context*/, const ::octaneapi::VdbGridInfo_maxBoundRequest* /*request*/, ::octaneapi::VdbGridInfo_maxBoundResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestmaxBound(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_transform : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_transform() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_transform() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status transform(::grpc::ServerContext* /*context*/, const ::octaneapi::VdbGridInfo_transformRequest* /*request*/, ::octaneapi::VdbGridInfo_transformResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requesttransform(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_name : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_name() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->name(context, request, response); }));
    }
    ~WithRawCallbackMethod_name() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status name(::grpc::ServerContext* /*context*/, const ::octaneapi::VdbGridInfo_nameRequest* /*request*/, ::octaneapi::VdbGridInfo_nameResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* name(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_type : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_type() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->type(context, request, response); }));
    }
    ~WithRawCallbackMethod_type() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status type(::grpc::ServerContext* /*context*/, const ::octaneapi::VdbGridInfo_typeRequest* /*request*/, ::octaneapi::VdbGridInfo_typeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* type(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_resolution : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_resolution() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->resolution(context, request, response); }));
    }
    ~WithRawCallbackMethod_resolution() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status resolution(::grpc::ServerContext* /*context*/, const ::octaneapi::VdbGridInfo_resolutionRequest* /*request*/, ::octaneapi::VdbGridInfo_resolutionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* resolution(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_minBound : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_minBound() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->minBound(context, request, response); }));
    }
    ~WithRawCallbackMethod_minBound() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status minBound(::grpc::ServerContext* /*context*/, const ::octaneapi::VdbGridInfo_minBoundRequest* /*request*/, ::octaneapi::VdbGridInfo_minBoundResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* minBound(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_maxBound : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_maxBound() {
      ::grpc::Service::MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->maxBound(context, request, response); }));
    }
    ~WithRawCallbackMethod_maxBound() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status maxBound(::grpc::ServerContext* /*context*/, const ::octaneapi::VdbGridInfo_maxBoundRequest* /*request*/, ::octaneapi::VdbGridInfo_maxBoundResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* maxBound(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_transform : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_transform() {
      ::grpc::Service::MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->transform(context, request, response); }));
    }
    ~WithRawCallbackMethod_transform() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status transform(::grpc::ServerContext* /*context*/, const ::octaneapi::VdbGridInfo_transformRequest* /*request*/, ::octaneapi::VdbGridInfo_transformResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* transform(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_name : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_name() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::VdbGridInfo_nameRequest, ::octaneapi::VdbGridInfo_nameResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::VdbGridInfo_nameRequest, ::octaneapi::VdbGridInfo_nameResponse>* streamer) {
                       return this->Streamedname(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_name() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status name(::grpc::ServerContext* /*context*/, const ::octaneapi::VdbGridInfo_nameRequest* /*request*/, ::octaneapi::VdbGridInfo_nameResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedname(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::VdbGridInfo_nameRequest,::octaneapi::VdbGridInfo_nameResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_type : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_type() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::VdbGridInfo_typeRequest, ::octaneapi::VdbGridInfo_typeResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::VdbGridInfo_typeRequest, ::octaneapi::VdbGridInfo_typeResponse>* streamer) {
                       return this->Streamedtype(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_type() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status type(::grpc::ServerContext* /*context*/, const ::octaneapi::VdbGridInfo_typeRequest* /*request*/, ::octaneapi::VdbGridInfo_typeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedtype(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::VdbGridInfo_typeRequest,::octaneapi::VdbGridInfo_typeResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_resolution : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_resolution() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::VdbGridInfo_resolutionRequest, ::octaneapi::VdbGridInfo_resolutionResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::VdbGridInfo_resolutionRequest, ::octaneapi::VdbGridInfo_resolutionResponse>* streamer) {
                       return this->Streamedresolution(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_resolution() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status resolution(::grpc::ServerContext* /*context*/, const ::octaneapi::VdbGridInfo_resolutionRequest* /*request*/, ::octaneapi::VdbGridInfo_resolutionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedresolution(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::VdbGridInfo_resolutionRequest,::octaneapi::VdbGridInfo_resolutionResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_minBound : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_minBound() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::VdbGridInfo_minBoundRequest, ::octaneapi::VdbGridInfo_minBoundResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::VdbGridInfo_minBoundRequest, ::octaneapi::VdbGridInfo_minBoundResponse>* streamer) {
                       return this->StreamedminBound(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_minBound() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status minBound(::grpc::ServerContext* /*context*/, const ::octaneapi::VdbGridInfo_minBoundRequest* /*request*/, ::octaneapi::VdbGridInfo_minBoundResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedminBound(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::VdbGridInfo_minBoundRequest,::octaneapi::VdbGridInfo_minBoundResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_maxBound : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_maxBound() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::VdbGridInfo_maxBoundRequest, ::octaneapi::VdbGridInfo_maxBoundResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::VdbGridInfo_maxBoundRequest, ::octaneapi::VdbGridInfo_maxBoundResponse>* streamer) {
                       return this->StreamedmaxBound(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_maxBound() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status maxBound(::grpc::ServerContext* /*context*/, const ::octaneapi::VdbGridInfo_maxBoundRequest* /*request*/, ::octaneapi::VdbGridInfo_maxBoundResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedmaxBound(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::VdbGridInfo_maxBoundRequest,::octaneapi::VdbGridInfo_maxBoundResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_transform : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_transform() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::VdbGridInfo_transformRequest, ::octaneapi::VdbGridInfo_transformResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::VdbGridInfo_transformRequest, ::octaneapi::VdbGridInfo_transformResponse>* streamer) {
                       return this->Streamedtransform(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_transform() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status transform(::grpc::ServerContext* /*context*/, const ::octaneapi::VdbGridInfo_transformRequest* /*request*/, ::octaneapi::VdbGridInfo_transformResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedtransform(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::VdbGridInfo_transformRequest,::octaneapi::VdbGridInfo_transformResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_name<WithStreamedUnaryMethod_type<WithStreamedUnaryMethod_resolution<WithStreamedUnaryMethod_minBound<WithStreamedUnaryMethod_maxBound<WithStreamedUnaryMethod_transform<Service > > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_name<WithStreamedUnaryMethod_type<WithStreamedUnaryMethod_resolution<WithStreamedUnaryMethod_minBound<WithStreamedUnaryMethod_maxBound<WithStreamedUnaryMethod_transform<Service > > > > > > StreamedService;
};

// GRPC interface definition for class 'VdbGridSampler' from 'octanevolume.h'
class VdbGridSamplerService final {
 public:
  static constexpr char const* service_full_name() {
    return "octaneapi.VdbGridSamplerService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // / Returns the voxel value at the given location of the current grid
    virtual ::grpc::Status getValue(::grpc::ClientContext* context, const ::octaneapi::VdbGridSampler_getValueRequest& request, ::octaneapi::VdbGridSampler_getValueResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::VdbGridSampler_getValueResponse>> AsyncgetValue(::grpc::ClientContext* context, const ::octaneapi::VdbGridSampler_getValueRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::VdbGridSampler_getValueResponse>>(AsyncgetValueRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::VdbGridSampler_getValueResponse>> PrepareAsyncgetValue(::grpc::ClientContext* context, const ::octaneapi::VdbGridSampler_getValueRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::VdbGridSampler_getValueResponse>>(PrepareAsyncgetValueRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      // / Returns the voxel value at the given location of the current grid
      virtual void getValue(::grpc::ClientContext* context, const ::octaneapi::VdbGridSampler_getValueRequest* request, ::octaneapi::VdbGridSampler_getValueResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void getValue(::grpc::ClientContext* context, const ::octaneapi::VdbGridSampler_getValueRequest* request, ::octaneapi::VdbGridSampler_getValueResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::VdbGridSampler_getValueResponse>* AsyncgetValueRaw(::grpc::ClientContext* context, const ::octaneapi::VdbGridSampler_getValueRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::VdbGridSampler_getValueResponse>* PrepareAsyncgetValueRaw(::grpc::ClientContext* context, const ::octaneapi::VdbGridSampler_getValueRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status getValue(::grpc::ClientContext* context, const ::octaneapi::VdbGridSampler_getValueRequest& request, ::octaneapi::VdbGridSampler_getValueResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::VdbGridSampler_getValueResponse>> AsyncgetValue(::grpc::ClientContext* context, const ::octaneapi::VdbGridSampler_getValueRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::VdbGridSampler_getValueResponse>>(AsyncgetValueRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::VdbGridSampler_getValueResponse>> PrepareAsyncgetValue(::grpc::ClientContext* context, const ::octaneapi::VdbGridSampler_getValueRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::VdbGridSampler_getValueResponse>>(PrepareAsyncgetValueRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void getValue(::grpc::ClientContext* context, const ::octaneapi::VdbGridSampler_getValueRequest* request, ::octaneapi::VdbGridSampler_getValueResponse* response, std::function<void(::grpc::Status)>) override;
      void getValue(::grpc::ClientContext* context, const ::octaneapi::VdbGridSampler_getValueRequest* request, ::octaneapi::VdbGridSampler_getValueResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::octaneapi::VdbGridSampler_getValueResponse>* AsyncgetValueRaw(::grpc::ClientContext* context, const ::octaneapi::VdbGridSampler_getValueRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::VdbGridSampler_getValueResponse>* PrepareAsyncgetValueRaw(::grpc::ClientContext* context, const ::octaneapi::VdbGridSampler_getValueRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_getValue_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // / Returns the voxel value at the given location of the current grid
    virtual ::grpc::Status getValue(::grpc::ServerContext* context, const ::octaneapi::VdbGridSampler_getValueRequest* request, ::octaneapi::VdbGridSampler_getValueResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_getValue : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_getValue() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_getValue() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getValue(::grpc::ServerContext* /*context*/, const ::octaneapi::VdbGridSampler_getValueRequest* /*request*/, ::octaneapi::VdbGridSampler_getValueResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetValue(::grpc::ServerContext* context, ::octaneapi::VdbGridSampler_getValueRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::VdbGridSampler_getValueResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_getValue<Service > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_getValue : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_getValue() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::VdbGridSampler_getValueRequest, ::octaneapi::VdbGridSampler_getValueResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::VdbGridSampler_getValueRequest* request, ::octaneapi::VdbGridSampler_getValueResponse* response) { return this->getValue(context, request, response); }));}
    void SetMessageAllocatorFor_getValue(
        ::grpc::MessageAllocator< ::octaneapi::VdbGridSampler_getValueRequest, ::octaneapi::VdbGridSampler_getValueResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::VdbGridSampler_getValueRequest, ::octaneapi::VdbGridSampler_getValueResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_getValue() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getValue(::grpc::ServerContext* /*context*/, const ::octaneapi::VdbGridSampler_getValueRequest* /*request*/, ::octaneapi::VdbGridSampler_getValueResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getValue(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::VdbGridSampler_getValueRequest* /*request*/, ::octaneapi::VdbGridSampler_getValueResponse* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_getValue<Service > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_getValue : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_getValue() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_getValue() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getValue(::grpc::ServerContext* /*context*/, const ::octaneapi::VdbGridSampler_getValueRequest* /*request*/, ::octaneapi::VdbGridSampler_getValueResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_getValue : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_getValue() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_getValue() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getValue(::grpc::ServerContext* /*context*/, const ::octaneapi::VdbGridSampler_getValueRequest* /*request*/, ::octaneapi::VdbGridSampler_getValueResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetValue(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_getValue : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_getValue() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->getValue(context, request, response); }));
    }
    ~WithRawCallbackMethod_getValue() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getValue(::grpc::ServerContext* /*context*/, const ::octaneapi::VdbGridSampler_getValueRequest* /*request*/, ::octaneapi::VdbGridSampler_getValueResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getValue(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_getValue : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_getValue() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::VdbGridSampler_getValueRequest, ::octaneapi::VdbGridSampler_getValueResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::VdbGridSampler_getValueRequest, ::octaneapi::VdbGridSampler_getValueResponse>* streamer) {
                       return this->StreamedgetValue(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_getValue() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status getValue(::grpc::ServerContext* /*context*/, const ::octaneapi::VdbGridSampler_getValueRequest* /*request*/, ::octaneapi::VdbGridSampler_getValueResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedgetValue(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::VdbGridSampler_getValueRequest,::octaneapi::VdbGridSampler_getValueResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_getValue<Service > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_getValue<Service > StreamedService;
};

// GRPC interface definition for class 'VdbInfo' from 'octanevolume.h'
class VdbInfoService final {
 public:
  static constexpr char const* service_full_name() {
    return "octaneapi.VdbInfoService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // / If the VDB information was loaded successfully, this will return TRUE, otherwise FALSE
    virtual ::grpc::Status valid(::grpc::ClientContext* context, const ::octaneapi::VdbInfo_validRequest& request, ::octaneapi::VdbInfo_validResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::VdbInfo_validResponse>> Asyncvalid(::grpc::ClientContext* context, const ::octaneapi::VdbInfo_validRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::VdbInfo_validResponse>>(AsyncvalidRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::VdbInfo_validResponse>> PrepareAsyncvalid(::grpc::ClientContext* context, const ::octaneapi::VdbInfo_validRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::VdbInfo_validResponse>>(PrepareAsyncvalidRaw(context, request, cq));
    }
    // / Returns the number of grids stored in the VDB file
    virtual ::grpc::Status gridCount(::grpc::ClientContext* context, const ::octaneapi::VdbInfo_gridCountRequest& request, ::octaneapi::VdbInfo_gridCountResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::VdbInfo_gridCountResponse>> AsyncgridCount(::grpc::ClientContext* context, const ::octaneapi::VdbInfo_gridCountRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::VdbInfo_gridCountResponse>>(AsyncgridCountRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::VdbInfo_gridCountResponse>> PrepareAsyncgridCount(::grpc::ClientContext* context, const ::octaneapi::VdbInfo_gridCountRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::VdbInfo_gridCountResponse>>(PrepareAsyncgridCountRaw(context, request, cq));
    }
    // / Returns a pointer to the VdbGridInfo of the specified index or NULL if the index is invalid
    // / or the VdbInfo wasn't loaded correctly
    virtual ::grpc::Status grid(::grpc::ClientContext* context, const ::octaneapi::VdbInfo_gridRequest& request, ::octaneapi::VdbInfo_gridResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::VdbInfo_gridResponse>> Asyncgrid(::grpc::ClientContext* context, const ::octaneapi::VdbInfo_gridRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::VdbInfo_gridResponse>>(AsyncgridRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::VdbInfo_gridResponse>> PrepareAsyncgrid(::grpc::ClientContext* context, const ::octaneapi::VdbInfo_gridRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::VdbInfo_gridResponse>>(PrepareAsyncgridRaw(context, request, cq));
    }
    // / Returns a pointer to the VdbGridSampler of the specified index or NULL if the index is invalid
    // / , the current grid is not a float grid or the VdbInfo wasn't loaded correctly
    virtual ::grpc::Status sampler(::grpc::ClientContext* context, const ::octaneapi::VdbInfo_samplerRequest& request, ::octaneapi::VdbInfo_samplerResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::VdbInfo_samplerResponse>> Asyncsampler(::grpc::ClientContext* context, const ::octaneapi::VdbInfo_samplerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::VdbInfo_samplerResponse>>(AsyncsamplerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::VdbInfo_samplerResponse>> PrepareAsyncsampler(::grpc::ClientContext* context, const ::octaneapi::VdbInfo_samplerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::VdbInfo_samplerResponse>>(PrepareAsyncsamplerRaw(context, request, cq));
    }
    // / Destroys the single sampler if any
    virtual ::grpc::Status destroySampler(::grpc::ClientContext* context, const ::octaneapi::VdbInfo_destroySamplerRequest& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncdestroySampler(::grpc::ClientContext* context, const ::octaneapi::VdbInfo_destroySamplerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncdestroySamplerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncdestroySampler(::grpc::ClientContext* context, const ::octaneapi::VdbInfo_destroySamplerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncdestroySamplerRaw(context, request, cq));
    }
    // / Convenience function to check whether a grid a) exists, b) is of a suitable type for the 
    // / channel specified
    virtual ::grpc::Status findGrid(::grpc::ClientContext* context, const ::octaneapi::VdbInfo_findGridRequest& request, ::octaneapi::VdbInfo_findGridResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::VdbInfo_findGridResponse>> AsyncfindGrid(::grpc::ClientContext* context, const ::octaneapi::VdbInfo_findGridRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::VdbInfo_findGridResponse>>(AsyncfindGridRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::VdbInfo_findGridResponse>> PrepareAsyncfindGrid(::grpc::ClientContext* context, const ::octaneapi::VdbInfo_findGridRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::VdbInfo_findGridResponse>>(PrepareAsyncfindGridRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      // / If the VDB information was loaded successfully, this will return TRUE, otherwise FALSE
      virtual void valid(::grpc::ClientContext* context, const ::octaneapi::VdbInfo_validRequest* request, ::octaneapi::VdbInfo_validResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void valid(::grpc::ClientContext* context, const ::octaneapi::VdbInfo_validRequest* request, ::octaneapi::VdbInfo_validResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Returns the number of grids stored in the VDB file
      virtual void gridCount(::grpc::ClientContext* context, const ::octaneapi::VdbInfo_gridCountRequest* request, ::octaneapi::VdbInfo_gridCountResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void gridCount(::grpc::ClientContext* context, const ::octaneapi::VdbInfo_gridCountRequest* request, ::octaneapi::VdbInfo_gridCountResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Returns a pointer to the VdbGridInfo of the specified index or NULL if the index is invalid
      // / or the VdbInfo wasn't loaded correctly
      virtual void grid(::grpc::ClientContext* context, const ::octaneapi::VdbInfo_gridRequest* request, ::octaneapi::VdbInfo_gridResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void grid(::grpc::ClientContext* context, const ::octaneapi::VdbInfo_gridRequest* request, ::octaneapi::VdbInfo_gridResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Returns a pointer to the VdbGridSampler of the specified index or NULL if the index is invalid
      // / , the current grid is not a float grid or the VdbInfo wasn't loaded correctly
      virtual void sampler(::grpc::ClientContext* context, const ::octaneapi::VdbInfo_samplerRequest* request, ::octaneapi::VdbInfo_samplerResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void sampler(::grpc::ClientContext* context, const ::octaneapi::VdbInfo_samplerRequest* request, ::octaneapi::VdbInfo_samplerResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Destroys the single sampler if any
      virtual void destroySampler(::grpc::ClientContext* context, const ::octaneapi::VdbInfo_destroySamplerRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void destroySampler(::grpc::ClientContext* context, const ::octaneapi::VdbInfo_destroySamplerRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Convenience function to check whether a grid a) exists, b) is of a suitable type for the 
      // / channel specified
      virtual void findGrid(::grpc::ClientContext* context, const ::octaneapi::VdbInfo_findGridRequest* request, ::octaneapi::VdbInfo_findGridResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void findGrid(::grpc::ClientContext* context, const ::octaneapi::VdbInfo_findGridRequest* request, ::octaneapi::VdbInfo_findGridResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::VdbInfo_validResponse>* AsyncvalidRaw(::grpc::ClientContext* context, const ::octaneapi::VdbInfo_validRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::VdbInfo_validResponse>* PrepareAsyncvalidRaw(::grpc::ClientContext* context, const ::octaneapi::VdbInfo_validRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::VdbInfo_gridCountResponse>* AsyncgridCountRaw(::grpc::ClientContext* context, const ::octaneapi::VdbInfo_gridCountRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::VdbInfo_gridCountResponse>* PrepareAsyncgridCountRaw(::grpc::ClientContext* context, const ::octaneapi::VdbInfo_gridCountRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::VdbInfo_gridResponse>* AsyncgridRaw(::grpc::ClientContext* context, const ::octaneapi::VdbInfo_gridRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::VdbInfo_gridResponse>* PrepareAsyncgridRaw(::grpc::ClientContext* context, const ::octaneapi::VdbInfo_gridRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::VdbInfo_samplerResponse>* AsyncsamplerRaw(::grpc::ClientContext* context, const ::octaneapi::VdbInfo_samplerRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::VdbInfo_samplerResponse>* PrepareAsyncsamplerRaw(::grpc::ClientContext* context, const ::octaneapi::VdbInfo_samplerRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncdestroySamplerRaw(::grpc::ClientContext* context, const ::octaneapi::VdbInfo_destroySamplerRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncdestroySamplerRaw(::grpc::ClientContext* context, const ::octaneapi::VdbInfo_destroySamplerRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::VdbInfo_findGridResponse>* AsyncfindGridRaw(::grpc::ClientContext* context, const ::octaneapi::VdbInfo_findGridRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::octaneapi::VdbInfo_findGridResponse>* PrepareAsyncfindGridRaw(::grpc::ClientContext* context, const ::octaneapi::VdbInfo_findGridRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status valid(::grpc::ClientContext* context, const ::octaneapi::VdbInfo_validRequest& request, ::octaneapi::VdbInfo_validResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::VdbInfo_validResponse>> Asyncvalid(::grpc::ClientContext* context, const ::octaneapi::VdbInfo_validRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::VdbInfo_validResponse>>(AsyncvalidRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::VdbInfo_validResponse>> PrepareAsyncvalid(::grpc::ClientContext* context, const ::octaneapi::VdbInfo_validRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::VdbInfo_validResponse>>(PrepareAsyncvalidRaw(context, request, cq));
    }
    ::grpc::Status gridCount(::grpc::ClientContext* context, const ::octaneapi::VdbInfo_gridCountRequest& request, ::octaneapi::VdbInfo_gridCountResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::VdbInfo_gridCountResponse>> AsyncgridCount(::grpc::ClientContext* context, const ::octaneapi::VdbInfo_gridCountRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::VdbInfo_gridCountResponse>>(AsyncgridCountRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::VdbInfo_gridCountResponse>> PrepareAsyncgridCount(::grpc::ClientContext* context, const ::octaneapi::VdbInfo_gridCountRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::VdbInfo_gridCountResponse>>(PrepareAsyncgridCountRaw(context, request, cq));
    }
    ::grpc::Status grid(::grpc::ClientContext* context, const ::octaneapi::VdbInfo_gridRequest& request, ::octaneapi::VdbInfo_gridResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::VdbInfo_gridResponse>> Asyncgrid(::grpc::ClientContext* context, const ::octaneapi::VdbInfo_gridRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::VdbInfo_gridResponse>>(AsyncgridRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::VdbInfo_gridResponse>> PrepareAsyncgrid(::grpc::ClientContext* context, const ::octaneapi::VdbInfo_gridRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::VdbInfo_gridResponse>>(PrepareAsyncgridRaw(context, request, cq));
    }
    ::grpc::Status sampler(::grpc::ClientContext* context, const ::octaneapi::VdbInfo_samplerRequest& request, ::octaneapi::VdbInfo_samplerResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::VdbInfo_samplerResponse>> Asyncsampler(::grpc::ClientContext* context, const ::octaneapi::VdbInfo_samplerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::VdbInfo_samplerResponse>>(AsyncsamplerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::VdbInfo_samplerResponse>> PrepareAsyncsampler(::grpc::ClientContext* context, const ::octaneapi::VdbInfo_samplerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::VdbInfo_samplerResponse>>(PrepareAsyncsamplerRaw(context, request, cq));
    }
    ::grpc::Status destroySampler(::grpc::ClientContext* context, const ::octaneapi::VdbInfo_destroySamplerRequest& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncdestroySampler(::grpc::ClientContext* context, const ::octaneapi::VdbInfo_destroySamplerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncdestroySamplerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncdestroySampler(::grpc::ClientContext* context, const ::octaneapi::VdbInfo_destroySamplerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncdestroySamplerRaw(context, request, cq));
    }
    ::grpc::Status findGrid(::grpc::ClientContext* context, const ::octaneapi::VdbInfo_findGridRequest& request, ::octaneapi::VdbInfo_findGridResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::VdbInfo_findGridResponse>> AsyncfindGrid(::grpc::ClientContext* context, const ::octaneapi::VdbInfo_findGridRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::VdbInfo_findGridResponse>>(AsyncfindGridRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::VdbInfo_findGridResponse>> PrepareAsyncfindGrid(::grpc::ClientContext* context, const ::octaneapi::VdbInfo_findGridRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::octaneapi::VdbInfo_findGridResponse>>(PrepareAsyncfindGridRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void valid(::grpc::ClientContext* context, const ::octaneapi::VdbInfo_validRequest* request, ::octaneapi::VdbInfo_validResponse* response, std::function<void(::grpc::Status)>) override;
      void valid(::grpc::ClientContext* context, const ::octaneapi::VdbInfo_validRequest* request, ::octaneapi::VdbInfo_validResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void gridCount(::grpc::ClientContext* context, const ::octaneapi::VdbInfo_gridCountRequest* request, ::octaneapi::VdbInfo_gridCountResponse* response, std::function<void(::grpc::Status)>) override;
      void gridCount(::grpc::ClientContext* context, const ::octaneapi::VdbInfo_gridCountRequest* request, ::octaneapi::VdbInfo_gridCountResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void grid(::grpc::ClientContext* context, const ::octaneapi::VdbInfo_gridRequest* request, ::octaneapi::VdbInfo_gridResponse* response, std::function<void(::grpc::Status)>) override;
      void grid(::grpc::ClientContext* context, const ::octaneapi::VdbInfo_gridRequest* request, ::octaneapi::VdbInfo_gridResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void sampler(::grpc::ClientContext* context, const ::octaneapi::VdbInfo_samplerRequest* request, ::octaneapi::VdbInfo_samplerResponse* response, std::function<void(::grpc::Status)>) override;
      void sampler(::grpc::ClientContext* context, const ::octaneapi::VdbInfo_samplerRequest* request, ::octaneapi::VdbInfo_samplerResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void destroySampler(::grpc::ClientContext* context, const ::octaneapi::VdbInfo_destroySamplerRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      void destroySampler(::grpc::ClientContext* context, const ::octaneapi::VdbInfo_destroySamplerRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void findGrid(::grpc::ClientContext* context, const ::octaneapi::VdbInfo_findGridRequest* request, ::octaneapi::VdbInfo_findGridResponse* response, std::function<void(::grpc::Status)>) override;
      void findGrid(::grpc::ClientContext* context, const ::octaneapi::VdbInfo_findGridRequest* request, ::octaneapi::VdbInfo_findGridResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::octaneapi::VdbInfo_validResponse>* AsyncvalidRaw(::grpc::ClientContext* context, const ::octaneapi::VdbInfo_validRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::VdbInfo_validResponse>* PrepareAsyncvalidRaw(::grpc::ClientContext* context, const ::octaneapi::VdbInfo_validRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::VdbInfo_gridCountResponse>* AsyncgridCountRaw(::grpc::ClientContext* context, const ::octaneapi::VdbInfo_gridCountRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::VdbInfo_gridCountResponse>* PrepareAsyncgridCountRaw(::grpc::ClientContext* context, const ::octaneapi::VdbInfo_gridCountRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::VdbInfo_gridResponse>* AsyncgridRaw(::grpc::ClientContext* context, const ::octaneapi::VdbInfo_gridRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::VdbInfo_gridResponse>* PrepareAsyncgridRaw(::grpc::ClientContext* context, const ::octaneapi::VdbInfo_gridRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::VdbInfo_samplerResponse>* AsyncsamplerRaw(::grpc::ClientContext* context, const ::octaneapi::VdbInfo_samplerRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::VdbInfo_samplerResponse>* PrepareAsyncsamplerRaw(::grpc::ClientContext* context, const ::octaneapi::VdbInfo_samplerRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncdestroySamplerRaw(::grpc::ClientContext* context, const ::octaneapi::VdbInfo_destroySamplerRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncdestroySamplerRaw(::grpc::ClientContext* context, const ::octaneapi::VdbInfo_destroySamplerRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::VdbInfo_findGridResponse>* AsyncfindGridRaw(::grpc::ClientContext* context, const ::octaneapi::VdbInfo_findGridRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::octaneapi::VdbInfo_findGridResponse>* PrepareAsyncfindGridRaw(::grpc::ClientContext* context, const ::octaneapi::VdbInfo_findGridRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_valid_;
    const ::grpc::internal::RpcMethod rpcmethod_gridCount_;
    const ::grpc::internal::RpcMethod rpcmethod_grid_;
    const ::grpc::internal::RpcMethod rpcmethod_sampler_;
    const ::grpc::internal::RpcMethod rpcmethod_destroySampler_;
    const ::grpc::internal::RpcMethod rpcmethod_findGrid_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // / If the VDB information was loaded successfully, this will return TRUE, otherwise FALSE
    virtual ::grpc::Status valid(::grpc::ServerContext* context, const ::octaneapi::VdbInfo_validRequest* request, ::octaneapi::VdbInfo_validResponse* response);
    // / Returns the number of grids stored in the VDB file
    virtual ::grpc::Status gridCount(::grpc::ServerContext* context, const ::octaneapi::VdbInfo_gridCountRequest* request, ::octaneapi::VdbInfo_gridCountResponse* response);
    // / Returns a pointer to the VdbGridInfo of the specified index or NULL if the index is invalid
    // / or the VdbInfo wasn't loaded correctly
    virtual ::grpc::Status grid(::grpc::ServerContext* context, const ::octaneapi::VdbInfo_gridRequest* request, ::octaneapi::VdbInfo_gridResponse* response);
    // / Returns a pointer to the VdbGridSampler of the specified index or NULL if the index is invalid
    // / , the current grid is not a float grid or the VdbInfo wasn't loaded correctly
    virtual ::grpc::Status sampler(::grpc::ServerContext* context, const ::octaneapi::VdbInfo_samplerRequest* request, ::octaneapi::VdbInfo_samplerResponse* response);
    // / Destroys the single sampler if any
    virtual ::grpc::Status destroySampler(::grpc::ServerContext* context, const ::octaneapi::VdbInfo_destroySamplerRequest* request, ::google::protobuf::Empty* response);
    // / Convenience function to check whether a grid a) exists, b) is of a suitable type for the 
    // / channel specified
    virtual ::grpc::Status findGrid(::grpc::ServerContext* context, const ::octaneapi::VdbInfo_findGridRequest* request, ::octaneapi::VdbInfo_findGridResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_valid : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_valid() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_valid() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status valid(::grpc::ServerContext* /*context*/, const ::octaneapi::VdbInfo_validRequest* /*request*/, ::octaneapi::VdbInfo_validResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestvalid(::grpc::ServerContext* context, ::octaneapi::VdbInfo_validRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::VdbInfo_validResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_gridCount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_gridCount() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_gridCount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status gridCount(::grpc::ServerContext* /*context*/, const ::octaneapi::VdbInfo_gridCountRequest* /*request*/, ::octaneapi::VdbInfo_gridCountResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgridCount(::grpc::ServerContext* context, ::octaneapi::VdbInfo_gridCountRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::VdbInfo_gridCountResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_grid : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_grid() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_grid() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status grid(::grpc::ServerContext* /*context*/, const ::octaneapi::VdbInfo_gridRequest* /*request*/, ::octaneapi::VdbInfo_gridResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestgrid(::grpc::ServerContext* context, ::octaneapi::VdbInfo_gridRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::VdbInfo_gridResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_sampler : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_sampler() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_sampler() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status sampler(::grpc::ServerContext* /*context*/, const ::octaneapi::VdbInfo_samplerRequest* /*request*/, ::octaneapi::VdbInfo_samplerResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestsampler(::grpc::ServerContext* context, ::octaneapi::VdbInfo_samplerRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::VdbInfo_samplerResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_destroySampler : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_destroySampler() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_destroySampler() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status destroySampler(::grpc::ServerContext* /*context*/, const ::octaneapi::VdbInfo_destroySamplerRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestdestroySampler(::grpc::ServerContext* context, ::octaneapi::VdbInfo_destroySamplerRequest* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_findGrid : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_findGrid() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_findGrid() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status findGrid(::grpc::ServerContext* /*context*/, const ::octaneapi::VdbInfo_findGridRequest* /*request*/, ::octaneapi::VdbInfo_findGridResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestfindGrid(::grpc::ServerContext* context, ::octaneapi::VdbInfo_findGridRequest* request, ::grpc::ServerAsyncResponseWriter< ::octaneapi::VdbInfo_findGridResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_valid<WithAsyncMethod_gridCount<WithAsyncMethod_grid<WithAsyncMethod_sampler<WithAsyncMethod_destroySampler<WithAsyncMethod_findGrid<Service > > > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_valid : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_valid() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::VdbInfo_validRequest, ::octaneapi::VdbInfo_validResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::VdbInfo_validRequest* request, ::octaneapi::VdbInfo_validResponse* response) { return this->valid(context, request, response); }));}
    void SetMessageAllocatorFor_valid(
        ::grpc::MessageAllocator< ::octaneapi::VdbInfo_validRequest, ::octaneapi::VdbInfo_validResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::VdbInfo_validRequest, ::octaneapi::VdbInfo_validResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_valid() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status valid(::grpc::ServerContext* /*context*/, const ::octaneapi::VdbInfo_validRequest* /*request*/, ::octaneapi::VdbInfo_validResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* valid(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::VdbInfo_validRequest* /*request*/, ::octaneapi::VdbInfo_validResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_gridCount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_gridCount() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::VdbInfo_gridCountRequest, ::octaneapi::VdbInfo_gridCountResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::VdbInfo_gridCountRequest* request, ::octaneapi::VdbInfo_gridCountResponse* response) { return this->gridCount(context, request, response); }));}
    void SetMessageAllocatorFor_gridCount(
        ::grpc::MessageAllocator< ::octaneapi::VdbInfo_gridCountRequest, ::octaneapi::VdbInfo_gridCountResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::VdbInfo_gridCountRequest, ::octaneapi::VdbInfo_gridCountResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_gridCount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status gridCount(::grpc::ServerContext* /*context*/, const ::octaneapi::VdbInfo_gridCountRequest* /*request*/, ::octaneapi::VdbInfo_gridCountResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* gridCount(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::VdbInfo_gridCountRequest* /*request*/, ::octaneapi::VdbInfo_gridCountResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_grid : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_grid() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::VdbInfo_gridRequest, ::octaneapi::VdbInfo_gridResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::VdbInfo_gridRequest* request, ::octaneapi::VdbInfo_gridResponse* response) { return this->grid(context, request, response); }));}
    void SetMessageAllocatorFor_grid(
        ::grpc::MessageAllocator< ::octaneapi::VdbInfo_gridRequest, ::octaneapi::VdbInfo_gridResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::VdbInfo_gridRequest, ::octaneapi::VdbInfo_gridResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_grid() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status grid(::grpc::ServerContext* /*context*/, const ::octaneapi::VdbInfo_gridRequest* /*request*/, ::octaneapi::VdbInfo_gridResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* grid(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::VdbInfo_gridRequest* /*request*/, ::octaneapi::VdbInfo_gridResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_sampler : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_sampler() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::VdbInfo_samplerRequest, ::octaneapi::VdbInfo_samplerResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::VdbInfo_samplerRequest* request, ::octaneapi::VdbInfo_samplerResponse* response) { return this->sampler(context, request, response); }));}
    void SetMessageAllocatorFor_sampler(
        ::grpc::MessageAllocator< ::octaneapi::VdbInfo_samplerRequest, ::octaneapi::VdbInfo_samplerResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::VdbInfo_samplerRequest, ::octaneapi::VdbInfo_samplerResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_sampler() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status sampler(::grpc::ServerContext* /*context*/, const ::octaneapi::VdbInfo_samplerRequest* /*request*/, ::octaneapi::VdbInfo_samplerResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* sampler(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::VdbInfo_samplerRequest* /*request*/, ::octaneapi::VdbInfo_samplerResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_destroySampler : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_destroySampler() {
      ::grpc::Service::MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::VdbInfo_destroySamplerRequest, ::google::protobuf::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::VdbInfo_destroySamplerRequest* request, ::google::protobuf::Empty* response) { return this->destroySampler(context, request, response); }));}
    void SetMessageAllocatorFor_destroySampler(
        ::grpc::MessageAllocator< ::octaneapi::VdbInfo_destroySamplerRequest, ::google::protobuf::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::VdbInfo_destroySamplerRequest, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_destroySampler() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status destroySampler(::grpc::ServerContext* /*context*/, const ::octaneapi::VdbInfo_destroySamplerRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* destroySampler(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::VdbInfo_destroySamplerRequest* /*request*/, ::google::protobuf::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_findGrid : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_findGrid() {
      ::grpc::Service::MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::octaneapi::VdbInfo_findGridRequest, ::octaneapi::VdbInfo_findGridResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::octaneapi::VdbInfo_findGridRequest* request, ::octaneapi::VdbInfo_findGridResponse* response) { return this->findGrid(context, request, response); }));}
    void SetMessageAllocatorFor_findGrid(
        ::grpc::MessageAllocator< ::octaneapi::VdbInfo_findGridRequest, ::octaneapi::VdbInfo_findGridResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::octaneapi::VdbInfo_findGridRequest, ::octaneapi::VdbInfo_findGridResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_findGrid() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status findGrid(::grpc::ServerContext* /*context*/, const ::octaneapi::VdbInfo_findGridRequest* /*request*/, ::octaneapi::VdbInfo_findGridResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* findGrid(
      ::grpc::CallbackServerContext* /*context*/, const ::octaneapi::VdbInfo_findGridRequest* /*request*/, ::octaneapi::VdbInfo_findGridResponse* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_valid<WithCallbackMethod_gridCount<WithCallbackMethod_grid<WithCallbackMethod_sampler<WithCallbackMethod_destroySampler<WithCallbackMethod_findGrid<Service > > > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_valid : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_valid() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_valid() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status valid(::grpc::ServerContext* /*context*/, const ::octaneapi::VdbInfo_validRequest* /*request*/, ::octaneapi::VdbInfo_validResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_gridCount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_gridCount() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_gridCount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status gridCount(::grpc::ServerContext* /*context*/, const ::octaneapi::VdbInfo_gridCountRequest* /*request*/, ::octaneapi::VdbInfo_gridCountResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_grid : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_grid() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_grid() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status grid(::grpc::ServerContext* /*context*/, const ::octaneapi::VdbInfo_gridRequest* /*request*/, ::octaneapi::VdbInfo_gridResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_sampler : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_sampler() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_sampler() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status sampler(::grpc::ServerContext* /*context*/, const ::octaneapi::VdbInfo_samplerRequest* /*request*/, ::octaneapi::VdbInfo_samplerResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_destroySampler : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_destroySampler() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_destroySampler() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status destroySampler(::grpc::ServerContext* /*context*/, const ::octaneapi::VdbInfo_destroySamplerRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_findGrid : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_findGrid() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_findGrid() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status findGrid(::grpc::ServerContext* /*context*/, const ::octaneapi::VdbInfo_findGridRequest* /*request*/, ::octaneapi::VdbInfo_findGridResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_valid : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_valid() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_valid() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status valid(::grpc::ServerContext* /*context*/, const ::octaneapi::VdbInfo_validRequest* /*request*/, ::octaneapi::VdbInfo_validResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestvalid(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_gridCount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_gridCount() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_gridCount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status gridCount(::grpc::ServerContext* /*context*/, const ::octaneapi::VdbInfo_gridCountRequest* /*request*/, ::octaneapi::VdbInfo_gridCountResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgridCount(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_grid : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_grid() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_grid() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status grid(::grpc::ServerContext* /*context*/, const ::octaneapi::VdbInfo_gridRequest* /*request*/, ::octaneapi::VdbInfo_gridResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestgrid(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_sampler : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_sampler() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_sampler() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status sampler(::grpc::ServerContext* /*context*/, const ::octaneapi::VdbInfo_samplerRequest* /*request*/, ::octaneapi::VdbInfo_samplerResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestsampler(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_destroySampler : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_destroySampler() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_destroySampler() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status destroySampler(::grpc::ServerContext* /*context*/, const ::octaneapi::VdbInfo_destroySamplerRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestdestroySampler(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_findGrid : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_findGrid() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_findGrid() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status findGrid(::grpc::ServerContext* /*context*/, const ::octaneapi::VdbInfo_findGridRequest* /*request*/, ::octaneapi::VdbInfo_findGridResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestfindGrid(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_valid : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_valid() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->valid(context, request, response); }));
    }
    ~WithRawCallbackMethod_valid() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status valid(::grpc::ServerContext* /*context*/, const ::octaneapi::VdbInfo_validRequest* /*request*/, ::octaneapi::VdbInfo_validResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* valid(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_gridCount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_gridCount() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->gridCount(context, request, response); }));
    }
    ~WithRawCallbackMethod_gridCount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status gridCount(::grpc::ServerContext* /*context*/, const ::octaneapi::VdbInfo_gridCountRequest* /*request*/, ::octaneapi::VdbInfo_gridCountResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* gridCount(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_grid : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_grid() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->grid(context, request, response); }));
    }
    ~WithRawCallbackMethod_grid() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status grid(::grpc::ServerContext* /*context*/, const ::octaneapi::VdbInfo_gridRequest* /*request*/, ::octaneapi::VdbInfo_gridResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* grid(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_sampler : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_sampler() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->sampler(context, request, response); }));
    }
    ~WithRawCallbackMethod_sampler() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status sampler(::grpc::ServerContext* /*context*/, const ::octaneapi::VdbInfo_samplerRequest* /*request*/, ::octaneapi::VdbInfo_samplerResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* sampler(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_destroySampler : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_destroySampler() {
      ::grpc::Service::MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->destroySampler(context, request, response); }));
    }
    ~WithRawCallbackMethod_destroySampler() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status destroySampler(::grpc::ServerContext* /*context*/, const ::octaneapi::VdbInfo_destroySamplerRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* destroySampler(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_findGrid : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_findGrid() {
      ::grpc::Service::MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->findGrid(context, request, response); }));
    }
    ~WithRawCallbackMethod_findGrid() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status findGrid(::grpc::ServerContext* /*context*/, const ::octaneapi::VdbInfo_findGridRequest* /*request*/, ::octaneapi::VdbInfo_findGridResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* findGrid(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_valid : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_valid() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::VdbInfo_validRequest, ::octaneapi::VdbInfo_validResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::VdbInfo_validRequest, ::octaneapi::VdbInfo_validResponse>* streamer) {
                       return this->Streamedvalid(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_valid() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status valid(::grpc::ServerContext* /*context*/, const ::octaneapi::VdbInfo_validRequest* /*request*/, ::octaneapi::VdbInfo_validResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedvalid(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::VdbInfo_validRequest,::octaneapi::VdbInfo_validResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_gridCount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_gridCount() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::VdbInfo_gridCountRequest, ::octaneapi::VdbInfo_gridCountResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::VdbInfo_gridCountRequest, ::octaneapi::VdbInfo_gridCountResponse>* streamer) {
                       return this->StreamedgridCount(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_gridCount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status gridCount(::grpc::ServerContext* /*context*/, const ::octaneapi::VdbInfo_gridCountRequest* /*request*/, ::octaneapi::VdbInfo_gridCountResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedgridCount(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::VdbInfo_gridCountRequest,::octaneapi::VdbInfo_gridCountResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_grid : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_grid() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::VdbInfo_gridRequest, ::octaneapi::VdbInfo_gridResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::VdbInfo_gridRequest, ::octaneapi::VdbInfo_gridResponse>* streamer) {
                       return this->Streamedgrid(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_grid() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status grid(::grpc::ServerContext* /*context*/, const ::octaneapi::VdbInfo_gridRequest* /*request*/, ::octaneapi::VdbInfo_gridResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedgrid(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::VdbInfo_gridRequest,::octaneapi::VdbInfo_gridResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_sampler : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_sampler() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::VdbInfo_samplerRequest, ::octaneapi::VdbInfo_samplerResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::VdbInfo_samplerRequest, ::octaneapi::VdbInfo_samplerResponse>* streamer) {
                       return this->Streamedsampler(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_sampler() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status sampler(::grpc::ServerContext* /*context*/, const ::octaneapi::VdbInfo_samplerRequest* /*request*/, ::octaneapi::VdbInfo_samplerResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedsampler(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::VdbInfo_samplerRequest,::octaneapi::VdbInfo_samplerResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_destroySampler : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_destroySampler() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::VdbInfo_destroySamplerRequest, ::google::protobuf::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::VdbInfo_destroySamplerRequest, ::google::protobuf::Empty>* streamer) {
                       return this->StreameddestroySampler(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_destroySampler() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status destroySampler(::grpc::ServerContext* /*context*/, const ::octaneapi::VdbInfo_destroySamplerRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreameddestroySampler(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::VdbInfo_destroySamplerRequest,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_findGrid : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_findGrid() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::octaneapi::VdbInfo_findGridRequest, ::octaneapi::VdbInfo_findGridResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::octaneapi::VdbInfo_findGridRequest, ::octaneapi::VdbInfo_findGridResponse>* streamer) {
                       return this->StreamedfindGrid(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_findGrid() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status findGrid(::grpc::ServerContext* /*context*/, const ::octaneapi::VdbInfo_findGridRequest* /*request*/, ::octaneapi::VdbInfo_findGridResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedfindGrid(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::octaneapi::VdbInfo_findGridRequest,::octaneapi::VdbInfo_findGridResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_valid<WithStreamedUnaryMethod_gridCount<WithStreamedUnaryMethod_grid<WithStreamedUnaryMethod_sampler<WithStreamedUnaryMethod_destroySampler<WithStreamedUnaryMethod_findGrid<Service > > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_valid<WithStreamedUnaryMethod_gridCount<WithStreamedUnaryMethod_grid<WithStreamedUnaryMethod_sampler<WithStreamedUnaryMethod_destroySampler<WithStreamedUnaryMethod_findGrid<Service > > > > > > StreamedService;
};

}  // namespace octaneapi


#include <grpcpp/ports_undef.inc>
#endif  // GRPC_octanevolume_2eproto__INCLUDED
