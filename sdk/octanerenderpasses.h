// Copyright (C) 2025 OTOY NZ Ltd.

#ifndef _OCTANE_RENDER_PASSES_H_
#define _OCTANE_RENDER_PASSES_H_ 1

// api includes
#include "octaneenums.h"
#include "octanetypes.h"
#include "octaneids.h"
#include "octanevectypes.h"

/// length of the fixed size array in the render pass statistics
#define RP_ARRAY_LEN 128

namespace Octane
{


//--------------------------------------------------------------------------------------------------
/// Contains statistics for the render engine. A render result can be a single pass or a collection
/// of passes.
struct OCTANEAPI_DECL RenderResultStatistics
{
    //--- Image info ---
 
    /// The resolution set in the film node.
    Octane::uint32_2      mSetSize;
    /// The resolution used during the rendering
    Octane::uint32_2      mUsedSize;
    /// The subsample mode that was used to render the result.
    Octane::SubSampleMode mSubSampleMode;
    /// The upsample mode  that was used to render the result.
    /// NOTE: it will always be UPSAMPLEMODE_NONE for info pass
    Octane::UpSampleMode  mUpSampleMode;
    /// The format of the result buffer.
    Octane::TonemapBufferType mBufferType;
    /// The color space of the result.
    Octane::NamedColorSpace mColorSpace;
    /// The value of this is implied by mColorSpace unless it's NAMED_COLOR_SPACE_OTHER or
    /// NAMED_COLOR_SPACE_OCIO.
    bool                  mIsLinear;
    /// TRUE if the result has an alpha channel.
    bool                  mHasAlpha;
    /// The type of premultiplied alpha that the result has.
    Octane::PremultipliedAlphaType mPremultipliedAlphaType;
    /// TRUE if the result has the environment rendered together with an alpha channel.
    bool                  mKeepEnvironment;
    /// The render data change level.
    Octane::CLevelT       mChangeLevel;
    /// If TRUE, this result was rendered with some render data still missing, due to it still
    /// being compiled or loaded in the background, or due to it being generated by the render
    /// process itself. At a later point when all render data is ready you will start receiving
    /// results and statistics with the same changelevel but with this flag set to false.
    bool                  mHasPendingUpdates;
    /// Maximum number of deep bins per pixel.
    uint8_t               mDeepBinCount;
    /// Number of seed samples/px calculated before deep bin creation.
    uint32_t              mDeepSeedSpp;
    /// @deprecated set to 0
    uint32_t              mCryptomatteSeedSpp;
    /// if true, the deep bins contain render passes
    bool                  mDeepPassesEnabled;

    //-- Enabled/rendered render passes --

    /// Number of render passes that are tonemapped and therefor part of the last result.
    uint32_t              mTonemapPassesCount;
    /// Render passes that are tonemapped and therefor part of the result.
    /// NOTE: Only entries in range [0, mTonemapPassesCount) are valid in this array.
    Octane::RenderPassId  mTonemapPasses[RP_ARRAY_LEN];
    /// Number of passes that are actually being rendered (tonemap passes can be a subset of these).
    uint32_t              mPassesCount;
    /// Render passes that are being rendered.
    /// NOTE: Only entries in range [0, mPassesCount) are valid in this array.
    Octane::RenderPassId  mRenderPasses[RP_ARRAY_LEN];

    //--- Beauty passes statistics ---

    /// The current wipe count of the beauty film. Every time a the beauty film gets cleared, this
    /// count will be incremented.
    uint32_t              mBeautyWipeCount;
    /// The samples per pixel that have been calculated for the beauty passes.
    uint32_t              mBeautySamplesPerPixel;
    /// The maximum number of samples per pixel for the beauty passes.
    uint32_t              mBeautyMaxSamplesPerPixel;
    /// The number of samples rendered per second
    double                mBeautySamplesPerSecond;
    /// Samples per pixel rendered for the region (info passes don't do regions).
    uint32_t              mRegionSamplesPerPixel;
    /// Samples per pixel rendered in the denoiser pass or 0 if the denoiser isn't running yet.
    uint32_t              mDenoisedSamplesPerPixel;
    /// Samples per region pixel rendered in the denoiser pass.
    uint32_t              mRegionDenoisedSamplesPerPixel;

    //--- Info passes statistics ---

    /// The current wipe count of the info film. Every time a the info film gets cleared, this
    /// count will be incremented.
    uint32_t              mInfoWipeCount;
    /// The samples per pixel that have been calculated for the info passes.
    uint32_t              mInfoSamplesPerPixel;
    /// The maximum number of samples per pixel for the info passes.
    uint32_t              mInfoMaxSamplesPerPixel;
    /// The number of samples rendered per second for the info passes.
    double                mInfoSamplesPerSecond;

    //--- Render state ---

    /// The state the render target was in, when the statistics were created.
    Octane::RenderState   mState;
    /// The time spent rendering this result so far (seconds).
    double                mRenderTime;
    /// Estimate of the total render time to render all the passes (seconds).
    double                mEstimatedRenderTime;


    /// Clears our members and sets the sub sample mode to SUBSAMPLE_NONE and the state to
    /// RSTATE_STOPPED.
    void clear();

    //--- Extra convenience getters ---

    /// Returns the internal film resolution
    uint32_2 internalFilmResolution() const;

    /// Returns the type of the channels, this is either float or 8-bit unsigned int
    Octane::ImageChannelType channelType() const;

    /// Returns the samples per pixel of the specified render pass.
    uint32_t samplesPerPixel(
        const Octane::RenderPassId renderPassId) const;

    /// Returns the maximum samples per pixel of the specified render pass.
    uint32_t maxSamplesPerPixel(
        const Octane::RenderPassId renderPassId) const;

    /// Returns the samples per second of the specified render pass.
    double samplesPerSecond(
        const Octane::RenderPassId renderPassId) const;

    /// Returns the render progress for the specified render pass.
    double progress(
        const Octane::RenderPassId renderPassId) const;

    /// Returns TRUE if at least one sample per pixel has been calculated for the specified render
    /// pass.
    bool started(
        const Octane::RenderPassId renderPassId) const;

    /// Returns TRUE if all samples per pixel have been calculated for the specified render pass.
    bool finished(
        const Octane::RenderPassId renderPassId) const;
};



//--------------------------------------------------------------------------------------------------
/// Info required by the engine to export a single render pass.
struct RenderPassExport
{
    /// The render pass that's exported.
    RenderPassId mRenderPassId;
    /// Name under which this render pass is exported. The semantics depend on how
    /// the render passes are exported:
    ///
    /// 1) Multi-layer OpenEXR:
    ///     Name of the layer into which we export the channels of this pass (e.g. "Refraction"
    ///     would be exported into OpenEXR as Refraction.R, Refraction.G, Refraction.B,
    ///     Refraction.A). If this is the empty string "", it is assumed to be the default layer
    ///     (usually the one corresponding to the beauty pass) and the channels R, G, B, A will be
    ///     used. If it is the null pointer, the default layer name for this render pass is used.
    /// 2) Discrete files:
    ///     a) When using a filename template (currently only possible in standalone):
    ///         The name of the render pass - %l in the template will be substituted for this. If it
    ///         is the null pointer, the default name for this render pass is used.
    ///     b) When not using a filename template:
    ///         Name of the file (e.g. "Scene_Glossy"). This is a path that can be relative to the
    ///         output directory or absolute. If the string contains a file extension, it will be
    ///         changed to the correct one for the file type being exported, and if it doesn't, the
    ///         correct one will be added (e.g. ".exr" or ".png"). If it is the null pointer, the
    ///         default name for this render pass is used.
    const char   *mExportName;
};



//--------------------------------------------------------------------------------------------------
/// Tracks all static info about an AOV including render AOVs and output AOVs.
struct ApiRenderPassInfo
{
    /// The render pass ID.
    RenderPassId      mRenderPassId;
    /// The type of the render AOV node or NT_UNKNOWN if there is no corresponding node or if it's
    /// an output node.
    NodeType          mNodeType;
    /// The sub-type of the render pass node or 0 if the render AOV node doesn't have a sub-type.
    enum_t            mSubType;
    /// (deprecated) Pin ID for this render pass in the deprecated render pass node.
    PinId             mPinId;
    /// Long name for this render pass.
    const char *      mName;
    /// Default name for EXR layers saved for this pass.
    const char *      mExrLayerName;
    /// Abbreviated name for this render pass.
    const char *      mShortName;
    /// Description for this render pass.
    const char *      mDescription;
    /// Category of the AOV node.
    const char *      mCategory;
    /// TRUE if this pass is an info channel pass
    bool              mIsInfoPass;
    /// TRUE if this pass is rendered as a greyscale image.
    bool              mIsGreyscale;
    /// blending mode info
    BlendingModeId    mBlendingModeId;
    /// Render pass group.
    /// @deprecated Use mCategory instead.
    RenderPassGroupId mRenderPassGroupId;
};


/// Checks if the provided pass ID identifies a beauty render AOV.
inline bool isBeautyPass(
    const RenderPassId id)
{
    return (id < RENDER_PASS_INFO_OFFSET);
}


/// Checks if the provided pass ID identifies a cryptomatte render AOV.
inline bool isCryptomattePass(
    const RenderPassId id)
{
    return (id >= RENDER_PASS_CRYPTOMATTE_OFFSET && id <= RENDER_PASS_CRYPTOMATTE_LAST);
}


/// Checks if the provided pass ID identifies a AOV ouput type.
inline bool isOutputAov(
    const RenderPassId id)
{
    return id >= RENDER_PASS_OUTPUT_AOV_IDS_OFFSET;
}


/// Checks if the provided pass is a beauty pass or a cryptomatte pass. These passes are
/// rendered via the regular path tracing kernels.
inline bool isBeautyOrCryptomattePass(
    const RenderPassId id)
{
    return isBeautyPass(id) || isCryptomattePass(id) || isOutputAov(id);
}


/// Checks if the provided render pass ID is for custom AOV, which IS also part if the beauty AOVs,
/// i.e. isBeautyPass() will return true for custom AOV, too.
inline bool isCustomAov(
    const RenderPassId id)
{
    return id > RENDER_PASS_CUSTOM_OFFSET && id <= RENDER_PASS_CUSTOM_LAST;
}


/// Calculates the custom AOV index from a render pass ID.
inline uint32_t getCustomAovIx(
    const RenderPassId customAovId)
{
    return isCustomAov(customAovId) ? customAovId - RENDER_PASS_CUSTOM_1 : 0;
}


/// Checks if the provided pass ID identifies an info render AOV.
inline bool isInfoPass(
    const RenderPassId id)
{
    return id >= RENDER_PASS_INFO_OFFSET && id < RENDER_PASS_CRYPTOMATTE_OFFSET;
}


/// Checks if the provided render pass ID is for a global texture AOV, which IS also part of the
/// info AOVs, i.e. isInfoPass() will return true for global texture AOVs, too.
inline bool isGlobalTextureAov(
    const RenderPassId id)
{
    return id > RENDER_PASS_GLOBAL_TEX_OFFSET && id <= RENDER_PASS_GLOBAL_TEX_LAST;
}


/// Calculates the global texture AOV index from a render pass ID.
inline uint32_t getGlobalTextureAovIx(
    const RenderPassId id)
{
    return isGlobalTextureAov(id) ? id - RENDER_PASS_GLOBAL_TEX_1 : 0;
}


/// Determines the index of a ouput AOV from its render pass ID.
inline uint32_t getOutputAovIx(
    const RenderPassId id)
{
    return isOutputAov(id) ? id - RENDER_PASS_OUTPUT_AOV_IDS_OFFSET : 0;
}


/// Creates a render pass ID for the specified composite AOV index.
inline RenderPassId getOutputAovId(
    const uint32_t compositeAovIx)
{
    return (RenderPassId)(compositeAovIx + RENDER_PASS_OUTPUT_AOV_IDS_OFFSET);
}


/// Checks if the provided pass is a output from denoiser.
OCTANEAPI_DECL bool isDenoiserOutputPass(
    const RenderPassId id);

/// Checks if a render pass is rendered out as greyscale
OCTANEAPI_DECL bool isGreyscalePass(
    const RenderPassId id);

///  Check if an AOV id supported for deep image.
inline bool isDeepSupportedAov(
    const Octane::RenderPassId id)
{
    return !isCryptomattePass(id) &&
        !isOutputAov(id) &&
        !isDenoiserOutputPass(id);
}


} // namespace Octane



#endif // #ifndef _OCTANE_RENDER_PASSES_H_
